package ca.bc.gov.health.sfds.session;

import ca.bc.gov.health.sfds.dto.MetaDto;
import ca.bc.gov.health.sfds.dto.RulesbasedaccountDto;
import ca.bc.gov.health.sfds.dto.UseDto;
import ca.bc.gov.health.sfds.entity.Rulesbasedaccount;
import ca.bc.gov.health.sfds.entity.Use;
import ca.bc.gov.health.sfds.exception.DuplicateRecordException;
import ca.bc.gov.health.sfds.service.IUseFacade;
import jakarta.ejb.Stateless;
import jakarta.ejb.TransactionManagement;
import jakarta.ejb.TransactionManagementType;
import jakarta.persistence.NoResultException;
import jakarta.persistence.Query;
import java.util.ArrayList;
import java.util.List;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Facade for dealing with SFDS Uses.
 *
 * @author alexey.malikov
 *
 */
@Stateless
@TransactionManagement(TransactionManagementType.CONTAINER)
public class UseFacade extends AbstractFacade<Use> implements IUseFacade {

    public UseFacade() {
        super(Use.class);
    }

    private static final Logger LOG = LogManager.getLogger(UseFacade.class);

    @Override
    public List<UseDto> getAllUses() {
        List<UseDto> useDtos = new ArrayList<>();

        List<Use> useEntities = super.findAll();

        for (Use use : useEntities) {
            use.initTransientFields();
            UseDto useDto = use;
            useDtos.add(useDto);
        }

        return useDtos;
    }

    @Override
    public Use getByUseId(String useId) {
        Query query = super.getEntityManager().createNamedQuery("Use.findByUseId");
        query.setParameter("useId", useId);
        try {
            Use use = (Use) query.getSingleResult();
            use.initTransientFields();
            return use;
        } catch (NoResultException e) {
            return null;
        }
    }

    @Override
    public void deleteUse(UseDto useDto) {
        Use useDb = this.getByUseId(useDto.getUseId());
        Rulesbasedaccount rulesbasedaccount = useDb.getRulesbasedaccount();
        super.remove(useDb);

        deleteRulesbasedaccount(rulesbasedaccount);
    }

    private void deleteRulesbasedaccount(Rulesbasedaccount rulesbasedaccount) {
        if (rulesbasedaccount != null) {
            super.getEntityManager().remove(rulesbasedaccount);
        }
    }

    @Override
    public void createUse(UseDto useDto) throws DuplicateRecordException {
        this.validateExistingUseAndRulesbasedaccount(useDto);

        Use use = new Use();
        if (!useDto.isMulti()) {
            Rulesbasedaccount rulesbasedaccount = createRulesbasedaccount(useDto.getRulesbasedaccountDto());
            if (rulesbasedaccount != null) {
                LOG.debug("New Rulesbasedaccount ID is {}", rulesbasedaccount.getId());
            }
            use.setRulesbasedaccount(rulesbasedaccount);
        } else {
            use.setRulesbasedaccount(null);
        }

        copyUseFields(useDto, use);

        super.create(use);
        LOG.debug("New Use ID is {}", use.getId());
        useDto.setPersisted(true);
    }

    private void validateExistingUseAndRulesbasedaccount(UseDto useDto) throws DuplicateRecordException {
        DuplicateRecordException duplicateRecordException = new DuplicateRecordException();

        Use useDb = this.getByUseId(useDto.getUseId());
        if (useDb != null) {
            duplicateRecordException.addRecordType(DuplicateRecordException.RecordType.USE);
        }

        if (!useDto.isMulti()) {
            Rulesbasedaccount rulesbasedaccountDb = this
                    .getRulesbasedaccountByRecipient(useDto.getRulesbasedaccountDto().getRecipient());

            if (rulesbasedaccountDb != null) {
                duplicateRecordException.addRecordType(DuplicateRecordException.RecordType.RULESBASEDACCOUNT);
            }
        }

        if (!duplicateRecordException.getDuplicateRecordTypes().isEmpty()) {
            throw duplicateRecordException;
        }
    }

    private void copyUseFields(UseDto fromUseDto, Use toUse) {
        toUse.setAcknowledgement(fromUseDto.getAcknowledgement());
        toUse.setConfirmationType(fromUseDto.getConfirmationType());
        toUse.setCreateDate(fromUseDto.getCreateDate());
        toUse.setCreateUser(fromUseDto.getCreateUser());
        toUse.setDescription(fromUseDto.getDescription());
        toUse.setFileRecognizer(fromUseDto.getFileRecognizer());
        toUse.setFileRenamer(fromUseDto.getFileRenamer());
        toUse.setFileSizeLimit(fromUseDto.getFileSizeLimit());
        toUse.setGetLabel(fromUseDto.getGetLabel());
        toUse.setModifyDate(fromUseDto.getModifyDate());
        toUse.setModifyUser(fromUseDto.getModifyUser());
        toUse.setName(fromUseDto.getName());
        toUse.setNotificationType(fromUseDto.getNotificationType());
        toUse.setSearchFields(fromUseDto.getSearchFields());
        toUse.setSendLabel(fromUseDto.getSendLabel());
        toUse.setSortComparator(fromUseDto.getSortComparator());
        toUse.setTextMessage(fromUseDto.getTextMessage());
        toUse.setTimeLimit(fromUseDto.getTimeLimit());
        toUse.setUseId(fromUseDto.getUseId());
    }

    private Rulesbasedaccount createRulesbasedaccount(RulesbasedaccountDto rulesbasedaccountDto) {
        if (rulesbasedaccountDto == null) {
            return null;
        }
        Rulesbasedaccount rulesbasedaccount = new Rulesbasedaccount();

        this.copyRulesbasedaccountFields(rulesbasedaccountDto, rulesbasedaccount);

        super.getEntityManager().persist(rulesbasedaccount);
        return rulesbasedaccount;
    }

    @Override
    public void updateUse(UseDto useDto) {
        LOG.debug("Updating use {} ", useDto);
        Use useDb = this.getByUseId(useDto.getUseId());
        copyUseFields(useDto, useDb);

        if (useDb.getRulesbasedaccount() != null && useDto.isMulti()) {
            LOG.debug("Changed from regular to multi");

            this.deleteRulesbasedaccount(useDb.getRulesbasedaccount());
            useDb.setRulesbasedaccount(null);

        } else if (useDb.getRulesbasedaccount() == null && !useDto.isMulti()) {
            LOG.debug("Changed from multi to regular");

            Rulesbasedaccount rulesbasedaccount = this.createRulesbasedaccount(useDto.getRulesbasedaccountDto());
            useDb.setRulesbasedaccount(rulesbasedaccount);
        } else if (useDb.getRulesbasedaccount() == null && useDto.isMulti()) {
            LOG.debug("No change, remains multi");

        } else if (useDb.getRulesbasedaccount() != null && !useDto.isMulti()) {
            LOG.debug("No change, remains regular");

            this.updateRulesbasedaccount(useDto.getRulesbasedaccountDto(), useDb.getRulesbasedaccount(),
                    useDto.getModifyUser());
        }

        LOG.debug("Saving updates");
        super.edit(useDb);
    }

    private void updateRulesbasedaccount(RulesbasedaccountDto rulesbasedaccountDto,
            Rulesbasedaccount rulesbasedaccountDb, String modifyUser) {
        this.copyRulesbasedaccountFields(rulesbasedaccountDto, rulesbasedaccountDb);
        rulesbasedaccountDb.setModifyUser(modifyUser);
        this.getEntityManager().merge(rulesbasedaccountDb);
    }

    private void copyRulesbasedaccountFields(RulesbasedaccountDto rulesbasedaccountDto,
            Rulesbasedaccount rulesbasedaccount) {

        rulesbasedaccount.setAccountId(rulesbasedaccountDto.getAccountId());
        rulesbasedaccount.setRecipient(rulesbasedaccountDto.getRecipient());
        rulesbasedaccount.setBusinessArea(rulesbasedaccountDto.getBusinessArea());
        rulesbasedaccount.setOverwrite(rulesbasedaccountDto.getOverwrite());
        rulesbasedaccount.setSendingUseId(rulesbasedaccountDto.getSendingUseId());
        rulesbasedaccount.setNotificationType(rulesbasedaccountDto.getNotificationType());
        rulesbasedaccount.setConfirmationType(rulesbasedaccountDto.getConfirmationType());
        rulesbasedaccount.setAcknowledgementType(rulesbasedaccountDto.getAcknowledgementType());
    }

    private Rulesbasedaccount getRulesbasedaccountByRecipient(String recipient) {
        Query query = super.getEntityManager().createNamedQuery("Rulesbasedaccount.findByRecipient");
        query.setParameter("recipient", recipient);
        @SuppressWarnings("unchecked")
        List<Rulesbasedaccount> result = query.getResultList();
        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }

    /*
    * Check for existing account
     */
    public boolean rulesBasedAccountExists(String accountId, Long id) {
        LOG.info("Checking if RBA with account ID {} already exists", accountId);
        Query query = super.getEntityManager().createNamedQuery("Rulesbasedaccount.findByAccountId");
        query.setParameter("accountId", accountId);
        @SuppressWarnings("unchecked")
        List<Rulesbasedaccount> result = query.getResultList();
        if (id == null) {
            return !result.isEmpty();
        } else {
            if (result.isEmpty()) {
                return false;
            } else {
                return id != result.get(0).getId();
            }
        }
    }

    @Override
    public List<MetaDto> getUseMetas() {
        List<MetaDto> result = new ArrayList<>();
        List<UseDto> allUses = this.getAllUses();
        for (UseDto useDto : allUses) {
            result.add(useDto.getMeta());
        }

        return result;
    }

}
