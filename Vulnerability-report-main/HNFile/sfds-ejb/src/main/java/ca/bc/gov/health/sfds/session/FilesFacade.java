package ca.bc.gov.health.sfds.session;

import ca.bc.gov.health.sfds.dto.BulletinDto;
import ca.bc.gov.health.sfds.dto.FileMetaDataDto;
import ca.bc.gov.health.sfds.dto.RecipientDto;
import ca.bc.gov.health.sfds.dto.UseDto;
import ca.bc.gov.health.sfds.entity.Account;
import ca.bc.gov.health.sfds.entity.DataRecipient;
import ca.bc.gov.health.sfds.entity.DataTransportTransaction;
import ca.bc.gov.health.sfds.entity.Rulesbasedaccount;
import ca.bc.gov.health.sfds.enums.NotificationType;
import ca.bc.gov.health.sfds.exception.SFDSException;
import ca.bc.gov.health.sfds.files.FileDescription;
import ca.bc.gov.health.sfds.files.FileDescriptionGroup;
import ca.bc.gov.health.sfds.files.Mailbox;
import ca.bc.gov.health.sfds.files.SendFileEntry;
import ca.bc.gov.health.sfds.files.ServerFileEntry;
import ca.bc.gov.health.sfds.service.IBulletinsFacade;
import ca.bc.gov.health.sfds.service.IDataParcelIdentifierFacade;
import ca.bc.gov.health.sfds.service.IDataRecipientFacade;
import ca.bc.gov.health.sfds.service.IFilesFacade;
import ca.bc.gov.health.sfds.service.helper.SftpHelper;
import ca.bc.gov.health.sfds.util.SFDSConstants;
import jakarta.ejb.EJB;
import jakarta.ejb.Stateless;
import jakarta.ejb.TransactionManagement;
import jakarta.ejb.TransactionManagementType;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Implementation of IFilesFacade
 *
 * @author vladimir.dovgalyuk
 *
 */
@Stateless
@TransactionManagement(TransactionManagementType.CONTAINER)
public class FilesFacade implements IFilesFacade {

    private static final Logger LOG = LogManager.getLogger(FilesFacade.class);
    private static final String NEGATIVE = "N";

    @PersistenceContext(unitName = "sfds-ejb_pu")
    protected EntityManager entityManager;

    @EJB
    private IDataRecipientFacade dataRecipientFacade;

    @EJB
    private IDataParcelIdentifierFacade parcelIdentifierFacade;

    @EJB
    private IBulletinsFacade bulletinsFacade;

    /**
     * @see IFilesFacade#getFilesFromMailbox(Mailbox)
     */
    @Override
    public List<FileDescription> getFilesFromMailbox(Mailbox mailbox) {

        List<FileDescription> resultFiltered = new ArrayList<>();
        try {
            LOG.debug("Checking if mailbox {} exists on {}", mailbox, SFDSConstants.SFTP_PATH_TO_MAILBOXES);

            boolean exists = SftpHelper.fileExists(SFDSConstants.SFTP_PATH_TO_MAILBOXES, mailbox.getName());
            if (exists) {
                LOG.debug("Mailbox {} found", mailbox.getName());
            } else {
                return resultFiltered;
            }

            StringBuilder remotePath = new StringBuilder(SFDSConstants.SFTP_PATH_TO_MAILBOXES)
                    .append(SFDSConstants.SFTP_PATH_DELIMITER).append(mailbox.getName())
                    .append(SFDSConstants.SFTP_PATH_DELIMITER).append(SFDSConstants.SFTP_PATH_WITHIN_MAILBOX);
            List<ServerFileEntry> serverEntries = SftpHelper.listFileEntries(remotePath.toString());

            List<FileDescription> result = new ArrayList<>();
            for (ServerFileEntry entry : serverEntries) {
                result.add(new FileDescription(entry));
            }

            // Done with raw files in the file system, looking for what is inside database
            for (FileDescription file : result) {
                FileMetaDataDto fileMetaData = getFileMetaData(mailbox.getName(), file.getServerData().getName());
                if (fileMetaData != null) {
                    // Files with pending statuses do not go to the page
                    if (!SFDSConstants.FileStatuses.PENDING_DELETE.getDatabaseStatus().equals(fileMetaData.getStatus())
                            && !SFDSConstants.FileStatuses.PENDING_DELIVERY.getDatabaseStatus().equals(fileMetaData.getStatus())) {
                        // Additional filter: file's use must be in the user's list of uses associated with mailbox
                        if (mailbox.getUses().contains(fileMetaData.getUseId())) {
                            file.setMetadata(fileMetaData);
                            resultFiltered.add(file);
                        }
                    }
                } else {
                    resultFiltered.add(file);
                }
            }

            // Sorting results
            resultFiltered.sort((FileDescription o1, FileDescription o2) -> {
                if (o1.getUseName().equals(o2.getUseName())) {
                    int r = o1.getDateForCompare().compareTo(o2.getDateForCompare());
                    return -r;
                } else {
                    if (SFDSConstants.FILE_WITH_NO_METADATA.equals(o1.getUseName())
                            && !SFDSConstants.FILE_WITH_NO_METADATA.equals(o2.getUseName())) {
                        return -1;
                    } else if (!SFDSConstants.FILE_WITH_NO_METADATA.equals(o1.getUseName())
                            && SFDSConstants.FILE_WITH_NO_METADATA.equals(o2.getUseName())) {
                        return 1;
                    } else {
                        return o1.getUseName().compareToIgnoreCase(o2.getUseName());
                    }

                }
            });

        } catch (SFDSException e) {
            LOG.error("Exception when checking mailbox existence", e.fillInStackTrace());
        }

        return resultFiltered;
    }

    /**
     * @see IFilesFacade#getGroupedFilesFromMailbox(Mailbox)
     */
    @Override
    public List<FileDescriptionGroup> getGroupedFilesFromMailbox(Mailbox mailbox) {

        List<FileDescriptionGroup> result = new ArrayList<>();

        List<FileDescription> files = getFilesFromMailbox(mailbox);

        String groupName = "";
        FileDescriptionGroup group = null;
        int id = 0;
        List<FileDescription> temp = new ArrayList<>();
        if (!files.isEmpty()) {
            for (FileDescription file : files) {
                if (!file.getUseName().equals(groupName)) {
                    groupName = file.getUseName();
                    if (group != null) {
                        group.setFiles(temp);
                        result.add(group);
                    }

                    group = new FileDescriptionGroup(groupName, file.getUseGetLabel(), file.getUseSendLabel());
                    group.setId(id++);
                    temp = new ArrayList<>();
                    temp.add(file);
                } else {
                    temp.add(file);
                }
            }
            if (group != null) {
                group.setFiles(temp);
                result.add(group);
            }
        }

        return result;

    }

    /**
     * @see IFilesFacade#getFileContent(String, String)
     */
    @Override
    public byte[] getFileContent(String fileName, String pathToFile) {

        LOG.debug("Downloading file {} located at {}", fileName, pathToFile);
        try {
            return SftpHelper.downloadFile(fileName, pathToFile);
        } catch (SFDSException e) {
            LOG.error("Exception when downloading file", e.fillInStackTrace());
            return null;
        }

    }

    /**
     * Retrieves file SFDS metadata from the database
     *
     * @param accountId Receiving account identifier
     * @param fileName File name on the server
     * @return FileMetaDataDto object
     */
    protected FileMetaDataDto getFileMetaData(String accountId, String fileName) {
        Query query = entityManager.createNamedQuery("DataTransportTransaction.getFileMetadata");
        query.setParameter("accountId", accountId);
        query.setParameter("fileName", fileName);
        @SuppressWarnings("unchecked")
        List<FileMetaDataDto> result = query.getResultList();
        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }

    /**
     * @see IFilesFacade#deleteFileFromMailbox(Mailbox, FileDescription, String)
     */
    @Override
    public boolean deleteFileFromMailbox(Mailbox mailbox, FileDescription fileDescription, String user) {
        boolean result = true;

        if (fileDescription.getMetadata() == null) // Just the file, no metadata
        {
            if (fileDescription.getServerData() == null) {
                // This is not supposed to happen, but...
                LOG.error("Error in file deletion from the box {}: file has no descriptors.", mailbox.getDescription());
                result = false;
            } else {
                // No data in the database, simply drop this file from the directory
                StringBuilder remotePath = new StringBuilder(SFDSConstants.SFTP_PATH_TO_MAILBOXES)
                        .append(SFDSConstants.SFTP_PATH_DELIMITER).append(mailbox.getName())
                        .append(SFDSConstants.SFTP_PATH_DELIMITER).append(SFDSConstants.SFTP_PATH_WITHIN_MAILBOX);
                try {
                    SftpHelper.deleteFile(fileDescription.getServerData().getName(), remotePath.toString());
                } catch (SFDSException e) {
                    LOG.error("Error when deleting file {} from {}", fileDescription.getServerData().getName(), remotePath);
                    LOG.error("Error stack trace : ", e.fillInStackTrace());
                    result = false;
                }
            }
        } else {
            // There is information about this file in the database, mark it as ready for
            // deletion.
            result = dataRecipientFacade.softDeleteRecord(fileDescription.getMetadata().getDrId(),
                    fileDescription.getMetadata().getDrLockSeqNum(), user);
        }

        return result;
    }

    /**
     * Single recipient
     */
    public boolean sendFile(String accountId, boolean confirmation, SendFileEntry file, UseDto use, String userId, String... params) {
        LOG.info("Sending file {} from mailbox {} to use {}", file.getName(), accountId, use.getUseId());
        // Get the mailbox, from which everything is sent
        Query query = entityManager.createNamedQuery("Account.findByAccountIdentifier");
        query.setParameter("accountIdentifier", accountId);
        @SuppressWarnings("unchecked")
        List<Account> accounts = query.getResultList();
        if (accounts.isEmpty()) {
            LOG.error("Invalid account is : {}", accountId);
            return false;
        } else {
            Account account = accounts.get(0);
            LOG.debug("Sending account retrieved, its name is {}", account.getName());

            // Get receiving account 
            Query rbaQuery = entityManager.createNamedQuery("Rulesbasedaccount.findBySendingUse");
            rbaQuery.setParameter("sendingUseId", use.getUseId());
            @SuppressWarnings("unchecked")
            List<Rulesbasedaccount> rbas = rbaQuery.getResultList();
            if (rbas.isEmpty()) {
                LOG.error("No rule based account can be found for sending use {}", use.getUseId());
                return false;
            }
            String receivingAccountId = rbas.get(0).getAccountId();
            Query receivingAcctQuery = entityManager.createNamedQuery("Account.findByAccountIdentifier");
            receivingAcctQuery.setParameter("accountIdentifier", receivingAccountId);
            @SuppressWarnings("unchecked")
            List<Account> receivingAccounts = receivingAcctQuery.getResultList();
            if (receivingAccounts.isEmpty()) {
                LOG.error("Cannot find account for account identifier {}", receivingAccountId);
                return false;
            }
            LOG.debug("Receiving account ID is {} ", receivingAccounts.get(0).getId());

            // Create file metadata: FDSMetaDataMgmt.InsertFileMetaData
            LOG.info("Creating new record in DATA_TRANSPORT_TRANSACTION for file {} and account {}", file.getName(), accountId);
            DataTransportTransaction fileMetadata = new DataTransportTransaction();

            // BCMOHAD-1978 	
            // As a user I want to be able to send a file from one mailbox to another with complex rules
            if (!SFDSConstants.TEXT_MESSAGE_FILE_NAME.equals(file.getName())) // Bypassing messages
            {
                String fileName = file.getName();
                fileName = use.getRenamer().renameFile(fileName, receivingAccounts.get(0).getAccountIdentifier(), params);
                if (!file.getName().equalsIgnoreCase(fileName)) {
                    LOG.debug("File has been renamed from {} to {} ", file.getName(), fileName);
                    file.setName(fileName);
                }
            }

            fileMetadata.setFilename(file.getName());
            fileMetadata.setFilesize(new BigDecimal(file.getSize()));
            fileMetadata.setSendingDate(file.getSubmittedDate());
            fileMetadata.setAccount(account);
            fileMetadata.setSendingUid(userId);
            fileMetadata.setNotificationType(use.getNotificationType().getValue());
            fileMetadata.setConfirmationType(confirmation ? NotificationType.IMMEDIATE.getValue() : NotificationType.NONE.getValue());
            fileMetadata.setAcknowledgementType(use.getAcknowledgement().getValue());
            fileMetadata.setTransportUseName(use.getUseId());
            fileMetadata.setCreateUser(userId);

            entityManager.persist(fileMetadata);
            long dttId = fileMetadata.getId();
            LOG.debug("File metadata record created, ID = {}", dttId);

            // Create recipient metadata: FDSMetaDataMgmt.InsertRecipientMetaData
            LOG.info("Creating new record in DATA_RECIPIENTS for file {}, data transaction {} and receiving account {}",
                    file.getName(), dttId, receivingAccountId);
            DataRecipient dataRecipient = new DataRecipient();

            if (SFDSConstants.TEXT_MESSAGE_FILE_NAME.equals(file.getName())) {
                dataRecipient.setBusinessFilename(SFDSConstants.TEXT_MESSAGE_BUSINESS_FILE_NAME);
            } else {
                dataRecipient.setBusinessFilename(file.getName());
            }
            dataRecipient.setServerFilename(Long.toString(dttId));
            dataRecipient.setDataTransferStatus(SFDSConstants.FileStatuses.PENDING_DELIVERY.getDatabaseStatus());
            dataRecipient.setNotificationFlag(NEGATIVE);
            dataRecipient.setConfirmationFlag(NEGATIVE);
            dataRecipient.setAcknowledgementFlag(NEGATIVE);
            dataRecipient.setOverwriteServerFlag(NEGATIVE);
            dataRecipient.setDataTransportTransaction(fileMetadata);
            dataRecipient.setAccount(receivingAccounts.get(0));
            dataRecipient.setCreateUser(userId);
            entityManager.persist(dataRecipient);

            // Going into the Parcel system, reusing functionality created for bulletins
            LOG.debug("Retrieving Data Parcel Identifier ID for the sendig use {}", use.getUseId());
            Long userFilesId = parcelIdentifierFacade.getUserFilesContextId();
            Long sendingUseDataParcelId = parcelIdentifierFacade.getIdByContextIdCode(use.getUseId(), userFilesId, userId);
            LOG.debug("Data Parcel Identifier ID for the sendig use {} is {}", use.getUseId(), sendingUseDataParcelId);

            // Instantiating the inserted object
            BulletinDto fileDto = new BulletinDto(
                    -1L,
                    null, // Parcel context, not known at this point
                    file.getName(), // External identifier
                    Long.toString(fileMetadata.getId()), // Context -> set to DATA_TRANSPORT_TRANSACTION ID
                    null, // Effective date -> not needed here
                    null, // End date -> not needed here 
                    use.getUseId(), // Parent context
                    null); // Summary -> not needed here
            fileDto.setType(SFDSConstants.RootDataParcelIdentifiersForFDS.USER_FILES); // Indicating that this is a file
            fileDto.setSize(file.getSize());
            boolean result = bulletinsFacade.createBulletin(fileDto, file.getContent(), userId);
            LOG.info("File {} has been sent from mailbox {} to use {}", file.getName(), accountId, use.getUseId());
            return result;
        }

    }

    /**
     * Multiple recipients
     */
    @SuppressWarnings("unchecked")
    public boolean sendFile(String accountId, boolean confirmation, SendFileEntry file, UseDto use,
            List<RecipientDto> recipients, String userId, String... params) {
        boolean result = false;
        LOG.info("Sending file {} from mailbox {} to {} recipients", file.getName(), accountId, recipients.size());

        // Get the mailbox, from which everything is sent
        Query query = entityManager.createNamedQuery("Account.findByAccountIdentifier");
        query.setParameter("accountIdentifier", accountId);
        List<Account> accounts = query.getResultList();
        if (accounts.isEmpty()) {
            LOG.error("Invalid account is : {}", accountId);
            return result;
        } else {
            Account account = accounts.get(0);
            LOG.debug("Sending account retrieved, its name is {}", account.getName());

            // Get receiving accounts
            List<Account> receivingAccounts = new ArrayList<>();
            Query receivingAcctQuery = entityManager.createNamedQuery("Account.findByAccountIdentifier");

            LOG.debug("Retrieving recipents' accounts");
            for (RecipientDto recipient : recipients) {
                receivingAcctQuery.setParameter("accountIdentifier", recipient.getAccountIdentifier());
                accounts = receivingAcctQuery.getResultList();
                if (accounts.isEmpty()) {
                    LOG.error("Cannot find account for account identifier {}", recipient.getAccountIdentifier());
                    return false;
                }
                receivingAccounts.add(accounts.get(0));
            }
            LOG.debug("Recipents' accounts retrieved");

            // Create file metadata: FDSMetaDataMgmt.InsertFileMetaData
            LOG.info("Creating new record in DATA_TRANSPORT_TRANSACTION for file {} and account {}", file.getName(), accountId);
            DataTransportTransaction fileMetadata = new DataTransportTransaction();

            // As a user I want to be able to send a file from one mailbox to another with complex rules
            if (!SFDSConstants.TEXT_MESSAGE_FILE_NAME.equals(file.getName())) // Bypassing messages
            {
                String fileName = file.getName();
                fileName = use.getRenamer().renameFile(fileName, account.getAccountIdentifier(), params);
                if (!file.getName().equalsIgnoreCase(fileName)) {
                    LOG.debug("File has been renamed from {} to {} ", file.getName(), fileName);
                    file.setName(fileName);
                }
            }

            fileMetadata.setFilename(file.getName());
            fileMetadata.setFilesize(new BigDecimal(file.getSize()));
            fileMetadata.setSendingDate(file.getSubmittedDate());
            fileMetadata.setAccount(account);
            fileMetadata.setSendingUid(userId);
            fileMetadata.setNotificationType(use.getNotificationType().getValue());
            fileMetadata.setConfirmationType(confirmation ? NotificationType.IMMEDIATE.getValue() : NotificationType.NONE.getValue());
            fileMetadata.setAcknowledgementType(use.getAcknowledgement().getValue());
            fileMetadata.setTransportUseName(use.getUseId());
            fileMetadata.setCreateUser(userId);

            entityManager.persist(fileMetadata);
            long dttId = fileMetadata.getId();
            LOG.debug("File metadata record created, ID = {}", dttId);

            // Loop by recipients
            for (Account acc : receivingAccounts) {
                // Create recipient metadata: FDSMetaDataMgmt.InsertRecipientMetaData
                LOG.info("Creating new record in DATA_RECIPIENTS for file {}, data transaction {} and receiving account {}",
                        file.getName(), dttId, acc.getAccountIdentifier());
                DataRecipient dataRecipient = new DataRecipient();
                if (SFDSConstants.TEXT_MESSAGE_FILE_NAME.equals(file.getName())) {
                    dataRecipient.setBusinessFilename(SFDSConstants.TEXT_MESSAGE_BUSINESS_FILE_NAME);
                } else {
                    dataRecipient.setBusinessFilename(file.getName());
                }
                dataRecipient.setServerFilename(Long.toString(dttId));
                dataRecipient.setDataTransferStatus(SFDSConstants.FileStatuses.PENDING_DELIVERY.getDatabaseStatus());
                dataRecipient.setNotificationFlag(NEGATIVE);
                dataRecipient.setConfirmationFlag(NEGATIVE);
                dataRecipient.setAcknowledgementFlag(NEGATIVE);
                dataRecipient.setOverwriteServerFlag(NEGATIVE);
                dataRecipient.setDataTransportTransaction(fileMetadata);
                dataRecipient.setAccount(acc);
                dataRecipient.setCreateUser(userId);
                entityManager.persist(dataRecipient);
            }

            // Going into the Parcel system, reusing functionality created for bulletins
            LOG.debug("Retrieving Data Parcel Identifier ID for the sendig use {}", use.getUseId());
            Long userFilesId = parcelIdentifierFacade.getUserFilesContextId();
            Long sendingUseDataParcelId = parcelIdentifierFacade.getIdByContextIdCode(use.getUseId(), userFilesId, userId);
            LOG.debug("Data Parcel Identifier ID for the sendig use {} is {}", use.getUseId(), sendingUseDataParcelId);

            // Instantiating the inserted object
            BulletinDto fileDto = new BulletinDto(
                    -1L,
                    null, // Parcel context, not known at this point
                    file.getName(), // External identifier
                    Long.toString(fileMetadata.getId()), // Context -> set to DATA_TRANSPORT_TRANSACTION ID
                    null, // Effective date -> not needed here
                    null, // End date -> not needed here 
                    use.getUseId(), // Parent context
                    null); // Summary -> not needed here
            fileDto.setType(SFDSConstants.RootDataParcelIdentifiersForFDS.USER_FILES); // Indicating that this is a file
            fileDto.setSize(file.getSize());
            result = bulletinsFacade.createBulletin(fileDto, file.getContent(), userId);
            LOG.info("File {} has been sent from mailbox {} to use {}", file.getName(), accountId, use.getUseId());
            return result;

        }
    }
}
