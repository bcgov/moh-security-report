package ca.bc.gov.health.sfds.util;

import ca.bc.gov.health.sfds.files.Mailbox;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.context.FacesContext;
import jakarta.faces.model.SelectItem;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.tika.config.TikaConfig;
import org.apache.tika.exception.TikaException;
import org.apache.tika.metadata.Metadata;
import org.apache.tika.mime.MediaType;

/**
 * Convenience class
 *
 * @author vladimir.dovgalyuk
 *
 */
public class SFDSUtils {

    private static ResourceBundle bundle = null;
    private static final Pattern pStart = Pattern.compile("<body.*?>");
    private static final Pattern pEnd = Pattern.compile("</body>");

    private SFDSUtils() {
    }

    /**
     * Guesses MIME type for byte array
     *
     * @param input Byte array representing content
     * @return Mime type
     * @throws IOException IOException
     * @throws TikaException TikaException
     */
    public static String getMimeType(byte[] input) throws IOException, TikaException {
        TikaConfig tikaConfig = new TikaConfig();
        Metadata m = new Metadata();
        MediaType mediaType = tikaConfig.getDetector().detect(new ByteArrayInputStream(input), m);
        return mediaType.toString();
    }

    /**
     *
     * Parses BLOB as HTML and extracts inner HTML from the body tag
     *
     * @param input BLOB presented as byte array
     * @return HTML Markup
     * @throws IOException IOException
     */
    public static String parseBodyToHTML(byte[] input) throws IOException {
        String result = new String(input, "UTF-8");
        if (result != null) {
            Matcher m = pStart.matcher(result);
            if (m.find()) {
                result = result.substring(m.end());
                m = pEnd.matcher(result);
                if (m.find()) {
                    result = result.substring(0, m.start());
                }
            }
        }
        return result;
    }

    /**
     * Returns messages bundle
     *
     * @return Messages ResourceBundle
     */
    public static ResourceBundle getBundle() {
        if (bundle == null) {
            FacesContext context = FacesContext.getCurrentInstance();
            bundle = context.getApplication().getResourceBundle(context, "msg");
        }
        return bundle;
    }

    /**
     * Adds a faces message of severity ERROR and marks the request as validation failed
     *
     * @param id Component ID the message is for
     * @param message The message to be added
     * @param params Values to be inserted into message
     */
    public static void addErrorMessage(String id, String message, Object... params) {
        String m = MessageFormat.format(message, params);
        FacesContext.getCurrentInstance().addMessage(id, new FacesMessage(FacesMessage.SEVERITY_ERROR, m, m));
        FacesContext.getCurrentInstance().validationFailed();
    }

    /**
     * Adds a faces message of severity ERROR
     *
     * @param id Component ID the message is for
     * @param message The message to be added
     * @param params Values to be inserted into message
     */
    public static void addErrorMessageNoValidation(String id, String message, Object... params) {
        String m = MessageFormat.format(message, params);
        FacesContext.getCurrentInstance().addMessage(id, new FacesMessage(FacesMessage.SEVERITY_ERROR, m, m));
    }

    /**
     * Adds a faces message of severity INFO
     *
     * @param id Component ID the message is for
     * @param message The message to be added
     * @param params Values to be inserted into message
     */
    public static void addInfoMessage(String id, String message, Object... params) {
        String m = MessageFormat.format(message, params);
        FacesContext.getCurrentInstance().addMessage(id, new FacesMessage(FacesMessage.SEVERITY_INFO, m, m));
    }

    /**
     * Builds list of available accounts for Inbox and SendFile pages
     *
     * @param send if true selects mailboxes for which the selected use has the 'send' privilege
     * @param get if true selects mailboxes for which the selected use has the 'get' privilege
     * @param mailboxes List of available Mailbox objects
     * @return List of SelectItem objects
     */
    public static List<SelectItem> getListOfMailboxes(List<Mailbox> mailboxes, boolean send, boolean get) {
        List<SelectItem> result = new ArrayList<>();
        for (Mailbox mailbox : mailboxes) {
            if ((send && mailbox.hasSend()) || (get && mailbox.hasGet())) {
                // Fix for the case of multiple uses pointing at the same box
                boolean exists = false;
                if (!result.isEmpty()) {
                    for (SelectItem item : result) {
                        if (item.getValue().equals(mailbox.getName()) && (item.getLabel().equals(mailbox.getCompleteDescription()))) {
                            exists = true;
                            break;
                        }
                    }
                }
                if (!exists) {
                    result.add(new SelectItem(mailbox.getName(), mailbox.getCompleteDescription()));
                }
            }
        }
        return result;
    }

    public static String transformSearchFilter(String filter) {
        StringBuilder sb = new StringBuilder();
        String regexp = " (?=([^\"]*\"[^\"]*\")*[^\"]*$)";
        String[] result = filter.trim().replaceAll("\\s{2,}", " ").replace("%", ".*").replace("_", "?").split(regexp);
        if ((result != null) && (result.length > 0)) {
            for (int i = 0; i < result.length; i++) {
                sb.append("(").append(result[i].replaceAll("\"", "")).append(")");
                if (i < result.length - 1) {
                    sb.append("|");
                }
            }
        }
        return sb.toString();
    }

}
