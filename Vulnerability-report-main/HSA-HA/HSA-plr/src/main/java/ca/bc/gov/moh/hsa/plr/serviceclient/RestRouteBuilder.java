package ca.bc.gov.moh.hsa.plr.serviceclient;

import ca.bc.gov.health.plr.dto.esb.BatchRequest;
import ca.bc.gov.health.plr.dto.esb.BatchResponse;
import ca.bc.gov.health.plr.dto.esb.BatchTransactionStatusRequest;
import ca.bc.gov.health.plr.dto.esb.BatchTransactionStatusResponse;
import ca.bc.gov.health.plr.dto.esb.MaintainProviderRequest;
import ca.bc.gov.health.plr.dto.esb.MaintainProviderResponse;
import ca.bc.gov.health.plr.dto.esb.QueryRequest;
import ca.bc.gov.health.plr.dto.esb.QueryResponse;
import ca.bc.gov.moh.hsa.plr.esb.service.maintain.FHIRProcessorMaintainIn;
import ca.bc.gov.moh.hsa.plr.esb.service.maintain.FHIRProcessorMaintainOut;
import ca.bc.gov.moh.hsa.plr.esb.service.maintain.MessageIdExtractor;
import ca.bc.gov.moh.hsa.plr.esb.service.query.FHIRProcessorQueryIn;
import ca.bc.gov.moh.hsa.plr.esb.service.query.FHIRProcessorQueryOut;
import ca.bc.gov.moh.hsa.plr.esb.service.util.ConvertMetadataToHeaders;
import ca.bc.gov.moh.hsa.plr.esb.service.util.ConvertHeadersToMetadata;
import ca.bc.gov.moh.hsa.plr.esb.service.util.RemoveTransactionHeader;
import ca.bc.gov.moh.hsa.plr.esb.service.util.RestoreTransactionHeader;
import ca.bc.gov.moh.hsa.plr.esb.service.util.SetTransactionInfo;
import ca.bc.gov.moh.hsa.plr.esb.service.util.SetTransportLayerSecurity;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.TimeZone;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.jackson.JacksonDataFormat;
import org.apache.camel.converter.jaxb.JaxbDataFormat;
import org.apache.camel.converter.stream.CachedOutputStream;
import org.hl7.v3.m4_0.QUMTIN200002MCCIMT000300Message;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import prs2.whic.org.response.GRSMESSAGES;

/**
 *
 * @author greg.perkins
 */
@Component
public class RestRouteBuilder extends RouteBuilder {

    @Value("${maintainURI}")
    private String maintainURI;

    @Value("${queryURI}")
    private String queryURI;

    @Value("${batchURI}")
    private String batchURI;

    @Value("${batchStatusURI}")
    private String batchStatusURI;

    private static final RestoreTransactionHeader RESTORE_TRANSACTION_HEADER = new RestoreTransactionHeader();
    private static final RemoveTransactionHeader REMOVE_TRANSACTION_HEADER = new RemoveTransactionHeader();

    private static final SetTransactionInfo SET_TRANSACTION_INFO = new SetTransactionInfo();

    private static final ConvertHeadersToMetadata CONVERT_HEADERS_TO_METADATA = new ConvertHeadersToMetadata();
    private static final ConvertMetadataToHeaders CONVERT_METADATA_TO_HEADERS = new ConvertMetadataToHeaders();

    private static final SimpleDateFormat JSON_DATE_FORMAT_OJDK11 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");

    static {
        JSON_DATE_FORMAT_OJDK11.setLenient(false);
    }

    @Override
    public void configure() throws Exception {

        ObjectMapper obMapper = new ObjectMapper();
        DateFormat df = JSON_DATE_FORMAT_OJDK11;
        df.setTimeZone(TimeZone.getTimeZone("UTC"));

        obMapper.setDateFormat(df);
        obMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        obMapper.disable(SerializationFeature.WRITE_DATES_WITH_ZONE_ID);
        obMapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);

        // https://jira.vic.cgi.com/browse/PLR-2127?focusedCommentId=28333&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-28333
        getContext().getProperties().put(CachedOutputStream.THRESHOLD, "0");

        //Set the https to use TLSv1.2
        SetTransportLayerSecurity.getRegistry();

        JacksonDataFormat maintainFormat = new JacksonDataFormat(MaintainProviderRequest.class);
        maintainFormat.setInclude("NON_NULL");
        maintainFormat.setPrettyPrint(true);
        maintainFormat.setObjectMapper(obMapper);
        maintainFormat.disableFeature(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        JacksonDataFormat maintainResponseFormat = new JacksonDataFormat(MaintainProviderResponse.class);
        maintainResponseFormat.disableFeature(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        maintainResponseFormat.setInclude("NON_NULL");
        maintainResponseFormat.setPrettyPrint(true);
        maintainResponseFormat.setObjectMapper(obMapper);

        from("direct:plrMaintain")
                .routeId("direct:plrMaintain")
                .marshal(maintainFormat)
                .convertBodyTo(String.class)
                .to("audit:MAINTAIN_REST_IN?level=INFO")
                .to("messagedrop:MAINTAIN_REST_IN")
                .removeHeaders("CamelHttp*")
                .removeHeaders("org.apache.cxf*")
                .removeHeaders("CamelCxfMessage*")
                .removeHeader("HSA_TRANSACTION")
                .setHeader(Exchange.HTTP_METHOD, constant("POST")).setHeader("content-type", simple("application/json"))
                .process(REMOVE_TRANSACTION_HEADER)
                .to(maintainURI)
                .process(RESTORE_TRANSACTION_HEADER)
                .convertBodyTo(String.class)
                .to("audit:MAINTAIN_REST_OUT?level=INFO")
                .to("messagedrop:MAINTAIN_REST_OUT")
                .unmarshal(maintainResponseFormat);

        JacksonDataFormat queryFormat = new JacksonDataFormat(QueryRequest.class);
        queryFormat.disableFeature(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        queryFormat.setInclude("NON_NULL");
        queryFormat.setPrettyPrint(true);
        queryFormat.setObjectMapper(obMapper);

        JacksonDataFormat queryResponseFormat = new JacksonDataFormat(QueryResponse.class);
        queryResponseFormat.disableFeature(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        queryResponseFormat.setInclude("NON_NULL");
        queryResponseFormat.setPrettyPrint(true);
        queryResponseFormat.setObjectMapper(obMapper);

        from("direct:plrQuery")
                .routeId("direct:plrQuery")
                .marshal(queryFormat)
                .convertBodyTo(String.class)
                .to("audit:QUERY_REST_IN?level=INFO")
                .to("messagedrop:QUERY_REST_IN")
                .removeHeaders("CamelHttp*")
                .setHeader(Exchange.HTTP_METHOD, constant("POST")).setHeader("content-type", simple("application/json"))
                .process(REMOVE_TRANSACTION_HEADER)
                .to(queryURI)
                .process(RESTORE_TRANSACTION_HEADER)
                .convertBodyTo(String.class)
                .to("audit:QUERY_REST_OUT?level=INFO")
                .to("messagedrop:QUERY_REST_OUT")
                .unmarshal(queryResponseFormat);

        JacksonDataFormat batchFormat = new JacksonDataFormat(BatchRequest.class);
        batchFormat.disableFeature(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        batchFormat.setInclude("NON_NULL");
        batchFormat.setPrettyPrint(true);
        batchFormat.setObjectMapper(obMapper);
        batchFormat.disableFeature(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        from("direct:plrBatch")
                .routeId("direct:plrBatch")
                .streamCaching()
                .process(SET_TRANSACTION_INFO)
                .process(CONVERT_HEADERS_TO_METADATA)
                .marshal(batchFormat)
                .to("audit:BATCH_REST_IN?level=INFO")
                .to("messagedrop:BATCH_REST_IN")
                .removeHeaders("CamelHttp*")
                .setHeader(Exchange.HTTP_METHOD, constant("POST")).setHeader("content-type", simple("application/json"))
                .process(REMOVE_TRANSACTION_HEADER)
                .to(batchURI)
                .process(RESTORE_TRANSACTION_HEADER)
                .to("audit:BATCH_REST_OUT?level=INFO")
                .to("messagedrop:BATCH_REST_OUT");

        JaxbDataFormat plrJaxbFormat = new JaxbDataFormat("prs2.whic.org.response");
        plrJaxbFormat.setPrettyPrint(true);
        JaxbDataFormat hl740JaxbFormat = new JaxbDataFormat("org.hl7.v3.m4_0");
        hl740JaxbFormat.setPrettyPrint(true);
        JacksonDataFormat batchResponseFormat = new JacksonDataFormat(BatchResponse.class);
        batchResponseFormat.disableFeature(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        batchResponseFormat.setInclude("NON_NULL");
        batchResponseFormat.setPrettyPrint(true);
        batchResponseFormat.setObjectMapper(obMapper);

        from("rest://get:healthCheck")
                .routeId("rest://get:healthCheck")
                .transform(simple("ok"));

        FHIRProcessorQueryIn FHIRQueryIn = new FHIRProcessorQueryIn();
        FHIRProcessorQueryOut FHIRQueryOut = new FHIRProcessorQueryOut();
        FHIRProcessorMaintainIn FHIRMaintainIn = new FHIRProcessorMaintainIn();
        FHIRProcessorMaintainOut FHIRMaintainOut = new FHIRProcessorMaintainOut();

        from("rest://get:Bundle/{id}")
                .routeId("rest://get:Bundle/{id}")
                .log("The ${routeId} route received a request")
                .to("audit:RECEIVE?transactionType=QUERYPROVIDERS&level=INFO")
                .to("messagedrop:RECEIVE")
                .process(FHIRQueryIn)
                .to("direct:plrQuery")
                .process(FHIRQueryOut)
                .to("audit:RESPOND?level=INFO")
                .to("messagedrop:RESPOND")
                .removeHeader("HSA_TRANSACTION");

        from("rest://put:Bundle/{id}")
                .routeId("rest://put:Bundle")
                .streamCaching()
                .log("The ${routeId} route received a request")
                .to("audit:RECEIVE?transactionType=MAINTAINPROVIDER&level=INFO")
                .to("messagedrop:RECEIVE")
                .convertBodyTo(String.class)
                .process(FHIRMaintainIn)
                .to("direct:plrMaintain")
                .process(FHIRMaintainOut)
                .to("audit:RESPOND?level=INFO")
                .to("messagedrop:RESPOND")
                .removeHeader("HSA_TRANSACTION");

        from("rest://post:plrBatch")
                .routeId("rest://post:plrBatch")
                .log("The ${routeId} route received a request")
                .wireTap("direct:postBatchResponse")
                .transform(constant("ok"));

        from("direct:postBatchResponse")
                .routeId("direct:postBatchResponse")
                .streamCaching()
                // Unmarshal in order to restore headers from metadata because
                // the audit and messagedrop components use these headers.
                .unmarshal(batchResponseFormat)
                .process(CONVERT_METADATA_TO_HEADERS)
                // Marshal in order to audit and drop the message.
                .marshal(batchResponseFormat)
                .to("audit:BATCH_RESP_REST_OUT?level=INFO")
                // The audit component must be run before the messagedrop
                // component because the audit component restores the 
                // TRANSACTION_MESSAGE_TYPE_HEADER_KEY header by looking it up
                // in the DB using the TRANSACTION_ID_HEADER_KEY, and the
                // TRANSACTION_MESSAGE_TYPE_HEADER_KEY is used to determine
                // which folder to place the filedrop in ("BATCHPROVIDER").
                .to("messagedrop:BATCH_RESP_REST_OUT")
                .unmarshal(batchResponseFormat)
                .choice()
                .when().simple("${headers.hl7} == null or ${headers.hl7} == 'true'")
                .convertBodyTo(QUMTIN200002MCCIMT000300Message.class)
                .bean(MessageIdExtractor.class)
                .otherwise()
                .convertBodyTo(GRSMESSAGES.class)
                .end()
                .to(ExchangePattern.InOnly, "direct:plrBatchResponseQueue");

        JacksonDataFormat batchStatusFormat = new JacksonDataFormat(BatchTransactionStatusRequest.class);
        batchStatusFormat.disableFeature(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        batchStatusFormat.setInclude("NON_NULL");
        batchStatusFormat.setPrettyPrint(true);
        batchStatusFormat.setObjectMapper(obMapper);

        JacksonDataFormat batchStatusResponseFormat = new JacksonDataFormat(BatchTransactionStatusResponse.class);
        batchStatusResponseFormat.disableFeature(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        batchStatusResponseFormat.setInclude("NON_NULL");
        batchStatusResponseFormat.setPrettyPrint(true);
        batchStatusResponseFormat.setObjectMapper(obMapper);

        from("direct:plrBatchStatus")
                .routeId("direct:plrBatchStatus")
                .marshal(batchStatusFormat)
                .convertBodyTo(String.class)
                .to("audit:BATCH_STATUS_REQUEST?level=INFO")
                .to("messagedrop:BATCH_STATUS_REQUEST")
                .removeHeaders("CamelHttp*")
                .setHeader(Exchange.HTTP_METHOD, constant("POST")).setHeader("content-type", simple("application/json"))
                .process(REMOVE_TRANSACTION_HEADER)
                .to(batchStatusURI)
                .process(RESTORE_TRANSACTION_HEADER)
                .convertBodyTo(String.class)
                .to("audit:BATCH_STATUS_REPLY?level=INFO")
                .to("messagedrop:BATCH_STATUS_REPLY")
                .unmarshal(batchStatusResponseFormat);

    }

//    public void setTransportSecurityLevel() throws KeyManagementException, NoSuchAlgorithmException {
//        getRegistry();
//    }
//    
//    //Set the https use TLSv1.2
//    private static Registry<ConnectionSocketFactory> getRegistry() throws KeyManagementException, NoSuchAlgorithmException {
//        SSLContext sslContext = SSLContexts.custom().build();
//        SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory(sslContext,
//                new String[]{"TLSv1.2"}, null, SSLConnectionSocketFactory.getDefaultHostnameVerifier());
//        return RegistryBuilder.<ConnectionSocketFactory>create()
//                .register("http", PlainConnectionSocketFactory.getSocketFactory())
//                .register("https", sslConnectionSocketFactory)
//                .build();
//    }
}
