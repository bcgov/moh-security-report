package ca.bc.gov.moh.hsa.plr.converter.facilitytofhir;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.lang3.ArrayUtils;

/**
 * This is just a helper class for some reflection methods.
 *
 * @author jonathan.wiebe
 */
public class ReflectionUtils {

    private static Map<String, Method> methodMap = new HashMap();

    /**
     * Invoke but with no arguments and assumed public member
     *
     * @param obj
     * @param methodName
     * @return
     * @throws InvocationTargetException
     */
    public static Object methodInvoke(Object obj, String methodName) throws InvocationTargetException {
        return methodInvoke(obj, methodName, false, null);
    }

    /**
     * Invoke the method
     *
     * @param obj Object with method
     * @param methodName Method to invoke
     * @param forceAccessible
     * @param args paramter
     * @return Result of invocation, can be null
     * @throws java.lang.reflect.InvocationTargetException
     */
    public static Object methodInvoke(Object obj, String methodName, boolean forceAccessible, Object args) throws InvocationTargetException {
        if (obj == null) {
            return null;
        }
        Method method = hasMethod(obj, methodName, args);
        if (method != null) {
            try {
                if (forceAccessible) {
                    method.setAccessible(forceAccessible);
                }
                return invokeMe(args, method, obj);
            } catch (IllegalAccessException | IllegalArgumentException | SecurityException ex) {
            }
        }
        return null;
    }

    public static Object invokeMe(Object args, Method method, Object obj) throws InvocationTargetException, IllegalArgumentException, IllegalAccessException {
        if (args != null) {
            return method.invoke(obj, args);
        } else {
            return method.invoke(obj);
        }
    }

    public static Method hasMethod(Object obj, String methodName) {
        return hasMethod(obj, methodName, null);
    }

    /**
     * Is there a method of that name?
     *
     * This method tries to save a bit of performance by hash-mapping the
     * results of each look up to avoid the looping where possible.
     *
     * @param obj Object to check
     * @param methodName Method name
     * @return True if there is a method
     */
    public static Method hasMethod(Object obj, String methodName, Object args) {
        if (obj == null) {
            return null;
        }
        Method retMethod = null;
        String key = obj.getClass().getCanonicalName() + "_" + methodName + (args != null ? "_" + args.getClass().getCanonicalName() : "");
        if (!methodMap.containsKey(key)) {
            Method[] methods = getDeclaredMethods(obj.getClass());
            for (Method method : methods) {
                if (noArgsMatch(methodName, method, args)) {
                    retMethod = method;
                    break;
                }
                if (oneArgMatch(args, method, methodName)) {
                    Class paramClazz = method.getParameterTypes()[0];
                    if (paramClazz.isInstance(args)) {
                        retMethod = method;
                        break;
                    }
                }
            }
            if (!methodMap.containsKey(key) && retMethod != null) {
                methodMap.put(key, retMethod);
            }
        } else {
            retMethod = methodMap.get(key);
        }

        return retMethod;
    }

    protected static boolean noArgsMatch(String methodName, Method method, Object args) {
        return methodName.matches(method.getName()) && method.getParameterCount() == 0 && args == null;
    }

    /**
     * Serch through class and parent classes until Object is hit
     *
     * @param clazz
     * @return
     */
    private static Method[] getDeclaredMethods(Class clazz) {
        Method[] methods = {};
        while (!(clazz.getSimpleName().equals(Object.class.getSimpleName()))) {
            methods = ArrayUtils.insert(methods.length, methods, clazz.getDeclaredMethods());
            clazz = clazz.getSuperclass();
        }
        return methods;
    }

    protected static boolean oneArgMatch(Object args, Method method, String methodName) {
        return args != null && method.getParameterCount() == 1 && method.getName().equals(methodName) && method.getParameterTypes()[0].isInstance(args);
    }

    /**
     * Gets the declared fields, including super classes
     * @param clazz
     * @return 
     */
    public static Field[] getDeclaredFields(Class clazz) {
        Field[] fields = {};
        while (!(clazz.getSimpleName().equals(Object.class.getSimpleName()))) {
            fields = ArrayUtils.insert(fields.length, fields, clazz.getDeclaredFields());
            clazz = clazz.getSuperclass();
        }
        return fields;
    }
}
