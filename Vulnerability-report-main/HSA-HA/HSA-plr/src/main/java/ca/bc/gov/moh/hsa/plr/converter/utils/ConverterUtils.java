package ca.bc.gov.moh.hsa.plr.converter.utils;

import java.io.StringWriter;
import java.io.Writer;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.PropertyException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.apache.commons.collections.BidiMap;
import org.apache.commons.collections.bidimap.DualHashBidiMap;
import org.apache.commons.lang.StringUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Node;

/**
 *
 * @author conrad.gustafson
 */
public class ConverterUtils implements OidsUser {

    private static final BidiMap OIDS_LOOKUP = initOidsLookup();

    public static final String SCHEME_EMAIL = "mailto";
    public static final String SCHEME_FTP = "ftp";
    public static final String SCHEME_HTTP = "http";
    public static final String SCHEME_MODEM = "modem";
    public static final String SCHEME_FAX = "fax";
    public static final String SCHEME_TEL = "tel";
    public static final int EXPIRY_DATE_DEFAULT_YEAR = 9999;
    
    /**
     * Constant for message interaction extension id for distribution add. 
     */
    public static final String MESSAGE_INTERACTION_EXTENSION_DIST_ORG_ADD = "IN401030CA";
    /**
     * Constant for message interaction extension id for distribution update. 
     */
    public static final String MESSAGE_INTERACTION_EXTENSION_DIST_ORG_UPDATE = "IN403030CA";
    /**
     * Constant for provider type 'ORG'. 
     */
    public static final String PROVIDER_TYPE_ORG = "ORG";

    private static final class PlrTypes {
        public static final String EMAIL = "E";
        public static final String FTP = "F";
        public static final String HTTP = "H";
        public static final String FAX = "FAX";
        public static final String MODEM = "M";
        public static final String MOBILE = "MB";
        public static final String PAGER = "PG";
        public static final String TELEPHONE = "T";
    }

    // Formats specified by JIRA PLR-1808 / EA REQ-01079.
    private static final SimpleDateFormat HL7_YEAR_MONTH_DAY_FORMAT = new SimpleDateFormat("yyyyMMdd");                                                           //  200001013
    private static final SimpleDateFormat HL7_DATE_TIME_FORMAT = new SimpleDateFormat("yyyyMMddHHmmss");
    private static final SimpleDateFormat PRS_XML_YEAR_MONTH_DAY_FORMAT = new SimpleDateFormat("yyyy-MM-dd");
    private static final SimpleDateFormat PRS_XML_DATE_TIME_FORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");

    private static final Map<String, String> plrTypeToHl7Use = new HashMap<>();
    private static final Map<String, String> plrPurposeToHl7Use = new HashMap<>();
    private static final Map<String, String> plrTypeToHl7Scheme = new HashMap<>();
    private static final Map<String, String> hl7SchemeToPlrType = new HashMap<>();

    private static String convertPlrTypeToHl7Use(String plrType) {
        return StringUtils.defaultString(plrTypeToHl7Use.get(plrType));
    }

    private static String convertPlrPurposeToHl7Use(String plrPurpose) {
        return StringUtils.defaultString(plrPurposeToHl7Use.get(plrPurpose));
    }

    public static String convertPlrTypeToHl7Scheme(String plrType) {
        return StringUtils.defaultString(plrTypeToHl7Scheme.get(plrType));
    }

    public static String convertToHl7Use(String communicationPurposeCode, String uncodedType) {
        String purpose = ConverterUtils.convertPlrPurposeToHl7Use(communicationPurposeCode);
        String type = ConverterUtils.convertPlrTypeToHl7Use(uncodedType);
        return (purpose + " " + type).trim(); // if either String is empty, trim the space
    }
    
    static {
        // The conversion between PLR TYPE and HL7 scheme is not easily bi-directional:
        // PAGER, MOBILE, and TELEPHONE types cannot be determined by scheme alone, and note
        // that PAGER, MOBILE, and TELEPHONE types all convert back to the same scheme: "tel".
        plrTypeToHl7Scheme.put(PlrTypes.EMAIL, SCHEME_EMAIL + ":");
        plrTypeToHl7Scheme.put(PlrTypes.FTP, SCHEME_FTP + ":");
        plrTypeToHl7Scheme.put(PlrTypes.HTTP, SCHEME_HTTP + ":");
        plrTypeToHl7Scheme.put(PlrTypes.FAX, SCHEME_FAX + ":");
        plrTypeToHl7Scheme.put(PlrTypes.MODEM, SCHEME_MODEM + ":");
        plrTypeToHl7Scheme.put(PlrTypes.MOBILE, SCHEME_TEL + ":");
        plrTypeToHl7Scheme.put(PlrTypes.PAGER, SCHEME_TEL + ":");
        plrTypeToHl7Scheme.put(PlrTypes.TELEPHONE, SCHEME_TEL + ":");
        
        hl7SchemeToPlrType.put(SCHEME_FAX, PlrTypes.FAX);
        hl7SchemeToPlrType.put(SCHEME_MODEM, PlrTypes.MODEM);
        hl7SchemeToPlrType.put(SCHEME_HTTP, PlrTypes.HTTP);
        hl7SchemeToPlrType.put(SCHEME_FTP, PlrTypes.FTP);
        hl7SchemeToPlrType.put(SCHEME_EMAIL, PlrTypes.EMAIL);
        hl7SchemeToPlrType.put(SCHEME_TEL, PlrTypes.TELEPHONE);

        plrTypeToHl7Use.put(PlrTypes.MOBILE, "MC");
        plrTypeToHl7Use.put(PlrTypes.PAGER, "PG");

        plrPurposeToHl7Use.put("HC", "H");
        plrPurposeToHl7Use.put("BC", "WP");
        plrPurposeToHl7Use.put("OC", "OTH");
        plrPurposeToHl7Use.put("CC", "CC");
        plrPurposeToHl7Use.put("DC", "DC");
        plrPurposeToHl7Use.put("MC", "MNC");
        plrPurposeToHl7Use.put("EC", "EC");
    }
    
    static {
        HL7_YEAR_MONTH_DAY_FORMAT.setLenient(false);
        HL7_DATE_TIME_FORMAT.setLenient(false);
        PRS_XML_YEAR_MONTH_DAY_FORMAT.setLenient(false);
        PRS_XML_DATE_TIME_FORMAT.setLenient(false);
    }
    
    public static String convertNodeToString(Node node) {

        try {
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            // Omit XML declration of HL7 batch response for PLR-1722.
            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
            DOMSource source = new DOMSource(node);
            Writer stringWriter = new StringWriter();
            StreamResult streamResult = new StreamResult(stringWriter);
            transformer.transform(source, streamResult);
            return stringWriter.toString();
        } catch (TransformerConfigurationException ex) {
            throw new RuntimeException(ex);
        } catch (TransformerException ex) {
            throw new RuntimeException(ex);
        }
    }

    public static Document marshall(Object hl7Message, Class<?> clazz, String schemaHeader) throws PropertyException, ParserConfigurationException, JAXBException {
        JAXBContext jaxbContext = JAXBContext.newInstance(clazz);
        Marshaller jaxbMarshaller = jaxbContext.createMarshaller();
        jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        Document document = db.newDocument();
        jaxbMarshaller.marshal(hl7Message, document);
        return document;
    }

    public static String convertToFlag(boolean booleanFlag) {
        return booleanFlag ? "Y" : "N";
    }

    public static String convertFromDateToPLRString(Date date) {
        if (date == null) {
            return null;
        }
        synchronized (PRS_XML_DATE_TIME_FORMAT) {
            return PRS_XML_DATE_TIME_FORMAT.format(date);
        }
    }

    public static String convertExpiryDateToPLRString(Date date) {
        if(isYearExpiryDateDefaultYear(date)) {
            return "";
        }
        return convertFromDateToPLRString(date);
    }
   
    public static String convertFromDateToHL7String(Date date) throws ParseException {
        if (date == null) {
            return null;
        }
        synchronized (HL7_DATE_TIME_FORMAT) {
            return HL7_DATE_TIME_FORMAT.format(date);
        }
    }

    public static String convertExpiryDateToHL7String(Date date) throws ParseException {
        if(isYearExpiryDateDefaultYear(date)) {
            return "";
        }
        return convertFromDateToHL7String(date);
    }
    
    public static Date convertFromPLRStringToDate(String prsXmlDateString) {
        return convertStringToDate(prsXmlDateString, PRS_XML_DATE_TIME_FORMAT, PRS_XML_YEAR_MONTH_DAY_FORMAT);
    }

    public static Date convertFromHL7StringToDate(String hl7DateString) {
        return convertStringToDate(hl7DateString, HL7_DATE_TIME_FORMAT, HL7_YEAR_MONTH_DAY_FORMAT);
    }
    
    /**
     * Converts dateString to the first applicable DateFormat. 
     * 
     * Throws an exception if none of the formats match. 
     * Returns null if dateString is empty or null.
     * 
     * @param dateString a valid date string.
     * @param dateFormats convert dateString to a Date using the first applicable
     * DateFormat.
     * @return a Date representing the given dateString, or null if dateString
     * was empty or null.
     */
    public static Date convertStringToDate(String dateString, DateFormat... dateFormats) {
        if (StringUtils.isEmpty(dateString)) {
            return null;
        }
 
        for (DateFormat format : dateFormats) {
            // Synchronized because DateFormats are not thread-safe.
            synchronized (format) {
                try {
                    return format.parse(dateString);
                } catch (ParseException ex) {
                    // ignore and try the next format
                }
            }
        }
        throw new IllegalArgumentException("'" + dateString + "' is not a valid date. Please correct and resubmit.");
    }

    public static String findIdForOid416(List<org.hl7.v3.m4_16.II> ids, String oidToFind) {
        if (ids == null || StringUtils.isEmpty(oidToFind)) {
            return null;
        }
        for (org.hl7.v3.m4_16.II id : ids) {
            String root = id.getRoot();
            if (oidToFind.equals(root)) {
                return id.getExtension();
            }
        }
        return null;
    }

    public static String findIdForOid40(List<org.hl7.v3.m4_0.II> ids, String oidToFind) {
        if (ids == null || StringUtils.isEmpty(oidToFind)) {
            return null;
        }
        for (org.hl7.v3.m4_0.II id : ids) {
            String root = id.getRoot();
            if (oidToFind.equals(root)) {
                return id.getExtension();
            }
        }
        return null;
    }

    public static String getOidValue(String oid) {
        return (String) OIDS_LOOKUP.get(oid);
    }

    public static String getOid(String value) {
        return (String) OIDS_LOOKUP.inverseBidiMap().get(value);
    }

    private static BidiMap initOidsLookup() {
        BidiMap map = new DualHashBidiMap();
        map.put("2.16.840.1.113883.3.40.0.1", "internalID-oid");
        map.put("2.16.840.1.113883.3.40.0.2", "provider-oid");
        map.put("2.16.840.1.113883.3.40.1.1", "condition-oid");
        map.put("2.16.840.1.113883.3.40.1.10", "workLocation-oid");
        map.put("2.16.840.1.113883.3.40.1.2", "credential-oid");
        map.put("2.16.840.1.113883.3.40.1.3", "credentialType-oid");
        map.put("2.16.840.1.113883.3.40.1.4", "dispAction-oid");
        map.put("2.16.840.1.113883.3.40.1.5", "message-oid");
        map.put("2.16.840.1.113883.3.40.1.6", "note-oid");
        map.put("2.16.840.1.113883.3.40.1.7", "profile-oid");
        map.put("2.16.840.1.113883.3.40.1.8", "relationship-oid");
        map.put("2.16.840.1.113883.3.40.1.9", "targetMessage-oid");
        map.put("2.16.840.1.113883.3.40.2.6", "DENID");
        map.put("2.16.840.1.113883.3.40.2.10", "LPNID");
        map.put("2.16.840.1.113883.3.40.2.11", "MPID");
        map.put("2.16.840.1.113883.3.40.2.14", "PHID");
        map.put("2.16.840.1.113883.3.40.2.44", "PPID");
        map.put("2.16.840.1.113883.3.40.2.45", "MRTID");
        map.put("2.16.840.1.113883.3.40.2.46", "MOAID");
        map.put("2.16.840.1.113883.3.40.2.47", "ENPID");
        map.put("2.16.840.1.113883.4.607", "PHYID");
        map.put("2.16.840.1.113883.4.454", "RACID");
        map.put("2.16.840.1.113883.3.40.2.18", "RMID");
        map.put("2.16.840.1.113883.3.40.2.19", "RNID");
        map.put("2.16.840.1.113883.3.40.2.20", "RNPID");
        map.put("2.16.840.1.113883.3.40.2.23", "ORGID");
        map.put("2.16.840.1.113883.3.40.2.24","OOPID");
        map.put("2.16.840.1.113883.3.40.2.26", "AOMDID");
        map.put("2.16.840.1.113883.3.40.2.27", "CCPID");
        map.put("2.16.840.1.113883.3.40.2.28", "CREGID");
        map.put("2.16.840.1.113883.3.40.2.29", "EDCLASS1ID");
        map.put("2.16.840.1.113883.3.40.2.3", "CPN");
        map.put("2.16.840.1.113883.3.40.2.30", "EDCLASS2ID");
        map.put("2.16.840.1.113883.3.40.2.31", "EMRID");
        map.put("2.16.840.1.113883.3.40.2.32", "HAID");
        map.put("2.16.840.1.113883.4.429", "OPTID");
        map.put("2.16.840.1.113883.3.40.2.34", "PCPID");
        map.put("2.16.840.1.113883.3.40.2.35", "SRID");
        map.put("2.16.840.1.113883.3.40.2.36", "SRPART1ID");
        map.put("2.16.840.1.113883.3.40.2.37", "SRPART2ID");
        map.put("2.16.840.1.113883.3.40.2.38", "SRPART3ID");
        map.put("2.16.840.1.113883.3.40.2.39", "SRPART4ID");
        map.put("2.16.840.1.113883.3.40.2.4", "CPSID");
        map.put("2.16.840.1.113883.3.40.2.40", "SRPART5ID");
        map.put("2.16.840.1.113883.3.40.2.41", "SRPART6ID");
        map.put("2.16.840.1.113883.3.40.2.42", "SRPART7ID");
        map.put("2.16.840.1.113883.3.40.2.43", "SRPART8ID");
        map.put("2.16.840.1.113883.3.40.2.8", "IPC");
        map.put("2.16.840.1.113883.3.40.2.9", "JULI");
        map.put("2.16.840.1.113883.3.40.3.1", "identifier-oid");
        map.put("2.16.840.1.113883.3.40.3.2", "registryId-oid");
        map.put("2.16.840.1.113883.3.40.3.3", "registryUserOrg-oid");
        map.put("2.16.840.1.113883.3.40.4.1", "receiverOrganization-oid");
        map.put("2.16.840.1.113883.3.40.4.2", "senderOrganization-oid");
        map.put("2.16.840.1.113883.3.40.5.1", "receiverDevice-oid");
        map.put("2.16.840.1.113883.3.40.5.2", "senderDevice-oid");
        map.put("2.16.840.1.113883.3.40.6.1", "responsibleUser-oid");
        map.put("2.16.840.1.113883.3.40.6.2", "sendingUser-oid");
        map.put("2.16.840.1.113883.4.363", "CCID");
        map.put("2.16.840.1.113883.4.364", "OTID");
        map.put("2.16.840.1.113883.4.361", "SWID");
        map.put("2.16.840.1.113883.4.362", "PSYCHID");
        map.put("2.16.840.1.113883.4.439", "KNID");
        map.put("2.16.840.1.113883.4.452", "MFTID");
        map.put("2.16.840.1.113883.4.401", "PHTID");
        map.put("2.16.840.1.113883.4.414", "PHYSIOID");
        map.put("2.16.840.1.113883.4.422", "CHIROID");
        map.put("2.16.840.1.113883.4.433", "RMTID");
        map.put("2.16.840.1.113883.4.477", "COUNID");
        map.put("2.16.840.1.113883.4.530", "RDID");
        map.put("2.16.840.1.113883.4.538", "NDID");
        map.put("2.16.840.1.113883.4.753", "POID");
        return map;
    }

    public static List<String> createCommunicationUses(String addressTypeCode, String communicationPurposeCode) {
        List<String> uses = new ArrayList<>();

        if ("P".equals(addressTypeCode)) {
            uses.add("PHYS");
        } else if ("M".equals(addressTypeCode)) {
            uses.add("PST");
        } else if (PlrTypes.MOBILE.equals(addressTypeCode)) {
            uses.add("MC");
        } else if (PlrTypes.PAGER.equals(addressTypeCode)) {
            uses.add("PG");
        }

        if ("MC".equals(communicationPurposeCode)) {
            uses.add("MNC");
        } else if ("OC".equals(communicationPurposeCode)) {
            uses.add("OTH");
        } else if ("BC".equals(communicationPurposeCode)) {
            uses.add("WP");
        } else if ("HC".equals(communicationPurposeCode)) {
            uses.add("H");
        } else if ("CC".equals(communicationPurposeCode)) {
            uses.add("CC");
        } else if ("DC".equals(communicationPurposeCode)) {
            uses.add("DC");
        } else if ("EC".equals(communicationPurposeCode)) {
            uses.add("EC");
        }

        return uses;
    }

    public static String convertPurpose(List<String> uses) {
        if (uses == null) {
            return null;
        }
        String useCode = null;
        if (uses.contains("MNC")) {
            useCode = "MC";
        } else if (uses.contains("OTH")) {
            useCode = "OC";
        } else if (uses.contains("WP")) {
            useCode = "BC";
        } else if (uses.contains("DC")) {
            useCode = "DC";
        } else if (uses.contains("H")) {
            useCode = "HC";
        } else if (uses.contains("CC")) {
            useCode = "CC";
        } else if (uses.contains("EC")) {
            useCode = "EC";
        }

        return useCode;
    }
    
     public static String reverseConvertPurpose(String uses) {
        if (uses == null) {
            return null;
        }
        String useCode = null;
        if (uses.contains("MC")) {
            useCode = "MC";
        } else if (uses.contains("OC")) {
            useCode = "OTH";
        } else if (uses.contains("BC")) {
            useCode = "WP";
        } else if (uses.contains("DC")) {
            useCode = "DC";
        } else if (uses.contains("HC")) {
            useCode = "H";
        }

        return useCode;
    }

    public static String convertToPlrType(String scheme, List<String> use) {
        if(scheme != null){
            if (use.contains("PG") && SCHEME_TEL.equals(scheme)) {
                return PlrTypes.PAGER;
            }
            if (use.contains("MC") && SCHEME_TEL.equals(scheme)) {
                return PlrTypes.MOBILE;
            }
            if ((use.contains("MC") || use.contains("PG")) && !SCHEME_TEL.equals(scheme)) {
                return "invalid";
            }
            if (hl7SchemeToPlrType.containsKey(scheme)) {
                return hl7SchemeToPlrType.get(scheme);
            }
        }
        return "--";
    }

    public static String mapPersonNameUse(List<String> uses) {
        if (uses == null) {
            return null;
        }
        String useCode = null;
        if (uses.contains("C")) {
            useCode = "CRED";
        } else if (uses.contains("L")) {
            useCode = "CURR";
        }

        return useCode;
    }
    
    public static String reverseMapPersonNameUse(String uncodedType){
        if ("CRED".equals(uncodedType)){
            return "C";
        }
        if ("CURR".equals(uncodedType)){
            return "L";
        }  
        return null;
    }

    public static String convertAddressUse(List<String> uses) {
        if (uses == null) {
            return null;
        }
        String useCode = null;
        if (uses.contains("PHYS")) {
            useCode = "P";
        } else if (uses.contains("PST")) {
            useCode = "M";
        } else if (uses.contains("MC")) {
            useCode = PlrTypes.MOBILE;
        } else if (uses.contains("PG")) {
            useCode = PlrTypes.PAGER;
        }

        return useCode;
    }

    public static boolean isRegistryIdType(String idRoot) {
        return REGISTRY_IDENTIFIER_CPN_OID.equals(idRoot) || REGISTRY_IDENTIFIER_IPC_OID.equals(idRoot);
    }
    
    private static int extractYear(Date date) {
        if(date==null) {
            return -1;
        }
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        return cal.get(Calendar.YEAR);
    }
    
    public static boolean isYearExpiryDateDefaultYear(Date date) {
        if(extractYear(date)==EXPIRY_DATE_DEFAULT_YEAR) {
            return true;
        }
        return false;
    }

}
