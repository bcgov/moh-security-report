package ca.bc.gov.moh.hsa.plr.esb.service.batch;

import java.io.ByteArrayInputStream;
import java.io.StringReader;
import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.springframework.stereotype.Component;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;

/**
 * Component for validating HL7v3 batch messages Validates the message wrapper,
 * and the sub-messages Currently supports only the 301010(add) and
 * 303030(update) message types
 *
 * @author greg.perkins
 */
@Component
public class BatchMessageValidator implements Processor {

    Validator wrapperValidator;
    Validator addValidator;
    Validator updateValidator;

    static final String WRAPPER_SCHEMA_PATH = "/schema/hl7v3_4.0/schemas/MCCI_IN200100.xsd";
    static final String ADD_SCHEMA_PATH = "/schema/hl7v3_4.0/schemas/PRPM_IN301010.xsd";
    static final String UPDATE_SCHEMA_PATH = "/schema/hl7v3_4.0/schemas/PRPM_IN303010.xsd";

    public BatchMessageValidator() {
        try {

            // Need to set the SystemID on the StreamSource so that referenced XSD files with relative paths can be found.
            Source wrapperSchemaFile = new StreamSource(getClass().getResourceAsStream(WRAPPER_SCHEMA_PATH),
                    getClass().getResource(WRAPPER_SCHEMA_PATH).toString());
            Source addSchemaFile = new StreamSource(getClass().getResourceAsStream(ADD_SCHEMA_PATH),
                    getClass().getResource(ADD_SCHEMA_PATH).toString());
            Source updateSchemaFile = new StreamSource(getClass().getResourceAsStream(UPDATE_SCHEMA_PATH),
                    getClass().getResource(UPDATE_SCHEMA_PATH).toString());

            SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
            Schema addSchema = schemaFactory.newSchema(addSchemaFile);
            Schema updateSchema = schemaFactory.newSchema(updateSchemaFile);
            Schema wrapperSchema = schemaFactory.newSchema(wrapperSchemaFile);

            addValidator = addSchema.newValidator();
            updateValidator = updateSchema.newValidator();
            wrapperValidator = wrapperSchema.newValidator();

        } catch (Exception e) {
            throw new RuntimeException(e);
        }

    }

    /**
     * Processes the exchange: Validates the wrapper message, and each of the
     * wrapped messages individually
     *
     * @param exchange Exchange - the input message
     * @throws java.lang.Exception
     */
    @Override
    public synchronized void process(Exchange exchange) throws Exception {
        
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setValidating(false);
        DocumentBuilder builder = factory.newDocumentBuilder();
        
        String message = exchange.getIn().getBody(String.class);

        /*
         * The message is split up into parts, and each part will be parsed and
         * validated individually to reduce memory usage. Creating a DOM tree
         * of a 6000 message batch file can consume a large amout of memory,
         * and result in an OutOfMemoryException
         */

        String wrapper = "";
        String contents = "";

        // Split the file into the wrapper message, and batch message list
        int start1 = message.indexOf("PRPM_IN301010");
        int start2 = message.indexOf("PRPM_IN303010");
        int start = Math.min(start1, start2);
        if (start1 == -1) {
            start = start2;
        } else if (start2 == -1) {
            start = start1;
        }
        start = start - 1;
        int end = Math.max(message.lastIndexOf("PRPM_IN301010"), message.lastIndexOf("PRPM_IN303010")) + 14;
        if (start > 0 && end > 12) {
            wrapper = message.substring(0, start) + message.substring(end);
            contents = message.substring(start, end);
            message = null;
        } else {
            //No sub-messages!
            wrapper = message;
            message = null;
        }

        //Parse and validate the wrapper message
        Document doc = builder.parse(new InputSource(new StringReader(wrapper)));
        wrapperValidator.validate(new DOMSource(doc));

        //Parse and validate individual add messages
        start = 0;
        while (contents.indexOf("<PRPM_IN301010", start) > -1) {
            start = contents.indexOf("<PRPM_IN301010", start);
            end = contents.indexOf("</PRPM_IN301010>", start) + 16;
            String subMessage = contents.substring(start, end);
            doc = builder.parse(new InputSource(new StringReader(subMessage)));
            addValidator.validate(new DOMSource(doc));
            start = end + 1;
        }

        //Parse and validate  individual update messages
        start = 0;
        while (contents.indexOf("<PRPM_IN303010", start) > -1) {
            start = contents.indexOf("<PRPM_IN303010", start);
            end = contents.indexOf("</PRPM_IN303010>", start) + 16;
            String subMessage = contents.substring(start, end);
            doc = builder.parse(new InputSource(new StringReader(subMessage)));
            updateValidator.validate(new DOMSource(doc));
            start = end + 1;
        }

    }

}
