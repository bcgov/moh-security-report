/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.moh.hsa.util.audit;

import ca.bc.gov.moh.hsa.util.SimpleSerializer;
import static ca.bc.gov.moh.hsa.util.audit.TransactionIDAssigner.TRANSACTION_ID_HEADER_KEY;
import ca.bc.gov.moh.hsa.util.audit.entity.AffectedParty;
import ca.bc.gov.moh.hsa.util.audit.entity.EventMessage;
import ca.bc.gov.moh.hsa.util.audit.entity.Transaction;
import ca.bc.gov.moh.hsa.util.audit.entity.TransactionEvent;
import ca.bc.gov.moh.hsa.util.audit.entity.dao.TransactionDAO;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

/**
 * Processor class for auditing events in the Camel flows. Details can be added
 * by implementing the following interfaces on the classes for a Message object:
 *
 * AuditableMessage AuditableResponse AuditableParty
 *
 * @author greg.perkins
 */
@Component
public class AuditProcessor implements Processor {

    public static final String TRANSACTION_HEADER_KEY = "HSA_TRANSACTION";

    public static String MESSAGE_ID_HEADER_KEY = "messageId";

    /**
     * DAO for persisting transactions
     */
    @Autowired
    private TransactionDAO dao;

    /**
     * Configuration variables passed in from camel config
     */
    private String eventType = "DEFAULT";
    private String level = "DEFAULT";
    private String status = null;
    private String transactionType = null;

    /**
     * Default constructor
     */
    public AuditProcessor() {
    }

    /**
     * Constructor
     *
     * @param eventType String
     * @param level String
     * @param status String
     * @param transactionType String
     */
    public AuditProcessor(String eventType, String level, String status, String transactionType) {
        this.eventType = eventType;
        this.level = level;
        this.status = status;
        this.transactionType = transactionType;
    }

    /**
     * Setter for DAO
     *
     * @param dao TransactionDAO
     */
    public void setDao(TransactionDAO dao) {
        this.dao = dao;
    }

    /**
     * Audits the current state of the exchange to the transaction auditing
     * database
     *
     * @param exchange Exchange
     * @throws Exception
     */
    @Override
    @Transactional
    public void process(Exchange exchange) throws Exception {
        synchronized (dao) {
            boolean newTransaction = false;

            String serializedTransaction = exchange.getIn().getHeader(TRANSACTION_HEADER_KEY, String.class);
            String tid = exchange.getIn().getHeader(TRANSACTION_ID_HEADER_KEY, String.class);
            
            Transaction transaction;
            if (!StringUtils.isEmpty(serializedTransaction)) {
                transaction = (Transaction) SimpleSerializer.fromString(serializedTransaction);
            } else if (!StringUtils.isEmpty(tid)) {
                transaction = dao.getTransaction(tid);
                exchange.getIn().setHeader(FileDropComponent.TRANSACTION_MESSAGE_TYPE_HEADER_KEY, transaction.getType());
            } else {
                newTransaction = true;
                String transactionID = UUID.randomUUID().toString();
                exchange.getIn().setHeader(TRANSACTION_ID_HEADER_KEY, transactionID);
                transaction = new Transaction(transactionID);
            }

            if (status != null) {
                transaction.setStatus(status);
            } else {
                transaction.setStatus(eventType);
            }

            if (transactionType != null) {
                transaction.setType(transactionType);

                String messageTypeHeader = (String) exchange.getIn().getHeader(FileDropComponent.TRANSACTION_MESSAGE_TYPE_HEADER_KEY);
                if (StringUtils.isEmpty(messageTypeHeader)) {
                    exchange.getIn().setHeader(FileDropComponent.TRANSACTION_MESSAGE_TYPE_HEADER_KEY, transactionType);
                }
            }

            Object body = exchange.getIn().getBody();

            TransactionEvent event = new TransactionEvent();
            event.setEventTime(new Date());
            event.setType(eventType);
            String messageId = null;
            event.setTransactionId(transaction);
            if (body instanceof AuditableMessage) {
                messageId = ((AuditableMessage) body).getMessageId();
            } else {
                messageId = exchange.getIn().getHeader(MESSAGE_ID_HEADER_KEY, String.class);
            }
            event.setMessageId(messageId);

            if (body instanceof AffectedParties) {
                List<AuditableParty> parties = ((AffectedParties) body).getAuditableParties();
                for (AuditableParty party : parties) {
                    AffectedParty ap = new AffectedParty();
                    ap.setTransactionId(transaction);
                    ap.setIdentifierSource(party.getIdentifierSource());
                    ap.setIdentifier(party.getIdentifier());
                    ap.setIdentifierType(party.getIdentifierType());
                    ap.setStatus(party.getStatus());
                    if (ap.getIdentifier() != null && !ap.getIdentifier().isEmpty()) {
                        transaction.getAffectedPartyList().add(ap);
                    }
                }
            }

            if (body instanceof AuditableResponse) {
                AuditableResponse auditable = (AuditableResponse) body;
                List<AuditableResponseMessage> auditableResponseMessageList = auditable.getAuditableResponseMessageList();
                for (AuditableResponseMessage auditableResponseMessage : auditableResponseMessageList) {
                    EventMessage eventMessage = new EventMessage();
                    eventMessage.setErrorCode(StringUtils.abbreviate(auditableResponseMessage.getResponseCode(), 50));
                    eventMessage.setLevel(level);
                    eventMessage.setMessageText(StringUtils.abbreviate(auditableResponseMessage.getResponseText(), 500));
                    eventMessage.setTransactionEventId(event);
                    event.getEventMessageList().add(eventMessage);
                }

            } else if (exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class) != null) {
                Throwable exception = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Throwable.class);
                while (exception.getCause()!=null){
                    exception = exception.getCause();
                }
                EventMessage eventMessage = new EventMessage();
                eventMessage.setErrorCode(StringUtils.abbreviate(exception.getClass().getSimpleName(), 50));
                eventMessage.setLevel(level);
                String msg = StringUtils.abbreviate(exception.getMessage(), 500);
                eventMessage.setMessageText(msg);
                eventMessage.setTransactionEventId(event);
                event.getEventMessageList().add(eventMessage);
            }
            transaction.getTransactionEventList().add(event);

            try {
                if (newTransaction) {
                    transaction = dao.insert(transaction);
                } else {
                    transaction = dao.update(transaction);
                }

            } catch (Exception e) {
                e.printStackTrace();
            }

            String newSerializedTransaction = SimpleSerializer.toString(transaction);
            exchange.getIn().setHeader(TRANSACTION_HEADER_KEY, newSerializedTransaction);
        }
    }
}
