package ca.bc.gov.health.plr.web.bean;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.AddressDto;
import ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.OrgNameDto;
import ca.bc.gov.health.plr.dto.provider.PersonNameDto;
import ca.bc.gov.health.plr.dto.provider.ProviderType;
import ca.bc.gov.health.plr.dto.provider.StatusDto;
import ca.bc.gov.health.plr.dto.provider.search.SearchProviderResult;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import ca.bc.gov.health.plr.service.provider.SearchProviderService;
import ca.bc.gov.health.plr.dto.provider.search.SearchProviderRequest;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.service.provider.ProviderHelperService;
import ca.bc.gov.health.plr.web.Droplists;
import ca.bc.gov.health.plr.web.util.JSFUtils;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Logger;
import javax.annotation.PostConstruct;
import javax.ejb.EJB;
import javax.faces.application.FacesMessage;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.SessionScoped;
import javax.faces.context.FacesContext;
import javax.faces.model.SelectItem;
import javax.inject.Inject;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;

/**
 * JSF backing bean for SearchProvider.xhtml.
 *
 * @author Grant.Hodgins
 */
@ManagedBean
@SessionScoped
public class SearchProviderManager {
    
    private static final String CLASSNAME = SearchProviderManager.class.getSimpleName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);

    /**
     * alt enter to space the names, etc a little nicer
     */
    public static final char ALT_ENTER = 10;

    /**
     * HTML line break
     */
    private static final String HTML_BR = "<br/>";

    /**
     * render html or not
     */
    private boolean renderForExport = false;

    @EJB
    private SearchProviderService searchProviderService;
    private SearchProviderRequest searchProviderFormData;
    private SearchProviderResult searchResult;
    private List<SelectItem> providerRoleTypeINDSelectItems;
    private List<PrsCtProviderRoleTypes> providerRoleTypeForSearchOrg;
    private boolean allowSearchForOrg = false;

    public List<SelectItem> getProviderRoleTypeINDSelectItems() {
        return providerRoleTypeINDSelectItems;
    }

    public void setProviderRoleTypeINDSelectItems(List<SelectItem> providerRoleTypeINDSelectItems) {
        this.providerRoleTypeINDSelectItems = providerRoleTypeINDSelectItems;
    }
    private List<SelectItem> providerRoleTypeORGSelectItems;

    public List<SelectItem> getProviderRoleTypeORGSelectItems() {
        return providerRoleTypeORGSelectItems;
    }

    public void setProviderRoleTypeORGSelectItems(List<SelectItem> providerRoleTypeORGSelectItems) {
        this.providerRoleTypeORGSelectItems = providerRoleTypeORGSelectItems;
    }
    private List<SelectItem> expertiseTypeSelectItems;

    private boolean searchWithHistory;

    @Inject
    Droplists droplists;

    @EJB
    ProviderHelperService providerServiceHelper;
    
    private List<SelectItem> statusCodeSelectItems = new ArrayList<>();
    private List<SelectItem> statusReasonCodeSelectItems = new ArrayList<>();
    StatusDto statusDto = new StatusDto();

    @PostConstruct
    public void init() {
        searchProviderFormData = new SearchProviderRequest();
        searchProviderFormData.setRegistryIdentifierPostfix(".BC.PRS");
        searchProviderFormData.setHistoryFlag(false);
        providerRoleTypeINDSelectItems = droplists.getProviderRoleTypesForSearch(CodesDao.matchINDString);
        providerRoleTypeORGSelectItems = droplists.getProviderRoleTypesForSearchNoSelect(CodesDao.matchORGString);

        //The 'Select One' option is the first and default one, so check the size to 1
        if (providerRoleTypeINDSelectItems.isEmpty() || providerRoleTypeINDSelectItems.size() == 1) {
            BusinessRuleKeys key = BusinessRuleKeys.ERROR_SEARCH_NOPERMISSION;
            FacesContext.getCurrentInstance().addMessage(null,
                    new FacesMessage(FacesMessage.SEVERITY_INFO, BusinessRuleMessageDao.getMessageResource(key), null));
            return;
        }

        Long defaultProviderRoleTypeId = null;
        if (providerRoleTypeINDSelectItems.get(0).getLabel().equals(Consts.SELECT_ONE_LABLE)) {
            defaultProviderRoleTypeId = new Long(Consts.SELECT_ONE_VALUE);
        } else {
            defaultProviderRoleTypeId = new Long((String) providerRoleTypeINDSelectItems.get(0).getValue());
        }
        searchProviderFormData.setProviderRoleTypeId(defaultProviderRoleTypeId);
        this.providerRoleTypeChanged();
        providerRoleTypeForSearchOrg = searchProviderService.retrieveProviderRoleTypeSearchOrg();
        statusCodeSelectItems = droplists.getPrsCtStatusCodes();
        Long defaultLicenseStatusCodeId = null;
        if (statusCodeSelectItems.get(0).getLabel().equals(Consts.SELECT_ONE_LABLE)) {
            defaultLicenseStatusCodeId = new Long(Consts.SELECT_ONE_VALUE);
        } else {
            defaultLicenseStatusCodeId = new Long((String) statusCodeSelectItems.get(0).getValue());
        }
        searchProviderFormData.setLicenseStatusCd(defaultLicenseStatusCodeId);
        statusReasonCodeSelectItems = droplists.getPrsCtStatusReasonCodes();
    }

    /**
     * Process a search by college identifier query.
     *
     * @return redirect to ProviderDetails.xhtml if one result found; postback
     * if 0 or multiple results found.
     */
    public String searchByIdentifier() {
        searchResult = searchProviderService.searchByIdentifier(searchProviderFormData);

        for (BusinessRuleMessage message : searchResult.getMessages()) {
            FacesContext.getCurrentInstance().addMessage(null, JSFUtils.businessRuleMessageToFacesMessage(message));
        }

        return sendProviderRedirect();
    }

    /**
     *
     * @param dto - Selected provider dto
     * @return : Navigation to provider details
     */
    public String logAndNavigateToProvider(ProviderDto dto) {
        searchProviderService.updatePrimaryChid(searchResult.getDataAccessEventId(), dto.getPrimaryChid());
        return "ProviderDetails.xhtml?faces-redirect=true&p=" + dto.getPauthId();
    }

    /**
     * Calculate redirect string for view provider details page.
     *
     * @return the redirect string
     */
    private String sendProviderRedirect() {
        return null;
    }

    /**
     * Process a search by registry identifier query. Note that only registry
     * administrators can request this search.
     *
     * @return redirect to ProviderDetails.xhtml if one result found; postback
     * if 0 or multiple results found.
     */
    public String searchByRegistryIdentifier() {
        searchResult = searchProviderService.searchByRegistryIdentifier(searchProviderFormData);

        for (BusinessRuleMessage message : searchResult.getMessages()) {
            FacesContext.getCurrentInstance().addMessage(null, JSFUtils.businessRuleMessageToFacesMessage(message));
        }

        return sendProviderRedirect();
    }

    /**
     * Process a search by practitioner criteria query.
     *
     * @return redirect to ProviderDetails.xhtml if one result found; postback
     * if 0 or multiple results found.
     */
    public String searchByCriteria() {
        searchResult = searchProviderService.searchForPractitioner(searchProviderFormData);

        for (BusinessRuleMessage message : searchResult.getMessages()) {
            FacesContext.getCurrentInstance().addMessage(null, JSFUtils.businessRuleMessageToFacesMessage(message));
        }

        return sendProviderRedirect();
    }

    /**
     * Clear the fields used at the search by criteria page.
     */
    public void clearSearchByCriteria() {
        this.searchProviderFormData.clearSearchByCriteria();
    }

    /**
     * Process a search by organization criteria query.
     *
     * @return redirect to ProviderDetails.xhtml if one result found; postback
     * if 0 or multiple results found.
     */
    public String searchForOrganization() {
        searchResult = searchProviderService.searchForOrganization(searchProviderFormData);

        for (BusinessRuleMessage message : searchResult.getMessages()) {
            FacesContext.getCurrentInstance().addMessage(null, JSFUtils.businessRuleMessageToFacesMessage(message));
        }

        return sendProviderRedirect();
    }

    /**
     * Find the backing form data object
     *
     * @return the backing form data object
     */
    public SearchProviderRequest getSearchProviderFormData() {
        return searchProviderFormData;
    }

    /**
     * Find the search result for a query.
     *
     * @return the search result for a query
     */
    public SearchProviderResult getSearchResult() {
        return searchResult;
    }

    /**
     * Utility function to render practitioner and organization names in a
     * search result.
     *
     * @param resultRecord the provider details being rendered
     * @return the practitioner or organization name(s) with markup
     */
    public String renderNames(ProviderDto resultRecord) {
        StringBuilder builder = new StringBuilder();

        if (resultRecord.getProviderType().equals(ProviderType.PRACTITIONER)) {
            for (Iterator<PersonNameDto> it = resultRecord.getIndNames().iterator(); it.hasNext();) {
                PersonNameDto name = it.next();

                // don't show display inactive names
                if (name.isDisplayActive()) {
                    String lastName = StringEscapeUtils.escapeHtml4(name.getLastName());
                    String firstName = StringEscapeUtils.escapeHtml4(name.getFirstName());
                    concatenateNonNullElements(builder, lastName, firstName);
                    if (it.hasNext()) {
                        builder.append(renderForExport ? ALT_ENTER : HTML_BR);
                    }
                }
            }
        } else if (resultRecord.getProviderType().equals(ProviderType.ORGANIZATION)) {
            for (Iterator<OrgNameDto> it = resultRecord.getOrgNames().iterator(); it.hasNext();) {
                OrgNameDto name = it.next();

                // don't show display inactive names
                if (name.isDisplayActive()) {
                    String nameValue = StringEscapeUtils.escapeHtml4(name.getName());
                    builder.append(renderForExport ? "" : nameValue);
                    if (it.hasNext()) {
                        builder.append(renderForExport ? ALT_ENTER : HTML_BR);
                    }
                }
            }
        } else {
            throw new UnsupportedOperationException("Unrecognized Party Type: " + resultRecord.getProviderType());
        }

        // if there is no name, add some text so there is a link at least
        if (builder.toString().isEmpty()) {
            builder.append("Link to View Provider");
        }
        return builder.toString();
    }

    /**
     * Utility function to render provider identifiers in a search result.
     *
     * @param resultRecord the provider details being rendered
     * @return the provider identifier(s)
     */
    public String renderIdentifiers(ProviderDto resultRecord) {
        String format = "%s (%s)";
        StringBuilder builder = new StringBuilder();

        for (Iterator<CollegeIdentifierDto> it = resultRecord.getIdentifiers().iterator(); it.hasNext();) {
            CollegeIdentifierDto identifier = it.next();
            if (identifier.isDisplayActive()) {
                String identifierValue = StringEscapeUtils.escapeHtml4(identifier.getIdentifier());
                String typeCode = StringEscapeUtils.escapeHtml4(identifier.getTypeCode());
                builder.append(String.format(format, identifierValue, typeCode));
                if (it.hasNext()) {
                    builder.append(renderForExport ? ALT_ENTER : HTML_BR);
                }
            }
        }

        return builder.toString();
    }

    /**
     * Utility function to render provider addresses in a search result.
     *
     * @param resultRecord the provider details being rendered
     * @return the address(es)
     */
    public String renderAddresses(ProviderDto resultRecord) {
        StringBuilder builder = new StringBuilder();

        for (Iterator<AddressDto> it = resultRecord.getAddresses().iterator(); it.hasNext();) {
            AddressDto address = it.next();
            if (address.isDisplayActive()) {
                String addressLine1 = StringEscapeUtils.escapeHtml4(address.getAddressLineOne());
                String province = StringEscapeUtils.escapeHtml4(address.getProvinceOrStateTxt());
                String city = StringEscapeUtils.escapeHtml4(address.getCity());
                concatenateNonNullElements(builder, addressLine1, city, province);

                if (it.hasNext()) {
                    builder.append(renderForExport ? ALT_ENTER : HTML_BR);
                }
            }
        }

        return builder.toString();
    }

    /**
     * Utility function to render provider statuses in a search result.
     *
     * @param resultRecord the provider details being rendered
     * @return the provider status(es)
     */
    public String renderStatuses(ProviderDto resultRecord) {
        String format = "%s";
        StringBuilder builder = new StringBuilder();

        for (Iterator<StatusDto> it = resultRecord.getStatuses().iterator(); it.hasNext();) {
            StatusDto status = it.next();
            if (status.isDisplayActive()) {
                String statusType = StringEscapeUtils.escapeHtml4(status.getType());
                builder.append(String.format(format, statusType));
                if (it.hasNext()) {
                    builder.append(renderForExport ? ALT_ENTER : HTML_BR);
                }
            }
        }

        return builder.toString();
    }

    /**
     * Convenience utility to concatenate non null strings into a single string.
     *
     * @param builder the string builder to utilize
     * @param args the arguments to concatenate
     */
    private static void concatenateNonNullElements(StringBuilder builder, String... args) {
        List<String> items = new ArrayList<>(Arrays.asList(args));
        items.removeAll(Collections.singleton(null));
        for (Iterator<String> it = items.iterator(); it.hasNext();) {
            String string = it.next();
            builder.append(string);
            if (it.hasNext()) {
                builder.append(", ");
            }
        }
    }

    /**
     * Marks the end of exporter processing. Also adds line spacing.
     *
     * @param document document being prepared
     */
    public void postProcessExporter(Object document) {
        setRenderForExport(false);
        if (document instanceof HSSFWorkbook) {
            HSSFWorkbook wb = (HSSFWorkbook) document;
            HSSFCellStyle cellStyle = wb.createCellStyle();
            cellStyle.setWrapText(true);
            for (int j = 0; j < wb.getSheetAt(0).getPhysicalNumberOfRows(); j++) {
                HSSFRow r = wb.getSheetAt(0).getRow(j);
                for (int i = 0; i < r.getPhysicalNumberOfCells(); i++) {
                    r.getCell(i).setCellStyle(cellStyle);
                }
            }
        }
    }

    /**
     * Marks the start of exporter processing.
     *
     * @param document document being prepared
     */
    public void preProcessExporter(Object document) {
        setRenderForExport(true);
    }

    /**
     * getter
     *
     * @return render html?
     */
    public boolean isRenderForExport() {
        return renderForExport;
    }

    /**
     * setter
     *
     * @param renderForExport
     */
    public void setRenderForExport(boolean renderForExport) {
        this.renderForExport = renderForExport;
    }

    public List<SelectItem> getProviderRoleTypeSelectItems() {
        return providerRoleTypeINDSelectItems;
    }

    public void setProviderRoleTypeSelectItems(List<SelectItem> providerRoleTypeSelectItems) {
        this.providerRoleTypeINDSelectItems = providerRoleTypeSelectItems;
    }

    /**
     * When Provider Role Type is changed, update the Expertise Type dropdown.
     */
    public void providerRoleTypeChanged() {
        Long providerRoleTypeId = this.searchProviderFormData.getProviderRoleTypeId();
        if (providerRoleTypeId == null) {
            providerRoleTypeId = Long.valueOf(Consts.SELECT_ONE_VALUE);
        }
        this.expertiseTypeSelectItems = this.droplists.getApplicableExpertiseTypesExcludeLanguage(providerRoleTypeId);
    }

    public List<SelectItem> getExpertiseTypeSelectItems() {
        return expertiseTypeSelectItems;
    }

    public void setExpertiseTypeSelectItems(List<SelectItem> expertiseTypeSelectItems) {
        this.expertiseTypeSelectItems = expertiseTypeSelectItems;
    }

    public boolean isSearchWithHistory() {
        return searchWithHistory;
    }

    public void setSearchWithHistory(boolean searchWithHistory) {
        this.searchWithHistory = searchWithHistory;
        searchProviderFormData.setHistoryFlag(searchWithHistory);
    }

    public List<PrsCtProviderRoleTypes> getProviderRoleTypeForSearchOrg() {
        return providerRoleTypeForSearchOrg;
    }

    public void setProviderRoleTypeForSearchOrg(List<PrsCtProviderRoleTypes> providerRoleTypeForSearchOrg) {
        this.providerRoleTypeForSearchOrg = providerRoleTypeForSearchOrg;
    }

    public boolean isAllowSearchForOrg() {
        String searchProviderTypeOrg = CodeTableCodes.GrsCtPartyType.ORG.getValue();
        Iterator<PrsCtProviderRoleTypes> it = providerRoleTypeForSearchOrg.iterator();
        while (it.hasNext()) {
            if (it.next().getCtlNameCode().matches(searchProviderTypeOrg)) {
                allowSearchForOrg = true;
            }
        }
        return allowSearchForOrg;
    }
    
    public List<SelectItem> getStatusReasonCodeSelectItems() {
        return statusReasonCodeSelectItems;
    }
    
    public void setStatusReasonCodeSelectItems(List<SelectItem> statusReasonCodeSelectItems) {
        this.statusReasonCodeSelectItems = statusReasonCodeSelectItems;
    }

    public StatusDto getStatusDto() {
        return statusDto;
    }

    public void setStatusDto(StatusDto statusDto) {
        this.statusDto = statusDto;
        filterStatusReasonCodeSelectItems(statusDto.getTypeId());
    }

    public List<SelectItem> getStatusCodeSelectItems() {
        return statusCodeSelectItems;
    }

    public void setStatusCodeSelectItems(List<SelectItem> statusCodeSelectItems) {
        this.statusCodeSelectItems = statusCodeSelectItems;
    }

    /**
     * Filter the License Status Reason Code dropdown based on the provided
     * license status code.
     *
     * @param statusCodeId the status code to filter by
     */
    public void filterStatusReasonCodeSelectItems(Long statusCodeId) {
        statusReasonCodeSelectItems = new ArrayList<>();
        statusReasonCodeSelectItems = droplists.initializeStatusReasonCodeDropdowns(statusCodeId);
    }

    /**
     * Update the License Status Reason Code dropdown when License Status Code is changed.
     */
    public void licenseStatusCodeChanged() {
        Long statusCodeId = this.searchProviderFormData.getLicenseStatusCd();
        if (statusCodeId == null) {
            statusCodeId = Long.valueOf(Consts.SELECT_ONE_VALUE);
        }
        this.statusReasonCodeSelectItems = this.droplists.initializeStatusReasonCodeDropdowns(statusCodeId);
    }

}
