/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.web.bean.support.validators;

import ca.bc.gov.health.plr.web.PLRCalendar;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.faces.application.FacesMessage;
import javax.faces.component.UIComponent;
import javax.faces.component.UIInput;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.convert.ConverterException;
import javax.faces.validator.FacesValidator;
import javax.faces.validator.Validator;
import javax.faces.validator.ValidatorException;
import javax.validation.ValidationException;

/**
 * Validator which looks at all specified UIInput within a parent object
 *
 * To Implement 1. the item(and it's siblings - does not work with variable
 * nested siblings) parent (generally panelGrid or panel) must be given an ID
 *
 * 2. each item/sibling must be defined with a binding (unique to page not just
 * parent) by adding: binding="#{einput1}" to each relevant input
 *
 * 3.for each input with a binding directly below the parent (as defined in step
 * 1) add (changes by binding name) <f:attribute name="input1"
 * value="#{einput1}" />
 *
 * 4. directly under the 'last' <f: attribute/> add:(e.g) <h:inputHidden
 * id="emailHidden" class="input1 input2" >
 * <f:validator validatorId="optionalRequired" />
 * </h:inputHidden>
 * The class of the input should hold all the name values from the
 * <f:attributes/> defined in step 3
 *
 * 5. to each uiInput add: <p:ajax event='change' update="ID as defined in step
 * 1" process="@this hiddenInputid_As_defined_in_step_4" />
 *
 * 6. calendars get an extra: <p:ajax event='dateSelect' update="ID as defined
 * in step 1" process="@this hiddenInputid_As_defined_in_step_4" />
 *
 * 7. calendars which have their values determined by a long (table ID) may
 * require: converter="javax.faces.Long" (if they have additional validators
 * which expect to recieve a long - not all cases)
 *
 * 8. double check all pre-existing <p:ajax withListeners/> and ensure they have
 * event="change" or work appropriately (no defined event won't work any more)
 *
 * 9. for any component that is not required as a minium but should force
 * 'required' on required items add styleclass: triggeringBUTOptional
 *
 * @author ian.scott
 */
@FacesValidator(value = "optionalRequired")
public class OptionalRequiredValidator implements Validator {
    //logger

    private static final Logger logger = Logger.getLogger(OptionalRequiredValidator.class.getSimpleName());
    //the string which defines the style class attribute within a uiInput
    private final String STYLE_CLASS_TAG = "styleClass";
    //the string which a uiInputs styleClass must contain to denote an optional element
    private final String TRIGGERING_BUT_OPTIONAL_TAG = "triggeringBUTOptional";

    /**
     * Required validate function to satisfy interface
     *
     * @param context - faces context should be supplied automatically
     * @param component - component initiating call should be supplied
     * automatically
     * @param value - value of component initiating call should be supplied
     * automatically
     * @throws ValidatorException - will be handled by JSF without user
     * intervention
     */
    @Override
    public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {
        Collection<String> executeIds = context.getPartialViewContext().getExecuteIds();
        boolean nextButtonCausedSubmit = getDidNextButtonCauseSubmit(executeIds, component);
        ArrayList<UIInput> componentsToProcess = getComponents(component);

        if (nextButtonCausedSubmit) {
            processPageFinish(context, componentsToProcess);
            return;
        }

        UIInput triggeringComponent = determineTriggeringComponent(executeIds, componentsToProcess);
        ArrayList<UIInput> nonTriggeringComponentsToProcess = new ArrayList(componentsToProcess);
        nonTriggeringComponentsToProcess.remove(triggeringComponent);
        if (triggeringComponent == null) {
            return;
        }
        boolean triggeringComponentSetBlank = getWasTriggeringComponentSetBlank(triggeringComponent);
        boolean triggeringComponentPassesValidationAndConversion = componentPassesValidationAndConverstion(context, triggeringComponent, triggeringComponent.getSubmittedValue());
        if (!triggeringComponentPassesValidationAndConversion && !triggeringComponentSetBlank) {
            return;
        }

        boolean atLeastOneComponentWithValue = containsASetValue(nonTriggeringComponentsToProcess, false);
        ArrayList<UIInput> requiredComponentsToProcess = stripTriggeringBUTOptionalComponents(nonTriggeringComponentsToProcess);
        applyValidation(requiredComponentsToProcess, triggeringComponentSetBlank, atLeastOneComponentWithValue);
    }

    /**
     * determine if an Object is null or empty
     *
     * @param toCheck - the object which may or may not be a value
     * @return true if the object is null or empty
     */
    private boolean nullOrEmpty(Object toCheck) {
        if (toCheck != null) {
            if (toCheck instanceof String) {
                String temp = (String) toCheck;
                return (temp.isEmpty());
            }
            return false;
        }
        return true;
    }

    /**
     * find all the UIInput using the style class of the component and the
     * attributes of the parent component
     *
     * @param component - the component (hidden input) which triggered the
     * validator
     * @return - list of all UIInput within the parent(grid/panel) of the
     * component found using the values specified in the components styleclass
     */
    private ArrayList<UIInput> getComponents(UIComponent component) {
        ArrayList<UIInput> allComponents = new ArrayList();
        if (component == null) {
            return allComponents;
        }
        UIComponent parent = component.getParent();
        String allClasses = (String) component.getAttributes().get(STYLE_CLASS_TAG);
        if (allClasses == null) {
            return allComponents;
        }
        String[] componentNames = allClasses.split(" ");
        if (componentNames == null || componentNames.length == 0) {
            return allComponents;
        }
        for (String componentToFind : componentNames) {
            UIInput toCheck = null;
            //TODO turn back ontry {
            toCheck = (UIInput) parent.getAttributes().get(componentToFind);
            //TODO turn back on} catch (ClassCastException cce) {
            //TODO turn back on    continue;
            //TODO turn back on}
            if (toCheck == null) {
                continue;
            }

            allComponents.add(toCheck);
        }
        return allComponents;
    }

    /**
     * find which component triggered the validator by finding it in the
     * executed IDs
     *
     * @param executeIds list of the id's which were specified when the
     * validator was triggered
     * @param componentsToProcess - list of UIInput in which to find the
     * triggering component
     * @return
     */
    private UIInput determineTriggeringComponent(Collection<String> executeIds, ArrayList<UIInput> componentsToProcess) {
        if (executeIds == null || executeIds.isEmpty()) {
            return null;
        }
        for (UIInput input : componentsToProcess) {
            if (executeIds.contains(input.getClientId())) {
                return input;
            }
        }
        return null;
    }

    /**
     * check for if the component which triggered(contained) the validator was
     * part of hte list of id's which caused the full/partial submit
     *
     * @param executeIds list of the id's which were specified when the
     * validator was triggered
     * @param component - the component which triggered(contains) the validator
     * @return boolean if the triggering component was the next/submit button
     */
    private boolean getDidNextButtonCauseSubmit(Collection<String> executeIds, UIComponent component) {
        if (executeIds == null || executeIds.isEmpty()) {
            return false;
        }
        return !executeIds.contains(component.getClientId());
    }

    /**
     * check that the component had a non null and non empty value submitted
     *
     * @param component - the component to check
     * @return boolean if hte submitted value was not null or empty
     */
    private boolean getWasTriggeringComponentSetBlank(UIInput component) {

        return nullOrEmpty(component.getSubmittedValue());
    }

    /**
     * This is called to allow additional processing using the converter to
     * determine a pass/fail of a validator this is because some validators
     * require a convertered value to pass
     *
     * @param toRun the validator to run
     * @param
     * @param context - faces context should be supplied automatically to the
     * function that calls this
     * @param component - a component to process based on the provided arguments
     * @param value - the value the component provided
     * @param converter - the component's build in converter
     * @return true if the validator passes false if it doesn't.
     */
    private boolean runValidator(Validator toRun, FacesContext context, UIInput component, Object value, Converter converter) {
        try {
            toRun.validate(context, component, value);
        } catch (ValidatorException ve) {
            return false;
        } catch (ValidationException ve) {
            Throwable cause = ve.getCause();
            if (converter == null && cause != null && cause.getClass().equals(ClassCastException.class)) {
                logger.log(Level.WARNING, "ValidationException casting value and no converter specified.  For calendars add: converter=\"javax.faces.Long\"");
            }
            if (converter == null || nullOrEmpty(value) || !(value instanceof String) || cause == null) {
                return false;
            } else if (cause.getClass().equals(ClassCastException.class)) {
                Object converted = null;
                try {
                    converted = converter.getAsObject(context, component, (String) value);
                    toRun.validate(context, component, converted);
                } catch (Exception e) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * determines if the component passes all its pre-existing validators and
     * converters such that validators like email format return their messages
     * (rather than a 'required') and converters return theirs ('this is not a
     * valid date format')
     *
     * @param context - faces context should be supplied automatically to the
     * function that calls this
     * @param component - a component to process based on the provided arguments
     * @param value - the value the component provided
     * @return true if the component passes all it's preExisting validators &
     * converters
     */
    private boolean componentPassesValidationAndConverstion(FacesContext context, UIInput component, Object value) {
        Validator[] validators = component.getValidators();
        Converter foundConverter = component.getConverter();
        boolean result = false;
        for (Validator aa : validators) {
            if (!aa.getClass().equals(this.getClass())) {
                result = runValidator(aa, context, component, value, foundConverter);
                return result;
            }
        }
//        Converter foundConverter = component.getConverter();
        if (foundConverter == null && !nullOrEmpty(value)) {
            if (!(component instanceof PLRCalendar)) {
                return true;
            }
            PLRCalendar toCheck = (PLRCalendar) component;
            SimpleDateFormat dateFormat = new SimpleDateFormat(toCheck.calculatePattern(), toCheck.calculateLocale(context));
            try {
                dateFormat.parse((String) value);
            } catch (IllegalArgumentException | ParseException e) {
                return false;
            }
            return true;
        } else if (foundConverter == null) {
            return true;
        } else if (!nullOrEmpty(value)) {
            try {
                foundConverter.getAsObject(context, component, (String) value);
                return true;
            } catch (ConverterException ce) {
                return false;
            }
        }
        return true;
    }

    /**
     * Checks over all provided UIInput to see if a value is set. if it's on
     * page submit the 'submittedValue' is used, in all other cases the value is
     * used
     *
     * @param toCheck - list of Uinput to check over
     * @param isPageSubmit - boolean to indicated page submit (hitting of
     * next/submit button)
     * @return boolean to indicate if at least one Input contained a set value
     */
    private boolean containsASetValue(ArrayList<UIInput> toCheck, boolean isPageSubmit) {
        for (UIInput check : toCheck) {
            Object value = check.getValue();
            if (isPageSubmit) {
                value = check.getSubmittedValue();
            }
            if (!nullOrEmpty(value)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Method called at end of validate method which will change UIInput valid
     * values according to provided arguments
     *
     * -if the trigger was setBlank and no other UIInput has a value make all
     * uiInput valid
     *
     * -if the trigger was not blank for each item processed if it doesn't
     * contain a value set it to invalid
     *
     * @param context - faces context should be supplied automatically to the
     * function that calls this
     * @param toProcess - a list of components to process based on the provided
     * arguments
     * @param blankTrigger - a boolean to indicate if the component that
     * triggered the validation was submitted with a null or empty value
     * @param someHaveValue - a boolean to indicate if at least one component,
     * that did not trigger the validation, contains a value that is not null or
     * empty
     */
    private void applyValidation(ArrayList<UIInput> toProcess, boolean blankTrigger, boolean someHaveValue) {
        if (blankTrigger && !someHaveValue) {
            for (UIInput input : toProcess) {
                input.setValid(true);
            }
        } else if (!blankTrigger) {
            for (UIInput input : toProcess) {
                if (nullOrEmpty(input.getValue())) {
                    input.setValid(false);
                }
            }
        }

    }

    /**
     * function to call on page submit (hitting of next/submit button) this
     * calls required validator on all UIInput provided in the list
     *
     * @param context - faces context should be supplied automatically to the
     * function that calls this
     * @param componentsToProcess - a list of components to validate using a
     * RequiredValidator
     */
    private void processPageFinish(FacesContext context, ArrayList<UIInput> componentsToProcess) {
        boolean atLeastOneComponentWithValue = containsASetValue(componentsToProcess, true);
        if (atLeastOneComponentWithValue) {
            ArrayList<UIInput> leftOverComponents = stripTriggeringBUTOptionalComponents(componentsToProcess);
            javax.faces.validator.RequiredValidator reqValidate = new javax.faces.validator.RequiredValidator();
            ArrayList<FacesMessage> errorMessages = new ArrayList();
            for (UIInput input : leftOverComponents) {
                try {
                    reqValidate.validate(context, input, input.getValue());
                } catch (ValidatorException ve) {
                    input.setValid(false);
                    errorMessages.add(ve.getFacesMessage());
                }
            }
            if (!errorMessages.isEmpty()) {
                throw new ValidatorException(errorMessages);
            }
        }
    }

    /**
     * Remove all components designated 'optional' (determined by style class)
     * from a list of components
     *
     * @param requiredComponentsToProcess - a list of components which may
     * contain 'optional' components (determined by style class) which are to be
     * removed
     * @return - a list of components with all 'optional' components (determined
     * by style class) removed
     */
    private ArrayList<UIInput> stripTriggeringBUTOptionalComponents(ArrayList<UIInput> requiredComponentsToProcess) {
        Iterator<UIInput> iterator = requiredComponentsToProcess.iterator();
        UIInput input;
        while (iterator.hasNext()) {
            input = iterator.next();
            String allClasses = (String) input.getAttributes().get(STYLE_CLASS_TAG);
            if (allClasses == null) {
                continue;
            }
            String[] componentNames = allClasses.split(" ");
            if (componentNames == null || componentNames.length == 0) {
                continue;
            }
            for (String name : componentNames) {
                if (name.equalsIgnoreCase(TRIGGERING_BUT_OPTIONAL_TAG)) {
                    iterator.remove();
                }
            }
        }
        return requiredComponentsToProcess;
    }
}
