package ca.bc.gov.health.plr.web.util;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.DtoMetaData;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import java.util.Calendar;
import java.util.Date;
import javax.ejb.Stateless;
import javax.faces.application.FacesMessage;
import javax.inject.Named;

/**
 * Convenience utilities for JSF functionality in the PLR application.
 *
 * @author Grant.Hodgins
 */
@Stateless
@Named("jsfUtils")
public class JSFUtils {

    /**
     * Converts a business rule message to a JSF message, including severity.
     *
     * @param message the business rule message
     * @return the faces message with appropriate severity
     */
    public static FacesMessage businessRuleMessageToFacesMessage(BusinessRuleMessage message) {
        FacesMessage.Severity facesSev = null;
        switch (message.getSeverity()) {
            case INFO: {
                facesSev = FacesMessage.SEVERITY_INFO;
                break;
            }
            case WARNING: {
                facesSev = FacesMessage.SEVERITY_WARN;
                break;
            }
            case ERROR: {
                facesSev = FacesMessage.SEVERITY_ERROR;
                break;
            }
            case FATAL: {
                facesSev = FacesMessage.SEVERITY_FATAL;
                break;
            }
        }

        return new FacesMessage(facesSev, message.getMessage(), "");
    }

    /**
     * Sets a date range based on todays year (today's year minus 110
     * @return 
     */
    public static String getBirthdateYearRange() {
        return (Calendar.getInstance().get(Calendar.YEAR)- Consts.BIRTHDATE_RANGE)+":"+Calendar.getInstance().get(Calendar.YEAR);
    }

    /**
     * Convenience utility to format a date for presentation purposes. This
     * functional will not render dates in the year 9999.
     *
     * @param date the date to format.
     * @return the formatted date based on the default date format
     * ("yyyy-MM-dd").
     */
    public static String formatDate(Date date) {
        String result = null;

        if (date != null) {
            Calendar cal = Calendar.getInstance();
            cal.setTime(date);

            if (cal.get(Calendar.YEAR) != Consts.DEFAULT_END_DATE_YEAR) {
                result = Consts.DEFAULT_DATE_FORMAT.format(date);
            }
        }
        return result;
    }

    /**
     * Provides a display string for two dates.
     *
     * @param startDate the first date to format
     * @param endDate the second date to format
     * @return a formatted string "startDate - endDate" ("yyyy-MM-dd -
     * yyyy-MM-dd")
     */
    public static String displayDateRange(Date startDate, Date endDate) {
        StringBuilder result = new StringBuilder();

        if (startDate != null) {
            result.append(formatDate(startDate));
        }

        String deathDateString = formatDate(endDate);
        if (deathDateString != null) {
            result.append(" - ").append(deathDateString);
        }

        return result.toString();
    }

    /**
     * Returns the UI message on update/create
     *
     * @param blockName
     * @param dto
     * @return
     */
    public static String prepareSuccessMessage(String blockName, DtoMetaData dto) {
        StringBuilder message = new StringBuilder();
        if (!dto.isNew() && dto.isNoChangeOnUpdate()) {
            message.append(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.NO_CHANGE_ON_UPDATE));
        } else {
            message.append("The ").append(blockName).append(" was successfully ").append(dto.isNew() ? "created." : "updated.");
        }
        return message.toString();
    }
}
