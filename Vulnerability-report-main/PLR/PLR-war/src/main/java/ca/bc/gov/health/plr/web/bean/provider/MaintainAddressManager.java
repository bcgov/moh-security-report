package ca.bc.gov.health.plr.web.bean.provider;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.provider.AddressDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.ejb.entity.PrsCtCountries;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.service.provider.AddressSupportService;
import ca.bc.gov.health.plr.service.provider.DuplicateRecordException;
import ca.bc.gov.health.plr.service.provider.MaintainAddressService;
import ca.bc.gov.health.plr.service.provider.MaintainProviderServiceHelper;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.web.bean.PlrManagedBean;
import ca.bc.gov.health.plr.web.bean.provider.interfaces.GrowlEnabled;
import ca.bc.gov.health.plr.web.bean.provider.interfaces.WorkLocationChild;
import ca.bc.gov.health.plr.service.AddressDoctorService;
import ca.bc.gov.health.plr.dto.AddressSuggestion;
import ca.bc.gov.health.plr.ejb.entity.GrsAddresses;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes;
import ca.bc.gov.health.plr.persistence.ConfigurationDao;
import ca.bc.gov.health.plr.service.JNDIResourceLoader;
import ca.bc.gov.health.plr.web.util.JSFUtils;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.PostConstruct;
import javax.ejb.EJB;
import javax.faces.application.FacesMessage;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.ViewScoped;
import javax.faces.context.FacesContext;
import javax.faces.model.SelectItem;
import javax.inject.Inject;
import javax.naming.NamingException;
import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import org.primefaces.PrimeFaces;
import org.primefaces.event.SelectEvent;

/**
 * MaintainAddress.xhtml backing bean.
 *
 * @author ian.scott
 */
@ManagedBean
@ViewScoped
public class MaintainAddressManager extends MaintainLocationManager implements GrowlEnabled, WorkLocationChild {

    private static final String CLASSNAME = MaintainAddressManager.class.getSimpleName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);

    @Inject
    private AddressDoctorService addressDoctorManager;

    @EJB
    protected MaintainAddressService maintainAddressService;
    @EJB
    protected MaintainProviderServiceHelper maintainProviderServiceHelper;
    @EJB
    private AddressSupportService addressSupportService;
    @EJB
    CodesDao codesDao;
    @EJB
    private JNDIResourceLoader jndiResourceLoader;

    @EJB
    ConfigurationDao configurationDao;

    public ConfigurationDao getConfigurationDao() {
        return configurationDao;
    }

    private Long pauthId;
    private Long workLocationId;
    private AddressDto addressDto;
    private List<AddressDto> addresses;
    private Long defaultCountryId;
    private String postalCodePatternMatchMessage = "";

    private String addressAutoComplete;
    private List<AddressSuggestion> suggestedAddresses = new ArrayList<AddressSuggestion>();

    private List<SelectItem> addressProvinceSelectItems;

    /**
     * panel identifer ajax should use when re-rendering
     */
    private String panelToUpdate;

    //PLR-365 : Adding RU ID to handle the address for Registry User
    private Long ruId;

    private int DEFAULT_MAX_SUGGEST_RESULTS = 5;

    private boolean addrInvalidWarnedFlag = false;

    private AddressDto recommendedAddress;

    /**
     * Initialize the backing transfer objects. We'll do all at once since it's
     * cheap and we don't know what the users may choose.
     */
    @PostConstruct
    public void init() {
        addressDto = new AddressDto();
        defaultCountryId = addressSupportService.getDefaultCountry().getCtlId();
        addressDto.setCountryId(defaultCountryId);
        addressDto.setProvinceOrStateTxt(addressSupportService.getDefaultProvince(defaultCountryId).getCtlNameCode());
        postalCodePatternMatchMessage = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_ADDRESSPOSTALFIELD_PATTERNMATCH);
        //set to default
        pauthId = 0l;
        workLocationId = 0l;
        panelToUpdate = ":addressesPanel";
        ruId = 0L;
        suggestedAddresses = new ArrayList();
        addressProvinceSelectItems = addressSupportService.initProvinceDropdownOrderedByNameCode(addressDto.getCountryId());
    }

    public int getAutocompleteMaxResults() {
        try {
            // Check for the max autocomplete results property
            if (jndiResourceLoader.appResource().containsKey(Consts.ADDRESS_AUTOCOMPLETE_MAX_RESULTS)) {
                // Override default setting with supplied max results property
                return Integer.parseInt(jndiResourceLoader.appResource().get(Consts.ADDRESS_AUTOCOMPLETE_MAX_RESULTS));
            }
        } catch (NamingException ex) {
            // keep going and return the default
        }
        return DEFAULT_MAX_SUGGEST_RESULTS;
    }

    /**
     * If not null, but empty, then address doctor is availble but had no
     * results
     */
    public Boolean getSuggestedAddressesIsNotNullButEmpty() {
        return suggestedAddresses != null && suggestedAddresses.isEmpty();
    }

    /**
     * Initial method called from page which determines if the request is an add
     * or an update does not use growl
     */
    @Override
    public void save() {
        save(false);
    }

    public void saveInvalid(boolean detailsGrowl) {

        // at this point the address is invalid
        addressDto.setValidationStatus(CodeTableCodes.PrsCtAddressValidationCodes.INVALID.getValue());
        addressDto.setValidationStatusDesc(CodeTableCodes.PrsCtAddressValidationCodes.INVALID.getDesc());

        save(detailsGrowl);
    }

    /**
     * Initial method called from page which determines if the request is an add
     * or an update
     *
     * @param pDetailsGrowl boolean indicating if the page growl should be used
     */
    @Override
    public void save(boolean pDetailsGrowl) {

        FacesContext context = FacesContext.getCurrentInstance();

        if (this.addressDto.isNew()) {
            if (pauthId != 0l && workLocationId != 0l && ruId != 0L) {
                throw new UnsupportedOperationException("Address Manager:Code Change Required - both values not default.");
            }
            //if both 0l let JPA handle failure
            if (pauthId != 0l) {
                addressDto.setPauthId(pauthId);
            } else if (ruId != 0L) {
                addressDto.setRuRuID(ruId);
            } else {
                addressDto.setWlWlId(workLocationId);
            }
        }
        String growl = null;
        try {
            if (pDetailsGrowl) {
                growl = PlrManagedBean.PROVIDER_DETAILS_GROWL;
            }

            AddressDto temp = getAddressDto();
            
            if ( ruId != 0l) {
                temp = (AddressDto) maintainProviderServiceHelper.reflectionSave(null, temp, "save");
            } else {
                temp = (AddressDto) maintainProviderServiceHelper.processLocation(temp, super.providerDetails, null);
            }
          
            // handle warning messages for address invalid/valid
            if (temp.getValidationStatus().equals(CodeTableCodes.PrsCtAddressValidationCodes.INVALID.getValue())) {
                BusinessRuleKeys keyWarnInvalid = BusinessRuleKeys.WARNING_ADD_ADDRESS_VALIDATION_INVALID;
                String messageWarnInvalid = BusinessRuleMessageDao.getMessageResource(keyWarnInvalid);
                context.addMessage(growl, new FacesMessage(FacesMessage.SEVERITY_WARN, messageWarnInvalid, ""));
            }
            LOG.log(Level.INFO, "MaintainAddressManager save and addressDto.isNew is: {0}", new Object[]{addressDto.isNew()});
            String message = JSFUtils.prepareSuccessMessage("address", addressDto);
            context.addMessage(growl, new FacesMessage(FacesMessage.SEVERITY_INFO, message, ""));            
           
            // for work locations need to set the id, doesn't hurt to do this for providers as well
            getAddressDto().setId(temp.getId());
            getAddressDto().setValidationStatus(temp.getValidationStatus());
            getAddressDto().setValidationStatusDesc(temp.getValidationStatusDesc());
            getAddressDto().setCountry(temp.getCountry());
       
            // check Address dto temp record if has pauthId/workLocationId/ruId 
            if (temp.getPauthId() != null) {
                pauthId = temp.getPauthId();
            } else if (temp.getWlWlId() != null) {
                workLocationId = temp.getWlWlId();
            } else if (temp.getRuRuID() != null) {
                ruId = temp.getRuRuID();
            }

        } catch (DuplicateRecordException | BusinessRuleException | EntityValidationException dre) {
            context.addMessage(growl, new FacesMessage(FacesMessage.SEVERITY_ERROR, dre.getMessage(), ""));
            LOG.log(Level.INFO, "MaintainAddressManager save and growl is: {0} BusinessRuleException is: {1}", new Object[]{growl, dre.getMessage()});
            context.validationFailed();
        }
        if (addresses != null) {
            addresses.clear();
        } else {
            addresses = new ArrayList<>();
        }
        addresses.addAll(maintainAddressService.refreshAddresses(addressDto));

        //if workLocationId is 0, the request is to maintain provider's address
        //if workLocationId is not 0, the request is to maintain provider worklocation's address
        if (workLocationId != 0l && super.providerDetails.getWorkLocationList() != null) {
            //maintain provider worklocation's address
            //providerDetails is actually ViewProviderManager.providerDetailsCopy which passed in from WorkLocation.xhtml address section
            //so it needs to be updated in order to refect the up-to-date values
            for (WorkLocationDto wlDto : super.providerDetails.getWorkLocationList()) {
                if (wlDto.getId().equals(this.workLocationId)) {
                    wlDto.setAddresses(addresses);
                    break;
                }
            }
        }
        
        // hide the maintainAddressModal dialog if any 
        // validations/duplicate/business errors were not detected after the save
        if (!FacesContext.getCurrentInstance().isValidationFailed()) {
            PrimeFaces.current().executeScript("PF('maintainAddressModal').hide()");                    
        }

    }

    /*Add or update button */
    public void validateForSave(boolean pDetailsGrowl) {

        FacesContext context = FacesContext.getCurrentInstance();
        //ensures that class level constraints are fired/checked
        boolean passedValidation = preProcessDto(context, addressDto);
        LOG.log(Level.INFO, "MaintainAddressManager validateForSave and passedValidation is: {0}", new Object[]{passedValidation});
        if (!passedValidation) {
            context.validationFailed();
            return;
        }

        LOG.log(Level.INFO, "MaintainAddressManager validateForSave ************** AddressDTO ", addressDto.getEndReasonCodeId());

        // Only validate if the address is not being ceased
        if (addressDto.getEndReasonCodeId() == null || (addressDto.getEndReasonCodeId() != null && !codesDao.lookup(GrsCtEndReasonTypes.class, addressDto.getEndReasonCodeId()).getCtlNameCode().equals(CodeTableCodes.GrsCtEndReasonTypes.CEASE.getValue()))) {
            //Validate address against AddressDoctor, and provide user with correction to choose from.
            validateAddressForWarn(addressDto);
        } else {
            // if being ceased go straight to save, no need for address validation or preprocessing
            // as all changes are thrown out and the record is saved as original
            save(true);
        }
    }

    public void validateAddressForWarn(AddressDto addressDto) {
        if (addressDto.getCountryId().equals(codesDao.lookup(PrsCtCountries.class, CodeTableCodes.PrsCtCountries.CANADA.getValue()).getCtlId())) {
            GrsAddresses grsAddressResult = maintainAddressService.validateAddressForWarn(addressDto);
            if (grsAddressResult.getValidationStatus().getCtlNameCode().equals(CodeTableCodes.PrsCtAddressValidationCodes.INVALID.getValue())) {
                if (grsAddressResult.isProcessStatusWarnLevel()) {
                    // address is invalid and there are corrections
                    this.recommendedAddress = new AddressDto();
                    this.recommendedAddress = convertGrsToDtoAddress(grsAddressResult);
                    addrInvalidWarnedFlag = true;
                    LOG.log(Level.INFO, "validateAddressForWarn:=I= ");
                    PrimeFaces.current().executeScript("PF('addrValidDlg').show()");
                } else {
                    // address is invalid but there are no corrections available
                    addrInvalidWarnedFlag = true;
                    LOG.log(Level.INFO, "validateAddressForWarn:=I no corrections= ");
                    PrimeFaces.current().executeScript("PF('addrInvalidNoCorrectionsDlg').show()");
                }
            } else if (grsAddressResult.getValidationStatus().getCtlNameCode().equals(CodeTableCodes.PrsCtAddressValidationCodes.UNKNOWN.getValue())) {
                addrInvalidWarnedFlag = true;
                LOG.log(Level.INFO, "validateAddressForWarn:=U= ");
                PrimeFaces.current().executeScript("PF('addrValidationUnkownDlg').show()");
            } else {
                // at this point the address is valid
                addressDto.setValidationStatus(CodeTableCodes.PrsCtAddressValidationCodes.VALID.getValue());
                addressDto.setValidationStatusDesc(CodeTableCodes.PrsCtAddressValidationCodes.VALID.getDesc());
                save(true);
                if (!FacesContext.getCurrentInstance().isValidationFailed()) {
                    PrimeFaces.current().executeScript("PF('maintainAddressModal').hide()");                    
                }
            }
        } else {
            
            // this is not a canadian address, just save it without address validation
            // the MaintainAddressService.save will set the status to 'N'
            LOG.log(Level.INFO, "MaintainAddressManager validateAddressForWarn this is not a canadian address");
            save(true);
        }
    }

    public AddressDto getRecommendedAddress() {
        return recommendedAddress;
    }

    public void setRecommendedAddress(AddressDto recommended) {
        this.recommendedAddress = recommended;
    }

    /*User has entered an invalid address and has chosen to continue using the address returned from Address Doctor, so replace the address obj and continue*/
    public void useADAddress() {
        //convert to addressDto
        LOG.log(Level.INFO, "MaintainAddressManager useADAddress");
        //replace the dto address elements returned from AD
        AddressDto recommended = this.getRecommendedAddress();
        if (recommended.getAddressLineOne() != null && !recommended.getAddressLineOne().isEmpty()) {
            addressDto.setAddressLineOne(recommended.getAddressLineOne());
        }
        if (recommended.getAddressLineTwo() != null && !recommended.getAddressLineTwo().isEmpty()) {
            addressDto.setAddressLineTwo(recommended.getAddressLineTwo());
        }
        if (recommended.getCity() != null && !recommended.getCity().isEmpty()) {
            addressDto.setCity(recommended.getCity());
        }
        if (recommended.getProvinceOrStateTxt() != null && !recommended.getProvinceOrStateTxt().isEmpty()) {
            addressDto.setProvinceOrStateTxt(recommended.getProvinceOrStateTxt());
        }
        if (recommended.getPostalCode() != null && !recommended.getPostalCode().isEmpty()) {
            addressDto.setPostalCode(recommended.getPostalCode());
        }
        if (recommended.getValidationStatus() != null && !recommended.getValidationStatus().isEmpty()) {
            addressDto.setValidationStatus(recommended.getValidationStatus());
        }
        if (recommended.getValidationStatusDesc() != null && !recommended.getValidationStatusDesc().isEmpty()) {
            addressDto.setValidationStatusDesc(recommended.getValidationStatusDesc());
        }

        LOG.log(Level.INFO, "MaintainAddressManager useADAddress recommended.getAddressLineOne() is: {0} and addressDto.getAddressLineOne() is: {1}", new Object[]{recommended.getAddressLineOne(), addressDto.getAddressLineOne()});
        // added warning message when address status is changed to valid
        BusinessRuleKeys keyWarnValid = BusinessRuleKeys.WARNING_ADD_ADDRESS_VALIDATION_VALID;
        String messageWarnValid = BusinessRuleMessageDao.getMessageResource(keyWarnValid);
        FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_WARN, messageWarnValid, ""));

        save(true);
    }

    public String cancelDialog() {
        if (this.pauthId != null && this.pauthId != 0l) {
            return "ProviderDetails.xhtml?faces-redirect=true&p=" + this.pauthId;
        } else if (this.ruId != null && this.ruId != 0l) {
            return "RegUserDetails.xhtml?faces-redirect=true&r=" + this.ruId;
        }
        return null;
    }

    public AddressDto convertGrsToDtoAddress(GrsAddresses grsAddresses) {
        AddressDto addressDto = new AddressDto();
        if (!grsAddresses.getAddressLine1Txt().isEmpty() && grsAddresses.getAddressLine1Txt() != null) {
            addressDto.setAddressLineOne(grsAddresses.getAddressLine1Txt());
        }
        if (!grsAddresses.getAddressLine2Txt().isEmpty() && grsAddresses.getAddressLine2Txt() != null) {
            addressDto.setAddressLineTwo(grsAddresses.getAddressLine2Txt());
        }/* if(!grsAddresses.getAddressLine3Txt().isEmpty() && grsAddresses.getAddressLine3Txt() != null){
            addressDto.setAddressLineThree(grsAddresses.getAddressLine3Txt());
        } if(!grsAddresses.getAddressLine4Txt().isEmpty() && grsAddresses.getAddressLine4Txt() != null){
            addressDto.setAddressLineFour(grsAddresses.getAddressLine4Txt());
        }*/
        if (!grsAddresses.getCityTxt().isEmpty() && grsAddresses.getCityTxt() != null) {
            addressDto.setCity(grsAddresses.getCityTxt());
        }
        if (!grsAddresses.getProvinceOrStateTxt().isEmpty() && grsAddresses.getProvinceOrStateTxt() != null) {
            addressDto.setProvinceOrStateTxt(grsAddresses.getProvinceOrStateTxt());
        }
        if (!grsAddresses.getPostalCodeOrZipTxt().isEmpty() && grsAddresses.getPostalCodeOrZipTxt() != null) {
            addressDto.setPostalCode(grsAddresses.getPostalCodeOrZipTxt());
        }
        // added validation status conversiion from entity to addressDto
        if (grsAddresses.getValidationStatus() != null) {
            // this should be grsAddresses.getValidationStatus().getCtlNameCode()
            if (!grsAddresses.getValidationStatus().getCtlDescTxt().isEmpty() && grsAddresses.getValidationStatus().getCtlDescTxt() != null) {
                addressDto.setValidationStatus(grsAddresses.getValidationStatus().getCtlDescTxt());
            }
            if (!grsAddresses.getValidationStatus().getCtlNameCode().isEmpty() && grsAddresses.getValidationStatus().getCtlNameCode() != null) {
                addressDto.setValidationStatus(grsAddresses.getValidationStatus().getCtlNameCode());
            }
        }
        return addressDto;
    }

    /**
     * Retrieve a list of address suggestions from the AddressDoctorManager.
     *
     * @param criteria user input
     * @return list of suggested addresses
     */
    public List<AddressSuggestion> suggestAddresses(String criteria) {
        addressCountryChanged(addressSupportService.getDefaultCountry().getCtlId());
        suggestedAddresses = addressDoctorManager.suggestAddresses(criteria);
        return suggestedAddresses;
    }

    /**
     * Parses a selected address suggestion into the DTO's address fields.
     *
     * @param event represents an item selected by the user
     */
    public void onAutoCompleteSelection(SelectEvent event) {
        StringBuilder selection = new StringBuilder((String) event.getObject());
        for (AddressSuggestion address : suggestedAddresses) {
            if (address.toString().contains(selection)) {
                addressDto.setAddressLineOne(address.getAddressLine1());
                addressDto.setAddressLineTwo(address.getAddressLine2());
                addressDto.setAddressLineThree(address.getAddressLine3());
                addressDto.setAddressLineFour(address.getAddressLine4());
                addressDto.setCity(address.getCity());
                addressDto.setCountry(address.getCountry());
                addressDto.setCountryId(defaultCountryId);
                addressDto.setProvinceOrStateTxt(address.getProvince());
                addressDto.setPostalCode(address.getPostalCode());
                break;
            }
        }
        addressAutoComplete = "";
    }

    /**
     * Updates the province selection drop down when a new country is selected.
     *
     * @param updatedCountry given country code
     */
    public void addressCountryChanged(Long updatedCountry) {
        addressProvinceSelectItems = addressSupportService.initProvinceDropdownOrderedByNameCode(updatedCountry);
        addressDto.setProvinceOrStateTxt("");
    }

    /**
     * @return the addressDto
     */
    public AddressDto getAddressDto() {
        return addressDto;
    }

    /**
     * @param addressDto the addressDto to set
     */
    public void setAddressDto(AddressDto addressDto) {
        this.addressDto = addressDto;
    }

    /**
     *
     * @return list of all addresses
     */
    public List<AddressDto> getAddresses() {
        return addresses;
    }

    /**
     *
     * @param addresses set list of all addresses
     */
    public void setAddresses(List<AddressDto> addresses) {
        this.addresses = addresses;
    }

    /**
     * @param pauthId the pauthId to set
     */
    @Override
    public void setPauthId(Long pauthId) {
        this.workLocationId = 0L;
        this.pauthId = pauthId;
    }

    /**
     *
     * @return the : started representation of the panel to update
     */
    @Override
    public String getPanelToUpdate() {
        return panelToUpdate;
    }

    /**
     *
     * @param panelToUpdate the : started representation of the panel to update
     */
    @Override
    public void setPanelToUpdate(String panelToUpdate) {
        this.panelToUpdate = panelToUpdate;
    }

    /**
     *
     * @param workLocationId the id of the work location
     */
    @Override
    public void setWorkLocationId(Long workLocationId) {
        this.pauthId = 0L;
        this.workLocationId = workLocationId;
    }

    public String getPostalCodePatternMatchMessage() {
        return postalCodePatternMatchMessage;
    }

    /**
     * ensures that class level constraints are fired/checked
     *
     * @param context - faces context to inject messages if failures encountered
     * @param toProcess - the Address to call validation on.
     * @return true if all constraints passed. false if DTO failed any
     * validation
     */
    private boolean preProcessDto(FacesContext context, AddressDto toProcess) {
        String countryCode = toProcess.getCountryCode();
        if (toProcess.getCountryId() != null && codesDao.codeExists(PrsCtCountries.class, toProcess.getCountryId())) {
            countryCode = codesDao.lookup(PrsCtCountries.class, toProcess.getCountryId()).getCtlNameCode();
            toProcess.setCountryCode(countryCode);
        }
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        Validator validator = factory.getValidator();
        Set<ConstraintViolation<AddressDto>> constraintViolations = validator.validate(toProcess);
        LOG.log(Level.INFO, "MaintainAddressManager preProcessDto and constraintViolations size is: {0}", new Object[]{constraintViolations.size()});
        if (!constraintViolations.isEmpty()) {
            for (ConstraintViolation<?> constraintViolation : constraintViolations) {
                FacesMessage facesMessage = new FacesMessage(constraintViolation.getMessage());
                facesMessage.setSeverity(FacesMessage.SEVERITY_ERROR);
                context.addMessage(null, facesMessage);
            }
            return false;
        }
        return true;
    }

    public Long getRuId() {
        return ruId;
    }

    public void setRuId(Long ruId) {
        this.ruId = ruId;
    }

    public String getAddressAutoComplete() {
        return addressAutoComplete;
    }

    public void setAddressAutoComplete(String addressAutoComplete) {
        this.addressAutoComplete = addressAutoComplete;
    }

    public List<AddressSuggestion> getSuggestedAddresses() {
        return suggestedAddresses;
    }

    public void setSuggestedAddresses(List<AddressSuggestion> suggestedAddresses) {
        this.suggestedAddresses = suggestedAddresses;
    }

    public List<SelectItem> getAddressProvinceSelectItems() {
        return addressProvinceSelectItems;
    }

    public void setAddressProvinceSelectItems(List<SelectItem> addressProvinceSelectItems) {
        this.addressProvinceSelectItems = addressProvinceSelectItems;
    }

    // Required for @ManagedProperty injection.
    public void setAddressDoctorManager(AddressDoctorService addressDoctorManager) {
        this.addressDoctorManager = addressDoctorManager;
    }
}
