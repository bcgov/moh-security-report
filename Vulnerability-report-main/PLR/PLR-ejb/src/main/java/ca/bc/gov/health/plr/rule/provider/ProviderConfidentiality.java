package ca.bc.gov.health.plr.rule.provider;

import ca.bc.gov.health.plr.dto.provider.ConfidentialityIndicatorDto;
import ca.bc.gov.health.plr.dto.provider.OrgNameDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.PersonNameDto;
import ca.bc.gov.health.plr.dto.provider.ProviderType;
import java.util.ArrayList;
import java.util.List;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.inject.Inject;
import org.apache.commons.lang3.Validate;
import static ca.bc.gov.health.plr.constants.Consts.CONFIDENTIAL;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.service.PlrUserRoleService;
/**
 * Implementation of REQ-00539 and REQ-00490. The following rules are
 * implemented by this class:
 * <ul>
 * <li>REQ-00539 - If a Provider record is confidential, all data blocks must
 * not be visible except Provider Role Type and College Identifiers; the name
 * block only shows Surname as ‘Confidential’.</li>
 * <li>REQ-00490 - Confidential provider data must not be viewable except by the
 * owner or the registry administrator.</li>
 * </ul>
 *
 * @author Grant.Hodgins
 */

@Stateless
@LocalBean
public class ProviderConfidentiality {

    
    @Inject
    private PlrUserRoleService plrUserRoleService;

    /**
     * Apply the confidentiality rules to a provider details transfer object.
     *
     * @param details the details to check. Cannot be null.
     * @return a "confidential" provider record, or the original record if
     * confidentiality rules do not apply
     */
    public ProviderDto applyConfidentiality(ProviderDto details) {
        Validate.notNull(details);

        /**
         * Confidential Rules,
         * 1. If the Record is not confidential return the actual provider dto
         * 2. If the current user is reg admin, return the actual provider dto
         * 2. If the record is confidential
         *      2.1 : If there is active confidentiality indicator left after DPS (means the user have access to view the confidentiality block),
         *              then return the actual provider dto
         *      2.2 : If there is no active confidentiality indicator left after DPS (means the user doesn't have access to view the confidentiality block),
         *              then return MASKED provider dto
         */
        if (!details.isConfidential() || plrUserRoleService.isRegAdmin()) {
            return details;
        } else {
            boolean activeConfIndicatorfound = checkForActiveConfidentialtyIndicator(details.getConfidentialityIndicators());
            if (activeConfIndicatorfound) {
                return details;
            }
            ProviderDto result = new ProviderDto();
            result.setPauthId(details.getPauthId());
            result.setConfidential(true);

            result.setProviderType(details.getProviderType());
            result.setType(details.getType());
            result.setProviderRoleTypeCode(details.getProviderRoleTypeCode());
            
            if (details.getProviderType().equals(ProviderType.PRACTITIONER)) {
                PersonNameDto tempName = new PersonNameDto();
                tempName.setActive(true);
                tempName.setUpdatable(true);
                tempName.setLastName(CONFIDENTIAL);
                tempName.setDisplayActive(true);
                List<PersonNameDto> names = new ArrayList<>();
                names.add(tempName);
                result.setIndNames(names);
            } else if (details.getProviderType().equals(ProviderType.ORGANIZATION)) {
                OrgNameDto tempName = new OrgNameDto();
                tempName.setName(CONFIDENTIAL);
                tempName.setActive(true);
                tempName.setUpdatable(true);
                tempName.setDisplayActive(true);
                List<OrgNameDto> names = new ArrayList<>();
                names.add(tempName);
                result.setOrgNames(names);
            }
            result.getConfidentialityIndicators().addAll(details.getConfidentialityIndicators());
            
            result.setIdentifiers(details.getIdentifiers());
            
            return result;
        }
    }

    private boolean checkForActiveConfidentialtyIndicator(List<ConfidentialityIndicatorDto> confidentialityIndicators) {
        for (ConfidentialityIndicatorDto dto : confidentialityIndicators) {
            if (dto.isConfidential() && dto.isUpdatable()) {
                return true;
            }
        }
        return false;
    }

}
