package ca.bc.gov.health.plr.dto.provider;

import ca.bc.gov.health.plr.dto.MessageDataBlockDto;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.ejb.entity.GrsPersonNames;
import ca.bc.gov.health.plr.ejb.entity.PrsCtNameTypes;
import ca.bc.gov.health.plr.rule.provider.AcceptableCharacterValidator;
import ca.bc.gov.health.plr.rule.provider.AcceptableCodeName;
import ca.bc.gov.health.plr.rule.provider.AcceptableName;
import ca.bc.gov.health.plr.rule.provider.AcceptableNameValidator;
import java.lang.reflect.Method;
import java.util.Date;
import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.lang3.ObjectUtils;
import javax.validation.constraints.NotBlank;
import org.joda.time.DateTime;
import ca.bc.gov.health.plr.rule.provider.FirstCharacterLetter;

/**
 *
 * @author David Sharpe <david.a.sharpe@cgi.com>
 */
public class PersonNameDto extends AbstractProviderDetail implements MessageDataBlockDto, Comparable<PersonNameDto> {

    @AcceptableName
    @Size(max = 10, message = "{constraints.size.message.part1of2} 'Prefix' {constraints.size.message.part2of2}")
    private String prefix;
    @NotBlank(message = "{error.name.blank} First Name")
    @AcceptableName
    @FirstCharacterLetter(message = "{error.namefield.firstCharacterLetter1of2} First Name {error.namefield.firstCharacterLetter2of2}")
    @Size(min = 1, max = 50, message = "{constraints.size.message.part1of2} 'First Name' {constraints.size.message.part2of2}")
    private String firstName;
    @AcceptableName
    @FirstCharacterLetter(message = "{error.namefield.firstCharacterLetter1of2} Second Name {error.namefield.firstCharacterLetter2of2}")
    @Size(max = 50, message = "{constraints.size.message.part1of2} 'Second Name' {constraints.size.message.part2of2}")
    private String secondName;
    @FirstCharacterLetter(message = "{error.namefield.firstCharacterLetter1of2} Third Name {error.namefield.firstCharacterLetter2of2}")
    @AcceptableName
    @Size(max = 50, message = "{constraints.size.message.part1of2} 'Third Name' {constraints.size.message.part2of2}")
    private String thirdName;
    @NotBlank(message = "{error.name.blank} Surname ")
    @FirstCharacterLetter(message = "{error.namefield.firstCharacterLetter1of2} Surname {error.namefield.firstCharacterLetter2of2}")
    @AcceptableName
    @Size(min = 1, max = 50, message = "{constraints.size.message.part1of2} 'Surname' {constraints.size.message.part2of2}")
    private String lastName;
    @AcceptableName
    @Size(max = 10, message = "{constraints.size.message.part1of2} 'Suffix' {constraints.size.message.part2of2}")
    private String suffix;
    private String fullName;
    boolean preferred;
    private Long ruRuID;
    @AcceptableCodeName(clazz = PrsCtNameTypes.class, code = "Name Type")
    private String typeCode;
    @NotNull(message = "{error.notblank.part1of2} Person Name Effective Start Date {error.notblank.part2of2}")
    private Date effectiveStartDate;
    private Date effectiveEndDate;
    private Long typeId;

    /**
     * Sort by display active, most current ? date , then by last name, first
     * name.
     */
    @Override
    public int compareTo(PersonNameDto o) {
        final int BEFORE = -1;
        final int EQUAL = 0;
        final int AFTER = 1;

        //compare active
        if (this.isDisplayActive() && !o.isDisplayActive()) {
            return BEFORE;
        }
        if (!this.isDisplayActive() && o.isDisplayActive()) {
            return AFTER;
        }

        //date compare
        DateTime thisDate = new DateTime(this.getCreatedDate());
        DateTime thatDate = new DateTime(o.getCreatedDate());
        if (thisDate.isAfter(thatDate)) {
            return BEFORE;
        }

        //compare indNames
        int compare = ObjectUtils.compare(o.getLastName(), this.getLastName());
        if (compare != EQUAL) {
            return compare;
        }
        return ObjectUtils.compare(o.getFirstName(), this.getFirstName());
    }

    @Override
    public int hashCode() {
        int hash = super.hashCode();
        hash = 71 * hash + Objects.hashCode(this.prefix);
        hash = 71 * hash + Objects.hashCode(this.firstName);
        hash = 71 * hash + Objects.hashCode(this.secondName);
        hash = 71 * hash + Objects.hashCode(this.thirdName);
        hash = 71 * hash + Objects.hashCode(this.suffix);
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (!super.equals(obj)) {
            return false;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final PersonNameDto other = (PersonNameDto) obj;
        if (!Objects.equals(this.prefix, other.prefix)) {
            return false;
        }
        if (!Objects.equals(this.firstName, other.firstName)) {
            return false;
        }
        if (!Objects.equals(this.secondName, other.secondName)) {
            return false;
        }
        if (!Objects.equals(this.thirdName, other.thirdName)) {
            return false;
        }
        if (!Objects.equals(this.lastName, other.lastName)) {
            return false;
        }
        if (!Objects.equals(this.suffix, other.suffix)) {
            return false;
        }
        return true;
    }

    /**
     * @return the prefix
     */
    public String getPrefix() {
        return prefix;
    }

    /**
     * @param prefix the prefix to set
     */
    public void setPrefix(String prefix) {
        this.prefix = handleInvalidCharacters(prefix);
    }

    /**
     * @return the firstName
     */
    public String getFirstName() {
        return firstName;
    }

    /**
     * @param firstName the firstName to set
     */
    public void setFirstName(String firstName) {
        this.firstName = handleInvalidName(firstName);
    }

    /**
     * @return the secondName
     */
    public String getSecondName() {
        return secondName;
    }

    /**
     * @param secondName the secondName to set
     */
    public void setSecondName(String secondName) {
        this.secondName = handleInvalidName(secondName);
    }

    /**
     * @return the thirdName
     */
    public String getThirdName() {
        return thirdName;
    }

    /**
     * @param thirdName the thirdName to set
     */
    public void setThirdName(String thirdName) {
        this.thirdName = handleInvalidName(thirdName);
    }

    /**
     * @return the lastName
     */
    public String getLastName() {
        return lastName;
    }

    /**
     * @param lastName the lastName to set
     */
    public void setLastName(String lastName) {
        this.lastName = handleInvalidCharacters(lastName);
    }

    /**
     * @return the suffix
     */
    public String getSuffix() {
        return suffix;
    }

    /**
     * @param suffix the suffix to set
     */
    public void setSuffix(String suffix) {
        this.suffix = handleInvalidCharacters(suffix);
    }

    /**
     * @return the preferred
     */
    public boolean isPreferred() {
        return preferred;
    }

    /**
     * @param preferred the preferred to set
     */
    public void setPreferred(boolean preferred) {
        this.preferred = preferred;
    }

    /**
     *
     * @return registry user id
     */
    public Long getRuRuID() {
        return ruRuID;
    }

    /**
     *
     * @param ruruID registry user id
     */
    public void setRuRuID(Long ruruID) {
        this.ruRuID = ruruID;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    @Override
    public String[] getMessageDataBlockFields() {
        return new String[]{"typeCode"};
    }

    @Override
    public ca.bc.gov.health.plr.dto.provider.esb.AbstractProviderDetail toEsbVersion() throws Exception {
        ca.bc.gov.health.plr.dto.provider.esb.PersonNameDto esbVersion = new ca.bc.gov.health.plr.dto.provider.esb.PersonNameDto();

        PropertyUtils.copyProperties(esbVersion, this);

        return esbVersion;

    }

    @Override
    public String getTypeCode() {
        return typeCode;
    }

    @Override
    public void setTypeCode(String typeCode) {
        this.typeCode = typeCode;
    }

    @Override
    public String getBlockName() {
        return "Name";
    }

    /**
     * @return the effectiveStartDate
     */
    @Override
    public Date getEffectiveStartDate() {
        return effectiveStartDate;
    }

    /**
     * @param effectiveStartDate the effectiveStartDate to set
     */
    @Override
    public void setEffectiveStartDate(Date effectiveStartDate) {
        this.effectiveStartDate = effectiveStartDate;
    }

    @Override
    public Date getEffectiveEndDate() {
        return effectiveEndDate;
    }

    @Override
    public void setEffectiveEndDate(Date effectiveEndDate) {
        this.effectiveEndDate = effectiveEndDate;
    }

    public Long getTypeId() {
        return typeId;
    }

    public void setTypeId(Long typeId) {
        this.typeId = typeId;
    }

    @Override
    public void addToProviderDto(ProviderDto providerDto) {
        providerDto.getIndNames().add(this);
    }

    @Override
    public Class getEntityClass() {
        return GrsPersonNames.class;
    }

    @Override
    public Method getDtoConverterMethod() {
        Method method = null;
        try {
            method = ProviderDtoConverter.class.getMethod("buildPersonName", GrsPersonNames.class);
        } catch (NoSuchMethodException | SecurityException ex) {
            Logger.getLogger(AddressDto.class.getName()).log(Level.SEVERE, null, ex);
        }

        // return null is OK
        return method;
    }

    /**
     * This method will call handleInvalidCharacters() and also make sure that
     * the first character is in UpperCase
     *
     * @param value
     * @return
     */
    private static String handleInvalidName(String value) {
        value = handleInvalidCharacters(value);
        if (value != null && value.trim().length() > 0 && !Character.isUpperCase(value.trim().charAt(0))) {
            value = value.substring(0, 1).toUpperCase() + value.substring(1);
        }

        return value;
    }

    private static String handleInvalidCharacters(String value) {
        return AcceptableCharacterValidator.handleInvalidCharacters(value, AcceptableNameValidator.INVALID_NAME_CHARACTERS_PATTERN);
    }
}
