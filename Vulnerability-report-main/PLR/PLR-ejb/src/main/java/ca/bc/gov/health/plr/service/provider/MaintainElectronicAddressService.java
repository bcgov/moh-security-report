package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.converter.ElectronicAddressDtoConverter;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.ElectronicAddressDto;
import ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsElectronicAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.PrsCtCommunPurposeTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtElectronicAddrTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.BusinessRuleResult;
import ca.bc.gov.health.plr.rule.provider.AccessRestrictionService;
import ca.bc.gov.health.plr.rule.provider.ValidateEmailAddress;
import ca.bc.gov.health.plr.service.EntityValidatorService;
import ca.bc.gov.health.plr.service.validators.ConfidentialityValidator;
import ca.bc.gov.health.plr.service.validators.EntityChangeDetector;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

/**
 * Service class for persisting Electronic Address records
 *
 * @author greg.perkins
 */
@Stateless
@LocalBean
public class MaintainElectronicAddressService implements MaintainService<ElectronicAddressDto> {

    /**
     * Entity Manager for persistence
     */
    @PersistenceContext(unitName = "PLR-ejbPU")
    protected EntityManager em;
    @EJB
    private CodesDao codesDao;
    @EJB
    private JournalService<GrsElectronicAddresses> journalService;

    @EJB
    private ProviderDtoConverter providerDtoConverter;
    /**
     * Converter object for going between DTOs and Entities
     */
    @EJB
    private ElectronicAddressDtoConverter addressDtoConverter;

    @EJB
    private ValidateEmailAddress validateEmail;

    @EJB
    private EntityValidatorService<GrsElectronicAddresses> validatorService;

    @EJB
    private ConfidentialityValidator<GrsElectronicAddresses> confidentialityValidator;

    @EJB
    private AccessRestrictionService accessRestrictionService;
    
    @EJB
    private EntityChangeDetector<ElectronicAddressDto, GrsElectronicAddresses> entityChangeDetector;

    /**
     * Query a fresh complete list of telecommunications related to a specific
     * provider. Note this method does not return telecommunication details for
     * work locations.
     *
     * @param eAddr
     * @return a list of fresh note transfer objects
     */
    public List<ElectronicAddressDto> refreshAllEAddresses(ElectronicAddressDto eAddr) {
        List<GrsElectronicAddresses> foundEa = null;
        boolean ignoreWL = true;
        PrsCtProviderRoleTypes hptCode = null;
        if (eAddr.getPauthId() != null && eAddr.getWlWlId() != null && eAddr.getRuRuID() != null) {
            //TODO - shouldn't happen but what should happen here if it does
            PrsProviders provider = em.find(PrsProviders.class, eAddr.getPauthId());
            hptCode = provider.getHptCode();
            foundEa = provider.getGrsElectronicAddressesList();
        } else if (eAddr.getWlWlId() != null) {
            PrsWorkLocations workLocation = em.find(PrsWorkLocations.class, eAddr.getWlWlId());
            foundEa = workLocation.getGrsElectronicAddressesList();
            hptCode = workLocation.getPauthPauthId().getHptCode();
            ignoreWL = false;
        } else if (eAddr.getPauthId() != null) {
            PrsProviders provider = em.find(PrsProviders.class, eAddr.getPauthId());
            hptCode = provider.getHptCode();
            foundEa = provider.getGrsElectronicAddressesList();
        } else if (eAddr.getRuRuID() != null) {
            GrsRegistryUsers regUser = em.find(GrsRegistryUsers.class, eAddr.getRuRuID());
            foundEa = regUser.getGrsElectronicAddressesList();
        }
        List<ElectronicAddressDto> dtos = providerDtoConverter.buildElectronicAddresses(foundEa, ignoreWL);
        if (eAddr.getPauthId() != null) {
            accessRestrictionService.applyReadRestriction(dtos, hptCode, GrsElectronicAddresses.class);
        } else if (eAddr.getWlWlId() != null) {
            accessRestrictionService.applyWlReadRestriction(dtos, hptCode, GrsElectronicAddresses.class);
        }
        return dtos;
    }

    /**
     * Persists an ElectronicAddress to the database
     *
     * @param electronicAddress ElectronicAddress
     * @return ElectronicAddress with values refreshed from the database
     * @throws ca.bc.gov.health.plr.service.provider.DuplicateRecordException
     * @throws ca.bc.gov.health.plr.rule.BusinessRuleException
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     */
    @Override
    public ElectronicAddressDto save(ElectronicAddressDto electronicAddress) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {

        PrsCtCommunPurposeTypes commPurposeCode = codesDao.lookup(PrsCtCommunPurposeTypes.class, CodeTableCodes.PrsCtCommunPurposeTypes.BUSINESS_CONTACT);

        if (electronicAddress.getCommunicationPurposeCode() == null && electronicAddress.getCommunicationPurposeId() == null) {
            electronicAddress.setCommunicationPurposeId(commPurposeCode.getCtlId());
        }

        checkBusinessRules(electronicAddress);
        GrsElectronicAddresses newRecord = addressDtoConverter.toEntity(electronicAddress);
        
        //if the change is to cease a electronic address and the address is referenced by a information route(on provider or work location),
        //the csaeing operation is not allowed
        GrsCtEndReasonTypes ceaseEndReasonType = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CEASE);
//        if(electronicAddress.getEndReasonCode()!= null && electronicAddress.getEndReasonCode().equals(ceaseEndReasonType.getCtlNameCode())) {
//            this.validateCeaseCondition(newRecord);
//        }

        entityChangeDetector.checkForChanges(electronicAddress, newRecord);
        if(electronicAddress.isNoChangeOnUpdate()){
            return electronicAddress;
        }
        validate(newRecord);

        try {
            newRecord = journalService.journal(newRecord);

        } catch (DuplicateRecordException jex) {
            //If the error is duplicate record error, throw record specific error REQ-00916
            String duplicateAddressMsg;
            if (newRecord.getRuRuId() != null) {
                duplicateAddressMsg = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_DUPLICATE_ADDRESS_REGUSER_DATA_BLOCK);
            } else {
                duplicateAddressMsg = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_DUPLICATE_ADDRESS_PROVIDER_DATA_BLOCK);
            }
            throw new DuplicateRecordException(duplicateAddressMsg + newRecord.getFieldName());
        }
        return providerDtoConverter.buildElectronicAddress(newRecord);
    }

    /**
     * Validates the entity. Add all validators for the entity to
 validatorService and call checkForChanges method
     *
     * @param newRecord GrsElectronicAddresses
     * @throws DuplicateRecordException if validation fails
     */
    private void validate(GrsElectronicAddresses newRecord) throws DuplicateRecordException, EntityValidationException {
        if (newRecord.getPauthPauthId() != null || newRecord.getRuRuId() == null) {
            validatorService.validate(newRecord, confidentialityValidator);
        } else {
            //Don't add Confidential validator if the save is for Registry Users
            validatorService.validate(newRecord);
        }
    }

    /**
     * Validates additional business rules for this record.
     *
     * @param electronicAddress ElectronicAddressDto
     * @throws BusinessRuleException if validation fails
     */
    private void checkBusinessRules(ElectronicAddressDto electronicAddress) throws BusinessRuleException {
        //If email, check for valid characters
        boolean isEmail = false;
        if (electronicAddress.getTypeId() != null) {
            isEmail = electronicAddress.getTypeId().equals(codesDao.lookup(PrsCtElectronicAddrTypes.class, CodeTableCodes.PrsCtElectronicAddrTypes.EMAIL).getCtlId());
        } else if (electronicAddress.getTypeCode() != null) {
            isEmail = electronicAddress.getTypeCode().equals(CodeTableCodes.PrsCtElectronicAddrTypes.EMAIL.getValue());
        }
        if (isEmail) {
            BusinessRuleResult result = validateEmail.validate(electronicAddress.getAddress());
            if (!result.isValid()) {
                throw new BusinessRuleException(result);
            }
        }
        
    }

    /**
     * Bulids a dto from a record in the database based on primary key (ID)
     *
     * @param toRefresh - a dto with an ID
     * @return - dto built from database record or null
     */
    public ElectronicAddressDto refresh(ElectronicAddressDto toRefresh) {
        GrsElectronicAddresses found = em.find(GrsElectronicAddresses.class, toRefresh.getId());
        ElectronicAddressDto toSendBack = providerDtoConverter.buildElectronicAddress(found);
        return toSendBack;
    }
    
}
