package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.AddProviderDto;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.AddressDto;
import ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.ConditionsDto;
import ca.bc.gov.health.plr.dto.provider.ConfidentialityIndicatorDto;
import ca.bc.gov.health.plr.dto.provider.CredentialsDto;
import ca.bc.gov.health.plr.dto.provider.DemographicDetailsDto;
import ca.bc.gov.health.plr.dto.provider.DisciplinaryActionDto;
import ca.bc.gov.health.plr.dto.provider.ElectronicAddressDto;
import ca.bc.gov.health.plr.dto.provider.ExpertiseDto;
import ca.bc.gov.health.plr.dto.provider.InformationRouteDto;
import ca.bc.gov.health.plr.dto.provider.LocationDto;
import ca.bc.gov.health.plr.dto.provider.NoteDto;
import ca.bc.gov.health.plr.dto.provider.OrgNameDto;
import ca.bc.gov.health.plr.dto.provider.PersonNameDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.ProviderRelationshipDto;
import ca.bc.gov.health.plr.dto.provider.RegistryIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.RegistryUserRelationshipDto;
import ca.bc.gov.health.plr.dto.provider.StatusDto;
import ca.bc.gov.health.plr.dto.provider.TelecommunicationDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDetailsDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.ejb.entity.EntityCommon;
import ca.bc.gov.health.plr.ejb.entity.GrsAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsCtBooleanTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsCtRegIdentifierTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsIdentifiers;
import ca.bc.gov.health.plr.ejb.entity.GrsPersonNames;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryIdentifiers;
import ca.bc.gov.health.plr.ejb.entity.PrsCtElectronicAddrTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtIdentifierTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsDemographicDetails;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.util.EntityUtils;
import ca.bc.gov.health.plr.interceptors.AccessInterceptor;
import ca.bc.gov.health.plr.interceptors.ChangeInterceptor;
import ca.bc.gov.health.plr.interceptors.DistributionInterceptor;
import ca.bc.gov.health.plr.interceptors.TestUserInterceptor;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.producer.type.Authenticated;
import ca.bc.gov.health.plr.producer.type.User;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import ca.bc.gov.health.plr.rule.BusinessRuleResult;
import ca.bc.gov.health.plr.service.EntityValidatorService;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.CheckEndReasonCode;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.EJBContext;
import javax.ejb.Stateless;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.interceptor.Interceptors;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.joda.time.LocalDate;
import static ca.bc.gov.health.plr.constants.Consts.MAX_PROVIDER_RESULTS_FOR_LINKAGE;
import static ca.bc.gov.health.plr.constants.Consts.PROVIDER_SINGLE_RESULT_FOR_LINKAGE;
import java.util.HashMap;
import java.util.logging.Logger;

/**
 *
 * @author David Sharpe <david.a.sharpe@cgi.com>
 */
@Stateless
@Interceptors({TestUserInterceptor.class, AccessInterceptor.class, DistributionInterceptor.class, ChangeInterceptor.class})
public class MaintainProviderService {

    private static final String CLASSNAME = MaintainProviderService.class.getSimpleName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;
    @EJB
    private CodesDao codesDao;
    @EJB
    private ProviderDtoConverter providerDtoConverter;

    @EJB
    private EntityValidatorService<PrsProviders> entityValidatorService;

    @Inject
    @Authenticated
    private Instance<User> user;

    @EJB
    private MaintainStatusService maintainStatusService;

    @EJB
    private MaintainProviderIdentifierService maintainProviderIdentifierService;

    @EJB
    private MaintainPersonNameService maintainPersonNameService;

    @EJB
    private MaintainOrgNameService maintainOrgNameService;

    @EJB
    private MaintainDemographicDetailsService maintainDemographicDetailsService;

    @EJB
    private MaintainRegistryIdentifierService maintainRegistryIdentifierService;

    @EJB
    private MaintainAddressService maintainAddressService;

    @EJB
    private MaintainTelephoneService maintainTelephoneService;

    @EJB
    private MaintainDisciplinaryActionService maintainDisciplinaryActionService;

    @EJB
    private MaintainCredentialsService maintainCredentialsService;

    @EJB
    private MaintainExpertiseService maintainExpertiseService;

    @EJB
    private MaintainNoteService maintainNoteService;

    @EJB
    private MaintainConditionService maintainConditionService;

    @EJB
    private MaintainConfidentialityService maintainConfidentialityService;

    @EJB
    private MaintainElectronicAddressService maintainElectronicAddressService;

    @EJB
    private MaintainProviderRelationshipService maintainProviderRelationshipService;

    @EJB
    private MaintainRegistryUserRelationshipService maintainRegistryUserRelationshipService;

    @EJB
    private MaintainWorkLocationService maintainWorkLocationService;

    @EJB
    private MaintainInformationRouteService maintainInformationRouteService;

    @EJB
    private MaintainProviderServiceHelper maintainProviderServiceHelper;

    @Resource
    private EJBContext context;

    /**
     * Save method to be called from web beans to add the provider. Cannot use
     * the save(ProviderDto::providerDto) method, as transaction will not be
     * rolled back, if any of the maintain* service fails. Also making the
     * Exception as @ApplicationException or child of RuntimeException would
     * make life hard as the catch blocks in manager will not be reached and
     * will display all the EjbTransactionRolledBackException in the log For
     * messages the tx is handled from the remote implementation
     *
     * @param providerDto
     * @return
     * @throws EntityValidationException
     * @throws DuplicateRecordException
     * @throws BusinessRuleException
     */
    public PrsProviders saveWebProvider(ProviderDto providerDto) throws EntityValidationException, DuplicateRecordException, BusinessRuleException {
        PrsProviders provider;
        try {
            provider = addProvider_Save_MessageAndWeb(providerDto);
        } catch (EntityValidationException | DuplicateRecordException e) {
            context.setRollbackOnly();
            throw e;
        } catch (BusinessRuleException e) {
            if(e.getResults().get(0).getMessages().get(0).getSeverity().toString().equals("WARNING")){
                throw e;
            } else {
                context.setRollbackOnly();
                throw e;
            }
        }
        return provider;
    }

    /**
     * Persists a new provider and creates the registry identifiers, and returns
     * an entity representing the new provider.
     *
     * @param providerDto
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     * @throws ca.bc.gov.health.plr.service.provider.DuplicateRecordException
     * @throws ca.bc.gov.health.plr.rule.BusinessRuleException
     * @return the ca.bc.gov.health.plr.ejb.entity.PrsProviders
     */
    public PrsProviders addProvider_Save_MessageAndWeb(ProviderDto providerDto) throws EntityValidationException, DuplicateRecordException, BusinessRuleException {
        try {
            return createBlocks_MessageAndWeb_NewProvider(providerDto);

        } catch (IllegalArgumentException | NoSuchMethodException | IllegalAccessException ex) {
            throw new RuntimeException(ex);

        } catch (InvocationTargetException ex) {
            maintainProviderServiceHelper.handleInvocationTargetException(ex);
        }
        return null;
    }

    /**
     * Processes batch saving of all changed data blocks for a provider
     *
     * @param dtoBlocksToSave A list of all dto data block lists that should be
     * saved
     * @param existingProvider
     *
     * @return
     * @throws DuplicateRecordException
     * @throws EntityValidationException
     * @throws BusinessRuleException
     */
    public List<List<?>> saveMessageUpdate(List<List<?>> dtoBlocksToSave, ProviderDto existingProvider) throws DuplicateRecordException, EntityValidationException, BusinessRuleException {

        List<List<?>> dataBlockIemsList = new ArrayList<>();
        for (List<?> dtoBlockList : dtoBlocksToSave) {
            List<Object> dataBlockItems = new ArrayList<>();
            dataBlockIemsList.add(dataBlockItems);

            for (Object dto : dtoBlockList) {

                try {

                    if (dto instanceof WorkLocationDto) {

                        WorkLocationDto input = (WorkLocationDto) dto;

                        if (((WorkLocationDto) dto).getId() == null) {
                            // new work location
                            WorkLocationDetailsDto details = input.getWorkLocationDetails().remove(0);
                            WorkLocationDto output = saveNewWorkLocationAndDetail(input, details);
                            dataBlockItems.add(output);
                            dataBlockItems.addAll(processWorkLocationBlock(output, input, false, existingProvider));
                            input.getWorkLocationDetails().add(details);

                        } else {
                            // if ceasing the details, try to cease all the children
                            if (input.getWorkLocationDetails() != null && input.getWorkLocationDetails().size() > 0 && isCeased.isCeased(input.getWorkLocationDetails().get(0))) {
                                maintainProviderServiceHelper.setEndReasonToCease_AllWorkLocationChildren(existingProvider, input);
                            }

                            dataBlockItems.addAll(processWorkLocationBlockItemList(input, input.getWorkLocationDetails(), maintainWorkLocationService, true, existingProvider));
                            dataBlockItems.addAll(processWorkLocationBlock(input, input, false, existingProvider));

                        }

                    } else if (dto instanceof InformationRouteDto) {
                        dataBlockItems.add(maintainProviderServiceHelper.processInformationRoute((InformationRouteDto) dto, existingProvider, this));
                    } else if (dto instanceof LocationDto) {
                        dataBlockItems.add(maintainProviderServiceHelper.processLocation((LocationDto) dto, existingProvider, this));
                    } else {
                        dataBlockItems.add(maintainProviderServiceHelper.reflectionSave(this, dto, "save"));
                    }

                } catch (IllegalArgumentException | NoSuchMethodException | IllegalAccessException ex) {
                    throw new RuntimeException(ex);

                } catch (InvocationTargetException ex) {

                    maintainProviderServiceHelper.handleInvocationTargetException(ex);

                }
            }
        }

        return dataBlockIemsList;
    }

    /**
     * Sometime the conf. validator needs to run sometimes not, hence the run flag
     * Also sometimes the background address process is run
     * 
     * @param toSave address to save
     * @param runConfidentialValidator toggle the validator
     * #param fromBackgroundAddressProcessor toggle from background address processor
     * @return
     * @throws DuplicateRecordException
     * @throws BusinessRuleException
     * @throws EntityValidationException 
     */    
    public AddressDto save(AddressDto toSave, boolean runConfidentialValidator, boolean fromBackgroundAddressProcessor) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        return maintainAddressService.save(toSave, runConfidentialValidator, fromBackgroundAddressProcessor);
    }
    /**
     * Sometime the conf. validator needs to run sometimes not, hence the run flag
     * 
     * @param toSave address to save
     * @param runConfidentialValidator toggle the validator
     * @return
     * @throws DuplicateRecordException
     * @throws BusinessRuleException
     * @throws EntityValidationException 
     */
    public AddressDto save(AddressDto toSave, boolean runConfidentialValidator) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        return maintainAddressService.save(toSave, runConfidentialValidator, false);
    }

    public AddressDto save(AddressDto toSave) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        return maintainAddressService.save(toSave, true, false);
    }

    public ConditionsDto save(ConditionsDto toSave) throws DuplicateRecordException, EntityValidationException {
        return maintainConditionService.save(toSave);
    }

    public ConfidentialityIndicatorDto save(ConfidentialityIndicatorDto toSave) throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        return maintainConfidentialityService.save(toSave);
    }

    public CredentialsDto save(CredentialsDto toSave) throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        return maintainCredentialsService.save(toSave);
    }

    public DemographicDetailsDto save(DemographicDetailsDto toSave) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        return maintainDemographicDetailsService.save(toSave);
    }

    public DisciplinaryActionDto save(DisciplinaryActionDto toSave) throws DuplicateRecordException, EntityValidationException {
        return maintainDisciplinaryActionService.save(toSave);
    }

    public ElectronicAddressDto save(ElectronicAddressDto toSave) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        return maintainElectronicAddressService.save(toSave);
    }

    public ExpertiseDto save(ExpertiseDto toSave) throws DuplicateRecordException, EntityValidationException {
        return maintainExpertiseService.save(toSave);
    }

    public InformationRouteDto save(InformationRouteDto toSave) throws DuplicateRecordException, EntityValidationException {
        return maintainInformationRouteService.save(toSave);
    }

    public RegistryIdentifierDto save(RegistryIdentifierDto toSave) throws DuplicateRecordException, EntityValidationException {
        return maintainRegistryIdentifierService.save(toSave);
    }

    public NoteDto save(NoteDto toSave) throws DuplicateRecordException, EntityValidationException {
        return maintainNoteService.save(toSave);
    }

    public OrgNameDto save(OrgNameDto toSave) throws DuplicateRecordException, EntityValidationException {
        return maintainOrgNameService.save(toSave);
    }

    public PersonNameDto save(PersonNameDto toSave) throws DuplicateRecordException, EntityValidationException {
        return maintainPersonNameService.save(toSave);
    }

    public CollegeIdentifierDto save(CollegeIdentifierDto toSave) throws DuplicateRecordException, EntityValidationException {
        return maintainProviderIdentifierService.save(toSave);
    }

    public ProviderRelationshipDto save(ProviderRelationshipDto toSave) throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        return maintainProviderRelationshipService.save(toSave);
    }

    public RegistryUserRelationshipDto save(RegistryUserRelationshipDto toSave) throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        return maintainRegistryUserRelationshipService.save(toSave);
    }

    public StatusDto save(StatusDto toSave) throws DuplicateRecordException, EntityValidationException {
        return maintainStatusService.save(toSave);
    }

    public TelecommunicationDto save(TelecommunicationDto toSave) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        return maintainTelephoneService.save(toSave);
    }

    public WorkLocationDto saveNewWorkLocationAndDetail(WorkLocationDto workLocationDto, WorkLocationDetailsDto workLocationDetailsDto) throws DuplicateRecordException, EntityValidationException {
        return maintainWorkLocationService.saveNewWorkLocationAndDetail(workLocationDto, workLocationDetailsDto);
    }

    @EJB
    CheckEndReasonCode isCeased;

    public WorkLocationDetailsDto updateWorkLocationDetail(ProviderDto providerDetails, WorkLocationDetailsDto workLocationDetailsDto) throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        if (isCeased.isCeased(workLocationDetailsDto)) {
            // try to cease all the children for ceasing
            WorkLocationDto wlDto = providerDetails.getWorkLocationDtoByWLID(workLocationDetailsDto.getWlWlId());
            maintainProviderServiceHelper.setEndReasonToCease_AllWorkLocationChildren(providerDetails, wlDto);
            try {
                processWorkLocationBlock(wlDto, wlDto, true, providerDetails);
            } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException ex) {
                throw new RuntimeException(ex);
            } catch (InvocationTargetException ex) {
                maintainProviderServiceHelper.handleInvocationTargetException(ex);
            }
        }
        return maintainWorkLocationService.updateWorkLocationDetail(providerDetails, workLocationDetailsDto);
    }

    /**
     * Persists a new provider and creates the registry identifiers, and returns
     * an entity representing the new provider.
     *
     * @param providerDto
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     * @throws ca.bc.gov.health.plr.rule.BusinessRuleException
     * @return the ca.bc.gov.health.plr.ejb.entity.PrsProviders
     */
    private PrsProviders createProvider(ProviderDto providerDto) throws EntityValidationException, BusinessRuleException {
        PrsProviders provider = providerDtoConverter.toEntity(providerDto);
        entityValidatorService.validate(provider);
        setMandatoryInternalAttributes(provider);
        em.persist(provider);

        createGrsRegistryIdentifers(provider, CodeTableCodes.GrsCtRegIdentifierTypes.COMMON_PROVIDER_NUMBER);
        createGrsRegistryIdentifers(provider, CodeTableCodes.GrsCtRegIdentifierTypes.INTERNAL_PROVIDER_ID);

        createGrsIdentifiersAsCopyOfGrsRegistryIdentifiers(provider);

        return provider;
    }

    /**
     * Creates and saves the data blocks for a new Provider
     *
     *
     * @param providerDetails
     * @return
     * @throws EntityValidationException
     * @throws DuplicateRecordException
     * @throws BusinessRuleException
     */
    private PrsProviders createBlocks_MessageAndWeb_NewProvider(ProviderDto providerDetails) throws EntityValidationException, DuplicateRecordException, BusinessRuleException, NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {

        //If the provider to be created is an organization,
        //check database to see if there is an existing organization provider with same name and city.
        if (providerDetails.getPartyType().equals(CodeTableCodes.GrsCtPartyType.ORG)) {
            if (duplicateOrgsExist(providerDetails)) {
                List<BusinessRuleMessage> messages = new ArrayList<>();
                BusinessRuleKeys key = BusinessRuleKeys.ERROR_ADD_PROVIDER;
                String message = BusinessRuleMessageDao.getMessageResource(key);
                messages.add(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR));
                BusinessRuleResult brr = new BusinessRuleResult(false, messages);
                throw new BusinessRuleException(brr);
            }
        }

        PrsProviders provider = createProvider(providerDetails);
        Long pauthId = provider.getPauthId();

        //Save College Identifier
        for (CollegeIdentifierDto dto : providerDetails.getIdentifiers()) {
            dto.setPauthId(pauthId);
            save(dto);
        }

        //Save Address
        for (AddressDto dto : providerDetails.getAddresses()) {
            dto.setPauthId(pauthId);
            save(dto);
        }

        //Save Registry identifiers
        for (RegistryIdentifierDto dto : providerDetails.getRegistryIdentifiers()) {
            dto.setPauthId(pauthId);
            save(dto);
        }

        //Save Status     
        for (StatusDto dto : providerDetails.getStatuses()) {
            dto.setPauthId(pauthId);
            save(dto);
        }

        createNames(providerDetails, pauthId);

        if (providerDetails.getPartyType().equals(CodeTableCodes.GrsCtPartyType.IND)) {
            //Save Demographic details
            for (DemographicDetailsDto dto : providerDetails.getDemographicDetails()) {
                dto.setPauthId(pauthId);
                save(dto);
            }
        }

        createTelecommunications(providerDetails, pauthId);
        createEmail(providerDetails, pauthId);

        //Save Credential Details
        for (CredentialsDto dto : providerDetails.getCredentials()) {
            //Save Credential Details
            if (dto != null
                    && (dto.getTypeId() != null || dto.getTypeCode() != null)) {
                dto.setPauthId(pauthId);
                save(dto);
            }
        }
        //Save Expertise
        for (ExpertiseDto dto : providerDetails.getExpertise()) {
            //Save Expertise
            if (dto != null
                    && (dto.getTypeId() != null || dto.getTypeCode() != null)) {
                dto.setPauthId(pauthId);
                save(dto);
            }
        }

        //Save InfoRoute
        for (InformationRouteDto dto : providerDetails.getInformationRoutes()) {
            dto.setPauthId(pauthId);
            maintainProviderServiceHelper.processInformationRoute(dto, null /* no existing provider */, this);
        }

        //Save ProviderRelationship
        for (ProviderRelationshipDto dto : providerDetails.getProviderRelationships()) {
            dto.setPauthId(pauthId);
            save(dto);
        }

        //Save Notes
        for (NoteDto dto : providerDetails.getNotes()) {
            dto.setPauthId(pauthId);
            save(dto);
        }
        //Save Conditions
        for (ConditionsDto dto : providerDetails.getConditions()) {
            dto.setPauthId(pauthId);
            save(dto);
        }

        //Save Disciplinary Actions
        for (DisciplinaryActionDto dto : providerDetails.getDisciplinaryActions()) {
            dto.setPauthId(pauthId);
            save(dto);
        }

        //Save Confidentiality
        for (ConfidentialityIndicatorDto dto : providerDetails.getConfidentialityIndicators()) {
            dto.setPauthId(pauthId);
            save(dto);
        }
        //Save Registry User relationship
        for (RegistryUserRelationshipDto dto : providerDetails.getRegistryUserRelationships()) {
            dto.setPauthId(pauthId);
            save(dto);
        }

        //Save Work Location
        for (WorkLocationDto dto : providerDetails.getWorkLocationList()) {

            dto.setPauthId(pauthId);
            WorkLocationDto output = saveNewWorkLocationAndDetail(dto, dto.getWorkLocationDetails().remove(0));
            processWorkLocationBlock(output, dto, false, null /* no existing provider */);

        }

        em.refresh(provider);
        createLinkageIfNecessary(provider);
        return provider;

    }

    /**
     * As {@link AddProviderDto} does not contain all mandatory properties for
     * {@link PrsProviders}, those properties will be set by this method prior
     * to persisting, e.g. INTERNAL_INTERNAL_CHID, NAME_TYPE_CODE, etc.
     *
     * @param prsProviders
     * @param addProviderDto
     */
    private void setMandatoryInternalAttributes(PrsProviders prsProviders) {
        GrsCtBooleanTypes trueCode = codesDao.lookup(GrsCtBooleanTypes.class, CodeTableCodes.GrsCtBooleanTypes.YES);
        // TODO: PLR-246: Remove INTERNAL_INTERNAL_CHID
        prsProviders.setInternalInternalChid(
                "CGI_TODO");
        prsProviders.setCategoryCode(prsProviders.getHptCode().getCategoryCode());
        prsProviders.setActiveFlag(trueCode);

        prsProviders.setRuRuId(user.get().getUserEntity());
    }

    private void createGrsIdentifiersAsCopyOfGrsRegistryIdentifiers(PrsProviders provider) {
        List<GrsIdentifiers> IDs = providerDtoConverter.buildIdentifierCPNIPC(provider, new LocalDate());
        for (GrsIdentifiers id : IDs) {
            em.persist(id);
        }
    }

    private void createGrsRegistryIdentifers(PrsProviders provider, CodeTableCodes.GrsCtRegIdentifierTypes grsCtRegIdentifierTypes) {
        GrsRegistryIdentifiers identifier = providerDtoConverter.buildRegistryIdentifier(provider, new LocalDate(), grsCtRegIdentifierTypes);
        provider.getGrsRegistryIdentifiersList().add(identifier);
        em.persist(identifier);
    }

    /**
     * Search through identifiers for RNID
     *
     * @param identifiers list of identifiers to search
     * @return if a RNID is found the value is returned, otherwise null is
     * returned
     */
    private String hasRNID(List<GrsIdentifiers> identifiers) {
        for (GrsIdentifiers id : identifiers) {
            if (id.getIdentifierTypeCode().getCtlNameCode().equals(CodeTableCodes.PrsCtIdentifierTypeCodes.RNID.getValue())) {
                return id.getProviderChid();
            }
        }
        return null;
    }

    /**
     * Implementation of updated REQ-00681: "Provider To Provider Linkage
     * Detection Rules".
     *
     * Note: This is only done during add provider and the existing provider
     * keeps their CPN. Added new matching rules for linking providers by CPNs.
     *
     * @param newProvider
     */
    private void createLinkageIfNecessary(PrsProviders newProvider) {

        if (newProvider.getHptCode().getCtlNameCode().equals(CodeTableCodes.PrsCtProviderRoleTypes.ORG.getValue())) {
            // don't try to link organizations
            return;
        }

        // Don't link bad providers, like providers with matching role, id type and id
        List<PrsProviders> providerDuplicateList = new ArrayList<>();
        HashMap<Long, PrsProviders> providerDuplicateIDMap = new HashMap<>();
        for (GrsIdentifiers identifier : newProvider.getGrsIdentifiersList()) {
            providerDuplicateList.addAll(em.createNamedQuery("PrsProviders.findMatchingIdentifiersWithRole", PrsProviders.class)
                    .setParameter("identifierTypeCode", identifier.getIdentifierTypeCode().getCtlNameCode())
                    .setParameter("providerChid", identifier.getProviderChid())
                    .setParameter("role", newProvider.getHptCode().getCtlNameCode())
                    .getResultList());
            for(PrsProviders provider : providerDuplicateList) {
                providerDuplicateIDMap.putIfAbsent(provider.getPauthId(), provider);
            }
            providerDuplicateList.clear();
        }
        // Return if the new provider and an existing provider share a role, id and id type
        // This is bad data, return and don't link
        if(providerDuplicateIDMap.size() > 1) {
            return;
        }

        // If new provider is RN or RNP and has RNID then find other providers
        // with RNID and opposite role
        if ((newProvider.getHptCode().getCtlNameCode().equals(CodeTableCodes.PrsCtProviderRoleTypes.RN.getValue())
                || newProvider.getHptCode().getCtlNameCode().equals(CodeTableCodes.PrsCtProviderRoleTypes.RNP.getValue()))) {

            // do we have a RNID?
            String RNIDValue = hasRNID(newProvider.getGrsIdentifiersList());
            if (RNIDValue != null) {
                String RNIDTypeCode = CodeTableCodes.PrsCtIdentifierTypeCodes.RNID.getValue();

                // get opposite role
                String oppositeRole = newProvider.getHptCode().getCtlNameCode().equals(CodeTableCodes.PrsCtProviderRoleTypes.RN.getValue()) ? CodeTableCodes.PrsCtProviderRoleTypes.RNP.getValue() : CodeTableCodes.PrsCtProviderRoleTypes.RN.getValue();

                // now find other providers with the same RNID value and opposite role
                List<PrsProviders> providers = em.createNamedQuery("PrsProviders.findMatchingIdentifiersWithRole").setParameter("identifierTypeCode", RNIDTypeCode).setParameter("providerChid", RNIDValue).setParameter("role", oppositeRole).getResultList();

                if (providers.size() == PROVIDER_SINGLE_RESULT_FOR_LINKAGE) {
                    // we have a match
                    changeProviderIdentifierCPNId(providers.get(0), newProvider);

                    // nothing else to do, return, if size is not 1 carry on to criteria match
                    return;
                }

            }
        }

        // If the above fails to match/link then try the following
        // Find providers with matching city, 1st name, last names, dob, gender
        // and roles that are different
        HashMap<Long, PrsProviders> matchingUniqueProviders = new HashMap<>();
        List<PrsProviders> matchingProviders = new ArrayList<>();
        List<GrsPersonNames> grsPersonNames = newProvider.getGrsPersonNamesList();
        PrsDemographicDetails prsDemographicDetails = newProvider.getPrsDemographicDetailsList().get(0);
        List<GrsAddresses> grsAddresses = newProvider.getGrsAddressesList();

        long countMaxProvidersLinkage = 0;

        if (grsPersonNames != null && prsDemographicDetails != null
                && grsAddresses != null) {

            // For each combination of name and address from new provider check for matches
            // THere can only be one demographic so no need to check that
            for (GrsPersonNames names : grsPersonNames) {
                for (GrsAddresses addresses : grsAddresses) {

                    // The named query does the ERC and active check and also makes sure the roles do 
                    // not match ... so only mathcing providers with a different role are returned
                    // The named query also matches on name type and address type/purpose
                    matchingProviders = em.createNamedQuery("PrsProviders.findMatchingDemographics", PrsProviders.class)
                            .setParameter("suranme", names.getPrsnSurnameTxt())
                            .setParameter("firstName", names.getPrsnFirstGivenNameTxt())
                            .setParameter("role", newProvider.getHptCode().getCtlNameCode())
                            .setParameter("dob", prsDemographicDetails.getDateOfBirthDate())
                            .setParameter("genderCode", prsDemographicDetails.getGenderCode())
                            .setParameter("nameTypeCd", names.getNameTypeCode().getCtlNameCode())
                            .setParameter("addressTypeCd", addresses.getAddressTypeCode().getCtlNameCode())
                            .setParameter("cmnctnPrpsTypCd", addresses.getCmnctnPrpsTypCd().getCtlNameCode())
                            .setParameter("cityTxt", addresses.getCityTxt()).getResultList();

                    // add to map, guarrantees uniqueness by pauth
                    for (PrsProviders matches : matchingProviders) {
                        matchingUniqueProviders.putIfAbsent(matches.getPauthId(), matches);
                    }
                }
            }

            // if there is a single match and the counter has only two providers for linkage then we have a winner
            if (matchingUniqueProviders.size() == PROVIDER_SINGLE_RESULT_FOR_LINKAGE) {
                changeProviderIdentifierCPNId(matchingUniqueProviders.get((Long) matchingUniqueProviders.keySet().toArray()[0]), newProvider);
            }
        }

    }

    /**
     * Extracts active CPN registry identifier from the GrsRegistryIdentifiers
     * list on the existing provider and then links new provider with CPN
     * registry identifier extracted from the existing provider based on
     * ProviderChid; changes the CPN provider identifier as well when the link
     * is created and flushes the change made to the newProvider.
     *
     * @param existingProvider
     * @param newProvider
     */
    public void changeProviderIdentifierCPNId(PrsProviders existingProvider, PrsProviders newProvider) {

        if (existingProvider != null) {

            List<GrsRegistryIdentifiers> grsRegistryIdentifiersList = existingProvider.getGrsRegistryIdentifiersList();

            if (grsRegistryIdentifiersList != null && !grsRegistryIdentifiersList.isEmpty()) {

                // Extract active CPN reg identifitier from the regidnetifier list on the existing provider
                GrsRegistryIdentifiers cpnGrsRegistryIdentifiers = extractActiveRegistryIdentifiersFromList(grsRegistryIdentifiersList);

                // Link new Provider with CPN reg identifier extracted from the existing provider based on ProviderChid
                if (cpnGrsRegistryIdentifiers != null) {
                    extractActiveRegistryIdentifiersFromList(newProvider.getGrsRegistryIdentifiersList()).setProviderChid(cpnGrsRegistryIdentifiers.getProviderChid());

                    // Change the CPN provider identifier as well when the link is created
                    extractActiveIdentifiersFromList(newProvider.getGrsIdentifiersList()).setProviderChid(cpnGrsRegistryIdentifiers.getProviderChid());

                    // Flush the change made to the newProvider
                    em.flush();
                }
            }
        }
    }

    private <T extends EntityCommon> T getActive(List<T> items) {
        for (T item : items) {
            if (isActive(item)) {
                return item;
            }
        }
        return null;
    }

    private boolean isActive(EntityCommon item) {
        return item.getEndReasonCode() == null && EntityUtils.booleanValue(item.getActiveFlag());
    }

    /**
     * Find the matching CPN provider identifier
     *
     * @param grsIdentifiersList
     * @return
     */
    private GrsIdentifiers extractActiveIdentifiersFromList(List<GrsIdentifiers> grsIdentifiersList) {
        Iterator<GrsIdentifiers> itr = grsIdentifiersList.iterator();
        GrsIdentifiers temp = null;
        while (itr.hasNext()) {
            temp = itr.next();

            if (isCPN(temp) && isActive(temp)) {
                break;
            }
        }

        return temp;
    }

    private GrsRegistryIdentifiers extractActiveRegistryIdentifiersFromList(List<GrsRegistryIdentifiers> grsRegistryIdentifiersList) {

        Iterator<GrsRegistryIdentifiers> itr = grsRegistryIdentifiersList.iterator();
        GrsRegistryIdentifiers temp = null;
        while (itr.hasNext()) {
            temp = itr.next();

            if (isMatchinRegIdentifier(temp) && isActive(temp)) {
                break;
            }
        }

        return temp;

    }

    private boolean isMatchinRegIdentifier(GrsRegistryIdentifiers source) {
        return source.getIdentifierTypeCode().getCtlNameCode().equals(codesDao.lookup(GrsCtRegIdentifierTypes.class, CodeTableCodes.GrsCtRegIdentifierTypes.COMMON_PROVIDER_NUMBER.getValue()).getCtlNameCode());
    }

    /**
     * Match on CPN code
     *
     * @param source
     * @return
     */
    private boolean isCPN(GrsIdentifiers source) {
        return source.getIdentifierTypeCode().getCtlNameCode().equals(codesDao.lookup(PrsCtIdentifierTypes.class, CodeTableCodes.PrsCtIdentifierTypeCodes.CPN.getValue()).getCtlNameCode());
    }

    /**
     * Create the person name or org name depending on the party type
     *
     * @param addProviderDto
     * @param pauthId
     * @throws DuplicateRecordException
     * @throws EntityValidationException
     */
    private void createNames(ProviderDto providerDetails, Long pauthId) throws DuplicateRecordException, EntityValidationException {
        // Save Person Name or Org name depending on the party type
        if (providerDetails.getPartyType().equals(CodeTableCodes.GrsCtPartyType.ORG)) {
            for (OrgNameDto dto : providerDetails.getOrgNames()) {
                dto.setPauthId(pauthId);
                save(dto);
            }
        }

        if (providerDetails.getPartyType().equals(CodeTableCodes.GrsCtPartyType.IND)) {
            for (PersonNameDto dto : providerDetails.getIndNames()) {
                dto.setPauthId(pauthId);
                save(dto);
            }
        }
    }

    /**
     * Creates the telephone and fax details
     *
     * @param addProviderDto
     * @param pauthId
     * @throws DuplicateRecordException
     * @throws EntityValidationException
     */
    private void createTelecommunications(ProviderDto providerDetails, Long pauthId) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        //Save Telephone Details

        for (TelecommunicationDto dto : providerDetails.getTelecommunication()) {

            if (dto.getNumber() != null && (dto.getTypeCode() != null || dto.getTypeId() != null)) {
                dto.setPauthId(pauthId);
                save(dto);
            }
        }

    }

    /**
     * Creates the Email details
     *
     * @param addProviderDto
     * @param pauthId
     * @throws DuplicateRecordException
     * @throws BusinessRuleException
     * @throws EntityValidationException
     */
    private void createEmail(ProviderDto providerDetails, Long pauthId) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        //Save Email Details        
        for (ElectronicAddressDto dto : providerDetails.getElectronicAddresses()) {

            if (dto != null && dto.getAddress() != null) {
                dto.setPauthId(pauthId);

                if (dto.getTypeId() == null && dto.getTypeCode() == null) {
                    dto.setTypeId(codesDao.lookup(PrsCtElectronicAddrTypes.class, CodeTableCodes.PrsCtElectronicAddrTypes.EMAIL).getCtlId());
                }
                save(dto);
            }
        }
    }

    /*
     * Processes work location data block
     */
    private List<Object> processWorkLocationBlock(WorkLocationDto parent, WorkLocationDto dto, boolean isUpdate, ProviderDto existingProvider) throws EntityValidationException, DuplicateRecordException, BusinessRuleException, NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        List<Object> dtoList = new ArrayList<>();
        dtoList.addAll(processWorkLocationBlockItemList(parent, dto.getAddresses(), maintainAddressService, isUpdate, existingProvider));
        dtoList.addAll(processWorkLocationBlockItemList(parent, dto.getElectronicAddresses(), maintainElectronicAddressService, isUpdate, existingProvider));
        dtoList.addAll(processWorkLocationBlockItemList(parent, dto.getTelecommunications(), maintainTelephoneService, isUpdate, existingProvider));
        dtoList.addAll(processWorkLocationBlockItemList(parent, dto.getInformationRoutes(), maintainInformationRouteService, isUpdate, existingProvider));
        return dtoList;
    }

    /**
     * Processes the items that can be attached to a work location and work
     * location details e.g.
     *
     * @param parent
     * @param blockList
     * @param service
     * @param forceChange
     * @return
     * @throws NoSuchMethodException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     * @throws EntityValidationException
     */
    private List<?> processWorkLocationBlockItemList(WorkLocationDto parent, List<?> blockList, Object service, boolean forceChange, ProviderDto existingProvider) throws EntityValidationException, DuplicateRecordException, BusinessRuleException, NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        List<Object> outputList = new ArrayList<>();

        if (blockList != null && !blockList.isEmpty()) {
            for (Object temp : blockList) {
                // execute if tyhis this a change to a data block or we don't care a bout a change
                if (hasChanged(temp) || !forceChange) {
                    temp.getClass().getMethod("setWlWlId", Long.class
                    ).invoke(temp, parent.getId());

                    if (temp instanceof InformationRouteDto) {
                        PrsCtProviderRoleTypes hpt = codesDao.lookup(PrsCtProviderRoleTypes.class, parent.getId());
                        //validateInformationRoute((InformationRouteDto) temp, null, parent.getId(), hpt);
                        outputList.add(maintainProviderServiceHelper.processInformationRoute((InformationRouteDto) temp, existingProvider, service));
                    } else if (temp instanceof WorkLocationDetailsDto) {
                        outputList.add(maintainProviderServiceHelper.reflectionSave(service, temp, "updateWorkLocationDetail"));
                    } else if (temp instanceof LocationDto) {
                        outputList.add(maintainProviderServiceHelper.processLocation((LocationDto) temp, existingProvider, service));
                    }

                }
            }
        }

        return outputList;
    }

    //
    private boolean hasChanged(Object block) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        return block.getClass().getMethod("getEndReasonCodeId").invoke(block) != null || block.getClass().getMethod("getEndReasonCode").invoke(block) != null;
    }

    /**
     * Check if there are any existing organizations with same name and city in
     * database.
     *
     * @param providerDetails ProviderDto contains organization name and address
     * @return true if there are any existing organizations found.
     */
    private boolean duplicateOrgsExist(ProviderDto providerDetails) {
        String orgName = providerDetails.getOrgNames().get(0).getName();
        String cityTxt = providerDetails.getAddresses().get(0).getCity();

        if (orgName != null && cityTxt != null) {
            List<PrsProviders> providers = em.createNamedQuery("PrsProviders.findMatchingOrgs", PrsProviders.class
            )
                    .setParameter("orgName", orgName)
                    .setParameter("cityTxt", cityTxt).getResultList();

            //Create linkage only when there is a single match
            //The first one in providers list is the existing one, the second one is the new provider just created
            return providers != null && !providers.isEmpty();
        } else {
            return false;
        }
    }

}
