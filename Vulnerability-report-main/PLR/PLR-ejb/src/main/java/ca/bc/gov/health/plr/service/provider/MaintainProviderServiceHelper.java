package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.provider.AbstractProviderDetail;
import ca.bc.gov.health.plr.dto.provider.AddressDto;
import ca.bc.gov.health.plr.dto.provider.ElectronicAddressDto;
import ca.bc.gov.health.plr.dto.provider.InformationRouteDto;
import ca.bc.gov.health.plr.dto.provider.LocationDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.TelecommunicationDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.CheckEndReasonCode;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.inject.Inject;

/**
 * This class is here to avoid calling methods in the MaintainProviderService as
 * those public methods are watched by interceptors and we don't want to break
 * the interceptors ... so this is a helper that avoids the interceptors.
 *
 * @author Jonathan.Wiebe
 */
@Stateless
public class MaintainProviderServiceHelper {

    @EJB
    CheckEndReasonCode checkERC;

    @EJB
    MaintainProviderService maintainProviderService;

    /**
     * Try to save an object
     *
     * @param service invoke save on this object
     * @param dtoToSave parameter for save
     * @param methodString method to call
     * @return result method or null
     * @throws DuplicateRecordException
     * @throws EntityValidationException
     * @throws BusinessRuleException
     */
    public Object reflectionSave(Object service, Object dtoToSave, String methodString) throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        try {
            if (service == null) {
                service = maintainProviderService;
            }
            return service.getClass().getDeclaredMethod(methodString, dtoToSave.getClass()).invoke(service, dtoToSave);
        } catch (IllegalAccessException | IllegalArgumentException | NoSuchMethodException | SecurityException ex) {
            Logger.getLogger(MaintainProviderService.class.getName()).log(Level.SEVERE, null, ex);
            throw new RuntimeException(ex);
        } catch (InvocationTargetException ex) {
            handleInvocationTargetException(ex);
        }
        return null;
    }

    /**
     * Finds the children of a WL and sets them to CEASE
     *
     * @param existingProvider provider dto with all data blocks
     * @param input WL
     * @return
     */
    public List<AbstractProviderDetail> setEndReasonToCease_AllWorkLocationChildren(ProviderDto existingProvider, WorkLocationDto input) {
        List<AbstractProviderDetail> apdList = new ArrayList<>();
        for (WorkLocationDto matchingDto : existingProvider.getWorkLocationList()) {
            if (Objects.equals(matchingDto.getIdentifier(), input.getIdentifier())) {
                apdList.addAll(matchingDto.getAddresses());
                apdList.addAll(matchingDto.getElectronicAddresses());
                apdList.addAll(matchingDto.getTelecommunications());
                apdList.addAll(matchingDto.getInformationRoutes());
            }
        }
        input.setAddresses(new ArrayList<AddressDto>());
        input.setElectronicAddresses(new ArrayList<ElectronicAddressDto>());
        input.setTelecommunications(new ArrayList<TelecommunicationDto>());
        input.setInformationRoutes(new ArrayList<InformationRouteDto>());
        for (AbstractProviderDetail apdObj : apdList) {
            if (apdObj.getEndReasonCode() == null) {
                apdObj.setEndReasonCode(CodeTableCodes.GrsCtEndReasonTypes.CEASE.getValue());
                if (apdObj instanceof TelecommunicationDto) {
                    input.getTelecommunications().add((TelecommunicationDto) apdObj);
                } else if (apdObj instanceof ElectronicAddressDto) {
                    input.getElectronicAddresses().add((ElectronicAddressDto) apdObj);
                } else if (apdObj instanceof AddressDto) {
                    input.getAddresses().add((AddressDto) apdObj);
                } else if (apdObj instanceof InformationRouteDto) {
                    input.getInformationRoutes().add((InformationRouteDto) apdObj);
                }
            }
        }
        return apdList;
    }

    /**
     * Helps handle some exceptions
     *
     * @param ex
     * @throws BusinessRuleException
     * @throws EntityValidationException
     * @throws DuplicateRecordException
     * @throws RuntimeException
     */
    void handleInvocationTargetException(InvocationTargetException ex) throws BusinessRuleException, EntityValidationException, DuplicateRecordException, RuntimeException {
        if (ex.getCause() instanceof DuplicateRecordException) {
            throw (DuplicateRecordException) ex.getCause();
        } else if (ex.getCause() instanceof EntityValidationException) {
            throw (EntityValidationException) ex.getCause();
        } else if (ex.getCause() instanceof BusinessRuleException) {
            throw (BusinessRuleException) ex.getCause();
        } else {
            throw new RuntimeException(ex);
        }
    }

    /**
     * Before saving an IR one must make sure there is a location that matches
     *
     * @param irToSave IR to save
     * @param existingProvider exiting provider, where the match is found
     * @throws EntityValidationException
     */
    void validateInformationRoutePreSave(InformationRouteDto irToSave, ProviderDto existingProvider) throws EntityValidationException {
        if (checkERC.isCeased(irToSave) && irToSave.getId() != null) {
            return;
        }
        List<LocationDto> locationList = new ArrayList<>();
        collectLocations(locationList, existingProvider);
        LocationDto matchingLocDto = null;
        for (LocationDto locDto : locationList) {
            if (locDto.getEndReasonCode() == null) {
                matchingLocDto = compareIRAndLocation(locDto, irToSave, existingProvider, true);
                if (matchingLocDto != null) {
                    break;
                }
            }
        }

        // if you found a location, fill in the ir
        if (matchingLocDto != null) {
            if (matchingLocDto instanceof ElectronicAddressDto) {
                irToSave.setElectronicAddressDto((ElectronicAddressDto) matchingLocDto);
            } else if (matchingLocDto instanceof AddressDto) {
                irToSave.setAddressDto((AddressDto) matchingLocDto);
            } else if (matchingLocDto instanceof TelecommunicationDto) {
                irToSave.setTelecommunicationDto((TelecommunicationDto) matchingLocDto);
            }
        } else {
            throw new EntityValidationException(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_NO_LOCATIONS_INFOROUTES));
        }
    }

    /**
     * Before saving a ceased location, make sure no IRs are associated (that
     * aren't being ceased themselves)
     *
     * @param dtoToSave location objet to save
     * @param existingProvider provider with all IRs
     * @throws EntityValidationException
     */
    void validateLocationCeasePreSave(LocationDto dtoToSave, ProviderDto existingProvider) throws EntityValidationException {
        LocationDto matchingLocDto = null;
        List<InformationRouteDto> irList = new ArrayList<>();
        irList.addAll(existingProvider.getInformationRoutes());
        for (WorkLocationDto wlDto : existingProvider.getWorkLocationList()) {
            irList.addAll(wlDto.getInformationRoutes());
        }
        for (InformationRouteDto irDto : irList) {
            if (irDto.getEndReasonCode() == null) {
                matchingLocDto = compareIRAndLocation(dtoToSave, irDto, existingProvider, false);
                if (matchingLocDto != null) {
                    break;
                }
            }
        }
        if (matchingLocDto != null && !irList.isEmpty()) {
            throw new EntityValidationException(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_LOCATION_ASSOCIATED_WITH_INFOROUTE));
        }
    }

    /**
     * Collects all the locations of a provider
     *
     * @param locationList list to populate
     * @param existingProvider provider with locations
     */
    private void collectLocations(List<LocationDto> locationList, ProviderDto existingProvider) {
        if (existingProvider != null) {
            locationList.addAll(existingProvider.getElectronicAddresses());
            locationList.addAll(existingProvider.getAddresses());
            locationList.addAll(existingProvider.getTelecommunication());
            for (WorkLocationDto wlDto : existingProvider.getWorkLocationList()) {
                locationList.addAll(wlDto.getAddresses());
                locationList.addAll(wlDto.getElectronicAddresses());
                locationList.addAll(wlDto.getTelecommunications());
            }
        }
    }

    /**
     * Returns the given Location if there is a link between the given Location
     * and the given Information Route, or null if there is no link. ("Link"
     * means that the Information Route points at the Location.)
     *
     * @param locDto location to compare
     * @param irToSave ir to compare
     * @param existingProvider provider with work locations
     * @param isUpdatingInformationRoute : TRUE when the information route is
     * getting updated. FALSE if location is getting updated. If TRUE, to
     * identify if the location is child of Work location check for the Work
     * location Identifier attribute, if FALSE check for the location's wlWlId
     * attribute.
     * @return
     */
    private LocationDto compareIRAndLocation(LocationDto locDto, InformationRouteDto irToSave, ProviderDto existingProvider, boolean isUpdatingInformationRoute) {
        if (matchDataOwnerCodes(locDto, irToSave)
                && matchPurposeCodes(locDto, irToSave)
                && matchTypeCodes(locDto, irToSave)) {

            if (shouldCheckWorkLocation(isUpdatingInformationRoute, irToSave, locDto)) {
                for (WorkLocationDto wlDto : existingProvider.getWorkLocationList()) {
                    if (wlDto.getId().equals(locDto.getWlWlId())
                            && wlDto.getDataOwnerCode().equals(irToSave.getWorkLocationDataOwnerCode())
                            && wlDto.getIdentifier().equals(irToSave.getWorkLocationIdentifier())) {

                        return locDto;
                    }
                }
            } else {
                
                // the location found could be a work location location, but at this point 
                // we are no longer looking for that, so discard if there is any hint we
                // match with a work location location
                if (locDto.getWlWlId() == null) {
                    return locDto;
                }
            }
        }
        return null;
    }

    private boolean shouldCheckWorkLocation(boolean isUpdatingInformationRoute, InformationRouteDto irToSave, LocationDto locDto) {
        // PLR-2161
        if (isUpdatingInformationRoute && irToSave.getWorkLocationIdentifier() != null) {
            // adding/updating Information Route that points at Work Location child
            return true;
        } else if (!isUpdatingInformationRoute && locDto.getWlWlId() != null && locDto.getPauthId() == null) {
            // CEASING Work Location child
            return true;
        }
        return false;
    }

    /**
     * matching helper
     *
     * @param locDto
     * @param irToSave
     * @return
     */
    private boolean matchPurposeCodes(LocationDto locDto, InformationRouteDto irToSave) {
        boolean matches = false;
        if (locDto instanceof ElectronicAddressDto) {
            matches = locDto.getCommunicationPurposeCode().equals(irToSave.getElectronicAddressDto().getCommunicationPurposeCode());
        } else if (locDto instanceof AddressDto) {
            matches = locDto.getCommunicationPurposeCode().equals(irToSave.getAddressDto().getCommunicationPurposeCode());
        } else if (locDto instanceof TelecommunicationDto) {
            matches = locDto.getCommunicationPurposeCode().equals(irToSave.getTelecommunicationDto().getCommunicationPurposeCode());
        }
        if (!matches) {
            if (locDto.getCommunicationPurposeCode().equals(irToSave.getCommunicationPurposeCode())) {
                matches = true;
            }
        }
        return matches;
    }

    /**
     * matching helper
     *
     * @param locDto
     * @param irToSave
     * @return
     */
    private boolean matchTypeCodes(LocationDto locDto, InformationRouteDto irToSave) {
        boolean matches = false;
        if (locDto instanceof ElectronicAddressDto) {
            matches = locDto.getTypeCode().equals(irToSave.getElectronicAddressDto().getTypeCode());
        } else if (locDto instanceof AddressDto) {
            matches = locDto.getTypeCode().equals(irToSave.getAddressDto().getTypeCode());
        } else if (locDto instanceof TelecommunicationDto) {
            matches = locDto.getTypeCode().equals(irToSave.getTelecommunicationDto().getTypeCode());
        }
        if (!matches) {
            if (locDto.getTypeCode().equals(irToSave.getTypeCode())) {
                matches = true;
            }
        }
        return matches;
    }

    /**
     * matching helper
     *
     * @param locDto
     * @param irToSave
     * @return
     */
    private boolean matchDataOwnerCodes(LocationDto locDto, InformationRouteDto irToSave) {
        boolean matches = false;
        if (locDto instanceof ElectronicAddressDto) {
            matches = locDto.getDataOwnerCode().equals(irToSave.getElectronicAddressDto().getDataOwnerCode());
        } else if (locDto instanceof AddressDto) {
            matches = locDto.getDataOwnerCode().equals(irToSave.getAddressDto().getDataOwnerCode());
        } else if (locDto instanceof TelecommunicationDto) {
            matches = locDto.getDataOwnerCode().equals(irToSave.getTelecommunicationDto().getDataOwnerCode());
        }
        if (!matches) {
            if (locDto.getDataOwnerCode().equals(irToSave.getCommunicationDataOwnerCode())) {
                matches = true;
            }
        }
        return matches;
    }

    /**
     * Start processing a location
     *
     * @param dtoToSave location to save
     * @param existingProvider provider with existing data
     * @param service service to use for save
     * @return
     * @throws EntityValidationException
     * @throws DuplicateRecordException
     * @throws BusinessRuleException
     */
    public Object processLocation(LocationDto dtoToSave, ProviderDto existingProvider, Object service) throws EntityValidationException, DuplicateRecordException, BusinessRuleException {
        if (checkERC.isCeased(dtoToSave) && existingProvider != null) {
            validateLocationCeasePreSave(dtoToSave, existingProvider);
        }
        return reflectionSave(service, dtoToSave, "save");
    }

    /**
     * Processing information routes for messages. This doesn't need to invoked
     * for web, as the address is already populated.
     *
     * @param dtoToSave
     * @return
     * @throws DuplicateRecordException
     * @throws EntityValidationException
     */
    public Object processInformationRoute(InformationRouteDto dtoToSave, ProviderDto existingProvider, Object service) throws EntityValidationException, DuplicateRecordException, BusinessRuleException {
        validateInformationRoutePreSave(dtoToSave, existingProvider);
        return reflectionSave(service, dtoToSave, "save");
    }

}
