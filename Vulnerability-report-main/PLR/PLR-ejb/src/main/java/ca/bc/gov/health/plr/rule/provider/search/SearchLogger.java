package ca.bc.gov.health.plr.rule.provider.search;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.provider.search.SearchProviderResult;
import ca.bc.gov.health.plr.ejb.entity.GrsCtBooleanTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsDataAccessEvents;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.interceptors.TestUserInterceptor;
import ca.bc.gov.health.plr.persistence.CodesDao;
import static ca.bc.gov.health.plr.ejb.entity.util.DatabaseConstants.PERSISTENCE_CONTEXT_UNIT_NAME;
import ca.bc.gov.health.plr.producer.type.Authenticated;
import ca.bc.gov.health.plr.producer.type.User;
import ca.bc.gov.health.plr.service.provider.MatchHistory;
import ca.bc.gov.health.plr.service.registry.user.RegistryUserSearchParam;
import ca.bc.gov.health.plr.service.validators.UserChidGenerator;
import java.math.BigInteger;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.interceptor.Interceptors;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.apache.commons.lang3.StringUtils;

/**
 * Contains methods for logging searches.
 *
 * Methods conform to REQ-00594, "Search Logging".
 *
 * @author David Sharpe <david.a.sharpe@cgi.com>
 */
@Stateless
@Interceptors({TestUserInterceptor.class})
public class SearchLogger {

    @PersistenceContext(unitName = PERSISTENCE_CONTEXT_UNIT_NAME)
    private EntityManager em;

    @EJB
    private CodesDao codesDao;
    
    @Inject
    @Authenticated
    private Instance<User> user;
    
    @EJB
    private UserChidGenerator chidGenerator;

    private static final String JURISDICTION_CODE = "BC";
    private static final String UNSPECIFIED_ROLE_TYPE = "UNSPECIFIED";

    private static enum TopicType{PROV, RU, APG};

    /**
     * Log a search for College IDs.
     *
     * @param providerResult
     * @param identifierTypeId query parameter - the ID of the Identifier Type
     * @param identifier query parameter - the College ID
     * @param matchHistory query parameter - whether to include historical
 results
     */
    public void logSearchForCollegeId(SearchProviderResult providerResult, long identifierTypeId, String identifier, MatchHistory matchHistory) {
        Map<String, Object> searchParameters = new HashMap<>();
        searchParameters.put("College Type ID", identifierTypeId);
        searchParameters.put("College ID", identifier);
        searchParameters.put("Match History", matchHistory);
        log(providerResult, searchParameters, null);
    }

    /**
     * Log a search for Registry IDs.
     *
     * @param providerResult
     * @param registryIdentifierTypeCodeId query parameter - the ID of the
 Registry Identifier Type
     * @param identifier query parameter - the Registry ID
     * @param matchHistory query parameter - whether to include historical
 results
     */
    public void logSearchForRegId(SearchProviderResult providerResult, long registryIdentifierTypeCodeId, String identifier, MatchHistory matchHistory) {
        Map<String, Object> searchParameters = new HashMap<>();
        searchParameters.put("Reg Type ID", registryIdentifierTypeCodeId);
        searchParameters.put("Reg ID", identifier);
        searchParameters.put("Match History", matchHistory);
        log(providerResult, searchParameters, null);
    }

    /**
     * Log a search for Organizations.
     *
     * @param providerResult
     * @param providerRoleTypeId query parameter - the ID of the Registry
 Identifier Type
     * @param orgName query parameter - the organization name
     * @param addressCity query parameter - the city
     * @param matchHistory query parameter - whether to include historical
 results
     */
    public void logSearchForOrganization(SearchProviderResult providerResult, Long providerRoleTypeId, String orgName, String orgLongName, String addressCity, MatchHistory matchHistory) {
        Map<String, Object> searchParameters = new HashMap<>();
        searchParameters.put("Org Name", orgName);
        searchParameters.put("Description", orgLongName);
        searchParameters.put("City", addressCity);
        searchParameters.put("Match History", matchHistory);
        log(providerResult, searchParameters, providerRoleTypeId);
    }

    /**
     * Log a search for individual Providers/Practitioners.
     *
     * @param providerResult
     * @param providerRoleTypeId query parameter - the ID of the Registry
 Identifier Type
     * @param firstName query parameter - the first name
     * @param lastName query parameter - the last name
     * @param city query parameter - the city
     * @param matchHistory query parameter - whether to include historical
 results
     */
    public void logSearchForPractitioner(SearchProviderResult providerResult, Long providerRoleTypeId, String firstName, String lastName, String city, MatchHistory matchHistory, List<Long> expertiseList, List<Long> languageList) {

        Map<String, Object> searchParameters = new HashMap<>();
        searchParameters.put("First Name", firstName);
        searchParameters.put("Last Name", lastName);
        searchParameters.put("City", city);
        searchParameters.put("Match History", matchHistory);
        searchParameters.put("Expertise", expertiseList);
        searchParameters.put("Language", languageList);
        log(providerResult, searchParameters, providerRoleTypeId);
    }
    
    /**
     * Log a search for location, expertise and Language
     * @param providerResult SearchProviderResult
     * @param providerRoleTypeId Long
     * @param firstName string the first name
     * @param lastName string the last name
     * @param gender string the gender name
     * @param city string the city name
     * @param expertise string the expertise
     * @param language string the language
     * @param matchHistory MatchHistory
     */
    public void logSearchForLocationExpertiseLanaguage(SearchProviderResult providerResult, Long providerRoleTypeId, String firstName, String lastName, String gender, String city, String expertise, String language, MatchHistory matchHistory) {

        Map<String, Object> searchParameters = new HashMap<>();
        if(StringUtils.isNoneBlank(firstName)) {
            searchParameters.put("First Name", firstName);
        }
        if(StringUtils.isNoneBlank(lastName)) {
            searchParameters.put("Last Name", lastName);
        }
        if(StringUtils.isNoneBlank(gender)) {
            searchParameters.put("Gender", gender);
        }
        if(StringUtils.isNoneBlank(city)) {
            searchParameters.put("City", city);
        }
        if(StringUtils.isNoneBlank(expertise)) {
            searchParameters.put("Expertise", expertise);
        }
        if(StringUtils.isNoneBlank(language)) {
            searchParameters.put("language", language);
        }
        searchParameters.put("Match History", matchHistory);
        log(providerResult, searchParameters, providerRoleTypeId);
    }
    
    /**
     * Log search for Registry Users. It will be invoked once the user searches from Search Reg User page.
     *
     * @param searchParam
     * @param queryResults the search results. Pass null if the search failed.
     */
    public void logSearchForRegistryUser(RegistryUserSearchParam searchParam, List<GrsRegistryUsers> queryResults) {
        Map<String, Object> searchParameters = new HashMap<>();
        if(searchParam.getRegistryUserType() != null){
            searchParameters.put("Registry User Type", searchParam.getRegistryUserType());
        } 
        if(searchParam.getEarliestRegDate() != null){
            searchParameters.put("Earliest Registration Date", searchParam.getEarliestRegDate());
        }
        int rowsReturned = queryResults != null?queryResults.size():0;
        log(rowsReturned, searchParameters, TopicType.RU, null);
    }
    /**
     * For Provider Search : Set the topic Type to PROV and call the log 
     * @param queryResults
     * @param searchParameters
     * @param provRoleId 
     */
    private void log(SearchProviderResult providerResult, Map<String, Object> searchParameters, Long provRoleId) {
        int rowsReturned = providerResult.getSearchResults() != null?providerResult.getSearchResults().size():0;
        Long dataAccessEventId = log(rowsReturned, searchParameters, TopicType.PROV, provRoleId);        
        providerResult.setDataAccessEventId(dataAccessEventId);
    }
    /**
     *  log method for all topic types
     * @param rowsReturned
     * @param searchParameters
     * @param topicType
     * @param provRoleId 
     */
    private Long log(int rowsReturned, Map<String, Object> searchParameters, TopicType topicType, Long provRoleId) {
        GrsDataAccessEvents accessEvent = new GrsDataAccessEvents();
        GrsCtBooleanTypes successFlag;
        if (rowsReturned > 0) {
            accessEvent.setRowsReturnedNum(BigInteger.valueOf(rowsReturned));
            successFlag = codesDao.lookup(GrsCtBooleanTypes.class, "Y");
        } else {
            accessEvent.setRowsReturnedNum(BigInteger.valueOf(0));
            successFlag = codesDao.lookup(GrsCtBooleanTypes.class, "N");
        }
        accessEvent.setJurisdictionCode(JURISDICTION_CODE);
        accessEvent.setDateTimeDts(new Date());        
        accessEvent.setUserChid(chidGenerator.find());
        if (user.get().getUserEntity()!=null){
            accessEvent.setRegistryUserOrgChid(user.get().getUserEntity().getPartyPartyId().getRegistryUserOrgChid());
        }
        accessEvent.setTopicTypeCode(topicType.name());
        if(topicType.equals(TopicType.PROV)){
            if (provRoleId != null && provRoleId!=Long.parseLong(Consts.SELECT_ONE_VALUE)) {
                accessEvent.setProviderRoleTypeCode(codesDao.lookup(PrsCtProviderRoleTypes.class, provRoleId).getCtlNameCode());
            } else {
                accessEvent.setProviderRoleTypeCode(UNSPECIFIED_ROLE_TYPE);
            }
            
        }
        accessEvent.setSuccessFlag(successFlag);
        accessEvent.setQueryPayloadTxt(toLogMessage(searchParameters));
        em.persist(accessEvent);
        return accessEvent.getDaalId();
    }

    private String toLogMessage(Map<String, Object> searchParameters) {

        StringBuilder parameterMsg = new StringBuilder();
        String parameterFormatString = "%s: '%s'";
        for (Iterator<Map.Entry<String, Object>> it = searchParameters.entrySet().iterator(); it.hasNext();) {
            Map.Entry<String, Object> searchParam = it.next();
            parameterMsg.append(String.format(parameterFormatString, searchParam.getKey(), searchParam.getValue()));
            if (it.hasNext()) {
                parameterMsg.append(", ");
            }
        }

        return parameterMsg.toString();
    }

    /**
     * Updates the primary chid of the data access event log table
     * s
     * @param dataAccessEventId
     * @param primaryChid 
     */
    public void updatePrimaryChid(Long dataAccessEventId, String primaryChid) {
        GrsDataAccessEvents accessEvent = em.find(GrsDataAccessEvents.class, dataAccessEventId);
        accessEvent.setPrimaryChid(primaryChid);
        em.merge(accessEvent);
    }
}
