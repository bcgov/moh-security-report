package ca.bc.gov.health.plr.persistence;

import ca.bc.gov.health.plr.constants.Consts;
import static ca.bc.gov.health.plr.constants.Consts.AFTER;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsCtPartyType;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderExpertises;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import static ca.bc.gov.health.plr.ejb.entity.util.DatabaseConstants.PERSISTENCE_CONTEXT_UNIT_NAME;
import ca.bc.gov.health.plr.service.provider.MatchHistory;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;
import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;

/**
 * Data access object that handles persistence for a provider and related
 * entities.
 *
 * @author Grant.Hodgins
 */
@Stateless
@LocalBean
public class ProviderDao {
    
    private static final String CLASSNAME = ProviderDao.class.getSimpleName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);

    @PersistenceContext(unitName = PERSISTENCE_CONTEXT_UNIT_NAME)
    EntityManager em;

    @EJB
    CodesDao codesDao;
    @EJB
    private ConfigurationDao configurationDao;

    /**
     * Find a provider that corresponds to a primary key value.
     *
     * @param pauthId the primary key for a provider
     * @return a matching provider record or null if no match
     */
    public PrsProviders searchByProviderId(Long pauthId) {
        String queryString = "select p from PrsProviders p where p.pauthId = :pauthId";
        TypedQuery<PrsProviders> query = em.createQuery(queryString, PrsProviders.class).setParameter("pauthId", pauthId);

        List<PrsProviders> queryResult = query.getResultList();
        if (!queryResult.isEmpty()) {
            return query.getResultList().get(0);
        } else {
            return null;
        }
    }

    /**
     * Find a list of providers that relate to a specific provider college
     * identifier.
     *
     * @param identifierTypeId the type of identifier
     * @param providerChid the provider's college identifier
     * @param matchHistory match on historical records
     * @return a list of matching identifiers.
     */
    public List<PrsProviders> searchByIdentifer(long identifierTypeId, String providerChid, MatchHistory matchHistory) {
        return searchByIdentifer(identifierTypeId, providerChid, matchHistory, false);
    }

    /**
     * Find a list of providers that relate to a specific provider college
     * identifier.
     *
     * @param identifierTypeId the type of identifier
     * @param providerChid the provider's college identifier
     * @param matchHistory match on historical records
     * @param excludeOrg - exclude organization providers
     * @return a list of matching identifiers.
     */
    public List<PrsProviders> searchByIdentifer(long identifierTypeId, String providerChid, MatchHistory matchHistory, boolean excludeOrg) {
        StringBuilder builder = new StringBuilder();
        builder.append("select distinct p from PrsProviders p ")
                .append("join p.grsIdentifiersList i ");
        
        if(matchHistory.equals(MatchHistory.YES)) {
            builder.append("left join i.endReasonCode identifierEndReasonCode ");
        }
        
        builder.append("where i.identifierTypeCode.ctlId = :identifierTypeId ")
                .append("and i.providerChid = :providerChid ");
        
        if (matchHistory.equals(MatchHistory.NO)) {
            builder.append("and i.endReasonCode is null ");
        }else{
            builder.append("and (identifierEndReasonCode is null or identifierEndReasonCode.ctlNameCode != :corrected) "); //PLRP3-38. Search with history must not include CORRECTED records
        }
        
        if (excludeOrg) {
            builder.append("and p.partyTypeCode.ctlId != :organization ");
        }
        
        if(matchHistory.equals(MatchHistory.YES)){
            // Order by "i.endReasonCode.ctlNameCode desc" favours NULL end reason codes, so active identifiers are sorted higher.
            builder.append("order by identifierEndReasonCode.ctlNameCode desc");
        }
        
        TypedQuery<PrsProviders> query = em.createQuery(
                builder.toString(), PrsProviders.class);
        query.setParameter("identifierTypeId", identifierTypeId);
        query.setParameter("providerChid", providerChid);
        if(matchHistory.equals(MatchHistory.YES)){
            query.setParameter("corrected", CodeTableCodes.GrsCtEndReasonTypes.CORRECT.getValue());
        }
        if (excludeOrg) {
            query.setParameter("organization", codesDao.lookup(GrsCtPartyType.class, CodeTableCodes.GrsCtPartyType.ORG).getCtlId());
        }

        return query.getResultList();
    }

    /**
     * Find a list of providers that relate to a specific provider college
     * identifier.
     *
     * @param identifierTypeCode
     * @param providerChid the provider's college identifier
     * @param matchHistory match on historical records
     * @return a list of matching identifiers.
     */
    public List<PrsProviders> searchByIdentifer(String identifierTypeCode, String providerChid, MatchHistory matchHistory) {
        StringBuilder builder = new StringBuilder();
        builder.append("select distinct p from PrsProviders p ")
                .append("join p.grsIdentifiersList i ");
        
        if(matchHistory.equals(MatchHistory.YES)) {
            builder.append("left join i.endReasonCode identifierEndReasonCode ");
        }
                
        builder.append("where i.identifierTypeCode.ctlNameCode = :identifierTypeCode ")
                .append("and i.providerChid = :providerChid ");
        
        if (matchHistory.equals(MatchHistory.NO)) {
            builder.append("and i.endReasonCode is null");
        }else{
            builder.append("and (identifierEndReasonCode is null or identifierEndReasonCode.ctlNameCode != :corrected) "); //PLRP3-38. Search with history must not include CORRECTED records
        }
        
        if(matchHistory.equals(MatchHistory.YES)){
            // Order by "i.endReasonCode.ctlNameCode desc" favours NULL end reason codes, so active identifiers are sorted higher.
            builder.append("order by identifierEndReasonCode.ctlNameCode desc");
        }
        
        TypedQuery<PrsProviders> query = em.createQuery(
                builder.toString(), PrsProviders.class);
        query.setParameter("identifierTypeCode", identifierTypeCode);
        query.setParameter("providerChid", providerChid);
        if(matchHistory.equals(MatchHistory.YES)){
            query.setParameter("corrected", CodeTableCodes.GrsCtEndReasonTypes.CORRECT.getValue());
        }

        return query.getResultList();
    }

    /**
     * Find the provider that matches the provided registry identifier.
     *
     * @param providerChid the registry identifier
     * @param matchHistory match on historical records
     * @return a matching identifier or <code>null</code>
     */
    public List<PrsProviders> searchByRegistryIdentifier(String providerChid, MatchHistory matchHistory) {

        StringBuilder builder = new StringBuilder();
        builder.append("select distinct p from PrsProviders p ")
                .append("join p.grsRegistryIdentifiersList i ");
        
        if(matchHistory.equals(MatchHistory.YES)) {
            builder.append("left join i.endReasonCode regIdentEndReasonCode ");
        }
        
        builder.append("where i.providerChid = :providerChid ");
        
        if (matchHistory.equals(MatchHistory.NO)) {
            builder.append("and i.endReasonCode is null ");
        }else{
            builder.append("and (regIdentEndReasonCode is null or regIdentEndReasonCode.ctlNameCode != :corrected) "); //PLRP3-38. Search with history must not include CORRECTED records
        }

        if(matchHistory.equals(MatchHistory.YES)){
            // Order by "i.endReasonCode.ctlNameCode desc" favours NULL end reason codes, so active identifiers are sorted higher.
            builder.append("order by regIdentEndReasonCode.ctlNameCode desc");
        }
        
        TypedQuery<PrsProviders> query = em.createQuery(builder.toString(), PrsProviders.class);
        query.setParameter("providerChid", providerChid);
        if(matchHistory.equals(MatchHistory.YES)){
            query.setParameter("corrected", CodeTableCodes.GrsCtEndReasonTypes.CORRECT.getValue());
        }
        return query.getResultList();
    }

    /**
     * Find the organizational providers that match the provided criteria.
     *
     * @param providerRoleType the type of provider. Corresponds to
     * PRS_PROVIDERS.HPT_CODE
     * @param orgName the name of the organization, or partial name with
     * trailing wildcard
     * @param orgLongName the long name of the organization, or partial name with
     * trailing wildcard
     * @param addressCity the city of the organization, or partial name with
     * trailing wildcard
     * @param matchHistory match on historical records
     * @return a list of providers that match the criteria
     */
    public List<PrsProviders> searchOrgByCriteria(Long providerRoleType, String orgName, String orgLongName, String addressCity, MatchHistory matchHistory) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder
                .append("select distinct p from PrsProviders p ")
                .append("left join p.grsOrgNamesList org ");
        
        if (StringUtils.isNotBlank(addressCity)) {
            stringBuilder.append("left join p.grsAddressesList addressList ");
        }
        
        if(matchHistory.equals(MatchHistory.YES)){
            //The join should not be added when MatchHistory is NO because
            //we want endReasonCode == null. 
            //If we leave the join then JPA will alter it to an inner one which
            //will have for consequence to not return any records.
            stringBuilder.append("left join org.endReasonCode endReason ");
        }
        
        stringBuilder.append("where p.hptCode.ctlId = :providerRoleType ")
                .append("and p.partyTypeCode.ctlNameCode = :partyType ")
                .append("and lower(org.orgnztnNameTxt) LIKE lower(:orgName) ");

        if (StringUtils.isNotBlank(addressCity)) {
            stringBuilder.append("and lower(addressList.cityTxt) = lower(:city) ");
        }

        if (matchHistory.equals(MatchHistory.NO)) {
            stringBuilder.append("and org.endReasonCode is null ");
        }else{
            stringBuilder.append("and (endReason is null or endReason.ctlNameCode != :corrected) "); //PLRP3-38. Search with history must not include CORRECTED records
        }

        if (StringUtils.isNoneBlank(orgLongName)) {
            stringBuilder.append("and lower(org.orgnztnLongNameTxt) LIKE lower(:orgLongName) ");
        }

        
        if(matchHistory.equals(MatchHistory.YES)){
            // Order by "org.endReasonCode.ctlNameCode desc" favours NULL end reason codes, so active names are sorted higher.
            stringBuilder.append("order by endReason.ctlNameCode desc, org.orgnztnNameTxt asc, org.orgnztnLongNameTxt asc");
        }else{
            stringBuilder.append("order by org.orgnztnNameTxt asc, org.orgnztnLongNameTxt asc");
        }

        TypedQuery<PrsProviders> createQuery = em.createQuery(
                stringBuilder.toString(), PrsProviders.class);

        createQuery.setParameter("providerRoleType", providerRoleType);
        createQuery.setParameter("partyType", CodeTableCodes.GrsCtPartyType.ORG.getValue());
        if (StringUtils.isNotBlank(orgName)) {
            orgName = convertWildcardOrg(orgName);
            createQuery.setParameter("orgName", orgName);
        }
        if (StringUtils.isNotBlank(orgLongName)) {
            orgLongName = convertWildcardOrg(orgLongName);
            createQuery.setParameter("orgLongName", orgLongName);
        }
        if (StringUtils.isNotBlank(addressCity)) {
            createQuery.setParameter("city", addressCity);
        }
        if(matchHistory.equals(MatchHistory.YES)){
            createQuery.setParameter("corrected", CodeTableCodes.GrsCtEndReasonTypes.CORRECT.getValue());
        }

        return createQuery.setMaxResults(getMaxSearchResultsForOrgsToReturn()).getResultList();
    }

    /**
     * Find the individual providers that match the provided criteria.
     *
     * @param providerRoleTypeId the provider role type, or HPT code id
     * @param firstName the first name
     * @param lastName the last name
     * @param gender the gender
     * @param city the city
     * @param expertiseList
     * @param languageList
     * @param maxResults the maximum result set size to return
     * @param matchHistory match on historical records
     * @param licenseStatusCd the license Status code
     * @param licenseStatusReasonCd the license Status Reason code
     * @return a list of search results that match the criteria
     */
    public List<PrsProviders> findIndividualByCriteria(
            Long providerRoleTypeId,
            String firstName,
            String lastName,
            String gender,
            String city,
            Long licenseStatusCd,
            String licenseStatusReasonCd,
            List<Long> expertiseList,
            List<Long> languageList,
            int maxResults,
            MatchHistory matchHistory) {

        TypedQuery<PrsProviders> query = buildFindIndividualQuery(providerRoleTypeId, firstName, lastName, gender, city, licenseStatusCd, licenseStatusReasonCd, expertiseList, languageList, matchHistory);
        query.setMaxResults(maxResults);

        /*
         The query's ORDER BY clause includes non-PrsProviders fields, and so
         "SELECT DISTINCT" does not return distinct Providers, it returns distinct
         combinations of Providers and everything else in the ORDER BY clause.
         Put the Providers into a set to filter out duplicates, and use a
         LinkedHashSet to maintain the order. The query orders active names
         first, so non-active names will be filtered-out.
         */
        ArrayList<PrsProviders> providers = new ArrayList<>(new LinkedHashSet<>(query.getResultList()));
        removeProvidersNotHavingAllExpertisesAndLanguages(providers, expertiseList, languageList, matchHistory);

        return providers;
    }

    /**
     * Convenience method to construct the JPQL query for searching an
     * individual provider by criteria.
     *
     * @param firstName the first name
     * @param lastName the last name
     * @param gender the gender
     * @param city the city
     * @param licenseStatusCd the license Status code
     * @param licenseStatusReasonCd the license Status Reason code
     * @return the dynamically constructed query string
     */
    private TypedQuery<PrsProviders> buildFindIndividualQuery(
            Long providerRoleTypeId,
            String firstName,
            String lastName,
            String gender,
            String city,
            Long licenseStatusCd, 
            String licenseStatusReasonCd,
            List<Long> expertiseList,
            List<Long> languageList,
            MatchHistory matchHistory) {

        StringBuilder queryString = new StringBuilder();
        queryString.append("select distinct provider from PrsProviders provider ")
                .append("left join provider.grsPersonNamesList name ")
                .append("left join provider.grsAddressesList address ");

        if (StringUtils.isNotBlank(gender)) {
            queryString.append("left join provider.prsDemographicDetailsList demo ");
        }

        queryString.append("left join provider.prsStatusesList licenseStatus "); //left join licenseStatus.statusTypeCode licenseStatusCode 
       
        if (StringUtils.isNotBlank(licenseStatusReasonCd)) {
            queryString.append("left join provider.prsStatusesList licenseStatusReason "); //left join licenseStatusReason.statusReasonCode licenseStatusReasonCode 
        }
        
        if (matchHistory.equals(MatchHistory.YES)) {
            queryString.append("left join name.endReasonCode nameEndReason ");
            queryString.append("left join address.endReasonCode addressEndReason ");
            queryString.append("left join licenseStatus.endReasonCode licenseStatusEndReason ");
        }

        List<Long> mergedExpertiseList = new ArrayList<>();
        if (CollectionUtils.isNotEmpty(expertiseList)) {
            mergedExpertiseList.addAll(expertiseList);
        }
        if (CollectionUtils.isNotEmpty(languageList)) {
            mergedExpertiseList.addAll(languageList);
        }
        if (CollectionUtils.isNotEmpty(mergedExpertiseList)) {
            queryString.append("left join provider.prsProviderExpertisesList expertise ");
            if(matchHistory.equals(MatchHistory.YES)){
                queryString.append("left join expertise.endReasonCode expertiseEndReason ");
            }
        }

        queryString.append("where provider.partyTypeCode.ctlNameCode = :partyType ");
        if (providerRoleTypeId != null && providerRoleTypeId != Long.parseLong(Consts.SELECT_ONE_VALUE)) {
            queryString.append("and provider.hptCode.ctlId = :providerRoleTypeId ");
        }

        if (StringUtils.isNotBlank(firstName)) {
            queryString.append("and upper(name.prsnFirstGivenNameTxt) ");
            if (StringUtils.endsWith(firstName, "*")) {
                queryString.append("like ");
            } else {
                queryString.append("=");
            }
            queryString.append("upper(:firstName) ");
        }

        if (StringUtils.isNotBlank(lastName)) {
            queryString.append("and upper(name.prsnSurnameTxt) ");
            if (StringUtils.endsWith(lastName, "*")) {
                queryString.append("like ");
            } else {
                queryString.append(" = ");
            }
            queryString.append("upper(:lastName) ");
        }
        if (StringUtils.isNotBlank(gender)) {
            queryString.append("and demo.genderCode.ctlId = :gender ");
        }

        if (StringUtils.isNotBlank(city)) {
            queryString.append("and upper(address.cityTxt) = upper(:cityName) ");
        }
        
        if (licenseStatusCd != null && licenseStatusCd != Long.parseLong(Consts.SELECT_ONE_VALUE)) {
            queryString.append("and licenseStatus.statusTypeCode.ctlId = :licenseStatusCd ");
        }
        
        if (StringUtils.isNotBlank(licenseStatusReasonCd)) {
            queryString.append("and licenseStatusReason.statusReasonCode.ctlId = :licenseStatusReasonCd ");
        }

        if (CollectionUtils.isNotEmpty(mergedExpertiseList)) {
            queryString.append("and expertise.providerExpertiseTypeCode.ctlId in :expertise ");
        }
        
        if (matchHistory.equals(MatchHistory.NO)) {
            queryString.append("and name.endReasonCode is null ");
            queryString.append("and address.endReasonCode is null ");
            queryString.append("and licenseStatus.endReasonCode is null ");
        }else{
            queryString.append("and (nameEndReason is null or nameEndReason.ctlNameCode != :corrected) "); //PLRP3-38. Search with history must not include CORRECTED records
            queryString.append("and (addressEndReason is null or addressEndReason.ctlNameCode != :corrected) "); 
            queryString.append("and (licenseStatusEndReason is null or licenseStatusEndReason.ctlNameCode != :corrected) "); 
        }

        if (matchHistory.equals(MatchHistory.NO) && CollectionUtils.isNotEmpty(mergedExpertiseList)) {
            queryString.append("and expertise.endReasonCode is null ");
        }else if (CollectionUtils.isNotEmpty(mergedExpertiseList)){
            queryString.append("and (expertiseEndReason is null or expertiseEndReason.ctlNameCode != :corrected) "); //PLRP3-38. Search with history must not include CORRECTED records
        }

        // Order by "nameEndReason.ctlNameCode desc" favours NULL end reason codes, so active names are sorted higher.
        queryString.append("order by");
        if (matchHistory.equals(MatchHistory.YES)) {
            queryString.append(" nameEndReason.ctlNameCode desc,");
        }
        queryString.append(" name.prsnSurnameTxt asc, name.prsnFirstGivenNameTxt asc");
        TypedQuery<PrsProviders> query = assignFindIndividualQueryParameters(
                queryString.toString(), providerRoleTypeId, firstName, lastName, 
                gender, city, licenseStatusCd, licenseStatusReasonCd, 
                mergedExpertiseList, matchHistory);

        return query;
    }

    /**
     * Convenience method to construct the JPA Query object for searching an
     * individual provider by criteria.
     *
     * @param queryString the JPQL query string
     * @param providerRoleTypeId the provider role type, or HPT code id
     * @param firstName the first name
     * @param lastName the last name
     * @param gender the gender
     * @param city the city
     * @param licenseStatusCd the license Status code
     * @param licenseStatusReasonCd the license Status Reason code
     * @param mergedExpertiseList the mergedExpertiseList
     * @param matchHistory the matchHistory
     * @return the dynamically constructed query string
     */
    private TypedQuery<PrsProviders> assignFindIndividualQueryParameters(
            String queryString,
            Long providerRoleTypeId,
            String firstName,
            String lastName,
            String gender,
            String city,
            Long licenseStatusCd, 
            String licenseStatusReasonCd,
            List<Long> mergedExpertiseList,
            MatchHistory matchHistory) {

        TypedQuery<PrsProviders> query = em.createQuery(queryString, PrsProviders.class);
        query.setParameter("partyType", CodeTableCodes.GrsCtPartyType.IND.getValue());
        if (providerRoleTypeId != null && providerRoleTypeId != Long.parseLong(Consts.SELECT_ONE_VALUE)) {
            query.setParameter("providerRoleTypeId", providerRoleTypeId);
        }

        if (StringUtils.isNotBlank(firstName)) {
            firstName = convertWildcard(firstName);
            query.setParameter("firstName", firstName);
        }
        if (StringUtils.isNotBlank(lastName)) {
            lastName = convertWildcard(lastName);
            query.setParameter("lastName", lastName);
        }
        if (StringUtils.isNotBlank(gender)) {
            query.setParameter("gender", Long.parseLong(gender));
        }

        if (StringUtils.isNotBlank(city)) {
            query.setParameter("cityName", city);
        }
        
        if (licenseStatusCd != null && licenseStatusCd != Long.parseLong(Consts.SELECT_ONE_VALUE)) {
            query.setParameter("licenseStatusCd", licenseStatusCd);
        }    
        if (StringUtils.isNotBlank(licenseStatusReasonCd)) {
            query.setParameter("licenseStatusReasonCd", Long.parseLong(licenseStatusReasonCd));
        }
        
        if (CollectionUtils.isNotEmpty(mergedExpertiseList)) {
            List<Long> mergedExpertiseListLong = new ArrayList<>();
            for (int i = 0; i < mergedExpertiseList.size(); i++) {
                mergedExpertiseListLong.add(mergedExpertiseList.get(i));
            }
            query.setParameter("expertise", mergedExpertiseListLong);
        }
        
        if(matchHistory.equals(MatchHistory.YES)){
            query.setParameter("corrected", CodeTableCodes.GrsCtEndReasonTypes.CORRECT.getValue());
        }
        
        return query;
    }

    /**
     * Remove Providers from the given list that do not have ALL of the given
     * Expertises.
     *
     * The SQL query built by buildFindIndividualQuery returns all Providers
     * that have ANY of the given Expertises. I could have modified the SQL
     * query, but I found it much easier to do in Java.
     */
    private static void removeProvidersNotHavingAllExpertisesAndLanguages(
            List<PrsProviders> providers,
            List<Long> expertiseList,
            List<Long> languageList,
            MatchHistory matchHistory) {

        @SuppressWarnings("unchecked")
        Collection<String> union = CollectionUtils.union(emptyIfNull(expertiseList), emptyIfNull(languageList));
        if (union.isEmpty()) {
            return;
        }
        for (Iterator<PrsProviders> it = providers.iterator(); it.hasNext();) {
            PrsProviders provider = it.next();
            Set<Long> expIds = new HashSet<>();
            for (PrsProviderExpertises exp : provider.getPrsProviderExpertisesList()) {
                if (exp.getEndReasonCode() == null || matchHistory.equals(MatchHistory.YES)) {
                    expIds.add(exp.getProviderExpertiseTypeCode().getCtlId());
                }
            }
            if (!CollectionUtils.isSubCollection(union, expIds)) {
                it.remove();
            }
        }
    }

    private String convertWildcard(String firstName) {
        if (StringUtils.endsWith(firstName, "*")) {
            firstName = firstName.replaceFirst("\\*$", "%");
        }
        return firstName;
    }
    
    /**
     * Converts wildcards from org name/longname for database search query.
     *
     * @param orgName the organization name/longname input from the screen
     * @return the converted org name search query string
     */
    private String convertWildcardOrg(String orgName) {
        if (StringUtils.contains(orgName, "*")) {
            orgName = orgName.replace('*', '%');
        }
        return orgName;
    }

    /**
     * Query for survivor records 1.1 Using Provider Role Type Code 1.2 Using
     * the registry identifiers If survivor records are found, return the
     * survivor records with a warning.
     *
     * @param providerDetails
     * @return
     */
    public List<PrsProviders> findSurvivorRecords(ProviderDto providerDetails) {
        return em.createNamedQuery("PrsProviders.findSurvivor", PrsProviders.class)
                .setParameter("ceased", codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CEASE))
                .setParameter("hpt", providerDetails.getProviderRoleTypeCode())
                .setParameter("pauthId", providerDetails.getPauthId()).getResultList();
    }

    /**
     * Return an IMMUTABLE empty collection if the given collection is null.
     */
    private static Collection<?> emptyIfNull(Collection<?> c) {
        if (c == null) {
            return Collections.emptyList();
        }
        return c;
    }
    
    /**
     * Retrieve the max search result from database and then increase it after.
     * 
     * @return maxSearchResultForOrgs the increased search result number for organizations
     */
    private int getMaxSearchResultsForOrgsToReturn() {
        int maxSearchResultForOrgs = configurationDao.getMaxSearchResults() + AFTER;
        return maxSearchResultForOrgs;
    }

}
