package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.converter.WorkLocationDetailsDtoConverter;
import ca.bc.gov.health.plr.dto.converter.WorkLocationDtoConverter;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDetailsDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocationDetails;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.ejb.entity.util.DatabaseConstants;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.provider.AccessRestrictionService;
import ca.bc.gov.health.plr.service.EntityValidatorService;
import ca.bc.gov.health.plr.service.validators.ConfidentialityValidator;
import ca.bc.gov.health.plr.service.validators.EntityChangeDetector;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.service.validators.UserChidGenerator;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import org.apache.commons.lang3.Validate;

/**
 *
 * @author ian.scott
 */
@Stateless
public class MaintainWorkLocationService {

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;

    @EJB
    private JournalService<PrsWorkLocationDetails> journalService;

    @EJB
    private WorkLocationDtoConverter workLocationDtoConverter;

    @EJB
    private WorkLocationDetailsDtoConverter workLocationDetailsDtoConverter;

    @EJB
    private EntityValidatorService<PrsWorkLocationDetails> validatorService;

    @EJB
    private EntityValidatorService<PrsWorkLocations> workLocationsValidator;

    @EJB
    private ConfidentialityValidator<PrsWorkLocationDetails> confidentialityValidator;

    @EJB
    private UserChidGenerator chidGenerator;

    @EJB
    private ProviderDtoConverter providerDtoConverter;

    @EJB
    private AccessRestrictionService accessRestrictionService;

    @EJB
    private EntityChangeDetector<WorkLocationDetailsDto, PrsWorkLocationDetails> entityChangeDetector;

    /**
     * Saves a new work location and work location detail.
     *
     * @param workLocationDto
     * @param workLocationDetailsDto
     * @return
     * @throws DuplicateRecordException
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     */
    public WorkLocationDto saveNewWorkLocationAndDetail(WorkLocationDto workLocationDto, WorkLocationDetailsDto workLocationDetailsDto) throws DuplicateRecordException, EntityValidationException {
        Validate.isTrue(workLocationDto.getWorkLocationDetails().isEmpty());

        workLocationDto.setActive(true);
        if (workLocationDto.getIdentifier() == null) {
            workLocationDto.setIdentifier(findNextUniqueChid(workLocationDto.getPauthId()));
        }

        PrsWorkLocations workLocation = workLocationDtoConverter.toEntity(workLocationDto);
        workLocationsValidator.validate(workLocation);
        workLocation.setUserChid(chidGenerator.find());
        workLocationDto.setDataOwnerCode(workLocation.getDataOwnerCode().getCtlNameCode());
        checkForDuplicate(workLocationDto);

        // Work Location is not a "journable entity", so we cannot use JournalService.
        // It does not have END_REASON_CODE or GENERATION_NUM.
        em.persist(workLocation);

        workLocationDetailsDto.setActive(true);
        PrsWorkLocationDetails workLocationDetails = workLocationDetailsDtoConverter.toEntity(workLocationDetailsDto);
        workLocationDetails.setWlWlId(workLocation);
        validate(workLocationDetails);
        workLocationDetails = journalService.journal(workLocationDetails);
        workLocation.getPrsWorkLocationDetailsList().add(workLocationDetails);

        em.refresh(workLocation);
        return providerDtoConverter.buildWorkLocation(workLocation);
    }

    public WorkLocationDetailsDto updateWorkLocationDetail(WorkLocationDetailsDto wlDetails) throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        PrsWorkLocationDetails newRecord = workLocationDetailsDtoConverter.toEntity(wlDetails);
        entityChangeDetector.checkForChanges(wlDetails, newRecord);
        if (wlDetails.isNoChangeOnUpdate()) {
            return wlDetails;
        }
        validate(newRecord);

        newRecord = journalService.journal(newRecord);

        return providerDtoConverter.buildWorkLocationDetail(newRecord);

    }

    public WorkLocationDetailsDto updateWorkLocationDetail(ProviderDto providerDto, WorkLocationDetailsDto wlDetails) throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        PrsWorkLocationDetails newRecord = workLocationDetailsDtoConverter.toEntity(wlDetails);
        entityChangeDetector.checkForChanges(wlDetails, newRecord);
        if (wlDetails.isNoChangeOnUpdate()) {
            return wlDetails;
        }
        validate(newRecord);

        newRecord = journalService.journal(newRecord);

        return providerDtoConverter.buildWorkLocationDetail(newRecord);

    }

    private void validate(PrsWorkLocationDetails newRecord) throws DuplicateRecordException, EntityValidationException {
        validatorService.validate(newRecord, confidentialityValidator);
    }

    /**
     * Finds the next unique Work Location CHID for the specified provider.
     *
     * @param pauthId specifies a valid Provider.
     * @return the next unique Work Location CHID for the specified provider.
     */
    private long findNextUniqueChid(Long pauthId) {
        Long nextUniqueChid = DatabaseConstants.DEFAULT_GENERATION_NUM;

        String queryString = "select max(t.workLocationChid) "
                + "from PrsWorkLocations t where t.pauthPauthId.pauthId = :pauthId";

        TypedQuery<Long> query = em.createQuery(queryString, Long.class);
        query.setParameter("pauthId", pauthId);

        Long currentMaxChid = query.getSingleResult();
        if (currentMaxChid != null) {
            nextUniqueChid = currentMaxChid + 1;
        }

        return nextUniqueChid;
    }

    /**
     * Builds a DTO from a record in the database based on primary key (ID)
     *
     * @param toRefresh a DTO with an ID
     * @return a DTO from a record in the database based on primary key (ID)
     */
    public WorkLocationDetailsDto refresh(WorkLocationDetailsDto toRefresh) {
        PrsWorkLocationDetails found = em.find(PrsWorkLocationDetails.class, toRefresh.getId());
        WorkLocationDetailsDto toSendBack = providerDtoConverter.buildWorkLocationDetail(found);
        return toSendBack;
    }

    public List<WorkLocationDto> getWorkLocations(ProviderDto providerDto) {
        PrsProviders provider = em.find(PrsProviders.class, providerDto.getPauthId());
        List<WorkLocationDto> workLocations = providerDtoConverter.buildWorkLocations(provider.getPrsWorkLocationsList());
        providerDto.setWorkLocationList(workLocations);
        accessRestrictionService.applyWorkLocationReadRestrictions(providerDto, provider.getHptCode());
        providerDtoConverter.buildPrimaryWorkLocation(workLocations);
        return workLocations;
    }

    public WorkLocationDto getWorkLocation(Long wlId) {
        PrsWorkLocations workLocation = em.find(PrsWorkLocations.class, wlId);
        return providerDtoConverter.buildWorkLocation(workLocation);
    }

    public List<WorkLocationDetailsDto> getWorkLocationsDetails(Long id) {
        PrsWorkLocations workLocation = em.find(PrsWorkLocations.class, id);
        return providerDtoConverter.buildWorkLocationDetails(workLocation.getPrsWorkLocationDetailsList());
    }

    public WorkLocationDetailsDto getFirstNonEndedWorkLocationsDetails(Long id) {
        List<WorkLocationDetailsDto> wldDtoList = this.getWorkLocationsDetails(id);
        for (WorkLocationDetailsDto wldDto : wldDtoList) {
            if (wldDto.getEndReasonCodeId() == null) {
                return wldDto;
            }
        }
        return null;
    }

    /**
     * Throws an exception if adding this work location would result in a
     * duplicate.
     *
     * @param workLocationDto the work location to be added.
     * @throws DuplicateRecordException
     */
    private void checkForDuplicate(WorkLocationDto workLocationDto) throws DuplicateRecordException {
        TypedQuery<PrsWorkLocations> query = em.createQuery("select w from PrsWorkLocations w "
                + "where w.pauthPauthId.pauthId = :pauthId "
                + "and w.workLocationChid = :chid ", PrsWorkLocations.class);
        query.setParameter("pauthId", workLocationDto.getPauthId());
        query.setParameter("chid", workLocationDto.getIdentifier());
        List<PrsWorkLocations> locations = query.getResultList();
        if (!locations.isEmpty()) {
            String messageResource = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_DUPLICATE_DATA_BLOCK);
            throw new DuplicateRecordException(messageResource + "work location id");
        }

    }

}
