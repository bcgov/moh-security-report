package ca.bc.gov.health.plr.service.audit;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.MessageDataBlockDto;
import ca.bc.gov.health.plr.dto.OwnableDto;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.AbstractProviderDetail;
import ca.bc.gov.health.plr.dto.provider.ProviderDetailsUtil;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDetailsDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.dto.reguser.DistributionDto;
import ca.bc.gov.health.plr.ejb.entity.GrsChangedRecords;
import ca.bc.gov.health.plr.ejb.entity.GrsCtDataObjects;
import ca.bc.gov.health.plr.ejb.entity.GrsCtTransactionTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsTransactions;
import ca.bc.gov.health.plr.ejb.entity.MessageDataBlock;
import ca.bc.gov.health.plr.ejb.entity.PrsCtDataOwnerCodes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProvState;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.events.ChangeEvent;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.service.GrsChangedRecordsFacade;
import ca.bc.gov.health.plr.service.JNDIResourceLoader;
import ca.bc.gov.health.plr.service.PLRConfigurationResourceLoader;
import ca.bc.gov.health.plr.service.distribution.Serializer;
import ca.bc.gov.health.plr.service.provider.AddressSupportService;
import ca.bc.gov.health.plr.service.provider.ProviderHelperService;
import ca.bc.gov.health.plr.service.remote.FindMessageDataBlockService;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.MetaDataUtil;
import ca.bc.gov.health.plr.util.ReflectionUtils;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.PostConstruct;
import javax.ejb.AsyncResult;
import javax.ejb.Asynchronous;
import javax.ejb.Stateless;
import javax.enterprise.event.Observes;
import javax.enterprise.event.TransactionPhase;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

/**
 * Change event consumer. This class sudits any provider changes. It tries to
 * continue even if there were issues so that something is logged, rather than
 * nothing.
 *
 * @author adebiyi.kuseju
 */
@Stateless
public class ProviderChangeEventConsumer {

    private static final Logger logger = Logger.getLogger(ProviderChangeEventConsumer.class.getName());

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;

    private PrsCtProvState defaultProvince;

    // when the user chid isn't found use this 
    public static final String UNKNOWN_USER_CHID = "Unknown";

    @Inject
    CodesDao codesDao;

    @Inject
    private AddressSupportService addressSupportService;

    @Inject
    private GrsChangedRecordsFacade grsChangedrecordsFacade;

    @Inject
    private JNDIResourceLoader prod;

    @Inject
    private MetaDataUtil metaDataUtil;

    @Inject
    private ProviderDtoConverter providerDtoConverter;

    @Inject
    FindMessageDataBlockService findMessageDataBlockService;

    @Inject
    Serializer<AbstractProviderDetail> serializerAbsProviderDetail;

    @Inject
    private ProviderHelperService providerHelperService;
    
    @Inject
    private PLRConfigurationResourceLoader plrConfigLoader;

    @PostConstruct
    private void init() {
        defaultProvince = addressSupportService.getDefaultProvince(addressSupportService.getDefaultCountry().getCtlId());
    }

    /**
     * Processes change event
     *
     * @param changeEvent
     */
    @Asynchronous
    public Future<GrsChangedRecords> processEvent(@Observes(during = TransactionPhase.AFTER_SUCCESS) ChangeEvent changeEvent) {

        GrsChangedRecords changedRec = null;

        try {
            Object changedItem = changeEvent.getChangedItem();

            // The change event consumer is only meant for changes to a provider.
            // We do not want to make create GrsChangedRecords for changes to a
            // distribution profile as it is not being tracked in the existing 
            // PRS application
            if (changedItem instanceof DistributionDto) {
                return null;
            }

            // Is auditing on?
            // changes to load auditing enable flag from database 
            if (!Boolean.parseBoolean(plrConfigLoader.getValue(Consts.ENABLE_AUDITING))) {
                return null;
            }

            changedRec = new GrsChangedRecords();

            // Break down the changedItem into dtos that we can audit as
            // this should simplfy all the code below.
            //
            // And changedItem is what is returned from the interceptor so
            // it is what we want to work with.
            List<AbstractProviderDetail> dtoToAuditList = new ArrayList<>();
            breakDownChangedItem(changedItem, dtoToAuditList);

            PrsProviders prov = changedItem instanceof PrsProviders ? (PrsProviders) changedItem : providerHelperService.findProvider(dtoToAuditList);

            if (changedItem instanceof PrsProviders) {
                changedRec.setCreateUpdateCode(Consts.CREATE_PROVIDER);
            } else {
                changedRec.setCreateUpdateCode(Consts.UPDATE_PROVIDER);
            }

            if (prov != null) {
                changedRec.setPauthChangedPauthId(prov.getPauthId());
                changedRec.setSourceProRoleTypeCode(prov.getHptCode());
            } else {
                // null provider, we are hooped, we can't proceed
                // -- must be bad data --
                logger.log(Level.WARNING, "Couldn't audit the change.  No provider found in changed data.");
                return null;
            }

            String userChid = findUserChid(dtoToAuditList);
            changedRec.setRegistryUserOrgChid(changeEvent.getRequester().getPartyPartyId().getRegistryUserOrgChid());

            // if the user chid was not found us Unknown ... so the auditing can continue
            changedRec.setUserChid(userChid == null ? UNKNOWN_USER_CHID : userChid);

            changedRec.setProvinceCode(defaultProvince);

            changedRec.setStatusCode("N");
            changedRec.setChangeTopicCode(Consts.PROVIDER_CHG_TOPIC);
            changedRec.setDateChangedDts(new Date());

            changedRec.setGrsTransactionsList(new ArrayList<GrsTransactions>());

            for (AbstractProviderDetail abs : dtoToAuditList) {
                GrsTransactions trans = getTransaction(abs, changedRec.getCreateUpdateCode(), prov.getHptCode());
                if (trans != null) {
                    trans.setCr1Cr1Id(changedRec);
                    if (trans.getRdeChangedData() != null || trans.getRdePriorData() != null) {
                        changedRec.getGrsTransactionsList().add(trans);
                    }
                }
            }

            // if transaction list is empty, skip creation of changed record
            if (changedRec.getGrsTransactionsList() != null 
                    && !changedRec.getGrsTransactionsList().isEmpty()) {
                grsChangedrecordsFacade.create(changedRec);
            }

        } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
            logger.log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, null, ex);
        }

        return new AsyncResult<>(changedRec);
    }

    /**
     * This is a recursive method that breaks down whatever comes in through the
     * change event and leaves you with only the DTOs.
     *
     * @param changedItem The change event item
     * @param dtoToAuditList List of dtos
     * @throws IllegalArgumentException
     * @throws IllegalAccessException
     */
    private void breakDownChangedItem(Object changedItem, List<AbstractProviderDetail> dtoToAuditList) throws IllegalArgumentException, IllegalAccessException {

        if (changedItem instanceof PrsProviders) {
            // if this is a prsprovider, grab all the lists and break them down

            Object realDto = providerDtoConverter.toProviderDetails((PrsProviders) changedItem, false);

            Field[] fields = ProviderDto.class.getDeclaredFields();

            for (Field f : fields) {
                boolean isAccessible = f.isAccessible();
                try {
                    f.setAccessible(true);
                    Object item = f.get(realDto);
                    if (item != null && List.class.isAssignableFrom(item.getClass())) {
                        breakDownChangedItem(item, dtoToAuditList);
                    }
                } finally {
                    f.setAccessible(isAccessible);
                }
            }
        } else if (changedItem instanceof WorkLocationDetailsDto) {

            // work location details are tricky, get the work location then add the owner code
            PrsWorkLocations workLocation = em.find(PrsWorkLocations.class, ReflectionUtils.methodInvoke(changedItem, "getWlWlId"));
            ((OwnableDto) changedItem).setDataOwnerCode(workLocation.getDataOwnerCode().getCtlNameCode());
            if (!(((WorkLocationDetailsDto) changedItem).isNoChangeOnUpdate())) {
                dtoToAuditList.add((AbstractProviderDetail) changedItem);
            }

        } else if (changedItem instanceof AbstractProviderDetail) {

            // you are down to the abstractproviderdetails, good enough, add to the list
            if (!((AbstractProviderDetail) changedItem).isNoChangeOnUpdate()) {
                dtoToAuditList.add((AbstractProviderDetail) changedItem);
            }

        } else if (changedItem instanceof List) {

            // if it is a list, send each item back ...
            for (Object obj : (Iterable) changedItem) {
                // recursively call this until all Lists are gone
                breakDownChangedItem(obj, dtoToAuditList);
            }

        } else if (changedItem instanceof WorkLocationDto) {
            // if it is a work location, tricky ... add owner code and breakdown each
            // work location list
            WorkLocationDto wlDto = (WorkLocationDto) changedItem;
            String ownerCode = wlDto.getDataOwnerCode();
            breakDownWorkLocationChildren(wlDto.getWorkLocationDetails(), ownerCode, dtoToAuditList);
            breakDownWorkLocationChildren(wlDto.getTelecommunications(), ownerCode, dtoToAuditList);
            breakDownWorkLocationChildren(wlDto.getAddresses(), ownerCode, dtoToAuditList);
            breakDownWorkLocationChildren(wlDto.getElectronicAddresses(), ownerCode, dtoToAuditList);
            breakDownWorkLocationChildren(wlDto.getInformationRoutes(), ownerCode, dtoToAuditList);
        }
    }

    /**
     * Helper method for work locations.
     *
     * @param wlChilrenList A list of work location children
     * @param ownerCode The owner code
     * @param dtoToAuditList The list of dtos to be audited
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     */
    private void breakDownWorkLocationChildren(List<? extends OwnableDto> wlChilrenList, String ownerCode, List<AbstractProviderDetail> dtoToAuditList) throws IllegalAccessException, IllegalArgumentException {
        for (Object obj : wlChilrenList) {
            if (((OwnableDto) obj).getDataOwnerCode() == null && ownerCode != null) {
                ((OwnableDto) obj).setDataOwnerCode(ownerCode);
            }
        }
        breakDownChangedItem(wlChilrenList, dtoToAuditList);
    }

    /**
     * Returns a transaction with lots of juicy details
     *
     * @param dto The record affected by the transactions
     * @param createOrUpdate Is creating a whole new provider or just updates
     * @param providerRoleType Provider tole type
     * @return The transaction (can be null)
     * @throws NoSuchMethodException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     */
    private GrsTransactions getTransaction(AbstractProviderDetail dto, String createOrUpdate, PrsCtProviderRoleTypes providerRoleType) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        GrsTransactions trans = new GrsTransactions();

        // we must have a gen num, otherwise this record isn't complete
        if (dto.getGenerationNum() == null) {
            return null;
        }

        // return if pauth id or work location id is null, which means there is no parent ...
        // an empty object which doesn't need auditing
        if (dto.getPauthId() == null && ReflectionUtils.hasMethod(dto, "getWlWlId") != ReflectionUtils.MethodType.none && ReflectionUtils.methodInvoke(dto, "getWlWlId") == null) {
            return null;
        }

        try {
            // force the transaction type to created if necessary
            GrsCtTransactionTypes tType = metaDataUtil.getTransactionType(dto, isNew(dto));
            if (tType != null) {
                trans.setTtCode(tType);
            } else {
                // no transaction type, log and continue
                Logger.getLogger(ProviderChangeEventConsumer.class.getName()).log(Level.WARNING, "The Transaction Type was not found, audit is proceeding anyways!");
            }
        } catch (NoSuchMethodException | IllegalArgumentException | IllegalAccessException | InvocationTargetException ex) {
            // no transaction type, log and continue
            Logger.getLogger(ProviderChangeEventConsumer.class.getName()).log(Level.WARNING, null, ex);
        }

        // data owner, try to find it.
        String ownerCode = (String) ReflectionUtils.methodInvoke(dto, "getDataOwnerCode");

        if (ownerCode != null) {
            PrsCtDataOwnerCodes ownerCodeObj = codesDao.lookup(PrsCtDataOwnerCodes.class, ownerCode);
            trans.setDataOwnerCode(ownerCodeObj);
            dto.setDataOwnerCode(ownerCode);
        } else {
            // continue without an owner code
            Logger.getLogger(ProviderChangeEventConsumer.class.getName()).log(Level.WARNING, "The Owner Code was not found, audit is proceeding anyways!");
        }

        fillInTransactionDetails(trans, dto, providerRoleType);

        return trans;
    }

    /**
     * Is this dto new? This isn't a generic function, but specific to the
     * specific garbage this class receives.
     *
     * @param dto The record.
     * @return True is the record is new.
     */
    private boolean isNew(AbstractProviderDetail dto) {
        return dto.getGenerationNum() == 1l && dto.getEndReasonCodeId() == null && dto.getEndReasonCode() == null;
    }

    /**
     * Fills in more transaction details.
     *
     * @param trans The transaction.
     * @param dto The record.
     * @param providerRoleType The provider role type.
     */
    protected void fillInTransactionDetails(GrsTransactions trans, AbstractProviderDetail dto, PrsCtProviderRoleTypes providerRoleType) {

        // object code
        Class<? extends MessageDataBlock> entity = dto.getEntityClass();
        String objectName = ProviderDetailsUtil.getDataObjectName(entity);
        trans.setObjectTypeCode(codesDao.lookup(GrsCtDataObjects.class, objectName));

        // effective start date
        trans.setEffectiveStartDate(dto.getEffectiveStartDate());

        try {
            Long wlWlId = null;
            Long pauthWlId = null;
            // if it has a work location id it is a child of work location
            if (ReflectionUtils.hasMethod(dto, "getWlWlId") != ReflectionUtils.MethodType.none) {
                wlWlId = (Long) ReflectionUtils.methodInvoke(dto, "getWlWlId");
            }
            // if it has a pauth it is a child of provider
            if (ReflectionUtils.hasMethod(dto, "getPauthId") != ReflectionUtils.MethodType.none) {
                pauthWlId = (Long) ReflectionUtils.methodInvoke(dto, "getPauthId");
            }

            Method method = dto.getDtoConverterMethod();
            MessageDataBlock originalRecord;

            Long newRecordGenNum = null;
            Long origRecordGenNum = dto.getGenerationNum();

            // This is confusing, there are a couple of scenarios
            // The DTO comes in with the current generation number ... there is always one
            if (isNew(dto)) {
                // 1. it is a generation 1 record, no end reason code
                // Do nothing, the initialized generation numbers work
            } else if (isNewAndCeased(dto)) {
                // 2. Ceased with only one generation
                // This should be the ceased record, 
                newRecordGenNum = origRecordGenNum + 1L;
            } else {
                AbstractProviderDetail origDto = null;

                // 3. There is more than 1 generation, look for the original based on generation number and the end reason code
                originalRecord = findMessageDataBlockService.find(pauthWlId, wlWlId, (MessageDataBlockDto) dto, entity, providerRoleType, dto.getGenerationNum() - 1l, Arrays.asList(dto.getDataOwnerCode()));
                origRecordGenNum--;
                if (originalRecord != null) {
                    // if type if CHG then skip one more back
                    origDto = (AbstractProviderDetail) method.invoke(providerDtoConverter, originalRecord);
                    if (origDto.getEndReasonCode().matches(CodeTableCodes.GrsCtEndReasonTypes.CHANGE.getValue())) {
                        origRecordGenNum--;
                    }
                }
                if (origDto != null && origDto.getEndReasonCode().matches(CodeTableCodes.GrsCtEndReasonTypes.CEASE.getValue())) {
                    // ceased then the new record has genNum - 1L ... find 
                    newRecordGenNum = dto.getGenerationNum();
                }
            }

            originalRecord = findMessageDataBlockService.find(pauthWlId, wlWlId, (MessageDataBlockDto) dto, entity, providerRoleType, origRecordGenNum, Arrays.asList(dto.getDataOwnerCode()));
            MessageDataBlock newRecord = findMessageDataBlockService.find(pauthWlId, wlWlId, (MessageDataBlockDto) dto, entity, providerRoleType, newRecordGenNum, Arrays.asList(dto.getDataOwnerCode()));

            if (method != null) {
                // try to add the records, but if some are missing, keep going
                if (originalRecord != null) {
                    AbstractProviderDetail originalDto = (AbstractProviderDetail) method.invoke(providerDtoConverter, originalRecord);
                    trans.setRdePriorData(serializerAbsProviderDetail.serialize(originalDto));
                }
                if (newRecord != null) {
                    AbstractProviderDetail newDto = (AbstractProviderDetail) method.invoke(providerDtoConverter, newRecord);
                    trans.setRdeChangedData(serializerAbsProviderDetail.serialize(newDto));
                }
            }

        } catch (EntityValidationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException ex) {
            // catch and continue ... write what we can later
            Logger.getLogger(ProviderChangeEventConsumer.class.getName()).log(Level.INFO, null, ex);
        }

    }

    /**
     * A new dto record (gen num 1) but has just been ceased This isn't a
     * generic function, but specific to the specific garbage this class
     * receives.
     *
     * @param dto The record in questiong
     * @return True is this record was ceased
     */
    private boolean isNewAndCeased(AbstractProviderDetail dto) {
        return dto.getGenerationNum() == 1l && (dto.getEndReasonCodeId() != null || dto.getEndReasonCode() != null);
    }

    /**
     * Looks for the user chid in the list, they should all be the same so the
     * first will do
     *
     * @param dtoToAuditList
     * @return the user chid
     */
    private String findUserChid(List<AbstractProviderDetail> dtoToAuditList) {
        for (AbstractProviderDetail apDetail : dtoToAuditList) {
            if (apDetail.getUserChid() != null) {
                return apDetail.getUserChid();
            }
        }
        return null;
    }
}
