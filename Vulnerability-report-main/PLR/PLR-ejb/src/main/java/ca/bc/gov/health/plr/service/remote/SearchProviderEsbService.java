package ca.bc.gov.health.plr.service.remote;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.esb.Acknowledgment;
import ca.bc.gov.health.plr.dto.esb.QueryParameters;
import ca.bc.gov.health.plr.dto.esb.QueryRequest;
import ca.bc.gov.health.plr.dto.esb.QueryResponse;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.esb.ProviderDetails;
import ca.bc.gov.health.plr.dto.provider.search.SearchProviderRequest;
import ca.bc.gov.health.plr.dto.provider.search.SearchProviderResult;
import ca.bc.gov.health.plr.ejb.entity.PrsCtGenderCodes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProvExpertiseTypes;
import ca.bc.gov.health.plr.interceptors.AccessViolationException;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.producer.type.Authenticated;
import ca.bc.gov.health.plr.producer.type.User;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import ca.bc.gov.health.plr.service.ErrorMessage;
import ca.bc.gov.health.plr.service.PLRConfigurationResourceLoader;
import ca.bc.gov.health.plr.service.provider.SearchProviderService;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.EsbMessageUtil;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;

/**
 * Search Provider Service Remote implementation, which receives the search
 * query from ESB and returns the result
 *
 * @author sumesh.kariyil
 */
@Stateless
public class SearchProviderEsbService implements SearchProviderServiceRemote {

    public static final String RESPONSE_CD_DELIVERED_RESPONSE = "deliveredResponse";
    public static final String STATUS_CD_SUCCESS = "SUCCESS";
    public static final String STATUS_CD_FAILURE = "FAILURE";

    @Inject
    @Authenticated
    private Instance<User> user;

    @Inject
    private MaintainProviderEsbProcessor<QueryParameters, SearchProviderRequest> requestProcessor;

    @Inject
    private SearchProviderService searchProviderService;

    @Inject
    private CodesDao codesDao;

    @Inject
    private PLRConfigurationResourceLoader plrConfigLoader;
    
    @EJB
    private EsbMessageUtil esbMessageUtil;

    /**
     * Search implementation for Search provider remote method query
     *
     * @param request : query request object
     * @return Search provider response
     */
    @Override
    public QueryResponse query(QueryRequest request) {
        Validate.notNull(request);
        Validate.notNull(request.getQueryParameters());

        user.get().setUserId(request.getRegistryUserOrgId());

        QueryResponse response = new QueryResponse();
        response.setResponseCode(RESPONSE_CD_DELIVERED_RESPONSE);

        try {

            if (user.get().getUserPrincipal() == null) {
                throw new AccessViolationException(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_ACCESS_VIOLATION_NO_AUTHENTICATION_GENERIC));
            }

            search(request, response);

        } catch (EntityValidationException | RuntimeException ex) {
            response.setStatusCode(STATUS_CD_FAILURE);
            response.setIsTransactionSuccess(false);
            ExceptionHandler.handleException(response, ex);
        }

        esbMessageUtil.populateMetadata(response);
        
        response.setUniqueMessageId(request.getUniqueMessageId());
        response.setMessageType(request.getMessageType());
        response.setMessageInteractionId(plrConfigLoader.getValue(PLRConfigurationResourceLoader.QUERY_INTERACTIONID_RESPONSE));
        response.setSourceUserId(request.getSourceUserId());
        response.setResponsiblePersonUserId(request.getResponsiblePersonUserId());
        

        response.setTargetFacilityId(request.getSourceFacilityId());
        response.setTargetServer(request.getSourceServer());
        response.setSourceFacilityId(request.getTargetFacilityId());        
        response.setSourceServer(request.getTargetServer());
        
        
        
        esbMessageUtil.populateMetadataForAcks(response.getAcknowledgments(), request);
        return response;
    }

    private void search(QueryRequest request, QueryResponse response) throws EntityValidationException {
        SearchProviderResult searchProviderResult = executeSearch(request);
        convertPlrDtosToEsbDtos(searchProviderResult, response);
        acknowledgeNoSearchResults(response);
        for (Acknowledgment ack: response.getAcknowledgments()){
            ack.setTargetMessageExtension(request.getUniqueMessageId());
        }
        markSuccessful(searchProviderResult, request, response);
        
    }

    private void markSuccessful(SearchProviderResult searchProviderResult, QueryRequest request, QueryResponse response) {
        if (!searchProviderResult.getSearchResults().isEmpty() || (searchProviderResult.getSearchResults().isEmpty() && searchProviderResult.getMessages().isEmpty())) {
            acknowledgeSuccess(request, response);
        } else {
            response.setStatusCode(STATUS_CD_FAILURE);
            response.setIsTransactionSuccess(false);
        }
    }

    /**
     * Identifies the type of search to perform, executes the search, and
     * returns the results.
     *
     * @param request
     * @param response
     * @return search results. May be empty, but cannot be null.
     * @throws EntityValidationException if the search cannot be executed.
     */
    private SearchProviderResult executeSearch(QueryRequest request) throws EntityValidationException {

        List<ErrorMessage> errors = new ArrayList<>();
        String mandatoryError = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_MANDATORY_PART1) + "%s"
                + BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_MANDATORY_PART2);

        SearchProviderRequest providerRequest = new SearchProviderRequest();
        requestProcessor.convertAndValidate(request.getQueryParameters(), providerRequest);
        convertQualifications(request, providerRequest);
        convertGender(request, providerRequest);
        providerRequest.setIsMessage(true);
        
        // The order of precedence for search params are,
        // 1. Identifier search, in BRD this is teh "Query by Provider ID"
        // 2. Name search, in BRD it is "Individual Provider Name"
        // 3. Location(City), Expertise or Language, in BRD it is like this
        // There are no Organization Name search, no Query by CPN and no Query by IPC in messages
        String identifierTypeCode = providerRequest.getIdentifierTypeCode();
        String identifier = providerRequest.getIdentifier();
        if (StringUtils.isNotBlank(identifierTypeCode) || StringUtils.isNotBlank(identifier)) {
            //Search By Identifier
            if(StringUtils.isBlank(identifierTypeCode)) {
                errors.add(new ErrorMessage(String.format(mandatoryError, "Identifier Type")));
            }
            if(StringUtils.isBlank(providerRequest.getIdentifier())) {
                errors.add(new ErrorMessage(String.format(mandatoryError, "Identifier ID")));
            }
            if (errors.isEmpty()) {
                return searchProviderService.searchByIdentifier(providerRequest);
            } else {
                throw new EntityValidationException(errors);
            }
        } else {
            String firstName = providerRequest.getFirstName();
            String lastName = providerRequest.getLastName();
            String city = providerRequest.getCity();
            boolean isNameSearch = false;
            boolean isLELSearch = false; //is location, expertise and lanaguage search
            if(StringUtils.isNotBlank(firstName) && StringUtils.isNotBlank(lastName)) {
                isNameSearch = true;
            } else {
                if (StringUtils.isNotBlank(city)
                        || CollectionUtils.isNotEmpty(providerRequest.getLanguageList()) || 
                        CollectionUtils.isNotEmpty(providerRequest.getExpertiseList())) {
                    isLELSearch = true;
                }
            }
            
            if(isNameSearch || isLELSearch) {
                return searchProviderService.searchForPractitioner(providerRequest);
            } else {
                String insufficientParams = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_SEARCH_INSUFFICIENT_PARAMETERS);
                errors.add(new ErrorMessage(insufficientParams));
            }
             
        }
        
        if (!errors.isEmpty()) {
            throw new EntityValidationException(errors);
        } else {
            throw new IllegalStateException("Programming error: method should have already returned.");
        }
    }
    
    private void convertGender(QueryRequest request, SearchProviderRequest providerRequest) {
        if (StringUtils.isNotBlank(request.getQueryParameters().getGender())) {
            PrsCtGenderCodes genderCode = codesDao.lookup(PrsCtGenderCodes.class, request.getQueryParameters().getGender());
            if (genderCode != null) {
                providerRequest.setGender(Long.toString(genderCode.getCtlId()));
            } else {
                // If the gender is not recognized, pass it through. It will be validated later.
                providerRequest.setGender(request.getQueryParameters().getGender());
            }
        }
    }

    /**
     * The qualifications list in request.getQueryParameters() is combined
     * expertise and languages in providerRequest. As the property name is
     * different, they were not mapped properly in method
     * requestProcessor.convertAndValidate(). It needs to manually copy.
     * qualificationList includes list of expertise/language code
     */
    private void convertQualifications(QueryRequest request, SearchProviderRequest providerRequest) throws EntityValidationException {
        List<String> qualificationList = request.getQueryParameters().getQualifications();
        if(qualificationList!=null) {
            //expertiseIdList includes expertise ids
            //languageIdList includes language ids
            //invalidExpLanSB includes the invalid expertise and language ids which could not be found in table PRS_CT_PROV_EXPERTISE_TYPES
            List<Long> expertiseIdList = new ArrayList<>();
            List<Long> languageIdList = new ArrayList<>();
            StringBuilder invalidExpLanSB = new StringBuilder();
            int i=0;
            for(String expLanCode : qualificationList) {
                if(StringUtils.isNoneBlank(expLanCode)) {
                    PrsCtProvExpertiseTypes pet = codesDao.lookupExpertiseByCode(expLanCode);
                    if(pet==null || pet.getCtlId()==null) {
                        //the expLanCode can not be found in table PRS_CT_PROV_EXPERTISE_TYPES
                        if(i>0) {
                            invalidExpLanSB.append(",");
                        }
                        invalidExpLanSB.append(expLanCode);
                        i++;
                    } else {
                        String prt = pet.getProvRoleType();
                        if(StringUtils.isNoneBlank(prt) && prt.trim().compareTo(Consts.LANG)==0) {
                            languageIdList.add(pet.getCtlId());
                        } else {
                            expertiseIdList.add(pet.getCtlId());
                        }
                    }
                }
            }
            if(invalidExpLanSB.toString().trim().isEmpty()) {
                //no incorrect expertise and language code found
                if(!expertiseIdList.isEmpty()) {
                    providerRequest.setExpertiseList(expertiseIdList);
                }
                if(!languageIdList.isEmpty()) {
                    providerRequest.setLanguageList(languageIdList);
                }
            } else {
                //throw exception as the message includes invalid expertise/language type code
                BusinessRuleKeys errKey = BusinessRuleKeys.ERROR_SEARCH_QUALIFICATION;
                String errMessageFormat = BusinessRuleMessageDao.getMessageResource(errKey);
                String errMessage = String.format(errMessageFormat, invalidExpLanSB.toString());
                throw new EntityValidationException(errMessage);
            }
        }
    }

    private void convertPlrDtosToEsbDtos(SearchProviderResult searchProviderResult, QueryResponse response) {
        for (ProviderDto dto : searchProviderResult.getSearchResults()) {
            try {
                ProviderDetails esbVersion = dto.toEsbVersion();
                response.addProviderDetails(esbVersion);
            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException ex) {
                // If toEsb is failing to convert DTOs, then there is a major application error.
                throw new IllegalStateException(ex);
            }
        }

        for (BusinessRuleMessage brm : searchProviderResult.getMessages()) {
            response.addAcknowledgement(new Acknowledgment(brm.getMessageCode(), brm.getMessage()));
        }
    }

    private void acknowledgeNoSearchResults(QueryResponse response) {
        if (response.getAcknowledgments().isEmpty() && response.getProviderDetails().isEmpty()) {
            String msg = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.NO_SEARCH_RESULTS);
            response.addAcknowledgement(ExceptionHandler.createAcknowledgement(msg));
        }
    }

    private void acknowledgeSuccess(QueryRequest request, QueryResponse response) {
        response.setIsTransactionSuccess(true);
        response.setStatusCode(STATUS_CD_SUCCESS);
        String msg = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.SEARCH_SUCCESS);
        Acknowledgment ack = ExceptionHandler.createAcknowledgement(msg);
        ack.setTypeCode(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.TX_ACK_TYPECODE));
        ack.setTargetMessageExtension(request.getUniqueMessageId());
        response.addAcknowledgement(ack);
    }
}
