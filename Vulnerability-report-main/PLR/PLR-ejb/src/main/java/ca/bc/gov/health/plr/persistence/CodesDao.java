package ca.bc.gov.health.plr.persistence;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.ejb.entity.GrsDataElementPermissions;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.PrsCtCommunPurposeTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtIdentifierTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProvCredentialTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProvExpertiseTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProvState;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtStatusClassCodes;
import ca.bc.gov.health.plr.ejb.session.GrsCtBooleanTypesFacade;
import ca.bc.gov.health.plr.ejb.session.GrsCtEndReasonTypesFacade;
import ca.bc.gov.health.plr.ejb.session.GrsCtMechanismsFacade;
import ca.bc.gov.health.plr.ejb.session.PrsCtCommunPurposeTypesFacade;
import ca.bc.gov.health.plr.ejb.session.PrsCtDataOwnerCodesFacade;
import ca.bc.gov.health.plr.ejb.session.PrsCtElectronicAddrTypesFacade;
import ca.bc.gov.health.plr.ejb.session.PrsCtNameTypesFacade;
import ca.bc.gov.health.plr.ejb.session.PrsCtProvCredentialTypesFacadeLocal;
import ca.bc.gov.health.plr.ejb.session.PrsCtProvExpertiseTypesFacade;
import ca.bc.gov.health.plr.ejb.session.PrsCtProviderRoleTypesFacade;
import ca.bc.gov.health.plr.ejb.session.PrsCtStatusCodesFacade;
import ca.bc.gov.health.plr.ejb.session.PrsCtTelecomNumberTypesFacade;
import ca.bc.gov.health.plr.ejb.session.PrsCtWorkLocationPurpsFacade;
import ca.bc.gov.health.plr.ejb.session.PrsCtAddressValidTypesFacade;
import static ca.bc.gov.health.plr.ejb.entity.util.DatabaseConstants.PERSISTENCE_CONTEXT_UNIT_NAME;
import ca.bc.gov.health.plr.ejb.session.PrsCtGenderCodesFacade;
import ca.bc.gov.health.plr.service.provider.security.AuthorizationService;
import ca.bc.gov.health.plr.util.LanguageExpertiseTypeComparator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;
import org.apache.commons.lang3.text.WordUtils;

/**
 * Data access object for retrieving lists of codes or individual codes. Typical
 * usage is for display in a web user interface.
 *
 * @author Grant.Hodgins
 * @author Adebiyi.Kuseju
 */
@Stateless
@LocalBean
public class CodesDao {

    private static final String CLASSNAME = CodesDao.class.getSimpleName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);

    public static final String matchINDString = ".*[,]?" + CodeTableCodes.GrsCtPartyType.IND.getValue() + "[,]?.*";
    public static final String matchORGString = ".*[,]?" + CodeTableCodes.GrsCtPartyType.ORG.getValue() + "[,]?.*";
    public static final String OOPRoleTypeRegex = "OOP-.*";

    @PersistenceContext(unitName = PERSISTENCE_CONTEXT_UNIT_NAME)
    private EntityManager em;

    @EJB
    private GrsCtBooleanTypesFacade grsCtBooleanTypesFacade;
    @EJB
    private GrsCtEndReasonTypesFacade grsCtEndReasonTypesFacade;
    @EJB
    private GrsCtMechanismsFacade grsCtMechanismsFacade;
    @EJB
    private PrsCtCommunPurposeTypesFacade prsCtCommunPurposeTypesFacade;
    @EJB
    private PrsCtNameTypesFacade prsCtNameTypesFacade;
    @EJB
    private PrsCtProvExpertiseTypesFacade prsCtProvExpertiseTypesFacade;
    @EJB
    private PrsCtProviderRoleTypesFacade prsCtProviderRoleTypesFacade;
    @EJB
    private PrsCtDataOwnerCodesFacade prsCtDataOwnerCodesFacade;
    @EJB
    private PrsCtElectronicAddrTypesFacade prsCtElectronicAddrTypesFacade;
    @EJB
    private PrsCtWorkLocationPurpsFacade prsCtWorkLocationPurpsFacade;
    @EJB
    private PrsCtTelecomNumberTypesFacade prsCtTelecomNumberTypesFacade;
    @EJB
    private PrsCtStatusCodesFacade prsCtStatusCodesFacade;
    @EJB
    private AuthorizationService authorizationService;
    @EJB
    private PrsCtGenderCodesFacade prsCtGenderCodesFacade;
    @EJB 
    private PrsCtAddressValidTypesFacade prsCtAddressValidTypesFacade;
    @Inject
    private PrsCtProvCredentialTypesFacadeLocal prsCtProvCredentialTypesFacade;

    /**
     * Returns a list provider role types that the given registry user is
     * allowed to view ordered by usage frequency where frequency > 0.
     *
     * @param regUser a registry user.
     * @return a list of provider role types that the given registry user is
     * allowed to view ordered by usage frequency where frequency > 0.
     */
    public List<PrsCtProviderRoleTypes> getProviderRoleTypesForSearch(GrsRegistryUsers regUser, String regEx) {
        boolean usedOnly = true;
        List<PrsCtProviderRoleTypes> result = findOrderedProviderRoleTypeCodes(usedOnly);

        // remove party types not allowed, null and IND are allowed
        for (Iterator<PrsCtProviderRoleTypes> it = result.iterator(); it.hasNext();) {
            PrsCtProviderRoleTypes providerRoleType = it.next();
            if (providerRoleType.getPartyType() != null && !providerRoleType.getPartyType().matches(regEx)) {
                it.remove();
            }
        }

        removeDisallowedRoleTypes(regUser, result);

        return result;
    }


    public List<PrsCtProviderRoleTypes> findOrderedProviderRoleTypeCodes(boolean includeOnlyIfUsed) {
        StringBuilder queryBuilder = new StringBuilder();
        queryBuilder.append("select t, count(p.pauthId) as thecount ");
        queryBuilder.append("from PrsCtProviderRoleTypes t ");
        queryBuilder.append("left join t.prsProvidersList p ");
        queryBuilder.append("group by t ");
        if (includeOnlyIfUsed) {
            queryBuilder.append("having thecount > 0 ");
        }
        queryBuilder.append("order by thecount desc ");
        Query query = em.createQuery(queryBuilder.toString());

        List<PrsCtProviderRoleTypes> result = new ArrayList<>();
        for (Object item : query.getResultList()) {
            result.add((PrsCtProviderRoleTypes) ((Object[]) item)[0]);
        }

        return result;
    }

    private void removeDisallowedRoleTypes(GrsRegistryUsers regUser, List<PrsCtProviderRoleTypes> result) {
        Set<String> allowedProviderTypes = authorizationService.getAllowedProviderTypes(regUser);
        for (Iterator<PrsCtProviderRoleTypes> it = result.iterator(); it.hasNext();) {
            PrsCtProviderRoleTypes providerRoleType = it.next();
            if (!allowedProviderTypes.contains(providerRoleType.getCtlNameCode())) {
                it.remove();
            }
        }
    }

    /**
     * Returns a list of provider role types that the given registry user is
     * allowed to add.
     *
     * @param regUser a registry user. Cannot be null.
     * @return a list of provider role types that the given registry user is
     * allowed to add.
     */
    public List<PrsCtProviderRoleTypes> getProviderRoleTypeForAdd(GrsRegistryUsers regUser) {
        Validate.notNull(regUser);

        List<PrsCtProviderRoleTypes> allowedProviderTypes = new ArrayList<>();
        List<PrsCtProviderRoleTypes> providerTypes = prsCtProviderRoleTypesFacade.findAll();
        for (PrsCtProviderRoleTypes providerType : providerTypes) {
            if (authorizationService.hasPermissionToAddProviderOfRoleType(regUser, providerType)
                    && !providerType.getCtlNameCode().matches(OOPRoleTypeRegex)
                    && providerType.getPartyType().matches(matchINDString)) {
                allowedProviderTypes.add(providerType);
            }
        }
        return allowedProviderTypes;
    }

    /**
     * Returns a list of provider role types that the given registry user is
     * allowed to add and are OOP role types.
     *
     * @param regUser a registry user. Cannot be null.
     * @return a list of provider role types that the given registry user is
     * allowed to add.
     */
    public List<PrsCtProviderRoleTypes> getProviderRoleTypeForAddOOP(GrsRegistryUsers regUser) {
        Validate.notNull(regUser);

        List<PrsCtProviderRoleTypes> allowedProviderTypes = new ArrayList<>();
        List<PrsCtProviderRoleTypes> providerTypes = prsCtProviderRoleTypesFacade.findAll();
        for (PrsCtProviderRoleTypes providerType : providerTypes) {
            if (authorizationService.hasPermissionToAddProviderOfRoleType(regUser, providerType)
                    && providerType.getCtlNameCode().matches(OOPRoleTypeRegex)
                    && providerType.getPartyType().matches(matchINDString)) {
                allowedProviderTypes.add(providerType);
            }
        }
        return allowedProviderTypes;
    }

    /**
     * Returns a list of provider role types that the given registry user is
     * allowed to add and are ORG role types.
     *
     * @param regUser a registry user. Cannot be null.
     * @return a list of provider role types that the given registry user is
     * allowed to add.
     */
    public List<PrsCtProviderRoleTypes> getProviderRoleTypeForAddORG(GrsRegistryUsers regUser) {
        Validate.notNull(regUser);

        List<PrsCtProviderRoleTypes> allowedProviderTypes = new ArrayList<>();
        List<PrsCtProviderRoleTypes> providerTypes = prsCtProviderRoleTypesFacade.findAll();
        for (PrsCtProviderRoleTypes providerType : providerTypes) {
            if (authorizationService.hasPermissionToAddProviderOfRoleType(regUser, providerType)
                    && providerType.getPartyType().matches(matchORGString)) {
                allowedProviderTypes.add(providerType);
            }
        }
        return allowedProviderTypes;
    }

    /**
     * Returns a list of identifier types that the given registry user is
     * allowed to view ordered by usage frequency where frequency > 0.
     *
     * @param regUser a registry user.
     * @return a list of identifier types that the given registry user is
     * allowed to view ordered by usage frequency where frequency > 0.
     */
    public List<PrsCtIdentifierTypes> getIdentifierTypesForSearch(GrsRegistryUsers regUser) {
        boolean usedOnly = true;
        List<PrsCtIdentifierTypes> identifierTypes = findIdentifierTypesOrderedByFreq(usedOnly);

        Set<String> allowedProviderTypes = authorizationService.getAllowedProviderTypes(regUser);

        List<PrsCtIdentifierTypes> allowedIdentifierTypes = new ArrayList<>();
        for (PrsCtIdentifierTypes identifierType : identifierTypes) {
            if (isAllowed(allowedProviderTypes, identifierType.getProvRoleType())) {
                allowedIdentifierTypes.add(identifierType);
            }
        }
        return allowedIdentifierTypes;
    }

    /**
     * Returns a list of identifier types ordered by usage frequency where
     * frequency >= 0.
     *
     * @return a list of identifier types ordered by usage frequency where
     * frequency >= 0.
     */
    public List<PrsCtIdentifierTypes> getIdentifierTypesCodes() {
        boolean usedOnly = false;
        return findIdentifierTypesOrderedByFreq(usedOnly);
    }

    private List<PrsCtIdentifierTypes> findIdentifierTypesOrderedByFreq(boolean includeOnlyIfUsed) {
        StringBuilder queryBuilder = new StringBuilder();
        queryBuilder.append("select t, count(i.pidId) as thecount ");
        queryBuilder.append("from PrsCtIdentifierTypes t ");
        queryBuilder.append("left join t.grsIdentifiersList i ");
        queryBuilder.append("group by t ");
        if (includeOnlyIfUsed) {
            queryBuilder.append("having count(i) > 0 ");
        }
        queryBuilder.append("order by thecount desc");
        Query query = em.createQuery(queryBuilder.toString());

        List<PrsCtIdentifierTypes> result = new ArrayList<>();
        for (Object item : query.getResultList()) {
            result.add((PrsCtIdentifierTypes) ((Object[]) item)[0]);
        }

        return result;
    }

    /**
     * Suggests a city name based on auto-complete search criteria. The
     * suggestion will provide cities that are in use for providers.
     *
     * @param criteria the search criteria
     * @return a list of city name suggestions, ordered by system relevance
     */
    public List<String> findCityNameByCriteria(String criteria) {
        List<String> result = new ArrayList<>();

        // ensure only provider cities since other cities are possible
        StringBuilder queryString = new StringBuilder();
        queryString.append("select distinct lower(a.cityTxt) from GrsAddresses a ")
                .append("join a.pauthPauthId p ")
                .append("where upper(a.cityTxt) like upper(:criteria) ")
                .append("group by lower(a.cityTxt) ")
                .append("order by count(1) desc");

        Query query = em.createQuery(queryString.toString()).setParameter("criteria", criteria + "%").setMaxResults(4);

        List<String> searchResults = query.getResultList();
        for (String cityName : searchResults) {
            result.add(WordUtils.capitalizeFully(cityName));
        }

        return result;
    }

    /**
     * Suggests a credential city name based on auto-complete search criteria.
     * The suggestion will provide cities that are in use for providers.
     *
     * @param criteria the search criteria
     * @return a list of city name suggestions, ordered by system relevance
     */
    public List<String> findCredentialCityNameByCriteria(String criteria) {
        List<String> result = new ArrayList<>();

        // ensure only institution cities since other cities are possible
        StringBuilder queryString = new StringBuilder();
        queryString.append("select distinct(c.institutionCityTxt) from PrsProviderCredentials c ")
                .append("join c.pauthPauthId p ")
                .append("where upper(c.institutionCityTxt) like upper(:criteria) ")
                .append("group by c.institutionCityTxt ")
                .append("order by count(1) desc");

        Query query = em.createQuery(queryString.toString()).setParameter("criteria", criteria + "%").setMaxResults(4);

        List<String> searchResults = query.getResultList();
        for (String cityName : searchResults) {
            result.add(cityName);
        }

        return result;
    }

    /**
     * Suggests a credential institution name based on auto-complete search
     * criteria. The suggestion will provide cities that are in use for
     * providers.
     *
     * @param criteria the search criteria
     * @return a list of city name suggestions, ordered by system relevance
     */
    public List<String> findCredentialInstitutionNameByCriteria(String criteria) {
        List<String> result = new ArrayList<>();

        StringBuilder queryString = new StringBuilder();
        queryString.append("select distinct(c.credentialGrantingInstTxt) from PrsProviderCredentials c ")
                .append("join c.pauthPauthId p ")
                .append("where upper(c.credentialGrantingInstTxt) like upper(:criteria) ")
                .append("group by c.credentialGrantingInstTxt ")
                .append("order by count(1) desc");

        Query query = em.createQuery(queryString.toString()).setParameter("criteria", criteria + "%").setMaxResults(4);

        List<String> searchResults = query.getResultList();
        for (String institutinName : searchResults) {
            result.add(institutinName);
        }

        return result;
    }

    /**
     * Return if the specified country has provinces/states/etc
     *
     * @param countryId a valid country ID.
     * @return true if at least one ative province or state exists
     */
    public boolean doesCountryPossessProvState(String countryCode) {
        TypedQuery<PrsCtProvState> query = em.createQuery("SELECT distinct(p.countryCode) FROM PrsCtProvState p WHERE p.countryCode = :country and p.activeFlag ='Y' and p.endReasonCode is null", PrsCtProvState.class).setMaxResults(1);
        query.setParameter("country", countryCode);
        int resultCount = query.getResultList().size();
        if (resultCount == 0) {
            return false;
        }
        return true;
    }

    /**
     * Return if the specified country has provinces/states/etc
     *
     * @param countryId a valid country ID.
     * @return true if at least one ative province or state exists
     */
    public boolean isValidProvStateCode(String countryCode, String provStateCode) {
        TypedQuery<PrsCtProvState> query = em.createQuery("SELECT distinct(p.countryCode) FROM PrsCtProvState p WHERE p.countryCode = :country and p.activeFlag ='Y' and p.endReasonCode is null and p.ctlNameCode=:provState", PrsCtProvState.class).setMaxResults(1);
        query.setParameter("country", countryCode);
        query.setParameter("provState", provStateCode);
        int resultCount = query.getResultList().size();
        if (resultCount == 0) {
            return false;
        }
        return true;
    }

    /**
     * Look up a code database entity given a {@link CodeTableEnum}.
     *
     * For example,      <code>
     * codesDao.lookup(GrsCtBooleanTypes.class, GrsCtBooleanTypes.NO)
     * </code> will execute JPA query      <code>
     * "select b from GrsCtBooleanTypes b where b.ctlNameCode = 'N'"
     * </code>
     *
     * @param <T> the code type to look up and return.
     * @param clazz the code type to look up (needed to retrieve the class name
     * for the JPA query).
     * @param code a CodeTableEnum indicating which code to look up.
     * @return the specified code.
     */
    public <T> T lookup(Class<T> clazz, CodeTableEnum code) {

        T result;

        switch (clazz.getName()) {

            case "ca.bc.gov.health.plr.ejb.entity.GrsCtBooleanTypes":
                result = (T) grsCtBooleanTypesFacade.findByBooleanType((CodeTableCodes.GrsCtBooleanTypes) code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes":
                result = (T) grsCtEndReasonTypesFacade.findByType((CodeTableCodes.GrsCtEndReasonTypes) code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.GrsCtMechanisms":
                result = (T) grsCtMechanismsFacade.findbyMechanismType((CodeTableCodes.GrsCtMechanisms) code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtCommunPurposeTypes":
                result = (T) prsCtCommunPurposeTypesFacade.findByCommunicationPurposeType((CodeTableCodes.PrsCtCommunPurposeTypes) code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtNameTypes":
                result = (T) prsCtNameTypesFacade.findNameType(code.getValue());
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtElectronicAddrTypes":
                result = (T) prsCtElectronicAddrTypesFacade.findbyElectronicAddrType((CodeTableCodes.PrsCtElectronicAddrTypes) code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtTelecomNumberTypes":
                result = (T) prsCtTelecomNumberTypesFacade.findbyTelecomNumberType((CodeTableCodes.PrsCtTelecomNumberTypes) code);
                break;
            default:
                String queryString = "select b from " + clazz.getSimpleName() + " b where b.ctlNameCode = :code";
                TypedQuery<T> query = em.createQuery(queryString, clazz);
                query.setParameter("code", code.getValue());
                result = getSingleResult(query, clazz, code);
        }

        return result;

    }

    /**
     *
     * @param <T> the code type to look up and return.
     * @param clazz the code type to look up (needed to retrieve the class name
     * for the JPA query).
     * @param code a code indicating which code to look up.
     * @return the specified code.
     */
    public <T> T lookup(Class<T> clazz, String code) {

        T result;

        switch (clazz.getName()) {

            case "ca.bc.gov.health.plr.ejb.entity.GrsCtBooleanTypes":
                result = (T) grsCtBooleanTypesFacade.findByBooleanType(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes":
                result = (T) grsCtEndReasonTypesFacade.findByName(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.GrsCtMechanisms":
                result = (T) grsCtMechanismsFacade.findbyMechanismType(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtCommunPurposeTypes":
                result = (T) prsCtCommunPurposeTypesFacade.findByCommunicationPurposeType(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtNameTypes":
                result = (T) prsCtNameTypesFacade.findNameType(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtProvExpertiseTypes":
                result = (T) prsCtProvExpertiseTypesFacade.findByProvExpertiseType(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes":
                result = (T) prsCtProviderRoleTypesFacade.findbyProviderRoleType(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtDataOwnerCodes":
                result = (T) prsCtDataOwnerCodesFacade.findByDataOwnerCode(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtElectronicAddrTypes":
                result = (T) prsCtElectronicAddrTypesFacade.findbyElectronicAddrType(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtWorkLocationPurps":
                result = (T) prsCtWorkLocationPurpsFacade.findbyWorkLocationPurpsType(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtTelecomNumberTypes":
                result = (T) prsCtTelecomNumberTypesFacade.findbyTelecomNumberType(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtStatusCodes":
                result = (T) prsCtStatusCodesFacade.findbyStatusCodeType(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtGenderCodes":
                result = (T) prsCtGenderCodesFacade.findbyGenderCode(code);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtAddressValidTypes":
                result = (T) prsCtAddressValidTypesFacade.findbyAddrValidTypeCode(code);
                break;
            default:
                String queryString = "select b from " + clazz.getSimpleName() + " b where b.ctlNameCode = :code";
                TypedQuery<T> query = em.createQuery(queryString, clazz);
                query.setParameter("code", code);
                result = getSingleResult(query, clazz, code);
        }

        return result;

    }

    /**
     *
     * @param <T> the code type to look up and return.
     * @param clazz the code type to look up (needed to retrieve the class name
     * for the JPA query).
     * @param codeId a code id indicating which code to look up.
     * @return the specified code.
     */
    public <T> T lookup(Class<T> clazz, Long codeId) {

        T result;

        switch (clazz.getName()) {

            case "ca.bc.gov.health.plr.ejb.entity.GrsCtBooleanTypes":
                result = (T) grsCtBooleanTypesFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes":
                result = (T) grsCtEndReasonTypesFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.GrsCtMechanisms":
                result = (T) grsCtMechanismsFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtCommunPurposeTypes":
                result = (T) prsCtCommunPurposeTypesFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtNameTypes":
                result = (T) prsCtNameTypesFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtProvExpertiseTypes":
                result = (T) prsCtProvExpertiseTypesFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes":
                result = (T) prsCtProviderRoleTypesFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtDataOwnerCodes":
                result = (T) prsCtDataOwnerCodesFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtElectronicAddrTypes":
                result = (T) prsCtElectronicAddrTypesFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtWorkLocationPurps":
                result = (T) prsCtWorkLocationPurpsFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtTelecomNumberTypes":
                result = (T) prsCtTelecomNumberTypesFacade.find(codeId);
                break;
            case "ca.bc.gov.health.plr.ejb.entity.PrsCtStatusCodes":
                result = (T) prsCtStatusCodesFacade.find(codeId);
                break;
            default:
                String queryString = "select b from " + clazz.getSimpleName() + " b where b.ctlId = :codeId";
                TypedQuery<T> query = em.createQuery(queryString, clazz);
                query.setParameter("codeId", codeId);
                result = getSingleResult(query, clazz, codeId);
        }

        return result;

    }

    public PrsCtProvExpertiseTypes lookupExpertiseByCode(String code) {
        return prsCtProvExpertiseTypesFacade.findByExpertiseCode(code);
    }

    /**
     * Return <code>query.getSingleResult()</code>.
     *
     * Throw an informative exception if the query does not return any results.
     *
     * @param <T> the code type to look up and return.
     * @param query the query to run.
     * @param clazz the code type to look up (used in the exception message).
     * @param code a code to look up (used in the exception message).
     * @return <code>query.getSingleResult()</code>
     * @throws IllegalArgumentException
     */
    private <T> T getSingleResult(TypedQuery<T> query, Class<T> clazz, Object code) throws IllegalArgumentException {
        try {
            return query.getSingleResult();
        } catch (Exception e) {
            String msg = String.format("Cannot find code '%s'='%s'", clazz.getSimpleName(), code.toString());
            throw new IllegalArgumentException(msg, e);
        }
    }

    /**
     *
     * @param <T> the code type to look up and return.
     * @param clazz the code type to look up (needed to retrieve the class name
     * for the JPA query).
     * @param code a code indicating which code to look up.
     * @return the specified code.
     */
    public <T> boolean codeExists(Class<T> clazz, String code) {
        String queryString = "select b from " + clazz.getSimpleName() + " b where b.ctlNameCode = :code and b.endReasonCode is null and b.activeFlag = :active";
        TypedQuery<T> query = em.createQuery(queryString, clazz);
        query.setParameter("code", code);
        query.setParameter("active", CodeTableCodes.GrsCtBooleanTypes.YES.getValue());
        return !query.getResultList().isEmpty();
    }

    /**
     *
     * @param <T> the code type to look up and return.
     * @param clazz the code type to look up (needed to retrieve the class name
     * for the JPA query).
     * @param codeId a code id indicating which code to look up.
     * @return the specified code.
     */
    public <T> boolean codeExists(Class<T> clazz, Long codeId) {
        String queryString = "select b from " + clazz.getSimpleName() + " b where b.ctlId = :codeId and b.endReasonCode is null and b.activeFlag = :active";
        TypedQuery<T> query = em.createQuery(queryString, clazz);
        query.setParameter("codeId", codeId);
        query.setParameter("active", CodeTableCodes.GrsCtBooleanTypes.YES.getValue());
        return !query.getResultList().isEmpty();
    }

    /**
     * Returns true if providerType (e.g. "MD") is within the CSV
     * applicableProviderTypes (e.g. "MD,DEN,RN"), or if applicableProviderTypes
     * is blank, or if applicableProviderTypes equals LANG which is a language
     *
     * (This odd approach is a quirk of the data model, which uses a CSV field
     * in PrsCtIdentifierTypes containing name codes of applicable
     * PrsCtProvRoleTypes, instead of using a many-to-many relationship between
     * the tables.)
     *
     * @param providerType the name of a Provider Type.
     * @param applicableProviderTypes a CSV list of "applicable Provider Types"
     * @return true if applicableProviderTypes is within the CSV
     * applicableProviderTypes or if applicableProviderTypes is blank.
     */
    private static boolean isApplicable(String providerType, String applicableProviderTypes) {
        if (StringUtils.isBlank(applicableProviderTypes) || applicableProviderTypes.compareToIgnoreCase(Consts.LANG) == 0) {
            return true;
        } else {
            List<String> applicableRoles = Arrays.asList(applicableProviderTypes.split(","));
            if (applicableRoles.contains(providerType)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if the set specified by allowedProviderTypes and the CSV
     * applicableTypes has a non-empty intersection.
     *
     * For example, if we have the set ["MD", "DEN", "RN"] and applicableTypes
     * are "DEN,RN", return true.
     *
     * Uses {@link #isApplicable(java.lang.String, java.lang.String)} on each
     * allowedProviderTypes.
     *
     * (This odd approach is a quirk of the data model, which uses a CSV field
     * in PrsCtIdentifierTypes containing name codes of applicable
     * PrsCtProvRoleTypes, instead of using a many-to-many relationship between
     * the tables.)
     *
     * @param allowedProviderTypes a set of provider types.
     * @param applicableProviderTypes a CSV list of "applicable types".
     * @return true if allowedProviderTypes and applicableProvider types have a
     * non-empty intersection.
     */
    private static boolean isAllowed(Set<String> allowedProviderTypes, String applicableProviderTypes) {
        for (String allowedProviderType : allowedProviderTypes) {
            if (isApplicable(allowedProviderType, applicableProviderTypes)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns a list of all PrsCtProvExpertiseTypes applicable to the specified
     * Provider Role Type.
     *
     * @param providerRoleTypeId specifies a valid Provider Role Type.
     * @return a list of all PrsCtProvExpertiseTypes applicable to the specified
     * Provider Role Type.
     */
    public List<PrsCtProvExpertiseTypes> getApplicableExpertiseTypes(long providerRoleTypeId) {
        String providerRoleTypeName = em.find(PrsCtProviderRoleTypes.class, providerRoleTypeId).getCtlNameCode();
        List<PrsCtProvExpertiseTypes> applicableExpertiseTypes = new ArrayList<>();
        List<PrsCtProvExpertiseTypes> expertiseTypes = prsCtProvExpertiseTypesFacade.findAll();
        for (PrsCtProvExpertiseTypes expertiseType : expertiseTypes) {
            if (CodesDao.isApplicable(providerRoleTypeName, expertiseType.getProvRoleType())) {
                applicableExpertiseTypes.add(expertiseType);
            }
        }
        Collections.sort(applicableExpertiseTypes, new LanguageExpertiseTypeComparator());
        return applicableExpertiseTypes;
    }

    /**
     * Returns a list of all PrsCtIdentifierTypes applicable to the specified
     * Provider Role Type ordered by usage frequency where frequency >= 0.
     *
     * @param providerRoleTypeId specifies a valid Provider Role Type.
     * @return a list of all PrsCtIdentifierTypes applicable to the specified
     * Provider Role Type ordered by usage frequency where frequency >= 0.
     */
    public List<PrsCtIdentifierTypes> getApplicableIdentifierTypes(long providerRoleTypeId) {
        PrsCtProviderRoleTypes find = em.find(PrsCtProviderRoleTypes.class, providerRoleTypeId);
        List<PrsCtIdentifierTypes> applicableIdentifierTypes = new ArrayList<>();
        // will throw nullPointer if no roleTypeFound.  the contract states only valid may be passed into this method so leaving nullpointer to occour.
        String roleType = find.getCtlNameCode();
        for (PrsCtIdentifierTypes identifierType : getAllIdentifierTypesOrderedByFrequency()) {
            if (CodesDao.isApplicable(roleType, identifierType.getProvRoleType())) {
                applicableIdentifierTypes.add(identifierType);
            }

        }
        return applicableIdentifierTypes;
    }

    private List<PrsCtIdentifierTypes> getAllIdentifierTypesOrderedByFrequency() {
        Query query = em.createQuery(
                "select t, count(i.pidId) as thecount "
                + "from PrsCtIdentifierTypes t "
                + "left join t.grsIdentifiersList i "
                + "group by t order by thecount desc");
        List<PrsCtIdentifierTypes> identifierTypes = new ArrayList<>();
        for (Object item : query.getResultList()) {
            PrsCtIdentifierTypes identifierType = (PrsCtIdentifierTypes) ((Object[]) item)[0];
            identifierTypes.add(identifierType);
        }
        return identifierTypes;
    }

    /**
     * Returns a list of all PrsCtProvCredentialTypes applicable to the
     * specified Provider Role Type.
     *
     * @param providerRoleTypeId specifies a valid Provider Role Type.
     * @return a list of all PrsCtProvCredentialTypes applicable to the
     * specified Provider Role Type.
     */
    public List<PrsCtProvCredentialTypes> getApplicableCredentials(Long providerRoleTypeId) {
        String roleType = em.find(PrsCtProviderRoleTypes.class, providerRoleTypeId).getCtlNameCode();
        List<PrsCtProvCredentialTypes> credentialTypes = prsCtProvCredentialTypesFacade.findAll();
        List<PrsCtProvCredentialTypes> applicableCredentials = new ArrayList<>();
        for (PrsCtProvCredentialTypes credentialType : credentialTypes) {
            if (CodesDao.isApplicable(roleType, credentialType.getProvRoleType())) {
                applicableCredentials.add(credentialType);
            }
        }
        return applicableCredentials;
    }

    /**
     * Gets the Identifier Types that the given registry user is allowed to add
     * to a Provider of the given type.
     *
     * @param regUser a registry user. Cannot be null.
     * @param hptCode a provider type. Cannot be null.
     * @return the Identifier Types that the given registry user is allowed to
     * add to a Provider of the given type.
     */
    public List<PrsCtIdentifierTypes> getIdentifierTypesForAdd(GrsRegistryUsers regUser, PrsCtProviderRoleTypes hptCode) {
        return getAllowedTypesForAdd(regUser, hptCode, "GRS_IDENTIFIER", "IDENTIFIER_TYPE_CODE=(.*)", PrsCtIdentifierTypes.class);
    }

    /**
     * Gets the Status Class Codes that the given registry user is allowed to
     * add to a Provider of the given type.
     *
     * @param regUser a registry user. Cannot be null.
     * @param hptCode a provider type. Cannot be null.
     * @return the Status Class Codes that the given registry user is allowed to
     * add to a Provider of the given type.
     */
    public List<PrsCtStatusClassCodes> getStatusClassesForAdd(GrsRegistryUsers regUser, PrsCtProviderRoleTypes hptCode) {
        return getAllowedTypesForAdd(regUser, hptCode, "PRS_STATUS", "STATUS_CLASS_CODE=(.*)", PrsCtStatusClassCodes.class);
    }

    /**
     * Gets the Address Communication Purpose Codes that the given registry user
     * is allowed to add to a Provider of the given type.
     *
     * @param regUser a registry user. Cannot be null.
     * @param hptCode a provider type. Cannot be null.
     * @return the Address Communication Purpose Codes that the given registry
     * user is allowed to add to a Provider of the given type.
     */
    public List<PrsCtCommunPurposeTypes> getAddressPurposeTypesForAdd(GrsRegistryUsers regUser, PrsCtProviderRoleTypes hptCode) {
        return getAllowedTypesForAdd(regUser, hptCode, "GRS_ADDRESS", "CMNCTN_PRPS_TYP_CD=(.*)", PrsCtCommunPurposeTypes.class);
    }

    /**
     * Gets the Email Address Communication Purpose Codes that the given
     * registry user is allowed to add to a Provider of the given type.
     *
     * @param regUser a registry user.
     * @param hptCode a provider type.
     * @return the Email Address Communication Purpose Codes that the given
     * registry user is allowed to add to a Provider of the given type.
     */
    public List<PrsCtCommunPurposeTypes> getEmailPurposeTypesForAdd(GrsRegistryUsers regUser, PrsCtProviderRoleTypes hptCode) {
        return getAllowedTypesForAdd(regUser, hptCode, "GRS_ELECTRONIC_ADDRESS", "CMNCTN_PRPS_TYP_CD=(.*)", PrsCtCommunPurposeTypes.class);
    }

    /**
     * Gets the Credential Types that the given registry user is allowed to add
     * to a Provider of the given type.
     *
     * @param regUser a registry user. Cannot be null.
     * @param hptCode a provider type. Cannot be null.
     * @return the Credential Types that the given registry user is allowed to
     * add to a Provider of the given type.
     */
    public List<PrsCtProvCredentialTypes> getCredentialTypesForAdd(GrsRegistryUsers regUser, PrsCtProviderRoleTypes hptCode) {
        return getAllowedTypesForAdd(regUser, hptCode, "PRS_PROVIDER_CREDENTIAL", "PROVIDER_CREDENTIAL_TYPE_CODE=(.*)", PrsCtProvCredentialTypes.class);
    }

    /**
     * Gets the Expertise Types that the given registry user is allowed to add
     * to a Provider of the given type.
     *
     * @param regUser a registry user. Cannot be null.
     * @param hptCode a provider type. Cannot be null.
     * @return the Expertise Types that the given registry user is allowed to
     * add to a Provider of the given type.
     */
    public List<PrsCtProviderRoleTypes> getExpertiseTypesForAdd(GrsRegistryUsers regUser, PrsCtProviderRoleTypes hptCode) {
        return getAllowedTypesForAdd(regUser, hptCode, "PRS_PROVIDER_EXPERTISE", "PROV_EXPERTISE_ROLE_TYPE_CODE=(.*)", PrsCtProviderRoleTypes.class);
    }

    /**
     * Gets the Telephone Communication Purpose Codes that the given registry
     * user is allowed to add to a Provider of the given type.
     *
     * @param regUser a registry user. Cannot be null.
     * @param hptCode a provider type. Cannot be null.
     * @return the Telephone Communication Purpose Codes that the given registry
     * user is allowed to add to a Provider of the given type.
     */
    public List<PrsCtCommunPurposeTypes> getTelephoneTypesForAdd(GrsRegistryUsers regUser, PrsCtProviderRoleTypes hptCode) {
        return getAllowedTypesForAdd(regUser, hptCode, "GRS_TELEPHONE", "CMNCTN_PRPS_TYP_CD=(.*)", PrsCtCommunPurposeTypes.class);
    }

    /**
     * Gets the record types of the specified table that the given registry user
     * is allowed to add to a Provider of the given type.
     *
     * @param <T> the record type.
     * @param regUser a registry user.
     * @param hptCode a provider type.
     * @param tableName a table name from GRS_CT_DATA_OBJECTS.
     * @param patternString a regex for the format of the
     * GRS_DATA_ELEMENT_PERMISSIONS DECL_CODE column, which specifies
     * RECORD_TYPE=RECORD_VALUE (e.g. CMNCTN_PRPS_TYP_CD=HC).
     * @param clazz the record type.
     * @return the record types that the given registry user is allowed to add
     * to a Provider of the given type.
     */
    private <T> List<T> getAllowedTypesForAdd(GrsRegistryUsers regUser, PrsCtProviderRoleTypes hptCode, String tableName, String patternString, Class<T> clazz) {
        Validate.notNull(regUser);
        Validate.notNull(hptCode);
        Validate.notNull(tableName);
        Validate.notNull(patternString);
        Validate.notNull(clazz);
        List<GrsDataElementPermissions> deps = authorizationService.getDataElementPermissions(regUser, tableName, hptCode);
        Pattern pattern = Pattern.compile(patternString);
        HashSet<String> typeNames = getTypeNamesAllowed(deps, pattern);
        List<T> statusClassCodes = convertTypeNamesToCodes(clazz, typeNames);
        return statusClassCodes;
    }

    private HashSet<String> getTypeNamesAllowed(List<GrsDataElementPermissions> deps, Pattern recordTypePattern) {
        HashSet<String> typeNames = new HashSet<>();
        for (GrsDataElementPermissions dep : deps) {
            String declCode = dep.getDeclCode();
            if (declCode.equals("ANY")) {
                typeNames.add(declCode);
            } else {
                Matcher matcher = recordTypePattern.matcher(declCode);
                matcher.matches();
                typeNames.add(matcher.group(1));
            }
        }
        return typeNames;
    }

    private <T> List<T> convertTypeNamesToCodes(Class<T> clazz, HashSet<String> typeNames) {
        if (typeNames.contains("ANY")) {
            return getAllEntities(clazz);
        } else {
            List<T> types = new ArrayList<>();
            for (String typeName : typeNames) {
                types.add(lookup(clazz, typeName));
            }
            return types;
        }
    }

    private <T> List<T> getAllEntities(Class<T> clazz) {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<T> cq = cb.createQuery(clazz);
        Root<T> rootEntry = cq.from(clazz);
        CriteriaQuery<T> all = cq.select(rootEntry);
        TypedQuery<T> allQuery = em.createQuery(all);
        return allQuery.getResultList();
    }

    /**
     * Returns a sorted list of Language Expertises regardless the provider
     * type.
     *
     * @return a sorted list of Language Expertises regardless the provider type
     */
    public List<PrsCtProvExpertiseTypes> getAllLanguageExpertiseTypes() {

        List<PrsCtProvExpertiseTypes> providerTypeList = prsCtProvExpertiseTypesFacade.findAllLanguageExpertiseTypes();
        Collections.sort(providerTypeList, new LanguageExpertiseTypeComparator());
        return providerTypeList;
    }
    
    /**
     * Returns a list of provider role types that the given registry user is
     * allowed to search and are ORG role types.
     *
     * @param regUser a registry user. Cannot be null.
     * @return a list of provider role types that the given registry user is
     * allowed to add.
     */
    public List<PrsCtProviderRoleTypes> getProviderRoleTypeForSearchORG(GrsRegistryUsers regUser) {
        Validate.notNull(regUser);

        List<PrsCtProviderRoleTypes> allowedProviderTypes = new ArrayList<>();
        List<PrsCtProviderRoleTypes> providerTypes = prsCtProviderRoleTypesFacade.findAll();
        for (PrsCtProviderRoleTypes providerType : providerTypes) {
            if (authorizationService.hasPermissionToSearchProviderOfRoleType(regUser, providerType)
                    && providerType.getPartyType().matches(matchORGString)) {
                allowedProviderTypes.add(providerType);
            }
        }
        return allowedProviderTypes;
    }

}
