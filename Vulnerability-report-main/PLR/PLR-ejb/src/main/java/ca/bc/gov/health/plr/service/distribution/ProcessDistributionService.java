/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.service.distribution;

import ca.bc.gov.health.plr.assembler.ProviderUtil;
import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.DtoCommon;
import ca.bc.gov.health.plr.dto.OwnableDto;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.ejb.entity.GrsAccessProfiles;
import ca.bc.gov.health.plr.ejb.entity.GrsCtBooleanTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsCtDistribOnOperations;
import ca.bc.gov.health.plr.ejb.entity.GrsCtDistribOwnCodes;
import ca.bc.gov.health.plr.ejb.entity.GrsDistribEvent;
import ca.bc.gov.health.plr.ejb.entity.GrsDistribEventItem;
import ca.bc.gov.health.plr.ejb.entity.GrsDistribEventItemTx;
import ca.bc.gov.health.plr.ejb.entity.GrsDistributionProfiles;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.util.EntityUtils;
import ca.bc.gov.health.plr.ejb.session.GrsCtTransactionTypesFacade;
import ca.bc.gov.health.plr.interceptors.TestUserInterceptor;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.rule.provider.AccessRestrictionService;
import ca.bc.gov.health.plr.service.JNDIResourceLoader;
import ca.bc.gov.health.plr.service.PLRConfigurationResourceLoader;
import ca.bc.gov.health.plr.service.provider.security.AuthorizationService;
import ca.bc.gov.health.plr.util.DateUtils;
import static ca.bc.gov.health.plr.util.PropertyUtils.isEmpty;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.ejb.DependsOn;
import javax.ejb.EJB;
import javax.ejb.Singleton;
import javax.ejb.LocalBean;
import javax.ejb.Lock;
import javax.ejb.LockType;
import javax.ejb.Startup;
import javax.inject.Inject;
import javax.interceptor.Interceptors;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.ws.rs.NotFoundException;
import org.apache.commons.lang3.Validate;

/**
 *
 * @author David.Sharpe
 */
@Singleton
@LocalBean
@Startup
@DependsOn("JNDIResourceLoader")
@Interceptors({TestUserInterceptor.class})
public class ProcessDistributionService {

    @Inject
    private Serializer<ProviderDto> distributionDatabaseSerializer;

    @EJB
    private GrsCtTransactionTypesFacade grsCtTransactionTypesFacade;

    private static final Logger LOGGER = Logger.getLogger(ProcessDistributionService.class.getName());

    private final Map<Long, Long> providerIdTracker = new ConcurrentHashMap<>();

    private final ReentrantLock providerIdTrackerLock = new ReentrantLock(true);

    @EJB
    private CodesDao codesDao;

    @Inject
    private JNDIResourceLoader prod;

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;

    @EJB
    private ProviderDtoConverter providerDtoConverter;

    @EJB
    private AuthorizationService authorizationService;

    @EJB
    private AccessRestrictionService accessRestrictionService;

    @Inject
    private PLRConfigurationResourceLoader plrConfigLoader;

    /**
     * Processes distribution for a change made to a provider
     *
     * @param distributableItemWrapper
     * @param requester
     */
    @Lock(LockType.READ)
    public GrsDistribEvent processDistribution(DistributableItemWrapper<PrsProviders> distributableItemWrapper, GrsRegistryUsers requester) {
        GrsDistribEvent distEvent = null;

        try {

            // Process distribution if distribution processing is enabled
            if (isDistributionEnabled()) {
                PrsProviders provider = null;
                try {

                    provider = distributableItemWrapper.getAfterChange();
                    if (provider != null) {
                        try {

                            // busy waiting, until provider in use becomes available
                            while (true) {
                                // obtain exclusive access to providerIdTrackerLock 
                                // to prevent race condition
                                if (!providerIdTrackerLock.isHeldByCurrentThread()) {
                                    providerIdTrackerLock.lock();
                                }

                                // if this provider does not have a distribution processing in progress
                                // then logically lock the provider to ensure any other distribution process
                                // for the same provider has to wait until the current one is done
                                if (!providerIdTracker.containsKey(provider.getPauthId())) {
                                    providerIdTracker.put(provider.getPauthId(), provider.getPauthId());
                                    break;
                                }
                            }

                        } finally {
                            providerIdTrackerLock.unlock();
                        }

                        if (ProviderUtil.isConfidential(provider)) {
                            // If this provider is confidential, we cannot send notification of change
                            return null;
                        }

//                        if (provider.getPartyTypeCode().getCtlNameCode().equals(CodeTableCodes.GrsCtPartyType.ORG.getValue())) {
//                            // PLR-2065: ORG changes are not distributable.
//                            return null;
//                        }
                        List<GrsRegistryUsers> regUsers = findAllWithActiveSubscription();
                        distEvent = makeDistributionEvent(provider, distributableItemWrapper.getChangeType());

                        processDistributableItem(distEvent, distributableItemWrapper, regUsers, requester);

                        // Add distribution to queue
                        sendToQueue(distEvent);
                    }
                } finally {
                    // provider should never be null, unlock provider for the use of other waiting threads
                    if (provider != null) {
                        providerIdTracker.remove(provider.getPauthId());
                    } else {
                        LOGGER.log(Level.SEVERE, "provider should never be null");
                    }
                }
            }
        } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchFieldException ex) {
            LOGGER.log(Level.SEVERE, null, ex);
        }

        return distEvent;
    }

    public boolean isDistributionEnabled() {

        boolean isEnabled;
        try {
            
            isEnabled = Boolean.parseBoolean(plrConfigLoader.getValue(Consts.PROCESS_DISTRIBUTION));
            LOGGER.log(Level.INFO, "ProcessDistributionService isDistributionEnabled is: {0}.", new Object[]{isEnabled});
            
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }

        return isEnabled;
    }

    /**
     * Fetches all registry users with an active subscription
     *
     * @return
     */
    private List<GrsRegistryUsers> findAllWithActiveSubscription() {
        GrsCtBooleanTypes trueCode = codesDao.lookup(GrsCtBooleanTypes.class, CodeTableCodes.GrsCtBooleanTypes.YES);
        return em.createNamedQuery("GrsRegistryUsers.findAllWithActiveSubscription", GrsRegistryUsers.class).setParameter("activeId", trueCode).getResultList();
    }

    private GrsDistribEvent makeDistributionEvent(PrsProviders provider, DistributableItemWrapper.ChangeType changeType) {

        GrsDistribEvent distEvent = new GrsDistribEvent();
        distEvent.setPrsProviders(provider);
        provider.getGrsDistribEventList().add(distEvent);
        distEvent.setGrsDistribEventItemList(new ArrayList<GrsDistribEventItem>());
        distEvent.setCreatedByNm(Consts.SYSTEM_USER);

        if (changeType.equals(DistributableItemWrapper.ChangeType.CREATE_PROVIDER)) {
            distEvent.setChangeType(GrsDistribEvent.ChangeType.CREATE_PROVIDER);
        } else if (changeType.equals(DistributableItemWrapper.ChangeType.UPDATE_PROVIDER)) {
            distEvent.setChangeType(GrsDistribEvent.ChangeType.UPDATE_PROVIDER);
        }

        return distEvent;
    }

    /**
     * Processes each data block change to determine the profiles that should
     * receive information about this change
     *
     * @param distEvent
     * @param distributableItemWrapper
     * @param regUsers
     * @throws NoSuchMethodException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     */
    private void processDistributableItem(GrsDistribEvent distEvent, DistributableItemWrapper<PrsProviders> distributableItemWrapper, List<GrsRegistryUsers> regUsers, GrsRegistryUsers requester) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException {

        PrsProviders provider = distributableItemWrapper.getAfterChange();
        Map<String, GrsAccessProfiles> accessProfileCache = new HashMap<>();

        for (GrsRegistryUsers gUser : regUsers) {

            List<GrsDistributionProfiles> distProfiles = gUser.getGrsDistributionProfilesList();

            for (GrsDistributionProfiles dp : distProfiles) {

                // Only process active subscriptions
                if (EntityUtils.isActive(dp.getActiveFlag()) && dp.getEndReasonCode() == null) {
                    ProviderDto provDetailsAfterChange = providerDtoConverter.toProviderDetails(distributableItemWrapper.getAfterChange(), false);
                    GrsDistribEventItem distEventItem = new GrsDistribEventItem();
                    distEventItem.setCreatedByNm(Consts.SYSTEM_USER);

                    // set the party type
                    if (distributableItemWrapper.getAfterChange().getPartyTypeCode().getCtlNameCode().matches(CodeTableCodes.GrsCtPartyType.ORG.getValue())) {
                        provDetailsAfterChange.setPartyType(CodeTableCodes.GrsCtPartyType.ORG);
                    }
                    if (distributableItemWrapper.getAfterChange().getPartyTypeCode().getCtlNameCode().matches(CodeTableCodes.GrsCtPartyType.IND.getValue())) {
                        provDetailsAfterChange.setPartyType(CodeTableCodes.GrsCtPartyType.IND);
                    }

                    // Filter out fields this profile cannot access
                    applySecurityRulesBeforeChange(distEventItem, dp, distributableItemWrapper);

                    //Run through the changes made, and confirm if this profile attached 
                    //to user being processed is allowed to receive this distribution
                    List<DistributableItemWrapper<?>> subChanges = distributableItemWrapper.getSubChanges();

                    // Used for tracking and grouping future-dated changes for easier processing downstream
                    Map<String, List<FutureDatedChangeHelper>> futureDatedChangesEventItemTracker = new HashMap<>();

                    for (DistributableItemWrapper<?> subChangeItemWrapper : subChanges) {

                        if (shouldSendDistribution(dp, gUser, provider, subChangeItemWrapper, accessProfileCache, requester)) {

                            // Can the subscriber handle future dated changes? If not, set send on date
                            // value to the date change is expected to take effect. This information
                            // will be used later when sending distribution notification to this consumer
                            if (isChangeFutureDated(subChangeItemWrapper.getAfterChange()) && !canHandleFutureDatedChanges(dp)) {

                                FutureDatedChangeHelper changeHelper = new FutureDatedChangeHelper();
                                // we nned to identify and remove this future dated change from ProviderDto 
                                // stored in the main DistributableItemWrapper container i.e. distributableItemWrapper
                                if (removeChangedItem(provDetailsAfterChange, subChangeItemWrapper.getAfterChange(), changeHelper)) {
                                    GrsDistribEventItem futureDated;
                                    String key = getEffectiveStartDate(subChangeItemWrapper.getAfterChange()).toString();
                                    List<FutureDatedChangeHelper> tempTracker = futureDatedChangesEventItemTracker.get(key);
                                    if (tempTracker == null) {
                                        tempTracker = new ArrayList<>();
                                        futureDatedChangesEventItemTracker.put(key, tempTracker);
                                    }

                                    if (tempTracker.isEmpty()) {
                                        futureDated = new GrsDistribEventItem();

                                        futureDated.setBeforeChgMsg(distEventItem.getBeforeChgMsg());
                                        futureDated.setCpdId(new GrsDistributionProfiles(dp.getCdpId()));
                                        futureDated.setSendOnDt(getEffectiveStartDate(subChangeItemWrapper.getAfterChange()));
                                        futureDated.setCreatedByNm(Consts.SYSTEM_USER);

                                    } else {
                                        futureDated = tempTracker.get(0).getEventItem();
                                    }

                                    changeHelper.setEventItem(futureDated);
                                    processSubscription(futureDated, subChangeItemWrapper);

                                    tempTracker.add(changeHelper);
                                }

                            } else {
                                processSubscription(distEventItem, subChangeItemWrapper);
                            }

                        }
                    }

                    // Apply security rules for changes effective immediately
                    // distEventItem may not always be a true distribution; therefore, we need to confirm
                    // that there are changes being tracked in the cutrrent distEventItem instance before
                    // adding it to this distribution
                    if (distEventItem.getGrsDistribEventItemTxList() != null) {
                        applySecurityRulesAfterChange(distEventItem, dp, provDetailsAfterChange, distributableItemWrapper, distEvent);
                    }

                    // Apply security rules for future-dated changes
                    for (List<FutureDatedChangeHelper> groupedChange : futureDatedChangesEventItemTracker.values()) {
                        applySecurityRulesAfterChange(groupedChange, dp, provDetailsAfterChange, distributableItemWrapper, distEvent);
                    }

                }
            }
        }

        // populate place holder with actual managed entities
        if (!distEvent.getGrsDistribEventItemList().isEmpty()) {
            replaceStubEntities(distEvent, provider);
        } else {
            distEvent.setGrsDistribEventItemList(null);
        }

    }

    /**
     * Send distribution event to queue for processing. To avoid complexity the
     * queue is a simple database table that we write into and read from using
     * another thread to decouple preparing and sending distribution
     *
     *
     * @param distEvent
     */
    private void sendToQueue(GrsDistribEvent distEvent) {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        Validator validator = factory.getValidator();

        Set<ConstraintViolation<GrsDistribEvent>> errors = validator.validate(distEvent);
        em.persist(distEvent);
    }

    private ProviderDto applySecurityRulesBeforeChange(GrsDistribEventItem distEventItem, GrsDistributionProfiles dp, DistributableItemWrapper<?> distributableItemWrapper) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException {

        PersonNameComparator personNameComparator = new PersonNameComparator();
        ProviderDto provDetailsBeforeChange = null;

        // Filter out inaccessible fields
        //  restrictAccess(dp, provDetailsAfterChange, (PrsProviders) distributableItemWrapper.getAfterChange());
        // if this subscription wwould like to know 
        // about values before a change was made to 
        // a data block.
        if (priorValuesRequired(dp) && distributableItemWrapper.getBeforeChange() != null) {

            provDetailsBeforeChange = providerDtoConverter.toProviderDetails((PrsProviders) distributableItemWrapper.getBeforeChange(), false);
            // the provDetailsBeforeChange instance we created above has new data instead of old values
            // therefore, we need to reset the changed block back to its prior values
            //  resetChangedDataBlock(provDetailsBeforeChange, distributableItemWrapper.getSubChanges());

            // Remove inaccessible values
            restrictAccess(dp, provDetailsBeforeChange, (PrsProviders) distributableItemWrapper.getBeforeChange());
        }

        // Convert old state to string in preparartion for saving permanently
        if (provDetailsBeforeChange != null && priorValuesRequired(dp)) {
            // Sort person names
            Collections.sort(provDetailsBeforeChange.getIndNames(), personNameComparator);
            distEventItem.setBeforeChgMsg(serialize(provDetailsBeforeChange, dp));
        }

        return provDetailsBeforeChange;
    }

    private ProviderDto applySecurityRulesAfterChange(GrsDistribEventItem distEventItem, GrsDistributionProfiles dp, ProviderDto provDetailsAfterChange, DistributableItemWrapper<?> distributableItemWrapper, GrsDistribEvent distEvent) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException {

        // Filter out inaccessible fields
        restrictAccess(dp, provDetailsAfterChange, (PrsProviders) distributableItemWrapper.getAfterChange());

        // We only want this item sent out as part of a distribution if there is at least one
        // data block that the associated profile can read
        if (!isEmpty(provDetailsAfterChange)) {

            // Sort person names
            PersonNameComparator personNameComparator = new PersonNameComparator();
            Collections.sort(provDetailsAfterChange.getIndNames(), personNameComparator);

            // Convert new state to string in preparartion for saving permanently
            distEventItem.setAfterChgMsg(serialize(provDetailsAfterChange, dp));

            // Link with GrsDistribEvent to maingain entity relationship
            distEvent.getGrsDistribEventItemList().add(distEventItem);
            distEventItem.setDistEventId(distEvent);
            distEventItem.setCpdId(new GrsDistributionProfiles(dp.getCdpId()));
        }

        return provDetailsAfterChange;
    }

    private ProviderDto applySecurityRulesAfterChange(List<FutureDatedChangeHelper> futureDatedChangeHelpers, GrsDistributionProfiles dp, ProviderDto provDetailsAfterChange, DistributableItemWrapper<?> distributableItemWrapper, GrsDistribEvent distEvent) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, NoSuchFieldException {

        if (futureDatedChangeHelpers != null) {

            // We need to insert the these future-dated changes into provDetailsAfterChange
            // all the changes in futureDatedChangeHelpers share have the same effective date
            // and share the same GrsDistribEventItem object thus they can be sent out together
            for (FutureDatedChangeHelper changeHelper : futureDatedChangeHelpers) {

                Field[] fields = provDetailsAfterChange.getClass().getDeclaredFields();

                for (Field f : fields) {

                    // find the field with the matching name. Fields are private; therefore
                    // we had to resort to looping to find the matching one
                    if (f.getName().equals(changeHelper.getPropertyName())) {
                        boolean accessible = f.isAccessible();
                        try {
                            f.setAccessible(true);
                            Object obj = f.get(provDetailsAfterChange);

                            if (obj instanceof List) {
                                ((List) obj).add(changeHelper.getSubChange());
                            } else {
                                f.set(provDetailsAfterChange, changeHelper.getSubChange());
                            }

                        } finally {
                            f.setAccessible(accessible);
                        }

                        break;
                    }

                }

            }

            // Filter out inaccessible fields
            restrictAccess(dp, provDetailsAfterChange, (PrsProviders) distributableItemWrapper.getAfterChange());

            // We only want this item sent out as part of a distribution if there is at least one
            // data block that the associated profile can read
            if (!isEmpty(provDetailsAfterChange)) {

                // Sort person names
                PersonNameComparator personNameComparator = new PersonNameComparator();
                Collections.sort(provDetailsAfterChange.getIndNames(), personNameComparator);

                // Convert new state state to string in preparartion for saving permanently
                futureDatedChangeHelpers.get(0).getEventItem().setAfterChgMsg(serialize(provDetailsAfterChange, dp));

                // Link with GrsDistribEvent to maingain entity relationship
                distEvent.getGrsDistribEventItemList().add(futureDatedChangeHelpers.get(0).getEventItem());
                futureDatedChangeHelpers.get(0).getEventItem().setDistEventId(distEvent);

            }

        }

        return provDetailsAfterChange;
    }

    /**
     * Processes a subscription for notification
     *
     * @param distEventItem
     * @param grsCtTransactionTypes
     */
    private void processSubscription(GrsDistribEventItem distEventItem, DistributableItemWrapper<?> subChangeWrapper) {

        distEventItem.setStatus(GrsDistribEventItem.Status.WAITING_FOR_PROCESSING);

        if (distEventItem.getGrsDistribEventItemTxList() == null) {
            distEventItem.setGrsDistribEventItemTxList(new ArrayList<GrsDistribEventItemTx>());
        }

        GrsDistribEventItemTx txEventItem = new GrsDistribEventItemTx();
        txEventItem.setCreatedByNm(Consts.SYSTEM_USER);
        txEventItem.setTranxType(grsCtTransactionTypesFacade.find(subChangeWrapper.getGrsCtTransactionType().getCtlId()));

        distEventItem.getGrsDistribEventItemTxList().add(txEventItem);
        txEventItem.setDistEventItemId(distEventItem);

        if (subChangeWrapper.getBeforeChange() != null) {
            txEventItem.setBeforeChangeItemId(getId(subChangeWrapper.getBeforeChange()));
        }
        if (subChangeWrapper.getAfterChange() != null) {
            txEventItem.setAfterChangeItemId(getId(subChangeWrapper.getAfterChange()));
        }
        if (subChangeWrapper.getBeforeChange() == null && subChangeWrapper.getAfterChange() == null) {
            throw new IllegalStateException("At least one of before or after change must exist.");
        }
    }

    /**
     * Removes a changed item from the ProviderDto.
     *
     * This is used is situations where a profile cannot handle a future-dated
     * changed to ensure the provider details sent out as part of a distribution
     * to such the owner of such profile does not immediately include the
     * future-dated changed item.
     *
     * @param providerDto
     * @param subChange
     * @throws IllegalArgumentException
     * @throws IllegalAccessException
     */
    private boolean removeChangedItem(ProviderDto providerDto, Object subChange, FutureDatedChangeHelper changeHelper) throws IllegalArgumentException, IllegalAccessException {

        boolean removed = false;
        Class<?> clazz = subChange.getClass();

        Field[] fields = providerDto.getClass().getDeclaredFields();

        for (Field f : fields) {
            boolean accessible = f.isAccessible();
            try {
                f.setAccessible(true);
                Object obj = f.get(providerDto);

                if (obj != null) {
                    if (obj instanceof List) {
                        List<?> temp = (List) obj;
                        if (!temp.isEmpty() && temp.get(0).getClass().equals(clazz)) {

                            temp.remove(subChange);

                            removed = true;
                            changeHelper.setPropertyName(f.getName());
                            changeHelper.setSubChange(subChange);
                            break;
                        }

                    } else if (obj.getClass().equals(clazz)) {
                        f.set(providerDto, null);
                        removed = true;
                        changeHelper.setPropertyName(f.getName());
                        changeHelper.setSubChange(subChange);
                        break;

                    }

                }

            } finally {
                f.setAccessible(accessible);
            }

        }

        return removed;
    }

    /**
     * Replaces stub entities with actual entity prior to persisting to avoid
     * entity manager errors due to partially persisted entity graph
     *
     * @param distEvent
     * @param provider
     */
    private void replaceStubEntities(GrsDistribEvent distEvent, PrsProviders provider) {
        //   distEvent.setPrsProviders(provider);
        //   provider.getGrsDistribEventList().add(distEvent);

        Map<Long, GrsDistributionProfiles> distProfMap = new HashMap<>();
        for (GrsDistribEventItem item : distEvent.getGrsDistribEventItemList()) {

            // Only fetch the distribution profile if this is the first item
            // on the list or the current item uses a distribution profile different 
            // from the last                
            GrsDistributionProfiles temp = distProfMap.get(item.getCpdId().getCdpId());
            if (temp == null) {
                temp = em.find(GrsDistributionProfiles.class, item.getCpdId().getCdpId());
                distProfMap.put(temp.getCdpId(), temp);
            }

            item.setCpdId(temp);
            temp.getGrsDistribEventItemList().add(item);
        }
    }

    /**
     * Checks to confirm if a subscription should be included in a distribution.
     * The checks performed are based on a number of selection in the
     * GrsDistributionProfiles instance for a GrsRegistryUsers
     *
     * @param dp
     * @param changeType
     * @param gUser
     * @param provider
     * @param accessProfileMap
     * @return
     */
    protected boolean shouldSendDistribution(GrsDistributionProfiles dp, GrsRegistryUsers gUser, PrsProviders provider, DistributableItemWrapper<?> distributableItemWrapper, Map<String, GrsAccessProfiles> accessProfileMap, GrsRegistryUsers requester) {

        boolean send = false;

        // Doess the user that owns this subcription has permission to access the changed provider?
        if (authorizationService.getReadableProviderTypes(gUser).contains(provider.getHptCode().getCtlNameCode())
                && canDistributeAfterDate(gUser, provider, distributableItemWrapper, accessProfileMap)) {

            // Is this subscription interested in additions
            // Null transactionType signifies a new provider creation
            if (distributableItemWrapper.getGrsCtTransactionType() != null) {
                if (distributableItemWrapper.getGrsCtTransactionType().getCtlDescTxt().toLowerCase().startsWith("create")) {
                    send = distributeCodesCheck(dp.getDistributeCreatesCode(), gUser, requester);

                } else if (distributableItemWrapper.getGrsCtTransactionType().getCtlDescTxt().toLowerCase().startsWith("update")) {
                    // Is this subscription interested in updates
                    send = distributeCodesCheck(dp.getDistributeUpdatesCode(), gUser, requester);

                }

                // also check the own code
                send = send && distributeCodesCheck(dp.getDistributeOwnCode(), gUser, requester);

            }
        }

        return send;
    }

    /**
     * Checks to see if the effective start date of changed block is after
     * distribute after date before sending
     *
     * @param gUser
     * @param provider
     * @param distributableItemWrapper
     * @param accessProfileMap
     * @return
     */
    private boolean canDistributeAfterDate(GrsRegistryUsers gUser, PrsProviders provider, DistributableItemWrapper<?> distributableItemWrapper, Map<String, GrsAccessProfiles> accessProfileMap) {
        boolean send = false;

        String dataOwner = getDataOwnerCode(distributableItemWrapper.getAfterChange());
        GrsCtBooleanTypes yes = EntityUtils.toGrsCtBooleanType(true, codesDao);

        String key = String.format("%s=%s=%s=%s", gUser.getRuId(), provider.getHptCode().getCtlNameCode(), dataOwner, yes.getCtlId());

        // Fetch if this access profile is not in the cache?
        GrsAccessProfiles accessProfile = accessProfileMap.get(key);
        if (accessProfile == null) {
            //find the accessProfile with most recent distribute date, 
            //if all access profiles have no value for distribution date, return the first one
            List<GrsAccessProfiles> accessProfiles = em.createNamedQuery("GrsAccessProfiles.findByCriteria", GrsAccessProfiles.class)
                    .setParameter("regUser", gUser)
                    .setParameter("providerType", provider.getHptCode().getCtlNameCode())
                    .setParameter("dataOwner", dataOwner)
                    .setParameter("active", yes).getResultList();
            if (accessProfiles != null && !accessProfiles.isEmpty()) {
                Date mostRecentDistributeAfterDate = null;
                for (GrsAccessProfiles tmpAccessProfile : accessProfiles) {
                    Date tmpDistributeAfterDate = tmpAccessProfile.getDistributeAfterDate();
                    if (tmpDistributeAfterDate != null) {
                        if (mostRecentDistributeAfterDate == null) {
                            mostRecentDistributeAfterDate = tmpDistributeAfterDate;
                            accessProfile = tmpAccessProfile;
                        } else {
                            if (tmpDistributeAfterDate.after(mostRecentDistributeAfterDate)) {
                                mostRecentDistributeAfterDate = tmpDistributeAfterDate;
                                accessProfile = tmpAccessProfile;
                            }
                        }
                    }
                }
                if (accessProfile == null) {
                    accessProfile = accessProfiles.get(0);
                    accessProfileMap.put(key, accessProfile);
                }
            }

        }

        if (accessProfile != null) {

            if (accessProfile.getDistributeAfterDate() == null) {
                //if accessProfile has no distribution after date, set send to true;
                send = true;
            } else {
                //if accessProfile has distribution after date, compare it with effective start date
                Date effectiveStartTime = getEffectiveStartDate(distributableItemWrapper.getAfterChange());
                if (effectiveStartTime != null) {
                    Calendar effectiveStartCalendar = Calendar.getInstance();
                    effectiveStartCalendar.setTime(effectiveStartTime);
                    DateUtils.truncateTime(effectiveStartCalendar);

                    Calendar distributionAfterCalendar = Calendar.getInstance();
                    distributionAfterCalendar.setTime(accessProfile.getDistributeAfterDate());
                    DateUtils.truncateTime(distributionAfterCalendar);

                    //only send if effective start date is after the distribution after date
                    if (effectiveStartCalendar.after(distributionAfterCalendar)) {
                        send = true;
                    }
                }
            }

        }

        return send;
    }

    /**
     * Checks to confirm if this subscription profile would like to be notified
     * of the change (Add/Update)that took place based on whether they would
     * like to know about their own, others or all changes
     *
     * @param grsCtDistribOwnCode
     * @param gUser
     * @return
     */
    protected boolean distributeCodesCheck(GrsCtDistribOwnCodes grsCtDistribOwnCode, GrsRegistryUsers gUser, GrsRegistryUsers requester) {
        return grsCtDistribOwnCode.getCtlNameCode().equals(CodeTableCodes.GrsCtDistribOwnCodes.ALL.getValue())
                || (grsCtDistribOwnCode.getCtlNameCode().equals(CodeTableCodes.GrsCtDistribOwnCodes.OTHER.getValue()) && !requester.getRuId().equals(gUser.getRuId()))
                || (grsCtDistribOwnCode.getCtlNameCode().equals(CodeTableCodes.GrsCtDistribOwnCodes.OWN.getValue()) && requester.getRuId().equals(gUser.getRuId()));
    }

    /**
     * Checks to confirm if this subscription profile would like to be notified
     * of the change (Add/Update)that took place based on whether they would
     * like to know about their own, others or all changes
     *
     * @param grsCtDistribOwnCode
     * @param gUser
     * @return
     */
    protected boolean distributeCodesCheck(GrsCtDistribOnOperations grsCtDistribOnOperation, GrsRegistryUsers gUser, GrsRegistryUsers requester) {
        return grsCtDistribOnOperation.getCtlNameCode().equals(CodeTableCodes.GrsCtDistribOnOperations.ALL.getValue())
                || (grsCtDistribOnOperation.getCtlNameCode().equals(CodeTableCodes.GrsCtDistribOnOperations.NOT_RELATED.getValue()) && !requester.getRuId().equals(gUser.getRuId()))
                || (grsCtDistribOnOperation.getCtlNameCode().equals(CodeTableCodes.GrsCtDistribOnOperations.RELATED.getValue()) && requester.getRuId().equals(gUser.getRuId()));
    }

    /**
     * Filter out fields that the distribution profile is not allowed to read.
     * And apply column restriction to ProviderDto
     *
     * @param dp
     * @param providerDetails
     * @param provider
     */
    private void restrictAccess(GrsDistributionProfiles dp, ProviderDto providerDetails, PrsProviders provider) {
        try {
            accessRestrictionService.populateReadRestrictions(providerDetails, provider, dp.getRuRuId());
            accessRestrictionService.populateColumnRestrictions(providerDetails, provider.getHptCode(), dp.getRuRuId(), true);
        } catch (Exception ex) {
            LOGGER.log(Level.WARNING, null, ex);
        }
    }

    /**
     * Is change future-dated
     *
     * @param afterChange
     * @return
     */
    private boolean isChangeFutureDated(Object afterChange) {
        Date effdate = getEffectiveStartDate(afterChange);
        return effdate != null && DateUtils.isFuture(effdate);
    }

    private Date getEffectiveStartDate(Object dataBlock) {
        // determine if this is one of the standard darad blocks
        // or it is WorkLocationDto. WorkLocationDto has no 
        // effective start date so we return null
        if (dataBlock instanceof DtoCommon) {
            return ((DtoCommon) dataBlock).getEffectiveStartDate();
        } else if (dataBlock instanceof WorkLocationDto) {
            return null;
        }
        LOGGER.log(Level.SEVERE, "Unrecognized distribution object: '{0}'", dataBlock);
        return null;
    }

    /**
     * Checks whether an instance of GrsDistributionProfiles can handle
     * future-dated changes
     *
     * @param dp
     * @return
     */
    private boolean canHandleFutureDatedChanges(GrsDistributionProfiles dp) {
        return EntityUtils.isActive(dp.getFutureDatedUpdatesFlag());
    }

    // check to determine if prior values are required
    private boolean priorValuesRequired(GrsDistributionProfiles dp) {
        return dp.getOptionCode().getCtlNameCode().equals(CodeTableCodes.GrsCtOptionCodes.PRIOR_VALUES.getValue());
    }

    private Long getId(Object dataBlock) {
        Validate.notNull(dataBlock);
        if (dataBlock instanceof ca.bc.gov.health.plr.dto.DtoMetaData) {
            return ((ca.bc.gov.health.plr.dto.DtoMetaData) dataBlock).getId();
        } else if (dataBlock instanceof WorkLocationDto) {
            return ((WorkLocationDto) dataBlock).getId();
        } else {
            LOGGER.log(Level.SEVERE, "Unrecognized distribution object: " + dataBlock);
            throw new IllegalArgumentException("dataBlock must be instanceof DtoMetaData or WorkLocationDto. Check log.");
        }
    }

    private String getDataOwnerCode(Object dataBlock) {
        if (dataBlock instanceof OwnableDto) {
            return ((OwnableDto) dataBlock).getDataOwnerCode();
        } else if (dataBlock instanceof WorkLocationDto) {
            return ((WorkLocationDto) dataBlock).getDataOwnerCode();
        } else {
            LOGGER.log(Level.SEVERE, "Unrecognized distribution object: " + dataBlock);
            throw new IllegalArgumentException("dataBlock must be instanceof DtoMetaData or WorkLocationDto. Check log.");
        }

    }

    private String serialize(ProviderDto entity, GrsDistributionProfiles dp) {

        if (EntityUtils.isActive(dp.getTextCaseCode())) {
            return distributionDatabaseSerializer.serialize(entity, Serializer.Options.CONVERT_STRING_VALS_TO_UPPERCASE);
        }

        return distributionDatabaseSerializer.serialize(entity);
    }
}
