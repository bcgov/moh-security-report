
package ca.bc.gov.health.plr.dto.provider;

import ca.bc.gov.health.plr.dto.MessageDataBlockDto;
import ca.bc.gov.health.plr.dto.businesskey.TypeAndDataOwnerBK;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.ejb.entity.PrsCtWorkLocationPurps;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocationDetails;
import ca.bc.gov.health.plr.rule.provider.AcceptableAnyField;
import ca.bc.gov.health.plr.rule.provider.AcceptableCodeName;
import ca.bc.gov.health.plr.util.DateUtils;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.lang3.StringUtils;
import javax.validation.constraints.NotBlank;

/**
 *
 * @author David Sharpe <david.a.sharpe@cgi.com>
 */
public class WorkLocationDetailsDto extends AbstractProviderDetail implements MessageDataBlockDto, Comparable<WorkLocationDetailsDto> {

    private static String[] MESSAGE_DATA_BLOCK_DTO = new String[]{};
    
    private Long wlWlId;
    @NotBlank(message = "{error.notblank.part1of2}Work Location Name {error.notblank.part2of2}")
    @AcceptableAnyField( message = "{error.anyfield.invalidcharacters.part1of2} 'Work Location Name' {error.anyfield.invalidcharacters.part2of2}")
    @Size(max = 255, message = "{constraints.size.message.part1of2} 'Work Location Name' {constraints.size.message.part2of2}")
    private String name;
    @AcceptableAnyField( message = "{error.anyfield.invalidcharacters.part1of2} 'Additional Address Info' {error.anyfield.invalidcharacters.part2of2}")
    @Size(max = 240, message = "{constraints.size.message.part1of2} 'Additional Address Info' {constraints.size.message.part2of2}")
    private String additionalAddresseeInfo;
    private boolean defaultFlag = false;
    
    @AcceptableCodeName(clazz = PrsCtWorkLocationPurps.class, code = "Work Location Purpose")
    private String typeCode;
    @NotNull(message = "{error.notblank.part1of2} Work Location Detail Effective Start Date {error.notblank.part2of2}")
    private Date effectiveStartDate;
    private Date effectiveEndDate;
    private Long typeId;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        name = StringUtils.stripAccents(name);
        name = StringUtils.strip(name);
        this.name = name;
    }

    public String getAdditionalAddresseeInfo() {
        return additionalAddresseeInfo;
    }

    public void setAdditionalAddresseeInfo(String additionalAddresseeInfo) {
        additionalAddresseeInfo = StringUtils.stripAccents(additionalAddresseeInfo);
        additionalAddresseeInfo = StringUtils.strip(additionalAddresseeInfo);
        this.additionalAddresseeInfo = additionalAddresseeInfo;
    }

    public boolean isDefaultFlag() {
        return defaultFlag;
    }

    public void setDefaultFlag(boolean defaultFlag) {
        this.defaultFlag = defaultFlag;
    }

    public Long getWlWlId() {
        return wlWlId;
    }

    public void setWlWlId(Long wlWlId) {
        this.wlWlId = wlWlId;
    }
    
    @Override
    public ca.bc.gov.health.plr.dto.provider.esb.AbstractProviderDetail toEsbVersion() throws Exception {  
        ca.bc.gov.health.plr.dto.provider.esb.WorkLocationDetailsDto esbVersion = new ca.bc.gov.health.plr.dto.provider.esb.WorkLocationDetailsDto();        
        
        PropertyUtils.copyProperties(esbVersion, this);
        
        return esbVersion;

    }

    @Override
    public String getTypeCode() {
        return typeCode;
    }

    @Override
    public void setTypeCode(String typeCode) {
        this.typeCode = typeCode;
    }
    @Override
    public String getBlockName() {
        return "Work Location Details";
    }

    /**
     * @return the effectiveStartDate
     */
    @Override
    public Date getEffectiveStartDate() {
        return effectiveStartDate;
    }

    /**
     * @param effectiveStartDate the effectiveStartDate to set
     */
    @Override
    public void setEffectiveStartDate(Date effectiveStartDate) {
        this.effectiveStartDate = effectiveStartDate;
    }

    @Override
    public Date getEffectiveEndDate() {
        return effectiveEndDate;
    }

    @Override
    public void setEffectiveEndDate(Date effectiveEndDate) {
        this.effectiveEndDate = effectiveEndDate;
    }

    public Long getTypeId() {
        return typeId;
    }

    public void setTypeId(Long typeId) {
        this.typeId = typeId;
    }

    @Override
    public void addToProviderDto(ProviderDto providerDto) {
        /* 
        How to know which Work Location to add it to? Probably we need to find
        the "active" one, but maybe not!
            
        This abstract method is used to process distributions. It was added
        to fix PLR-1594, "Distributions - CHANGED ONLY", but at this time 
        distributing work locations is already broken. The issue has been
        reported as PLR-1617, and its too big to fix concurrently with PLR-1594.
         */
        throw new UnsupportedOperationException("Not supported yet.");
    }
    
    @Override
    public Class getEntityClass() {
        return PrsWorkLocationDetails.class;
    }
    
    @Override
    public Method getDtoConverterMethod() {
        Method method = null;
        try {
            method = ProviderDtoConverter.class.getMethod("buildWorkLocationDetail", PrsWorkLocationDetails.class);
        } catch (NoSuchMethodException | SecurityException ex) {
            Logger.getLogger(AddressDto.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        // return null is OK
        return method;
    }

    @Override
    public String[] getMessageDataBlockFields() {
        return MESSAGE_DATA_BLOCK_DTO;
    }
    
    @Override
    public int compareTo(WorkLocationDetailsDto otherDto) {
        int keyCompareResult = ca.bc.gov.health.plr.util.PropertyUtils.compareString(this.getTypeCode(), otherDto.getTypeCode());
        if (keyCompareResult != 0) {
            return keyCompareResult;
        }
        keyCompareResult = ca.bc.gov.health.plr.util.PropertyUtils.compareString(this.getDataOwnerCode(), otherDto.getDataOwnerCode());
        if (keyCompareResult != 0) {
            return keyCompareResult;
        }
        keyCompareResult =  DateUtils.compareEffectiveStartAndCreatedDates(this.getEffectiveStartDate(), otherDto.getEffectiveStartDate(), this.getCreatedDate(), otherDto.getCreatedDate());
        if(keyCompareResult != 0) {
            return keyCompareResult;
        }
        return ca.bc.gov.health.plr.util.PropertyUtils.compareString(this.getEndReasonCode(), otherDto.getEndReasonCode());
    }    
    
   /**
    * Limit the size of input list of WorkLocationDetailsDto to be less or equals to maxBusinessObjectShown
    * @param inList - the list of WorkLocationDetailsDto
    * @param maxBusinessObjectShown int
    * @return the list of WorkLocationDetailsDto, it's size is less or equals to maxBusinessObjectShown
    */
   public static List<WorkLocationDetailsDto> limitDtoListBasedOnBK(List<WorkLocationDetailsDto> inList, int maxBusinessObjectShown) {
        if(inList==null) {
            return null;
        } else if(inList.size()<=maxBusinessObjectShown) {
            return inList; 
        }        
        //find all business key objects
        List<TypeAndDataOwnerBK> bKeyList = new ArrayList<>();
        for(WorkLocationDetailsDto t : inList) {
            TypeAndDataOwnerBK bk = new TypeAndDataOwnerBK(t.getTypeCode(), t.getDataOwnerCode());
            if(!bKeyList.contains(bk)) {
                bKeyList.add(bk);
            }
        }
        
        //go through each business key object and find all matching dtos
        List<WorkLocationDetailsDto> allList = new ArrayList<>();
        for(TypeAndDataOwnerBK bk : bKeyList) {
            List<WorkLocationDetailsDto> tmpList = new ArrayList<>();
            for(WorkLocationDetailsDto t : inList) {
                TypeAndDataOwnerBK bkFromDto = new TypeAndDataOwnerBK(t.getTypeCode(), t.getDataOwnerCode());
                if(bk.equals(bkFromDto)) {
                    tmpList.add(t);
                }
            }
            //only keep first maxBusinessObjectShown dtos
            if(tmpList.size()>maxBusinessObjectShown) {
                tmpList = tmpList.subList(0, maxBusinessObjectShown);
            }
            if(!tmpList.isEmpty()) {
                allList.addAll(tmpList);
            }
        }
        
        return allList;
        
    }    
    
    
}
