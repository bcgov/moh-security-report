package ca.bc.gov.health.plr.service.distribution;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.esb.DistributionProfileType;
import ca.bc.gov.health.plr.dto.esb.DistributionNotification;
import ca.bc.gov.health.plr.dto.provider.AddressDto;
import ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.ElectronicAddressDto;
import ca.bc.gov.health.plr.dto.provider.InformationRouteDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.TelecommunicationDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDetailsDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.dto.provider.esb.DistributionChangeType;
import ca.bc.gov.health.plr.dto.reguser.AccessProfileDto;
import ca.bc.gov.health.plr.dto.reguser.RegistryUserDetailsConverter;
import ca.bc.gov.health.plr.ejb.entity.GrsAccessProfiles;
import ca.bc.gov.health.plr.ejb.entity.GrsCtBooleanTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsCtTransactionTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsDistribEvent;
import ca.bc.gov.health.plr.ejb.entity.GrsDistribEventItem;
import ca.bc.gov.health.plr.ejb.entity.GrsDistribEventItemTx;
import ca.bc.gov.health.plr.ejb.entity.GrsDistributionProfiles;
import ca.bc.gov.health.plr.ejb.entity.util.EntityUtils;
import ca.bc.gov.health.plr.interceptors.TestUserInterceptor;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.persistence.ConfigurationDao;
import ca.bc.gov.health.plr.service.JNDIResourceLoader;
import ca.bc.gov.health.plr.service.PLRConfigurationResourceLoader;
import ca.bc.gov.health.plr.service.remote.MaintainProviderEsbService;
import ca.bc.gov.health.plr.util.DateUtils;
import ca.bc.gov.health.plr.util.EsbMessageUtil;
import ca.bc.gov.health.plr.util.PropertyUtils;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.ejb.DependsOn;
import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Schedule;
import javax.ejb.ScheduleExpression;
import javax.ejb.Singleton;
import javax.ejb.Startup;
import javax.ejb.Timeout;
import javax.ejb.Timer;
import javax.ejb.TimerConfig;
import javax.ejb.TimerService;
import javax.inject.Inject;
import javax.interceptor.Interceptors;
import javax.naming.NamingException;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;

/**
 * Responsible for sending distribution messages to the ESB service.
 *
 * @author adebiyi.kuseju
 */
@Singleton
@Startup
@DependsOn("JNDIResourceLoader")
@Interceptors({TestUserInterceptor.class})
@LocalBean
public class SendDistributionService {

    private static final Logger LOGGER = Logger.getLogger(SendDistributionService.class.getName());

    @Inject
    private Serializer<ProviderDto> distributionDatabaseSerializer;

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;

    @EJB
    private JNDIResourceLoader prod;

    @EJB
    private EsbMessageUtil esbMessageUtil;

    @EJB
    private ConfigurationDao configurationDao;

    @EJB
    private UpdateDistributionStatusService_HelperSynchronized updateDistributionStatusService_HelperSynchronized;

    @EJB
    private CodesDao codesDao;

    @EJB
    private RegistryUserDetailsConverter registryUserDetailsConverter;

    private Map<String, String> appProperties;

    private boolean distributionEnabledLastCheck;

    private boolean sendDistributionLastCheck;

    @Resource
    private TimerService timerService;

    private Timer timerRef;

    @Inject
    private RestClient restClient;

    @Inject
    private PLRConfigurationResourceLoader plrConfigLoader;
    
    private boolean isSendDistribEnabled;
    
    private boolean isProcessDistribEnabled;

    @PostConstruct
    void init() {
        try {
            // Used a method instead to force a reload of resource
            // to ensure updates are detected
            appProperties = prod.appResource();

            // turn this flags to help with initial checks and warning
            // for processing and sending distribution messages to ESB
            distributionEnabledLastCheck = true;
            sendDistributionLastCheck = true;
            isSendDistribEnabled = true;
            isProcessDistribEnabled = true;
            
        } catch (NamingException ex) {
            Logger.getLogger(SendDistributionService.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * Recreate programmatic timer for distribution notification processing
     *
     */
    @Schedule(hour = "*", minute = "*", second = "*/10", info = "Load distribution schedule")
    void reload() {

        try {
            appProperties = prod.appResource();

            // Check and warn if distribution processing has been disabled since the last check
            boolean currentCheck = isDistributionEnabled();
            if (!currentCheck && distributionEnabledLastCheck) {
                LOGGER.log(Level.WARNING, "Processing and queueing distribution messages is disabled");
            }
            distributionEnabledLastCheck = currentCheck;

            // Check and warn if sending distribution to ESB has been disabled since the last check
            currentCheck = isSendEnabled();
            if (!currentCheck && sendDistributionLastCheck) {
                LOGGER.log(Level.WARNING, "Sending distribution messages to ESB is disabled");
            }
            sendDistributionLastCheck = currentCheck;

            // Is sending distribution enabled
            if (sendDistributionLastCheck) {

                String scheduleStr = appProperties.get(Consts.DISTRIBUTION_SCHEDULE);
                String[] cronTokens = scheduleStr.trim().split(" ");

                // Is the schedule string provided
                if (StringUtils.isNotBlank(scheduleStr)) {

                    if (timerRef != null) {
                        cronTokens = scheduleStr.trim().split(" ");
                        //if a new schedule string has been provided cancel the existing timer; otherwise, do nothing                        
                        if (!String.format("%s %s %s", timerRef.getSchedule().getSecond(), timerRef.getSchedule().getMinute(), timerRef.getSchedule().getHour())
                                .equalsIgnoreCase(scheduleStr)) {
                            LOGGER.log(Level.WARNING, "Detected a change in distribution schedule, applying new schedule value");
                            timerRef.cancel();
                            timerRef = createTimer(cronTokens);
                        }
                    } else {
                        timerRef = createTimer(cronTokens);
                    }

                } else {
                    LOGGER.log(Level.WARNING, String.format("Sending distribution messages is enabled, but '%s' not set", Consts.DISTRIBUTION_SCHEDULE));
                }

            }

        } catch (NamingException nme) {
            LOGGER.log(Level.SEVERE, "'" + Consts.APP_JNDI_RESOURCE + "' resource cannot be located", nme);
        }
    }

    /**
     * Cleans up completed distribution messages after a specified retention
     * period
     */
    @Schedule(hour = "2", info = "Delete completed distributions")
    void cleanupOldData() {

        String durationStr = appProperties.get(Consts.DISTRIBUTION_RETENTION_DURATION);

        int duration;

        try {
            duration = Integer.parseInt(durationStr);

            Calendar cal = Calendar.getInstance();
            cal.add(Calendar.DAY_OF_MONTH, -duration);

            // Remove time portion
            DateUtils.truncateTime(cal);

            if (duration > 0) {

                // Delete all completed messages that are older than cal date value
                int distItem = em.createNamedQuery("GrsDistribEventItem.deleteByDuration")
                        .setParameter("status", GrsDistribEventItem.Status.COMPLETED)
                        .setParameter("durationInDate", cal.getTime()).executeUpdate();

                // Delete all that have no children
                //    int distItem = em.createNamedQuery("GrsDistribEventItem.deleteByNoChildren").executeUpdate();
                // Delete all that have no children
                int distEvent = em.createNamedQuery("GrsDistribEvent.deleteByNoChildren").executeUpdate();

                if (distItem != 0 || distEvent != 0) {
                    LOGGER.log(Level.INFO, String.format("Deleted %s and %s records from GrsDistribEventItem and GrsDistribEvent respectively", distItem, distEvent));
                }
            }

        } catch (NumberFormatException e) {
            LOGGER.log(Level.SEVERE, null, e);
        }

    }

    /*
     populates the metatdata for the DistributionNotification EsbMessage
     */
    private void populateMetadata(DistributionNotification distMessage, GrsDistributionProfiles dp) {
        try {
            esbMessageUtil.populateMetadataForDistribution(distMessage);
            distMessage.setDestinationAddress(dp.getTransmissionAddressTxt());
            distMessage.setIsHail(EntityUtils.booleanValue(dp.getHial()));
            distMessage.setTargetNetworkAddressChid(dp.getTransmissionAddressTxt());
            distMessage.setProfileType(fromCtlNameCode(dp.getDptCode().getCtlNameCode()));
            distMessage.setRelease(dp.getDistributionProfileChid());
        } catch (Exception ex) {
            Logger.getLogger(SendDistributionService.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private static DistributionProfileType fromCtlNameCode(String ctlNameCode) {
        if (ctlNameCode.equals(CodeTableCodes.GrsCtDistribProfileTypes.HL7V3.getValue())) {
            return DistributionProfileType.HL7;
        } else if (ctlNameCode.equals(CodeTableCodes.GrsCtDistribProfileTypes.PRSXML.getValue())) {
            return DistributionProfileType.PRSXML;
        } else {
            throw new IllegalArgumentException(ctlNameCode);
        }
    }

    private long fetchAttemptsCount = 0;

    /**
     * Fetch and send next distribution subscription
     */
    @Timeout
    void fetchAndSendDistribution(final Timer timer) throws Exception {

        // if send is not enabled, then just return
        if (!isSendEnabled()) {
            return;
        }

        fetchAttemptsCount++;

        if (fetchAttemptsCount % 30 == 0) {
            LOGGER.log(Level.INFO, "Fetching notifications from queue (showing every 30 fetches).");
            fetchAttemptsCount = 0;
        }

        // Find all items on the queue that can be processed
        TypedQuery<GrsDistribEventItem> query = em.createNamedQuery("GrsDistribEventItem.findAllByCriteria", GrsDistribEventItem.class);

        List<GrsDistribEventItem> result = query.getResultList();
        LOGGER.info("Processing GrsDistribEventItem:");
        for (GrsDistribEventItem grsDistribEventItem : result) {
            LOGGER.info(grsDistribEventItem.toString());
        }

        Map<Long, Long> tracker = new HashMap<>();

        for (GrsDistribEventItem item : result) {

            // If the profile associated with this notification is not been tracked yet, 
            // then it must be the notification for this subscriber on the queue.
            // Note: the key in the tracker points to nothing
            if (!tracker.containsKey(item.getCpdId().getCdpId())) {

                // Do not send if distribution is paused (on hold) for this profile
                // and if this change that triggered this distribution is future-dated
                // then don't send if current date is before the sendOnDt value
                if (!EntityUtils.isActive(item.getCpdId().getEditransmissionHoldFlag())
                        && canHandleFutureDated(item.getCpdId(), item.getSendOnDt())) {
                    //send distribution
                    LOGGER.log(Level.FINEST, String.format("Processing distribution message %s", item.getDistEventItemId()));
                    tracker.put(item.getCpdId().getCdpId(), null);
                    send(item);
                }
            }
        }
    }

    /**
     * Sends notification to consumer
     *
     * @param notification
     */
    private void send(GrsDistribEventItem eventItem) throws Exception {
        // PLR-2137 Prepare distibution notification object first which would remove the inactive records.
        DistributionNotification notification = prepareDistributionMessage(eventItem);
        //PLR-2137 - if there are no changes to distribute, then skip sending the distribution.
        if (isDistributionEmpty(notification, eventItem)) {
            LOGGER.log(Level.INFO, String.format("Empty distribution, SKIPPING id: " + eventItem.getDistEventId().getDistEventId()));
            updateDistributionStatusService_HelperSynchronized.writeDistribEventItemStatus(eventItem.getDistEventItemId(), GrsDistribEventItem.Status.SKIPPED);
            return;
        }

        if (notification != null) {
            LOGGER.log(Level.FINE, String.format("Sending distribution notification to ESB: ", notification));
            updateDistributionStatusService_HelperSynchronized.writeDistribEventItemStatus(eventItem.getDistEventItemId(), GrsDistribEventItem.Status.IN_PROGRESS);
            try {
                restClient.post(notification);
            } catch (RuntimeException e) {
                Throwable cause = e;
                while (cause.getCause() != null) {
                    cause = cause.getCause();
                }
                LOGGER.log(Level.WARNING, "Distribution notification to ESB failed for id [{0}]: {1}. Status reset to WAITING_FOR_PROCESSING", new Object[]{eventItem.getDistEventItemId(), cause.getMessage()});
                updateDistributionStatusService_HelperSynchronized.writeDistribEventItemStatus(eventItem.getDistEventItemId(), GrsDistribEventItem.Status.WAITING_FOR_PROCESSING);
            }
        }
    }

    /**
     * Prepares a distribution message from an instance of DistributionEventItem
     * taken from the front of the queue REQ-560
     *
     * @param eventItem
     * @return
     */
    private DistributionNotification prepareDistributionMessage(GrsDistribEventItem eventItem) throws Exception {

        DistributionNotification distMessage = new DistributionNotification(eventItem.getDistEventItemId().toString());

        setChangeType(distMessage, eventItem.getDistEventId().getChangeType());

        ProviderDto esbProviderDetails = distributionDatabaseSerializer.deserialize(eventItem.getAfterChgMsg(), ProviderDto.class);
        distMessage.setMessageInteractionId(configurationDao.getMessageInteractionId(distMessage.getChangeType(), esbProviderDetails.getPartyType()));

        //Filter out any blocks which are not active
        //PLR-2137 Moving this filtering as it needs to be applicable for all types of distribution
        esbMessageUtil.filterInactiveItems(esbProviderDetails);

        if (changedItemOnlyRequired(eventItem.getCpdId())) {
            ProviderDto providerDto = new ProviderDto();
            providerDto.setType(esbProviderDetails.getType());
            providerDto.setTypeId(esbProviderDetails.getTypeId());
            providerDto.setProviderRoleTypeCode(esbProviderDetails.getProviderRoleTypeCode());
            for (GrsDistribEventItemTx tx : eventItem.getGrsDistribEventItemTxList()) {
                addDataItemsForBlock(esbProviderDetails, providerDto, tx);
            }
            //Only add active IDs
            for (CollegeIdentifierDto id : esbProviderDetails.getIdentifiers()) {
                if (EntityUtils.isActiveForResponseOrDistribution(id.isActive(), id.getEndReasonCode(), id.getInvalidatedDate(), id.getEffectiveStartDate(), id.getEffectiveEndDate())) {
                    if (!providerDto.getIdentifiers().contains(id)) {
                        providerDto.getIdentifiers().add(id);
                    }
                }
            }
            distMessage.setProviderDetails(providerDto.toEsbVersion());
        } else if (entireRecordRequired(eventItem.getCpdId())) {
            filterWorkLocationsWithNoDetails(esbProviderDetails);
            filterForDistributeAfterDate(eventItem, esbProviderDetails);
            //PLR-2176 Filter out blocks with effective start date in future if distribution profile cannot handle future updates
            filterOutFutureEffectiveBlocks(eventItem.getCpdId(), esbProviderDetails);
            // Add the updated provider details
            distMessage.setProviderDetails(esbProviderDetails.toEsbVersion());
        } else {
            throw new UnsupportedOperationException(eventItem.getCpdId().getOptionCode().getCtlNameCode());
        }

        // Only send if the last message did not fail or currently being processed by ESB service                   
        if (!eventItem.getStatus().equals(GrsDistribEventItem.Status.FAILED)
                && !eventItem.getStatus().equals(GrsDistribEventItem.Status.IN_PROGRESS)) {

            // If this change is future dated, only send if SEND_ON_DT value is today or the related profile
            // can handle future-dated changes.  
            // Note: SEND_ON_DT is only populated if the profile (subscriber) cannot handle future-dated changes
            if (EntityUtils.isActive(eventItem.getCpdId().getFutureDatedUpdatesFlag()) || eventItem.getSendOnDt() == null || (eventItem.getSendOnDt() != null && DateUtils.isPresent(eventItem.getSendOnDt()))) {
                //send distribution
                LOGGER.log(Level.FINEST, String.format("Processing distribution message %s", eventItem.getDistEventItemId()));

                // Add all the trasanctions tracked by this distribution to the notification message
                // to be sent to ESB for processing
                for (GrsDistribEventItemTx txType : eventItem.getGrsDistribEventItemTxList()) {
                    distMessage.getTransactionType().add(txType.getTranxType().getCtlNameCode());
                }
            }
        } else {
            // Nothing to send as a message to this destination is in progress already or failed
            distMessage = null;
        }

        if (distMessage != null) {
            populateMetadata(distMessage, eventItem.getCpdId());
        }

        return distMessage;
    }

    private void filterForDistributeAfterDate(GrsDistribEventItem eventItem, ProviderDto esbProviderDetails) {
        //filter out the items having effective start data later than distribute after date
        GrsCtBooleanTypes yes = EntityUtils.toGrsCtBooleanType(true, codesDao);
        List<GrsAccessProfiles> accessProfiles = em.createNamedQuery("GrsAccessProfiles.findByRegistryUserProviderRoleType", GrsAccessProfiles.class)
                .setParameter("regUser", eventItem.getCpdId().getRuRuId())
                .setParameter("providerType", esbProviderDetails.getTypeId())
                .setParameter("active", yes).getResultList();
        if (accessProfiles != null && !accessProfiles.isEmpty()) {
            List<AccessProfileDto> accessProfileDtoList = new ArrayList<>();
            for (GrsAccessProfiles grsAccessProfile : accessProfiles) {
                if (grsAccessProfile.getDistributeAfterDate() != null) {
                    AccessProfileDto apDto = this.registryUserDetailsConverter.buildAccessProfile(grsAccessProfile);
                    accessProfileDtoList.add(apDto);
                }
            }
            if (!accessProfileDtoList.isEmpty()) {
                esbProviderDetails.removeEffectiveStartDateBeforeDistAfterDate(accessProfileDtoList);
            }
        }
    }

    // PLR-2126. Work Locations may be "active" but contain no active Work Location Details, but without Details it fails schema validation.
    private void filterWorkLocationsWithNoDetails(ProviderDto esbProviderDetails) {
        for (Iterator<WorkLocationDto> it = esbProviderDetails.getWorkLocationList().iterator(); it.hasNext();) {
            if (CollectionUtils.isEmpty(it.next().getWorkLocationDetails())) {
                it.remove();
            }
        }
    }

    private void setChangeType(DistributionNotification distMessage, GrsDistribEvent.ChangeType changeType) {

        if (changeType.equals(GrsDistribEvent.ChangeType.CREATE_PROVIDER)) {
            distMessage.setChangeType(DistributionChangeType.ADD);
        } else if (changeType.equals(GrsDistribEvent.ChangeType.UPDATE_PROVIDER)) {
            distMessage.setChangeType(DistributionChangeType.UPDATE);
        }
    }

    private boolean canHandleFutureDated(GrsDistributionProfiles prof, Date sendOnDt) {
        return EntityUtils.isActive(prof.getFutureDatedUpdatesFlag())
                || sendOnDt == null || DateUtils.isPresent(sendOnDt) || DateUtils.isPast(sendOnDt);
    }

    private boolean changedItemOnlyRequired(GrsDistributionProfiles dp) {
        return dp.getOptionCode().getCtlNameCode().equals(CodeTableCodes.GrsCtOptionCodes.CHANGED_ONLY.getValue());
    }

    private boolean entireRecordRequired(GrsDistributionProfiles dp) {
        return dp.getOptionCode().getCtlNameCode().equals(CodeTableCodes.GrsCtOptionCodes.ENTIRE_RECORD.getValue());
    }

    private <T> T getBlockById(List<T> dataBlocks, Long id) {
        if (dataBlocks != null) {
            for (T t : dataBlocks) {
                if (PropertyUtils.invokeGetter(t, "id").equals(id)) {
                    return t;
                }
            }
        }
        return null;
    }

    /**
     * Sometimes a null is returned
     *
     * @param <T>
     * @param listDto
     * @param block
     */
    private <T> void addIfNotNull(List<T> listDto, T block) {
        if (block != null) {
            listDto.add(block);
        }
    }

    private void addDataItemsForBlock(ProviderDto src, ProviderDto dest, GrsDistribEventItemTx tx) {
        GrsCtTransactionTypes tType = tx.getTranxType();
        String transactionType = tType.getCtlNameCode();
        if (CodeTableCodes.GrsCtTransactionTypes.CREATE_ADDRESS.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_ADDRESS.getValue().equals(transactionType)) {
            addIfNotNull(dest.getAddresses(), getBlockById(src.getAddresses(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_CONDITION.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_CONDITION.getValue().equals(transactionType)) {
            addIfNotNull(dest.getConditions(), getBlockById(src.getConditions(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_CONFIDENTIALITY.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_CONFIDENTIALITY.getValue().equals(transactionType)) {
            addIfNotNull(dest.getConfidentialityIndicators(), getBlockById(src.getConfidentialityIndicators(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_CREDENTIAL.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_CREDENTIAL.getValue().equals(transactionType)) {
            addIfNotNull(dest.getCredentials(), getBlockById(src.getCredentials(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_DEMOGRAPHIC.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_DEMOGRAPHIC_.getValue().equals(transactionType)) {
            addIfNotNull(dest.getDemographicDetails(), getBlockById(src.getDemographicDetails(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_DISCIPLINARY_ACTION.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_DISCIPLINARY_ACTION.getValue().equals(transactionType)) {
            addIfNotNull(dest.getDisciplinaryActions(), getBlockById(src.getDisciplinaryActions(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_E_ADDRESS.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_E_ADDRESS.getValue().equals(transactionType)) {
            addIfNotNull(dest.getElectronicAddresses(), getBlockById(src.getElectronicAddresses(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_EXPERTISE.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_EXPERTISE.getValue().equals(transactionType)) {
            addIfNotNull(dest.getExpertise(), getBlockById(src.getExpertise(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_INFORMATION_ROUTE.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_INFORMATION_ROUTE.getValue().equals(transactionType)) {
            addIfNotNull(dest.getInformationRoutes(), getBlockById(src.getInformationRoutes(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_NOTE.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_NOTE.getValue().equals(transactionType)) {
            addIfNotNull(dest.getNotes(), getBlockById(src.getNotes(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_ORGANIZATION_NAME.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_ORGANIZATION_NAME.getValue().equals(transactionType)) {
            addIfNotNull(dest.getOrgNames(), getBlockById(src.getOrgNames(), tx.getAfterChangeItemId()));

            // add the personal names as well cause at this point the personal names hold the org names
            addIfNotNull(dest.getIndNames(), getBlockById(src.getIndNames(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_PERSONAL_NAME.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_PERSONAL_NAME.getValue().equals(transactionType)) {
            addIfNotNull(dest.getIndNames(), getBlockById(src.getIndNames(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_IDENTIFIER.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_IDENTIFIER.getValue().equals(transactionType)) {
            addIfNotNull(dest.getIdentifiers(), getBlockById(src.getIdentifiers(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_RELATIONSHIP.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_RELATIONSHIP.getValue().equals(transactionType)) {
            addIfNotNull(dest.getProviderRelationships(), getBlockById(src.getProviderRelationships(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_REGISTRY_IDENTIFIER.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_REGISTRY_IDENTIFIER.getValue().equals(transactionType)) {
            addIfNotNull(dest.getRegistryIdentifiers(), getBlockById(src.getRegistryIdentifiers(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_REGISTRY_USER_RELATIONSHIP.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_REGISTRY_USER_RELATIONSHIP.getValue().equals(transactionType)) {
            addIfNotNull(dest.getRegistryUserRelationships(), getBlockById(src.getRegistryUserRelationships(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_STATUS.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_STATUS.getValue().equals(transactionType)) {
            addIfNotNull(dest.getStatuses(), getBlockById(src.getStatuses(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_TELEPHONE.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_TELEPHONE.getValue().equals(transactionType)) {
            addIfNotNull(dest.getTelecommunication(), getBlockById(src.getTelecommunication(), tx.getAfterChangeItemId()));

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_WORK_LOCATION_DETAIL.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_WORK_LOCATION_DETAIL.getValue().equals(transactionType)) {

            for (WorkLocationDto wl : src.getWorkLocationList()) {
                for (WorkLocationDetailsDto wld : wl.getWorkLocationDetails()) {
                    if (wld.getId().equals(tx.getAfterChangeItemId())) {
                        if (!dest.getWorkLocationList().contains(wl)) {
                            addIfNotNull(dest.getWorkLocationList(), wl);
                        }
                        return;
                    }
                }
            }

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_WORK_LOCATION_ADDRESS.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_WORK_LOCATION_ADDRESS.getValue().equals(transactionType)) {

            for (WorkLocationDto wl : src.getWorkLocationList()) {
                for (AddressDto addr : wl.getAddresses()) {
                    if (addr.getId().equals(tx.getAfterChangeItemId())) {
                        if (!dest.getWorkLocationList().contains(wl)) {
                            addIfNotNull(dest.getWorkLocationList(), wl);
                        }
                        return;
                    }
                }
            }

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_WORK_LOCATION_TELEPHONE.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_WORK_LOCATION_TELEPHONE.getValue().equals(transactionType)) {

            for (WorkLocationDto wl : src.getWorkLocationList()) {
                for (TelecommunicationDto tel : wl.getTelecommunications()) {
                    if (tel.getId().equals(tx.getAfterChangeItemId())) {
                        if (!dest.getWorkLocationList().contains(wl)) {
                            addIfNotNull(dest.getWorkLocationList(), wl);
                        }
                        return;
                    }
                }
            }

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_WORK_LOCATION_E_ADDRESS.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_WORK_LOCATION_E_ADDRESS.getValue().equals(transactionType)) {

            for (WorkLocationDto wl : src.getWorkLocationList()) {
                for (ElectronicAddressDto eaddr : wl.getElectronicAddresses()) {
                    if (eaddr.getId().equals(tx.getAfterChangeItemId())) {
                        if (!dest.getWorkLocationList().contains(wl)) {
                            addIfNotNull(dest.getWorkLocationList(), wl);
                        }
                        return;
                    }
                }
            }

        } else if (CodeTableCodes.GrsCtTransactionTypes.CREATE_WORK_LOCATION_INFORMATION_ROUTE.getValue().equals(transactionType)
                || CodeTableCodes.GrsCtTransactionTypes.UPDATE_WORK_LOCATION_INFORMATION_ROUTE.getValue().equals(transactionType)) {

            for (WorkLocationDto wl : src.getWorkLocationList()) {
                for (InformationRouteDto ir : wl.getInformationRoutes()) {
                    if (ir.getId().equals(tx.getAfterChangeItemId())) {
                        if (!dest.getWorkLocationList().contains(wl)) {
                            addIfNotNull(dest.getWorkLocationList(), wl);
                        }
                        return;
                    }
                }
            }

        } else {
            LOGGER.log(Level.SEVERE, "Unrecognized transaction type: {0}", tType);
            //throw new IllegalArgumentException("Unrecognized transaction type. Check log.");
        }
    }

    public boolean isSendEnabled() {
        
        isSendDistribEnabled = Boolean.parseBoolean(plrConfigLoader.getValue(Consts.SEND_DISTRIBUTION));
        
        LOGGER.log(Level.INFO, "SendDistributionService isSendDistribEnabled is: {0}.", new Object[]{isSendDistribEnabled});
        
        if (!sendDistributionLastCheck && isSendDistribEnabled) {
            LOGGER.log(Level.INFO, "Sending distribution messages is now enabled");
        }
        return isSendDistribEnabled;
    }

    private Timer createTimer(String[] cronTokens) {
        ScheduleExpression schedule = new ScheduleExpression()
                .second(cronTokens[0])
                .minute(cronTokens[1])
                .hour(cronTokens[2]);
        return timerService.createCalendarTimer(schedule, new TimerConfig("Send distribution", false));
    }

    private boolean isDistributionEnabled() {
        
        isProcessDistribEnabled = Boolean.parseBoolean(plrConfigLoader.getValue(Consts.PROCESS_DISTRIBUTION));
        
        LOGGER.log(Level.INFO, "SendDistributionService isProcessDistribEnabled is: {0}.", new Object[]{isProcessDistribEnabled});
        
        if (!distributionEnabledLastCheck && isProcessDistribEnabled) {
            LOGGER.log(Level.INFO, "Distribution processing and queueing is now enabled");
        }
        return isProcessDistribEnabled;
    }

    public Collection<Timer> getTimers() {
        return timerService.getTimers();
    }

    /**
     * PLR-2137 Check if distribution is empty.
     *
     * @param notification
     * @param eventItem
     * @return
     */
    private boolean isDistributionEmpty(DistributionNotification notification, GrsDistribEventItem eventItem) {
        if (notification == null) {
            return false;
        }
        // The identifiers are always added in a distribution even if there are no changes for identifier. 
        // E.g, if I cease address the DistributionNotification will have the identifiers even after filtering out the inactive address block. In this case we don't need to send distribution. 
        // If there are changes in identifiers then we need to send distribution. 
        // Check if the update is on College Identifiers, then consider it as a change and set flag as non empty
        for (GrsDistribEventItemTx tx : eventItem.getGrsDistribEventItemTxList()) {
            if (CodeTableCodes.GrsCtTransactionTypes.CREATE_IDENTIFIER.getValue().equals(tx.getTranxType().getCtlNameCode())
                    || CodeTableCodes.GrsCtTransactionTypes.UPDATE_IDENTIFIER.getValue().equals(tx.getTranxType().getCtlNameCode())) {
                return false;
            }
        }

        return CollectionUtils.isEmpty(notification.getProviderDetails().getRegistryIdentifiers())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getIndNames())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getDemographicDetails())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getAddresses())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getTelecommunication())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getElectronicAddresses())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getWorkLocationList())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getStatuses())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getConditions())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getExpertise())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getCredentials())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getInformationRoutes())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getDisciplinaryActions())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getConfidentialityIndicators())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getProviderRelationships())
                && CollectionUtils.isEmpty(notification.getProviderDetails().getNotes());
    }

    /**
     * PLR-2176 Filter out blocks with effective start date in future if
     * distribution profile cannot handle future updates
     *
     * @param dp
     * @param esbProviderDetails
     */
    private void filterOutFutureEffectiveBlocks(GrsDistributionProfiles dp, ProviderDto esbProviderDetails) {
        if (!EntityUtils.isActive(dp.getFutureDatedUpdatesFlag())) {
            esbProviderDetails.removeEffectiveStartDateAfterToday();
        }
    }

}
