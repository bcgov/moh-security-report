package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.DemographicDetailsDto;
import ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsDemographicDetails;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.BusinessRuleResultUtils;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.persistence.ProviderDao;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import ca.bc.gov.health.plr.rule.BusinessRuleResult;
import ca.bc.gov.health.plr.rule.provider.AccessRestrictionService;
import ca.bc.gov.health.plr.rule.provider.ValidateActiveDemographicStillExists;
import ca.bc.gov.health.plr.rule.provider.ValidateBeforeAfterDates;
import ca.bc.gov.health.plr.rule.provider.ValidateGender;
import ca.bc.gov.health.plr.service.EntityValidatorService;
import ca.bc.gov.health.plr.service.validators.ConfidentialityValidator;
import ca.bc.gov.health.plr.service.validators.EntityChangeDetector;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.MessageCodeHelper;
import java.util.ArrayList;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.apache.commons.lang3.StringUtils;

/**
 * Add or update a demographic detail for a provider.
 *
 * @author Grant.Hodgins
 */
@Stateless
@LocalBean
public class MaintainDemographicDetailsService implements MaintainService<DemographicDetailsDto> {

    @PersistenceContext(unitName = "PLR-ejbPU")
    protected EntityManager em;
    @EJB
    protected CodesDao codesDao;
    @EJB
    protected ProviderDao providerDao;
    @EJB
    protected ProviderDtoConverter providerDtoConverter;
    @EJB
    private JournalService<PrsDemographicDetails> journalService;

    private final ValidateBeforeAfterDates validateDemographics = new ValidateBeforeAfterDates();
    private final ValidateActiveDemographicStillExists activeRecordValidator = new ValidateActiveDemographicStillExists();

    @EJB
    private EntityValidatorService<PrsDemographicDetails> validatorService;

    @EJB
    private ConfidentialityValidator<PrsDemographicDetails> confidentialityValidator;

    @EJB
    private AccessRestrictionService accessRestrictionService;

    @EJB
    private EntityChangeDetector<DemographicDetailsDto, PrsDemographicDetails> entityChangeDetector;

    @EJB
    protected ValidateGender genderValidator;

    /**
     * Adds or updates a demographic details transfer object.
     *
     * @param demographicDetails the demographic details to maintain
     * @return a populated list of provider-related transfer objects with
     * refreshed details
     * @throws ca.bc.gov.health.plr.service.provider.DuplicateRecordException
     * @throws ca.bc.gov.health.plr.rule.BusinessRuleException
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     */
    @Override
    public DemographicDetailsDto save(DemographicDetailsDto demographicDetails) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {

        PrsProviders provider = checkBusinessRules(demographicDetails);
        if (provider == null) {
            provider = providerDao.searchByProviderId(demographicDetails.getPauthId());
        }
        PrsDemographicDetails newRecord = providerDtoConverter.mapPrsDemographicDetails(demographicDetails, provider);
        entityChangeDetector.checkForChanges(demographicDetails, newRecord);
        if (demographicDetails.isNoChangeOnUpdate()) {
            return demographicDetails;
        }
        validatorService.validate(newRecord, confidentialityValidator);
        newRecord = journalService.journal(newRecord);

        return providerDtoConverter.buildDemographicDetail(newRecord);
    }

    /**
     * Validates additional business rules for this record.
     *
     * @param demographicDetails ProviderDetails.DemographicDetails
     * @return PrsProviders The provider entity for the DemographicDetailsDto
     *
     * @throws BusinessRuleException if validation fails
     */
    private PrsProviders checkBusinessRules(DemographicDetailsDto demographicDetails) throws BusinessRuleException {
        PrsProviders provider = null;

        BusinessRuleKeys keyDeathBirthDate = BusinessRuleKeys.ERROR_DEATH_BEFORE_BIRTH;
        String[] messageDeathBirthDate = MessageCodeHelper.splitCodeAndMessage(BusinessRuleMessageDao.getMessageResource(keyDeathBirthDate));
        final BusinessRuleKeys keyProvState = BusinessRuleKeys.ERROR_DEMOGRAPICHPROVSTATEFIELD_INVALID;
        final String messageProvState[] = MessageCodeHelper.splitCodeAndMessage(BusinessRuleMessageDao.getMessageResource(keyProvState));

        ArrayList<BusinessRuleResult> businessRuleResults = new ArrayList<BusinessRuleResult>();

        BusinessRuleResult result = validateDemographics.validate(demographicDetails.getBirthDate(), demographicDetails.getDeathDate(), messageDeathBirthDate[0], messageDeathBirthDate[1]);
        businessRuleResults.add(result);

        GrsCtEndReasonTypes endReason = null;
        if (demographicDetails.getEndReasonCodeId() != null) {
            endReason = codesDao.lookup(GrsCtEndReasonTypes.class, demographicDetails.getEndReasonCodeId());
        } else if (demographicDetails.getEndReasonCode() != null) {
            endReason = codesDao.lookup(GrsCtEndReasonTypes.class, demographicDetails.getEndReasonCode());
        }
        
        if (endReason != null && endReason.equals(codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CEASE))) {
            BusinessRuleKeys keyLastActive = BusinessRuleKeys.ERROR_LAST_ACTIVE_DEMOGRAPHICS;
            String messageLastActive[] = MessageCodeHelper.splitCodeAndMessage(BusinessRuleMessageDao.getMessageResource(keyLastActive));
            provider = providerDao.searchByProviderId(demographicDetails.getPauthId());
            result = activeRecordValidator.validate(provider.getPrsDemographicDetailsList(), messageLastActive[0], messageLastActive[1]);

            businessRuleResults.add(result);
        }

        // if there is no country, then there can be no prov/state.  The GUI manages this, but messages need to be checked.
        if (demographicDetails.getBirthCountryCodeId() == null
                && (demographicDetails.getBirthCountryCode() == null || (demographicDetails.getBirthCountryCode() != null && demographicDetails.getBirthCountryCode().isEmpty()))
                && (demographicDetails.getBirthProvStateCodeId() != null
                || (demographicDetails.getBirthProvState() != null && !demographicDetails.getBirthProvState().isEmpty()))) {
            businessRuleResults.add(new BusinessRuleResult(false, new ArrayList<BusinessRuleMessage>() {
                {
                    add(new BusinessRuleMessage(messageProvState[0], messageProvState[1], BusinessRuleMessage.Severity.ERROR));
                }
            }));
        }
        
        //Message mode doesn't have gender id, it has to have gender code. 
        //GUI mode the the gender id is enforced on the page, so no need to validate.
        //So if the genderId is null, it must be from message mode.
        if(demographicDetails.getGenderId()==null) {
            BusinessRuleResult brrGender = genderValidator.validateGenderCode(demographicDetails.getGenderCode(), true);
            if(brrGender!=null && !brrGender.isValid()) {
                businessRuleResults.add(brrGender);
            }
        }
        
        if(!BusinessRuleResultUtils.isAllValid(businessRuleResults)) {
            throw new BusinessRuleException(businessRuleResults);
        }

        return provider;
    }

    /**
     * Query a fresh complete list of demographic details related to a specific
     * provider.
     *
     * @param pauthId the provider primary key
     * @return a list of fresh demographic details transfer objects
     */
    public List<DemographicDetailsDto> refreshDemographicDetails(Long pauthId) {
        PrsProviders provider = em.find(PrsProviders.class, pauthId);
        List<DemographicDetailsDto> dtos = providerDtoConverter.buildDemographicDetails(provider.getPrsDemographicDetailsList());
        accessRestrictionService.applyReadRestriction(dtos, provider.getHptCode(), PrsDemographicDetails.class);
        accessRestrictionService.applyColumnRestriction(dtos, provider.getHptCode(), PrsDemographicDetails.class, false);
        return dtos;
    }
}
