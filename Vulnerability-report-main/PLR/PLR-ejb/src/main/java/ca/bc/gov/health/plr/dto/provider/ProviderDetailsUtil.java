package ca.bc.gov.health.plr.dto.provider;

import ca.bc.gov.health.plr.dto.DtoMetaData;
import ca.bc.gov.health.plr.ejb.entity.CodeTableInterface;
import ca.bc.gov.health.plr.ejb.entity.RecordTypeEntity;
import ca.bc.gov.health.plr.service.provider.TableToDataObjectMap;
import ca.bc.gov.health.plr.service.provider.security.AuthorizationService;
import ca.bc.gov.health.plr.util.PropertyUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.ejb.Stateless;
import javax.inject.Named;
import javax.persistence.Table;
import org.apache.commons.lang3.StringUtils;

/**
 * A set of common utilities for finding and displaying provider detail
 * information.
 *
 * @author Grant.Hodgins
 */
@Stateless
@Named("providerDetailsUtil")
public class ProviderDetailsUtil {

    /**
     * registry ID valid pattern
     */
    final public static String regIDPattern = "[a-zA-Z0-9\\.]+";

    /**
     * provider ID valid pattern
     */
    final public static String provIDPattern = "[a-zA-Z0-9\\.]+";

    /**
     * Convenience method to strip post and prefix information from the registry
     * identifier. For example providing <code>CPN.00000012.BC.PRS</code> will
     * return the number portion of the identifier only: <code>00000012</code>.
     *
     * @param registryIdentifier the registry identifier, expected format
     * CPN.d8.BC.PRS or IPC.d8.BC.PRS
     * @return the simplified identifier or <code>null</code> if provided. If
     * the provided string does not follow the expected format, it is returned
     * unmodified.
     */
    public static String getRawIdentifier(String registryIdentifier) {
        String result = registryIdentifier;

        if (registryIdentifier != null && (registryIdentifier.contains("CPN") || registryIdentifier.contains("IPC"))) {
            result = StringUtils.substringBetween(registryIdentifier, ".", ".");
        }

        return result;
    }

    public static String getMostRecentName(List<PersonNameDto> names) {
        String result = null;
        //the reason to create a tmp ArrayList to include the inout list is to Not to change the sequence of the element in input list
        List<PersonNameDto> tmpNameList = new ArrayList<>();
        if (names != null && names.size() > 0) {
            tmpNameList.addAll(names);
            Collections.sort(tmpNameList);
            PersonNameDto topName = tmpNameList.get(0);

            result = displayName(topName);
        }

        return result;
    }

    public static String displayName(PersonNameDto name) {
        String result = new String();

        if (StringUtils.isNotBlank(name.getLastName())) {
            result = name.getLastName();
        }

        if (StringUtils.isNotBlank(name.getPrefix())
                || StringUtils.isNotBlank(name.getFirstName())
                || StringUtils.isNotBlank(name.getSecondName())) {
            result += ", ";
        }

        if (StringUtils.isNotBlank(name.getPrefix())) {
            result += name.getPrefix() + " ";
        }

        if (StringUtils.isNotBlank(name.getFirstName())) {
            result += name.getFirstName() + " ";
        }

        if (StringUtils.isNotBlank(name.getSecondName())) {
            result += name.getSecondName();
        }

        return result;

    }

    public static String getMostRecentDataOwnerCode(List<PersonNameDto> names) {
        StringBuilder result = new StringBuilder();
        //the reason to create a tmp ArrayList to include the inout list is to Not to change the sequence of the element in input list
        List<PersonNameDto> tmpNameList = new ArrayList<>();
        if (names != null && names.size() > 0) {
            tmpNameList.addAll(names);
            Collections.sort(tmpNameList);
            PersonNameDto topName = tmpNameList.get(0);
            result.append(topName.getDataOwnerCode());
        }

        return result.toString();
    }

    public static String getMostRecentCollegeId(List<CollegeIdentifierDto> identifiers) {
        StringBuilder result = new StringBuilder();

        if (identifiers != null && identifiers.size() > 0) {
//            Collections.sort(identifiers);
            CollegeIdentifierDto topId = identifiers.get(0);
            result.append(topId.getIdentifier());
        }

        return result.toString();
    }

    public static String getMostRecentStatus(List<StatusDto> statuses) {
        StringBuilder result = new StringBuilder();

        if (statuses != null && statuses.size() > 0) {
            Collections.sort(statuses);
            StatusDto topId = statuses.get(0);
            result.append(topId.getType());
        }

        return result.toString();
    }

    /**
     *
     * @param names
     * @return
     */
    public static String getMostRecentOrgName(List<OrgNameDto> names) {
        String result = null;
        if (names != null && names.size() > 0) {
            List<OrgNameDto> tmpNameList = new ArrayList<>();
            tmpNameList.addAll(names);
            Collections.sort(tmpNameList);
            OrgNameDto topName = tmpNameList.get(0);
            result = topName.getName();
        }

        return result;
    }

    public static String getMostRecentOrgDataOwnerCode(List<OrgNameDto> names) {
        String result = null;
        if (names != null && names.size() > 0) {
            List<OrgNameDto> tmpNameList = new ArrayList<>();
            tmpNameList.addAll(names);
            Collections.sort(tmpNameList);
            OrgNameDto topName = tmpNameList.get(0);
            result = topName.getDataOwnerCode();
        }

        return result;
    }

    /**
     * Utility method to get the data object name from the table annotation The
     * data object name is the name of the table in Data Element Permissions :
     * There is slight difference between the actual table name and data object
     * name
     *
     * @param entity
     * @return
     */
    public static String getDataObjectName(Class<?> entity) {
        String dataObjectName = null;
        Table table = entity.getAnnotation(Table.class);
        String tableName = table.name();
        if (tableName != null) {
            TableToDataObjectMap dataObjectMap = TableToDataObjectMap.fromTableName(tableName);
            if (dataObjectMap == null) {
                dataObjectName = getWlDataObjectName(entity);
            } else {
                dataObjectName = dataObjectMap.name();
            }
        }
        return dataObjectName;
    }

    /**
     * Utility method to get the data object name of work location related
     * tables from the table annotation.
     *
     * @param entity
     * @return
     */
    public static String getWlDataObjectName(Class<?> entity) {
        String dataObjectName = null;
        Table table = entity.getAnnotation(Table.class);
        String tableName = table.name();
        if (tableName != null) {
            TableToDataObjectMap dataObjectMap = TableToDataObjectMap.fromTableName("WL-" + tableName);
            dataObjectName = dataObjectMap.name();
        }
        return dataObjectName;
    }

    /**
     *
     * This method iterates the RecordTypes and returns a list of type values
     * for the passed object If the passed object is entity (instance of
     * CodeTableInterface) - returns the value of the entity field names else
     * will return the value of the dto field names
     *
     * @param object
     * @return
     */
    public static List<String> getDtoRecordTypeValues(DtoMetaData object) {
        Set<String> typeProperties = new HashSet<>();
        for (String recordTypeField : object.getRecordTypeFields()) {
            if (PropertyUtils.doesPropertyExist(object, recordTypeField)) {
                Object obj = PropertyUtils.invokeGetter(object, recordTypeField);
                if (obj != null && obj instanceof String) {
                    typeProperties.add((String) obj);
                }
            }
        }
        if (typeProperties.isEmpty()) {
            typeProperties.add(AuthorizationService.ANY);
        }
        return new ArrayList<>(typeProperties);
    }

    /**
     * Method to get record type values of the entity Cannot use the generic
     * expression instead of T, as not all entities are recordTypeEntities
     *
     * @param <T>
     * @param object
     * @return
     */
    public static <T> List<String> getEntityRecordTypeValues(T object) {
        Set<String> typeProperties = new HashSet<>();
        if (object instanceof RecordTypeEntity) {
            RecordTypeEntity recordTypeEntity = (RecordTypeEntity) object;
            for (String recordTypeField : recordTypeEntity.getRecordTypeFields()) {
                Object obj = PropertyUtils.invokeGetter(object, recordTypeField);
                if (obj != null && obj instanceof CodeTableInterface) {
                    CodeTableInterface cti = (CodeTableInterface) obj;
                    typeProperties.add(cti.getCtlNameCode());
                }
            }
        }

        if (typeProperties.isEmpty()) {
            typeProperties.add(AuthorizationService.ANY);
        }
        return new ArrayList<>(typeProperties);
    }
}
