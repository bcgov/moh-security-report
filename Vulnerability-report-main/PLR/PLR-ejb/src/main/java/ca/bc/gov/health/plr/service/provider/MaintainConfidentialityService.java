package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.converter.ConfidentialityDtoConverter;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.ConfidentialityIndicatorDto;
import ca.bc.gov.health.plr.ejb.entity.PrsConfidentialityIndicators;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.interceptors.TestUserInterceptor;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.producer.type.Authenticated;
import ca.bc.gov.health.plr.producer.type.User;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.BusinessRuleResult;
import ca.bc.gov.health.plr.rule.provider.AccessRestrictionService;
import ca.bc.gov.health.plr.rule.provider.ValidateConfidentialityEndReason;
import ca.bc.gov.health.plr.service.EntityValidatorService;
import ca.bc.gov.health.plr.service.provider.security.AuthorizationService;
import ca.bc.gov.health.plr.service.validators.EntityChangeDetector;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.interceptor.Interceptors;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

/**
 * Service class for persisting Electronic Address records
 *
 * @author greg.perkins
 */
@Stateless
@Interceptors({TestUserInterceptor.class})
@LocalBean
public class MaintainConfidentialityService implements MaintainService<ConfidentialityIndicatorDto>{
    
    private static final Logger logger = Logger.getLogger(MaintainConfidentialityService.class.getName());

    @PersistenceContext(unitName = "PLR-ejbPU")
    protected EntityManager em;
    @EJB
    private ConfidentialityDtoConverter confidentialityDtoConverter;
    @EJB
    private JournalService<PrsConfidentialityIndicators> journalService;
    @EJB
    private ValidateConfidentialityEndReason confidentialityEndReason;
    @EJB
    private AuthorizationService authorizationService;

    @EJB
    private EntityValidatorService<PrsConfidentialityIndicators> entityValidatorService;

    @EJB
    private AccessRestrictionService accessRestrictionService;
    
    @EJB
    private ProviderDtoConverter providerDtoConverter;
    
    @EJB
    private ProviderAuthorizationService providerAuthorizationService;

    @Inject
    @Authenticated
    private Instance<User> user;
    
    @EJB
    private EntityChangeDetector<ConfidentialityIndicatorDto, PrsConfidentialityIndicators> entityChangeDetector;

    /**
     * Re-queries an object from the database to update it with the latest
     * values
     *
     * @param toRefresh - a dto with an ID
     * @return - dto built from database record or null
     */
    public ConfidentialityIndicatorDto refresh(ConfidentialityIndicatorDto toRefresh) {
        PrsConfidentialityIndicators found = em.find(PrsConfidentialityIndicators.class, toRefresh.getId());
        ConfidentialityIndicatorDto toSendBack = providerDtoConverter.buildConfidentialityIndicator(found);
        return toSendBack;
    }

    /**
     * Persists a Confidentiality to the database.
     *
     * @param confInd Confidentiality
     * @throws ca.bc.gov.health.plr.service.provider.DuplicateRecordException
     * @throws ca.bc.gov.health.plr.rule.BusinessRuleException
     * @return the
     * java.util.List<ca.bc.gov.health.plr.dto.provider.ConfidentialityIndicatorDto>
     */
    @Override
    public ConfidentialityIndicatorDto save(ConfidentialityIndicatorDto confInd) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        checkEndReasonCode(confInd);
        PrsConfidentialityIndicators con = confidentialityDtoConverter.toEntity(confInd);
        entityChangeDetector.checkForChanges(confInd, con);
	if(confInd.isNoChangeOnUpdate()){
            return confInd;
	}
        entityValidatorService.validate(con);
        checkPermission(con);
        con = journalService.journal(con);

        return providerDtoConverter.buildConfidentialityIndicator(con);        
    }
    
    public List<ConfidentialityIndicatorDto> refreshConfidentialityIndicators(long pauthId){
        PrsProviders provider = em.find(PrsProviders.class, pauthId);
        /*
         The Provider is retrieved from the PersistenceContext/cache. It will not
         be automatically refreshed until the transaction commits after the EJB
         call completes. Refresh the entity to get the latest Confidentiality
         indicators.
         */
        List<ConfidentialityIndicatorDto> confidentialityIndicators = providerDtoConverter.buildConfidentialityIndicators(provider.getPrsConfidentialityIndicatorsList());
        accessRestrictionService.applyReadRestriction(confidentialityIndicators, provider.getHptCode(), PrsConfidentialityIndicators.class);
        return confidentialityIndicators;
    }
    
    public boolean isPermitted(ConfidentialityIndicatorDto confidentialityDto, AuthorizationService.AccessType accessType) {               
        return isPermitted(confidentialityDtoConverter.toEntity(confidentialityDto), accessType);
    }
    
    private boolean isPermitted(PrsConfidentialityIndicators confInd, AuthorizationService.AccessType accessType) {
        PrsProviders provider = confInd.getPauthPauthId();
        try {
            String dataOwnerCode = confInd.getDataOwnerCode() == null ? providerAuthorizationService.getDataOwnerCode(confInd, provider) : confInd.getDataOwnerCode().getCtlNameCode();
            return dataOwnerCode != null && authorizationService.isAllowed(user.get().getUserEntity(), DataObjects.PRS_CONFIDENTIALITY_INDICATOR.getDataObjectName(), null, null, provider.getHptCode(), dataOwnerCode, accessType);
        } catch (EntityValidationException ex) {
            logger.log(Level.SEVERE, null, ex);
        }
        
        return false;
        
    }

    private void checkPermission(PrsConfidentialityIndicators confInd) throws EntityValidationException {
        boolean hasPermissionToUpdate = isPermitted(confInd, AuthorizationService.AccessType.WRITE);
        if (!hasPermissionToUpdate) {
            String msg = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_UPDATE_PERMISSION_DENIED);
            throw new EntityValidationException(msg);
        }
    }

    private void checkEndReasonCode(ConfidentialityIndicatorDto confInd) throws BusinessRuleException {
        BusinessRuleResult brr = confidentialityEndReason.validate(confInd);
        if (!brr.isValid()) {
            throw new BusinessRuleException(brr);
        }
    }
}
