package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.ejb.entity.GrsCtBooleanTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes;
import ca.bc.gov.health.plr.ejb.entity.UniqueDataBlock;
import ca.bc.gov.health.plr.ejb.session.GenerationNumService;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.ejb.entity.util.DatabaseConstants;
import ca.bc.gov.health.plr.service.validators.UserChidGenerator;
import ca.bc.gov.health.plr.util.PropertyUtils;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.PersistenceContext;

/**
 * Service Class for handling boilerplate around journaling for updates.
 *
 * Also supports checking for duplicates and fetching generation numbers based
 * on the column list that makes up the data block.
 *
 * @author greg.perkins, David Sharpe <david.a.sharpe@cgi.com>
 * @param <T> - Entity class we are working with
 */
@Stateless
public class JournalService<T extends UniqueDataBlock> {

    /**
     * Entity Manager for persistence
     */
    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;
    /**
     * CodesDAO for looking up known code values
     */
    @EJB
    private CodesDao codesDao;
    @EJB
    private GenerationNumService generationNumService;
    
    @EJB
    private UserChidGenerator userChidGenerator;
    
    private static final String CLASSNAME = JournalService.class.getSimpleName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);
    /**
     * Adds or updates the specified record.
     *
     * An add is performed if the record does not have a primary key; otherwise,
     * an update is performed.
     *
     * The kind of update is determined by the record's END_REASON_CODE:
     *
     * <ul>
     * <li>REQ-00927 End Reason Code: Correction Rules</li>
     * <li>REQ-00928 End Reason Code: Cease Rules</li>
     * <li>REQ-00929 End Reason Code: Change Rules</li>
     * </ul>
     *
     * @param newRecord includes data for the new record, and optionally the
     * primary key of the original record and an END_REASON_CODE.
     * @return the updated record
     * @throws DuplicateRecordException if the add or update violates business rules for
     * the record type. Uses the "columns" class parameter.
     */
    public T journal(T newRecord) throws DuplicateRecordException {
        if (isAdd(newRecord)) {
            PropertyUtils.invokeSetter(newRecord, "userChid", userChidGenerator.find());
        }
        checkDuplicateAndUpdateExisting(newRecord);
        if (isAdd(newRecord)) {
            return performAdd(newRecord);
        } else {
            return performUpdate(newRecord);
        }
    }

    private boolean isAdd(T newRecord) {
        return getId(newRecord) == null;
    }

    /**
     * Applies Journaling Business Rules for adding a new record: REQ-00927,
     * REQ-00928, and REQ-00929.
     *
     * @param newEntity T - the new Entity to persist <code>null</code> if this
     * @param setEndReasonCodeToDefault - boolean for if endReasonCode should be
     * automatically set to default
     */
    private T performAdd(T newEntity) throws DuplicateRecordException {
        
        if (PropertyUtils.doesPropertyExist(newEntity, "generationNum")) {
            Long maxGenNum = generationNumService.findMaxGenerationNum(newEntity);
            PropertyUtils.invokeSetter(newEntity, "generationNum", maxGenNum + 1);
        }
        
        PropertyUtils.invokeSetter(newEntity, "activeFlag", codesDao.lookup(GrsCtBooleanTypes.class, CodeTableCodes.GrsCtBooleanTypes.YES));
        PropertyUtils.invokeSetter(newEntity, "endReasonCode", null);
        PropertyUtils.invokeSetter(newEntity, "invalidatedDts", DatabaseConstants.SYSTEM_HIGH_DATE.toDate());

        newEntity = em.merge(newEntity);
        em.flush();
        em.refresh(newEntity);
        return newEntity;
    }

    /**
     * Applies Journaling Business Rules for updates: REQ-00927, REQ-00928, and
     * REQ-00929.
     *
     * @param newEntity T - Entity to persist
     * @param endReasonCodeId the end reason code id
     * @param originalPrimaryKey the primary key for the original record, or
     * <code>null</code> if this is a new record.
     */
    private T performUpdate(T newEntity) throws DuplicateRecordException {
        GrsCtEndReasonTypes endReasonCode = (GrsCtEndReasonTypes) PropertyUtils.invokeGetter(newEntity, "endReasonCode");
        if (endReasonCode == null) {
            throw new IllegalArgumentException("End Reason Code is mandatory when updating a record.");
        }

        T originalRecord = updateOriginalRecord(newEntity);

        // Set common fields for new record
        PropertyUtils.invokeSetter(newEntity, "activeFlag", codesDao.lookup(GrsCtBooleanTypes.class, CodeTableCodes.GrsCtBooleanTypes.YES));
        PropertyUtils.invokeSetter(newEntity, "endReasonCode", null);
        PropertyUtils.invokeSetter(newEntity, "invalidatedDts", DatabaseConstants.SYSTEM_HIGH_DATE.toDate());
        PropertyUtils.invokeSetter(newEntity, "userChid", userChidGenerator.find());
        
        // Handle end reason rules
        if (CodeTableCodes.GrsCtEndReasonTypes.CORRECT.getValue().equals(endReasonCode.getCtlNameCode())) {
            // REQ-00927 - insert new record
            setId(newEntity, null);
            incrementAndSetGenerationNum(newEntity, generationNumService.findMaxGenerationNum(newEntity));

            newEntity = em.merge(newEntity);
        } else if (CodeTableCodes.GrsCtEndReasonTypes.CEASE.getValue().equals(endReasonCode.getCtlNameCode())) {
            // REQ-00928 - ignore data entered
            em.detach(originalRecord);
            setId(originalRecord, null);
            PropertyUtils.invokeSetter(originalRecord, "activeFlag", codesDao.lookup(GrsCtBooleanTypes.class, CodeTableCodes.GrsCtBooleanTypes.YES));

            incrementAndSetGenerationNum(originalRecord, (Long) PropertyUtils.invokeGetter(originalRecord, "generationNum"));

            PropertyUtils.invokeSetter(originalRecord, "endReasonCode", endReasonCode);
            PropertyUtils.invokeSetter(originalRecord, "effectiveStartDate", new Date());
            PropertyUtils.invokeSetter(originalRecord, "effectiveEndDate", new Date());
            PropertyUtils.invokeSetter(originalRecord, "invalidatedDts", DatabaseConstants.SYSTEM_HIGH_DATE.toDate());
            PropertyUtils.invokeSetter(originalRecord, "userChid", userChidGenerator.find());

            newEntity = em.merge(originalRecord);

        } else if (CodeTableCodes.GrsCtEndReasonTypes.CHANGE.getValue().equals(endReasonCode.getCtlNameCode())) {
            // REQ-00929 - insert mysterious record
            em.detach(originalRecord);
            setId(originalRecord, null);
            PropertyUtils.invokeSetter(originalRecord, "activeFlag", codesDao.lookup(GrsCtBooleanTypes.class, CodeTableCodes.GrsCtBooleanTypes.YES));
            
            Date originalRecordEndDate = (Date) PropertyUtils.invokeGetter(originalRecord, "effectiveEndDate");
            Date newEntityStartDate = (Date) PropertyUtils.invokeGetter(newEntity, "effectiveStartDate");

            //PLRP3-2 We only modify the original end date if there is an overlap with the new. 
            //If there is a gap we leave it that way.
            if(originalRecordEndDate != null && newEntityStartDate != null){
                if(originalRecordEndDate.compareTo(newEntityStartDate) >= 0){
                    Calendar calNewEndDate = Calendar.getInstance();
                    calNewEndDate.setTime(newEntityStartDate);
                    calNewEndDate.add(Calendar.DATE, -1);
                    PropertyUtils.invokeSetter(originalRecord, "effectiveEndDate", calNewEndDate.getTime());
                }
            }
            incrementAndSetGenerationNum(originalRecord, (Long) PropertyUtils.invokeGetter(originalRecord, "generationNum"));

            em.merge(originalRecord);
            em.flush();

            // REQ-00929 - insert new record
            setId(newEntity, null);
            incrementAndSetGenerationNum(newEntity, generationNumService.findMaxGenerationNum(newEntity));

            em.persist(newEntity);
        } else {
            throw new UnsupportedOperationException("Invalid End Reason Code detected on Update Status");
        }

        em.flush();
        em.refresh(newEntity);
        return newEntity;
    }

    private T updateOriginalRecord(T newEntity) {
        // Set common fields for original record
        @SuppressWarnings("unchecked")
        T originalRecord = (T) em.find(newEntity.getClass(), getId(newEntity));
        PropertyUtils.invokeSetter(originalRecord, "activeFlag", codesDao.lookup(GrsCtBooleanTypes.class, CodeTableCodes.GrsCtBooleanTypes.NO));
        PropertyUtils.invokeSetter(originalRecord, "invalidatedDts", new Date());
        // Update original record - same for 927, 928, 929

        if (PropertyUtils.doesPropertyExist(newEntity, "endReasonCode")) {
            PropertyUtils.invokeSetter(originalRecord, "endReasonCode", PropertyUtils.invokeGetter(newEntity, "endReasonCode"));
        }

        em.merge(originalRecord);
        // Must flush here because we later detach the record. See the Javadoc for detach.
        em.flush();
        return originalRecord;
    }

     /**
     * Determines if adding/updating this record will create a duplicate, based
     * on the column set passed in
     *
     * @param newRecord T - Record to examine
     * @param columns String[] - Set of columns making up the data block
     * @throws DuplicateRecordException
     */
    private void checkDuplicateAndUpdateExisting(T newRecord) throws DuplicateRecordException {
        if (PropertyUtils.doesPropertyExist(newRecord, "generationNum")) {
            T existingRecord = generationNumService.findMaxGenNumRecord(newRecord);
            if (existingRecord != null) {
                if (notUpdatingRecord(newRecord, existingRecord)) {
                    if (isAlive(existingRecord)) {
                        String messageResource = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_DUPLICATE_DATA_BLOCK);
                        throw new DuplicateRecordException(messageResource + PropertyUtils.invokeGetter(newRecord, "fieldName"));
                    } else if(isCeased(existingRecord)){
                        //update the active flag of existing record
                        PropertyUtils.invokeSetter(existingRecord, "activeFlag", codesDao.lookup(GrsCtBooleanTypes.class, CodeTableCodes.GrsCtBooleanTypes.NO));
                        em.merge(existingRecord);
                    }
                }
            }
        }
    }

    /**
     * Returns true if newRecord is not updating an existing record, but trying
     * to add a new one.
     *
     * @param newRecord
     * @param existingRecord
     * @return true if newRecord is not updating an existing record, but trying
     * to add a new one.
     */
    private boolean notUpdatingRecord(T newRecord, T existingRecord) {
        return isAdd(newRecord) || !getId(newRecord).equals(getId(existingRecord));
    }

    /**
     * Returns true if the record has not been changed, corrected, or ceased.
     *
     * Do not attempt to use ACTIVE_FLAG for this check, as a record may have
     * ACTIVE_FLAG='Y' but not been truly "active". For example, a CEASED record
     * has ACTIVE_FLAG='Y' if it is the most recent record of its type.
     *
     * @param existingRecord
     * @return true if the record has not been changed, corrected, or ceased.
     */
    private boolean isAlive(T existingRecord) {
        boolean alive = false;
        if (PropertyUtils.doesPropertyExist(existingRecord, "endReasonCode")) {
            alive = PropertyUtils.invokeGetter(existingRecord, "endReasonCode") == null;
        }

        return alive;
    }
    /**
     * Returns true if the record is ceased, and the status flag is true
     * 
     * @param existingRecord
     * @return 
     */
    private boolean isCeased(T existingRecord) {
        if (PropertyUtils.doesPropertyExist(existingRecord, "endReasonCode")) {
            GrsCtEndReasonTypes endReasonCode = (GrsCtEndReasonTypes) PropertyUtils.invokeGetter(existingRecord, "endReasonCode");
            return CodeTableCodes.GrsCtEndReasonTypes.CEASE.getValue().equals(endReasonCode.getCtlNameCode());
        }
        return false;
    }

    /*
     * Gets the value of the PK on the entity
     *
     * @param entity T - Entity to set the PK on
     * @param value Long - Value to set
     * @throws Exception
     */
    private Long getId(T entity) {
        Field pkField = getPKField(entity.getClass());
        return (Long) PropertyUtils.invokeGetter(entity, pkField.getName());
    }

    /*
     * Sets the value of the PK on the entity
     *
     * @param entity T - Entity to set the PK on
     * @param value Long - Value to set
     * @throws Exception
     */
    private void setId(T entity, Long value) {
        Field pkField = getPKField(entity.getClass());
        PropertyUtils.invokeSetter(entity, pkField.getName(), value);
    }

    /**
     * Looks up the Primary Key field of the entity using Reflection
     *
     * @param clazz Class
     * @return Field - the Field representing the PK
     */
    private static Field getPKField(Class<?> clazz) {
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            if (!Modifier.isFinal(field.getModifiers())) {
                if (field.getAnnotation(Id.class) != null) {
                    return field;
                }
            }
        }
        return null;
    }

    private void incrementAndSetGenerationNum(T entity, Long newValue) {

        if (newValue != null && PropertyUtils.doesPropertyExist(entity, "generationNum")) {
            PropertyUtils.invokeSetter(entity, "generationNum", newValue + 1);
        }
    }
}
