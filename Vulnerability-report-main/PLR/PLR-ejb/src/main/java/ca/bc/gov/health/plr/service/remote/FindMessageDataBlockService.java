/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.service.remote;

import ca.bc.gov.health.plr.dto.DtoMetaData;
import ca.bc.gov.health.plr.dto.MessageDataBlockDto;
import ca.bc.gov.health.plr.dto.MessageDataBlockDtoNullable;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.AbstractProviderDetail;
import ca.bc.gov.health.plr.ejb.entity.MessageDataBlock;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.service.provider.ProviderAuthorizationService;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.PropertyUtils;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.ejb.Stateless;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import org.apache.commons.lang3.StringUtils;

/**
 * This class checks if any existing record is there for the message data block
 * received
 *
 * @author sumesh.kariyil
 */
@Stateless
public class FindMessageDataBlockService {

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;

    @Inject
    private ProviderAuthorizationService authorizationService;

    @Inject
    private ProviderDtoConverter providerDtoConverter;

    /**
     * Builds a query that returns a record based on the parameters below.
     *
     * *****
     * This version of the find should only be used by auditing ... *****
     *
     * @param <T> Entity type
     * @param pauthId unique id of provider
     * @param wlId unqiue id of work location
     * @param record the dto record
     * @param entityClass the entity class
     * @param ctProviderRoleTypes provider role type
     * @param genNumber generation number of record, can be null
     * @param ownerCodes owner codes allowed
     * @return
     * @throws EntityValidationException
     */
    public <T extends MessageDataBlock> T find(Long pauthId, Long wlId, MessageDataBlockDto record,
            Class<? extends MessageDataBlock> entityClass, PrsCtProviderRoleTypes ctProviderRoleTypes, Long genNumber, List<String> ownerCodes) throws EntityValidationException {
        try {
            if (pauthId != null && wlId != null) {
                throw new IllegalArgumentException("Either provider id or work location can be not null. Coding issue. Check the logic.");
            }
            // Get all the message data block fields from dto
            String[] dtoFields = record.getMessageDataBlockFields();
            // Get all message data block fields from the entity
            String[] entityColumns = entityClass.newInstance().getMessageDataBlockFields();
            // Build the query with provider id and null end reason code for the passed entity type
            StringBuilder queryStr = new StringBuilder("SELECT t FROM ");

            if (genNumber != null) {
                queryStr.append(entityClass.getSimpleName()).append(" t WHERE t.endReasonCode is not null ");
            } else {
                queryStr.append(entityClass.getSimpleName()).append(" t WHERE t.endReasonCode is null ");
            }
            if (pauthId != null) {
                queryStr.append(" AND t.pauthPauthId.pauthId = ?1 ");
            } else if (wlId != null) {
                queryStr.append(" AND t.wlWlId.wlId = ?1 ");
            }
            int count = 2;//starts from 2, as pauthId is ?1
            boolean isCheckingdataOwnerCode = false;

            if (genNumber != null) {
                queryStr.append(" AND t.generationNum = ?").append(count++);
            }

            List<String> nullDtoFieldsDoNotSetParmeter = new ArrayList<>();
            for (int i = 0; i < entityColumns.length; i++) {
                // If the field is data owner code then we need to check with IN parameter, and pass all data owner codes which have access
                if ("dataOwnerCode.ctlNameCode".equals(entityColumns[i])) {
                    queryStr.append(" AND t.").append(entityColumns[i]).append(" IN :dataOwnerCodes ");
                    isCheckingdataOwnerCode = true;
                } else {
                    if (PropertyUtils.invokeGetter(record, dtoFields[i]) != null) {
                        queryStr.append(" AND t.").append(entityColumns[i]).append(" = ?").append(count++);
                    } else {
                        nullDtoFieldsDoNotSetParmeter.add(dtoFields[i]);
                    }
                }
            }
            queryStr.append(" order by t.generationNum DESC");
            TypedQuery<? extends Object> query = em.createQuery(queryStr.toString(), record.getClass());
            count = 2;
            query.setParameter(1, pauthId != null ? pauthId : wlId);

            if (genNumber != null) {
                query.setParameter(count, genNumber.longValue());
                count++;
            }

            for (String column : dtoFields) {
                Object value = PropertyUtils.invokeGetter(record, column);
                if (value == null && !nullDtoFieldsDoNotSetParmeter.contains(column)) {
                    return null;//If any query param is null
                } else if (value == null && nullDtoFieldsDoNotSetParmeter.contains(column)) {
                    // just ignore
                } else if (column.equals("dataOwnerCode"))  {
                    // just ignore, there already is a data owner code parameter
                } else {
                    query.setParameter(count++, value);
                }
            }
            if (isCheckingdataOwnerCode) {
                query.setParameter("dataOwnerCodes", ownerCodes);
            }
            List<? extends Object> resultList = query.getResultList();
            if (!resultList.isEmpty()) {
                if (resultList.size() > 1) {
                    throw new EntityValidationException(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_NONUNIQUE_TYPES_BLOCK));
                } else {
                    T result = (T) resultList.get(0);
                    return result;
                }
            } else {
                return null;
            }
        } catch (InstantiationException | IllegalAccessException ex) {
            throw new IllegalStateException(ex);
        }

    }

    /**
     * Returns if any existing record is there for the message data block
     * received
     *
     * @param <T> - The entity types
     * @param pauthId - provider id
     * @param wlId - Work location id
     * @param record - plr dto instance
     * @param entityClass - the entity class type
     * @param ctProviderRoleTypes - provider role type (to check the DPS)
     * @return
     * @throws EntityValidationException
     */
    public <T extends MessageDataBlock> T find(Long pauthId, Long wlId, MessageDataBlockDto record,
            Class<? extends MessageDataBlock> entityClass, PrsCtProviderRoleTypes ctProviderRoleTypes) throws EntityValidationException {
        try {
            if (pauthId != null && wlId != null) {
                throw new IllegalArgumentException("Either provider id or work location can be not null. Coding issue. Check the logic.");
            }
            // Get all the message data block fields from dto
            String[] dtoFields = record.getMessageDataBlockFields();
            // Get all message data block fields from the entity
            String[] entityColumns = entityClass.newInstance().getMessageDataBlockFields();
            // Build the query with provider id and null end reason code for the passed entity type
            StringBuilder queryStr = new StringBuilder("SELECT t FROM ");

            queryStr.append(entityClass.getSimpleName()).append(" t WHERE t.endReasonCode is null ");

            if (pauthId != null) {
                queryStr.append(" AND t.pauthPauthId.pauthId = ?1 ");
            } else if (wlId != null) {
                queryStr.append(" AND t.wlWlId.wlId = ?1 ");
            }
            int count = 2;//starts from 2, as pauthId is ?1
            boolean isCheckingdataOwnerCode = false;

            for (int i = 0; i < entityColumns.length; i++) {
                // If the field is data owner code then we need to check with IN parameter, and pass all data owner codes which have access
                if ("dataOwnerCode.ctlNameCode".equals(entityColumns[i])) {
                    queryStr.append(" AND t.").append(entityColumns[i]).append(" IN :dataOwnerCodes ");
                    isCheckingdataOwnerCode = true;
                } else {
                    Object fieldValue = PropertyUtils.invokeGetter(record, dtoFields[i]);
                    if (fieldValue != null) {
                        if(!(fieldValue instanceof String) || StringUtils.isNotBlank((String)fieldValue)) {
                            queryStr.append(" AND t.").append(entityColumns[i]).append(" = ?").append(count++);
                        }
                    }
                }
            }
            queryStr.append(" order by t.generationNum DESC");
            TypedQuery<? extends Object> query = em.createQuery(queryStr.toString(), record.getClass());
            count = 2;
            query.setParameter(1, pauthId != null ? pauthId : wlId);

            String[] nullableMessageDataBlockFields = null;
            if (record instanceof MessageDataBlockDtoNullable) {
                nullableMessageDataBlockFields = ((MessageDataBlockDtoNullable) record).getMessageDataBlockFieldsNullable();
            }
            for (String column : dtoFields) {
                Object value = PropertyUtils.invokeGetter(record, column);
                if (value!=null) {
                    if(!(value instanceof String) || StringUtils.isNotBlank((String)value)) {
                        query.setParameter(count++, value);
                    }
                } else {
                    if (nullableMessageDataBlockFields == null || !Arrays.asList(nullableMessageDataBlockFields).contains(column)) {
                        return null;
                    }
                }
            }
            if (isCheckingdataOwnerCode) {
                // get all applicable data owner codes for the table, for the current user and record types
                List<String> applicableDataOwnerCodes = null;
                if (pauthId != null) {
                    applicableDataOwnerCodes = authorizationService.getAllowedDataOwnerCodes(entityClass, ctProviderRoleTypes, (DtoMetaData) record);
                } else if (wlId != null) {
                    applicableDataOwnerCodes = authorizationService.getAllowedWlDataOwnerCodes(entityClass, ctProviderRoleTypes, (DtoMetaData) record);
                }
                //Add an empty string, return null 
                if (applicableDataOwnerCodes == null || applicableDataOwnerCodes.isEmpty()) {
                    return null;
                }
                query.setParameter("dataOwnerCodes", applicableDataOwnerCodes);
            }
            List<? extends Object> resultList = query.getResultList();
            if (!resultList.isEmpty()) {
                if (resultList.size() > 1) {
                    throw new EntityValidationException(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_NONUNIQUE_TYPES_BLOCK));
                } else {
                    T result = (T) resultList.get(0);
                    return result;
                }
            } else {
                return null;
            }
        } catch (InstantiationException | IllegalAccessException ex) {
            throw new IllegalStateException(ex.getMessage());
        }
    }

    /**
     * Get previous state of record
     *
     * @param dtoTemp Changed DTO
     * @param workLocationId Worklocation ID, can be null
     * @param role Provider role type
     * @return the previous record
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     * @throws EntityValidationException
     * @throws IllegalAccessException
     */
    public AbstractProviderDetail getOriginalAbsProvDetailRecord(final AbstractProviderDetail dtoTemp, Long workLocationId, PrsCtProviderRoleTypes role) throws IllegalArgumentException, InvocationTargetException, EntityValidationException, IllegalAccessException {
        MessageDataBlock dataBlock = getOriginalMessageDataBlockRecord(dtoTemp, workLocationId, role);
        Method method = dtoTemp.getDtoConverterMethod();
        AbstractProviderDetail prevDto = null;
        if (dataBlock != null) {
            prevDto = (AbstractProviderDetail) method.invoke(providerDtoConverter, dataBlock);
        }
        return prevDto;
    }

    public MessageDataBlock getOriginalMessageDataBlockRecord(final AbstractProviderDetail dtoTemp, Long workLocationId, PrsCtProviderRoleTypes role) throws IllegalArgumentException, InvocationTargetException, EntityValidationException, IllegalAccessException {
        long genNum = dtoTemp.getGenerationNum() > 1l ? dtoTemp.getGenerationNum() - 1l : 1l;
        MessageDataBlock dataBlock = find(dtoTemp.getPauthId(), workLocationId, (MessageDataBlockDto) dtoTemp, dtoTemp.getEntityClass(), role, genNum, Arrays.asList(dtoTemp.getDataOwnerCode()));
        Method method = dtoTemp.getDtoConverterMethod();
        if (dataBlock != null) {
            AbstractProviderDetail prevDto = (AbstractProviderDetail) method.invoke(providerDtoConverter, dataBlock);
            if (prevDto != null && prevDto.getEndReasonCode().matches(CodeTableCodes.GrsCtEndReasonTypes.CHANGE.getValue())) {
                genNum = dtoTemp.getGenerationNum() > 2l ? dtoTemp.getGenerationNum() - 2l : 1l;
                dataBlock = find(dtoTemp.getPauthId(), workLocationId, (MessageDataBlockDto) dtoTemp, dtoTemp.getEntityClass(), role, genNum, Arrays.asList(dtoTemp.getDataOwnerCode()));
            }
        }
        return dataBlock;
    }
}
