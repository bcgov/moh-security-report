package ca.bc.gov.health.plr.util;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This is just a helper class for some reflection methods.
 *
 * @author jonathan.wiebe
 */
public class ReflectionUtils {

    private static Map<String, MethodType> methodMap = new HashMap();
    private static Map<String, MethodType> methodMapDeclared = new HashMap();

    public enum MethodType {

        none, method, declaredMethod;
    }

    public static Object methodInvoke(Object obj, String methodName) {
        return methodInvoke(obj, methodName, false);
    }
    /**
     * Invoke the method
     *
     * @param obj Object with method
     * @param methodName Method to invoke
     * @return Result of invocation, can be null
     */
    public static Object methodInvoke(Object obj, String methodName, boolean forceAccessible) {
        if (obj == null) {
            return null;
        }
        MethodType methodType = hasMethod(obj, methodName);
        if (methodType == MethodType.method) {
            try {
                Method method = obj.getClass().getMethod(methodName);
                return method.invoke(obj);
            } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ex) {
                // this should never happen, but log it
                Logger.getLogger(ReflectionUtils.class.getName()).log(Level.INFO, null, ex);
            }
        } else if (methodType == MethodType.declaredMethod) {
            try {
                Method method = obj.getClass().getDeclaredMethod(methodName);
                method.setAccessible(forceAccessible);
                return method.invoke(obj);
            } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ex) {
                // this should never happen, but log it
                Logger.getLogger(ReflectionUtils.class.getName()).log(Level.INFO, null, ex);
            }
        }
        return null;
    }

    /**
     * Is there a method of that name?
     *
     * This method tries to save a bit of performance by hash-mapping the
     * results of each look up to avoid the looping where possible.
     *
     * @param obj Object to check
     * @param methodName Method name
     * @return True if there is a method
     */
    public static MethodType hasMethod(Object obj, String methodName) {
        MethodType methodType = MethodType.none;
        if (obj == null) {
            return MethodType.none;
        }
        String key = obj.getClass().getCanonicalName() + methodName;
        boolean hasIt = false;
        if (methodMap.containsKey(key)) {
            methodType = methodMap.get(key);
        } else if (methodMapDeclared.containsKey(key)) {
            methodType = methodMapDeclared.get(key);
        } else {
            Method[] methods = obj.getClass().getMethods();
            for (Method method : methods) {
                if (methodName.matches(method.getName())) {
                    hasIt = true;
                    methodType = MethodType.method;
                    break;
                }
            }
            if (!hasIt) {
                methodType = hasDeclaredMethod(obj, methodName);
            } else {
                if (!methodMap.containsKey(key)) {
                    methodMap.put(key, methodType);
                }
            }
        }

        return methodType;
    }

    /**
     * Is there a method of that name?
     *
     * This method tries to save a bit of performance by hash-mapping the
     * results of each look up to avoid the looping where possible.
     *
     * @param obj Object to check
     * @param methodName Method name
     * @return True if there is a method
     */
    private static MethodType hasDeclaredMethod(Object obj, String methodName) {
        MethodType methodType = MethodType.none;
        if (obj == null) {
            return MethodType.none;
        }
        String key = obj.getClass().getCanonicalName() + methodName;
        boolean hasIt = false;
        Method[] methods = obj.getClass().getDeclaredMethods();
        for (Method method : methods) {
            if (methodName.matches(method.getName())) {
                hasIt = true;
                methodType = MethodType.declaredMethod;
                break;
            }
        }
        if (!methodMapDeclared.containsKey(key)) {
            methodMapDeclared.put(key, methodType);
        }
        return methodType;
    }

}
