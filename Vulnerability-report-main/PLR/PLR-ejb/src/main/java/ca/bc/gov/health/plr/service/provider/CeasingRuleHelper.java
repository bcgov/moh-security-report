/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.converter.AddressDtoConverter;
import ca.bc.gov.health.plr.dto.converter.ElectronicAddressDtoConverter;
import ca.bc.gov.health.plr.dto.converter.InformationRouteDtoConverter;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.converter.TelephoneDtoConverter;
import ca.bc.gov.health.plr.dto.provider.AddressDto;
import ca.bc.gov.health.plr.dto.provider.ElectronicAddressDto;
import ca.bc.gov.health.plr.dto.provider.InformationRouteDto;
import ca.bc.gov.health.plr.dto.provider.LocationDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.TelecommunicationDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDetailsDto;
import ca.bc.gov.health.plr.ejb.entity.GrsAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsElectronicAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsTelephones;
import ca.bc.gov.health.plr.ejb.entity.PrsInformationRoutes;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import ca.bc.gov.health.plr.rule.BusinessRuleResult;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

/**
 * Helper class to cease locations.
 * @author kuan.fan
 */
@Stateless
public class CeasingRuleHelper {

    @PersistenceContext(unitName = "PLR-ejbPU")
    protected EntityManager em;

    @EJB
    private JournalService<PrsInformationRoutes> journalServiceInfoRoute;    
    
    @EJB
    private JournalService<GrsElectronicAddresses> journalServiceEleAddr;    
    
    @EJB
    private JournalService<GrsAddresses> journalServiceAddr;    
    
    @EJB
    private JournalService<GrsTelephones> journalServiceTelecomm;    
    
    @EJB
    protected CodesDao codesDao;

    @EJB
    private ElectronicAddressDtoConverter eleAddrDtoConverter;   
    
    @EJB
    private TelephoneDtoConverter telecommDtoConverter;    

    @EJB
    private AddressDtoConverter addressDtoConverter;         

    @EJB
    private ProviderDtoConverter providerDtoConverter; 
    
    @EJB
    private InformationRouteDtoConverter infoRouteDtoConverter;        

    /**
     * Validate if an electronic address can be ceased
     * @param pauthId the provider id
     * @param wlId the work location id
     * @param wlChid the work location chid
     * @param eleAddr the electronic address
     * @throws BusinessRuleException thrown if it can be ceased
     */
    public void validateEleAddrRefByInfoRoute(Long pauthId, Long wlId, Long wlChid, ElectronicAddressDto eleAddr) throws BusinessRuleException {
        boolean isRefByProviderOrWL = false;
        TypedQuery<Long> query = em.createNamedQuery("PrsInformationRoutes.countEleAddrRefByProviderInfoRoute", Long.class)
                .setParameter("wlChid", wlChid)
                .setParameter("pauthId", pauthId)
                .setParameter("commuPurposeTypeCodeId", eleAddr.getCommunicationPurposeId())
                .setParameter("eleAddrTypeCodeId", eleAddr.getTypeId());
        Long count = query.getSingleResult();
        if(count>0) {
            isRefByProviderOrWL = true;
        } else {

            //find the information route list which the WL electronic address is referenced by work locations
            //the work locations include the to be ceased work location and could also include work locations
            //doesn't belong to current provider
            TypedQuery<PrsInformationRoutes> query2 = em.createNamedQuery("PrsInformationRoutes.findEleAddrRefByWLInfoRoute", PrsInformationRoutes.class)
                    .setParameter("wlChid", wlChid)
                    .setParameter("commuPurposeTypeCodeId", eleAddr.getCommunicationPurposeId())
                    .setParameter("eleAddrTypeCodeId", eleAddr.getTypeId());
            List<PrsInformationRoutes> refByWLInfoRouteList = query2.getResultList();
            List<PrsInformationRoutes> refByCeasedWLInfoRouteList = this.filterRef(pauthId, refByWLInfoRouteList);
            for(PrsInformationRoutes infRoute : refByCeasedWLInfoRouteList) {
                if(infRoute.getWlWlId().getWlId().longValue()!=wlId.longValue()) {
                    isRefByProviderOrWL = true;
                    break;
                }
            }        
        }
        if(isRefByProviderOrWL) {
            BusinessRuleKeys key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASELEADDASSOCIATED;
            String message = BusinessRuleMessageDao.getMessageResource(key);
            BusinessRuleMessage businessRuleMessage = new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR);
            BusinessRuleResult brr = new BusinessRuleResult(false, Arrays.asList(businessRuleMessage));
            throw new BusinessRuleException(brr);
        }
        
    }

    /**
     * Validate if an telecommunication can be ceased
     * @param pauthId the provider id
     * @param wlId the work location id
     * @param wlChid the work location chid
     * @param telecomm the telecommunication
     * @throws BusinessRuleException thrown if it can be ceased
     */
    public void validateTelecommRefByInfoRoute(Long pauthId, Long wlId, Long wlChid, TelecommunicationDto telecomm) throws BusinessRuleException {
        boolean isRefByProviderOrWL = false;
        TypedQuery<Long> query = em.createNamedQuery("PrsInformationRoutes.countTelecommRefByProviderInfoRoute", Long.class)
                .setParameter("wlChid", wlChid)
                .setParameter("pauthId", pauthId)
                .setParameter("commuPurposeTypeCodeId", telecomm.getCommunicationPurposeId())
                .setParameter("telecommTypeCodeId", telecomm.getTypeId());
        Long count = query.getSingleResult();
        if(count>0) {
            isRefByProviderOrWL = true;
        } else {
        
            //find the information route list which the WL electronic address is referenced by work locations
            //the work locations include the to be ceased work location and could also include work locations
            //doesn't belong to current provider
            TypedQuery<PrsInformationRoutes> query2 = em.createNamedQuery("PrsInformationRoutes.findTelecommRefByWLInfoRoute", PrsInformationRoutes.class)
                    .setParameter("wlChid", wlChid)
                    .setParameter("commuPurposeTypeCodeId", telecomm.getCommunicationPurposeId())
                    .setParameter("telecommTypeCodeId", telecomm.getTypeId());
            List<PrsInformationRoutes> refByWLInfoRouteList = query2.getResultList();
            List<PrsInformationRoutes> refByCeasedWLInfoRouteList = this.filterRef(pauthId, refByWLInfoRouteList);
            for(PrsInformationRoutes infRoute : refByCeasedWLInfoRouteList) {
                if(infRoute.getWlWlId().getWlId().longValue()!=wlId.longValue()) {
                    isRefByProviderOrWL = true;
                    break;
                }
            }        
        }
        if(isRefByProviderOrWL) {
            BusinessRuleKeys key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASTELECOMMASSOCIATED;
            String message = BusinessRuleMessageDao.getMessageResource(key);
            BusinessRuleMessage businessRuleMessage = new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR);
            BusinessRuleResult brr = new BusinessRuleResult(false, Arrays.asList(businessRuleMessage));
            throw new BusinessRuleException(brr);
        }
        
    }

    /**
     * Validate if an telecommunication can be ceased
     * @param pauthId the provider id
     * @param wlId the work location id
     * @param wlChid the work location chid
     * @param addr the the address
     * @throws BusinessRuleException thrown if it can be ceased
     */
    public void validateAddrRefByInfoRoute(Long pauthId, Long wlId, Long wlChid, AddressDto addr) throws BusinessRuleException {
        boolean isRefByProviderOrWL = false;
        TypedQuery<Long> query = em.createNamedQuery("PrsInformationRoutes.countAddrRefByProviderInfoRoute", Long.class)
                .setParameter("wlChid", wlChid)
                .setParameter("pauthId", pauthId)
                .setParameter("commuPurposeTypeCodeId", addr.getCommunicationPurposeId())
                .setParameter("addrTypeCodeId", addr.getTypeId());
        Long count = query.getSingleResult();
        if(count>0) {
            isRefByProviderOrWL = true;
        } else {
            //find the information route list which the WL address is referenced by work locations
            //the work locations include the to be ceased work location and could also include work locations
            //doesn't belong to current provider
            TypedQuery<PrsInformationRoutes> query2 = em.createNamedQuery("PrsInformationRoutes.findAddrRefByWLInfoRoute", PrsInformationRoutes.class)
                    .setParameter("wlChid", wlChid)
                    .setParameter("commuPurposeTypeCodeId", addr.getCommunicationPurposeId())
                    .setParameter("addrTypeCodeId", addr.getTypeId());
            List<PrsInformationRoutes> refByWLInfoRouteList = query2.getResultList();
            List<PrsInformationRoutes> refByCeasedWLInfoRouteList = this.filterRef(pauthId, refByWLInfoRouteList);
            for(PrsInformationRoutes infRoute : refByCeasedWLInfoRouteList) {
                if(infRoute.getWlWlId().getWlId().longValue()!=wlId.longValue()) {
                    isRefByProviderOrWL = true;
                    break;
                }
            }        
        }
        if(isRefByProviderOrWL) {
            BusinessRuleKeys key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASADDRASSOCIATED;
            String message = BusinessRuleMessageDao.getMessageResource(key);
            BusinessRuleMessage businessRuleMessage = new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR);
            BusinessRuleResult brr = new BusinessRuleResult(false, Arrays.asList(businessRuleMessage));
            throw new BusinessRuleException(brr);
        }
        
    }
    
    /**
     * Remove the information routes whose work location ids don't belong to the pauthId
     * @param pauthId Long the provider id
     * @param refByWLInfoRouteList List the list of information route
     * @return List<PrsInformationRoutes> the filtered list
     */
    private  List<PrsInformationRoutes> filterRef(Long pauthId, List<PrsInformationRoutes> refByWLInfoRouteList) {
        List<PrsInformationRoutes> refByCeasedWLInfoRouteList = new ArrayList<>();
        for(PrsInformationRoutes infRoute : refByWLInfoRouteList) {
            TypedQuery<Long> query3 = em.createNamedQuery("PrsWorkLocations.countWorkLocationWithProvider", Long.class)
                .setParameter("pauthId", pauthId)
                .setParameter("wlId", infRoute.getWlWlId().getWlId());
            Long count3 = query3.getSingleResult();
            if(count3>0) {
                refByCeasedWLInfoRouteList.add(infRoute);
            }
        }
        return refByCeasedWLInfoRouteList;
    }

    /**
     * Cease the work location electronic addresses
     * @param eleAddrDtoList the electronic addresses to be ceased
     * @param ceaseEndReasonType the ceasing type
     * @return the ceased electronic address dtos
     * @throws DuplicateRecordException thrown the ceasing failed
     */
    public List<ElectronicAddressDto> ceaseWLEleAddresses(List<ElectronicAddressDto> eleAddrDtoList, GrsCtEndReasonTypes ceaseEndReasonType) throws DuplicateRecordException{
        List<ElectronicAddressDto> newEleAddrDtoList = new ArrayList<>();
        for(ElectronicAddressDto eleAddrDto : eleAddrDtoList) {
            if(eleAddrDto.getEndReasonCode()==null) {
                GrsElectronicAddresses eleAddr = this.eleAddrDtoConverter.toEntity(eleAddrDto);
                eleAddr.setEndReasonCode(ceaseEndReasonType);
                GrsElectronicAddresses newEleAddr = this.journalServiceEleAddr.journal(eleAddr);
                newEleAddrDtoList.add(this.providerDtoConverter.buildElectronicAddress(newEleAddr));
            } else {
                newEleAddrDtoList.add(eleAddrDto);
            }
        }
        return newEleAddrDtoList;
    }

    /**
     * Cease the work location telecommunications
     * @param telecommDtoList the telecommunications to be ceased
     * @param ceaseEndReasonType the ceasing type
     * @return the ceased telecommunication  dtos
     * @throws DuplicateRecordException thrown the ceasing failed
     */
    public List<TelecommunicationDto> ceaseWLTelecomms(List<TelecommunicationDto> telecommDtoList, GrsCtEndReasonTypes ceaseEndReasonType) throws DuplicateRecordException{
        List<TelecommunicationDto> newTelecommDtoList = new ArrayList<>();
        for(TelecommunicationDto telecommDto : telecommDtoList) {
            if(telecommDto.getEndReasonCode()==null) {
                GrsTelephones telecomm = this.telecommDtoConverter.toEntity(telecommDto);
                telecomm.setEndReasonCode(ceaseEndReasonType);
                GrsTelephones newTelecomm = this.journalServiceTelecomm.journal(telecomm);
                newTelecommDtoList.add(this.providerDtoConverter.buildTelephone(newTelecomm));
            } else {
                newTelecommDtoList.add(telecommDto);
            }
        }
        return newTelecommDtoList;
    }
    
    /**
    * Cease the work location addresses
    * @param addrDtoList the addrDtoList to be ceased
    * @param ceaseEndReasonType the ceasing type
    * @return the ceased address  dtos
    * @throws DuplicateRecordException thrown the ceasing failed
    */
    public List<AddressDto> ceaseWLAddresses(List<AddressDto> addrDtoList, GrsCtEndReasonTypes ceaseEndReasonType) throws DuplicateRecordException{
        List<AddressDto> newAddrDtoList = new ArrayList<>();
        for(AddressDto addrDto : newAddrDtoList) {
            if(addrDto.getEndReasonCode()==null) {
                GrsAddresses addr = this.addressDtoConverter.toEntity(addrDto);
                addr.setEndReasonCode(ceaseEndReasonType);
                GrsAddresses newAddr = this.journalServiceAddr.journal(addr);
                newAddrDtoList.add(this.providerDtoConverter.buildAddress(newAddr));
            } else {
                newAddrDtoList.add(addrDto);
            }
        }
        return newAddrDtoList;
    }    
    
    /**
    * Cease the work location information routes
    * @param infoRouteDtoList the infoRouteDtoList to be ceased
    * @param ceaseEndReasonType the ceasing type
    * @return the ceased address information route dtos
    * @throws DuplicateRecordException thrown the ceasing failed
    */
    public List<InformationRouteDto> ceaseWLInfoRoutes(List<InformationRouteDto> infoRouteDtoList, GrsCtEndReasonTypes ceaseEndReasonType) throws DuplicateRecordException{
        List<InformationRouteDto> newInfoRouteDtoList = new ArrayList<>();
        for(InformationRouteDto infoRouteDto : infoRouteDtoList) {
            if(infoRouteDto.getEndReasonCode()==null) {
                PrsInformationRoutes infoRoute = this.infoRouteDtoConverter.toEntity(infoRouteDto);
                infoRoute.setEndReasonCode(ceaseEndReasonType);
                PrsInformationRoutes newInfoRoute = this.journalServiceInfoRoute.journal(infoRoute);
                newInfoRouteDtoList.add(this.providerDtoConverter.buildInformationRoute(newInfoRoute));
            } else {
                newInfoRouteDtoList.add(infoRouteDto);
            }
        }
        return newInfoRouteDtoList;
    }    
    
    /**
     * Find if properties communicationPurposeCode, communicationDataOwnerCode, typeCode in InformationRouteDto and LocationDto match.
     * @param infoRouteDto
     * @param locationDto
     * @return 
     */
    public boolean isCommonMatchBetweenIRAndLocation(InformationRouteDto infoRouteDto, LocationDto locationDto) {
        if(infoRouteDto.getCommunicationPurposeCode().compareToIgnoreCase(locationDto.getCommunicationPurposeCode())==0 &&
                infoRouteDto.getCommunicationDataOwnerCode().compareToIgnoreCase(locationDto.getDataOwnerCode())==0 ) {
            if(locationDto instanceof ElectronicAddressDto) {
                if(infoRouteDto.getElectronicAddressDto().getTypeCode().compareToIgnoreCase(((ElectronicAddressDto)locationDto).getTypeCode())==0) {
                    return true;
                }
            } else if(locationDto instanceof AddressDto) {
                if(infoRouteDto.getAddressDto().getTypeCode().compareToIgnoreCase(((AddressDto)locationDto).getTypeCode())==0) {
                    return true;
                }
            } else if(locationDto instanceof ElectronicAddressDto) {
                if(infoRouteDto.getTelecommunicationDto().getTypeCode().compareToIgnoreCase(((TelecommunicationDto)locationDto).getTypeCode())==0) {
                    return true;
                }
            }
        }
        return false;
    }
    
    //the infoRoute is list of provider IR
    //the locationDto is WL Location
    /**
     * Verify if provider information route reference work location's location.
     * @param providerInfoRouteDto the provider information route 
     * @param wlLocationDto the work location's location
     * @param wlChid the to be ceased work location chid
     * @throws BusinessRuleException thrown if the providerInfoRouteDto references to the wlLocationDto
     */
    public void makeSureProviderIRNotRefWLLocation(InformationRouteDto providerInfoRouteDto, LocationDto wlLocationDto, Long wlChid) throws BusinessRuleException {
        
        //first find if the common properties in locationDto matched the ones in inforRouteDto
        boolean findCommonPropertiesMatch = this.isCommonMatchBetweenIRAndLocation(providerInfoRouteDto, wlLocationDto);
        if(findCommonPropertiesMatch) {
            if(providerInfoRouteDto.getWorkLocationIdentifier().longValue()==wlChid.longValue()) {
                BusinessRuleKeys key = null;
                if(wlLocationDto instanceof ElectronicAddressDto) {
                    key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASELEADDASSOCIATED;
                }
                if(wlLocationDto instanceof AddressDto) {
                    key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASADDRASSOCIATED;
                }
                if(wlLocationDto instanceof TelecommunicationDto) {
                    key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASTELECOMMASSOCIATED;
                }
                String message = BusinessRuleMessageDao.getMessageResource(key);
                BusinessRuleMessage businessRuleMessage = new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR);
                BusinessRuleResult brr = new BusinessRuleResult(false, Arrays.asList(businessRuleMessage));
                throw new BusinessRuleException(brr);

            }
        }
    }
    
    public void makeSureProviderIRListNotRefWLLocation(List<InformationRouteDto> providerInfoRouteDtoList, LocationDto wlLocationDto, Long wlChid) throws BusinessRuleException {
        for(InformationRouteDto infoRouteDto: providerInfoRouteDtoList) {
            this.makeSureProviderIRNotRefWLLocation(infoRouteDto, wlLocationDto, wlChid);
        }
    }

    /**
     * Verify if the work location's information route references to the given work location's location
     * @param wlInfoRouteDto the work locations's information route
     * @param wlLocationDtothe given work location's location
     * @param wlDataOwnerCode the to be ceased work location's data owner code
     * @param wlChid the to be ceased work location chid
     * @throws BusinessRuleException thrown if it does reference
     */
    public void makeSureWLIRExcludeSelfNotRefWLLocation(InformationRouteDto wlInfoRouteDto, LocationDto wlLocationDto, String wlDataOwnerCode, Long wlChid) throws BusinessRuleException {
        
        //first find if the common properties in locationDto matched the ones in inforRouteDto
        boolean findCommonPropertiesMatch = this.isCommonMatchBetweenIRAndLocation(wlInfoRouteDto, wlLocationDto);
        if(findCommonPropertiesMatch) {
            if(wlInfoRouteDto.getWorkLocationDataOwnerCode()!=null && wlDataOwnerCode!=null && wlInfoRouteDto.getWorkLocationDataOwnerCode().compareToIgnoreCase(wlDataOwnerCode)==0 &&
                    wlInfoRouteDto.getWorkLocationIdentifier().longValue()==wlChid.longValue() &&
                    wlInfoRouteDto.getWlWlId().longValue()!=wlLocationDto.getWlWlId().longValue()) {
                BusinessRuleKeys key = null;
                if(wlLocationDto instanceof ElectronicAddressDto) {
                    key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASELEADDASSOCIATED;
                }
                if(wlLocationDto instanceof AddressDto) {
                    key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASADDRASSOCIATED;
                }
                if(wlLocationDto instanceof TelecommunicationDto) {
                    key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASTELECOMMASSOCIATED;
                }
                String message = BusinessRuleMessageDao.getMessageResource(key);
                BusinessRuleMessage businessRuleMessage = new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR);
                BusinessRuleResult brr = new BusinessRuleResult(false, Arrays.asList(businessRuleMessage));
                throw new BusinessRuleException(brr);

            }
        }
    }
    
    public void makeSureWLIRListExcludeSelfNotRefWLLocation(List<InformationRouteDto> wlInfoRouteDtoList, LocationDto wlLocationDto, String wlDataOwnerCode, Long wlChid) throws BusinessRuleException {
        for(InformationRouteDto wlInforRouteDto : wlInfoRouteDtoList) {
            this.makeSureWLIRExcludeSelfNotRefWLLocation(wlInforRouteDto, wlLocationDto, wlDataOwnerCode, wlChid);
        }
    }    

    /**
     * Verify if the provider information route references to the given provider location
     * @param providerInfoRouteDto the provider information route
     * @param providerLocationDto the given provider location
     * @throws BusinessRuleException thrown if it does reference
     */
    public void makeSureProviderIRNotRefProviderLocation(InformationRouteDto providerInfoRouteDto, LocationDto providerLocationDto) throws BusinessRuleException {
        
        boolean findCommonPropertiesMatch = this.isCommonMatchBetweenIRAndLocation(providerInfoRouteDto, providerLocationDto);
        if(findCommonPropertiesMatch) {
            if(providerInfoRouteDto.getPauthId().longValue()==providerLocationDto.getPauthId().longValue()) {
                BusinessRuleKeys key = null;
                if(providerLocationDto instanceof ElectronicAddressDto) {
                    key = BusinessRuleKeys.ERROR_CASE_ELECADDR_HASINFOROUTE;
                }
                if(providerLocationDto instanceof AddressDto) {
                    key = BusinessRuleKeys.ERROR_CASE_ADDRESS_HASINFOROUTE;
                }
                if(providerLocationDto instanceof TelecommunicationDto) {
                    key = BusinessRuleKeys.ERROR_CASE_TELECOMM_HASINFOROUTE;
                }
                String message = BusinessRuleMessageDao.getMessageResource(key);
                BusinessRuleMessage businessRuleMessage = new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR);
                BusinessRuleResult brr = new BusinessRuleResult(false, Arrays.asList(businessRuleMessage));
                throw new BusinessRuleException(brr);
            }
        }
    }
    
    public void makeSureProviderIRListNotRefProviderLocation(List<InformationRouteDto> providerInfoRouteDtoList, LocationDto providerLocationDto) throws BusinessRuleException {
        for(InformationRouteDto providerInfoRouteDto : providerInfoRouteDtoList) {
            this.makeSureProviderIRNotRefProviderLocation(providerInfoRouteDto, providerLocationDto);
        }
        
    }
    
    /**
     * Verify if the work location information route references to the give work location location
     * @param wlInfoRouteDto the work location information route
     * @param wlLocationDto the give work location location
     * @param wlDataOwnerCode the to be csases work location data owner code
     * @param wlChid the to be ceased work location chid
     * @throws BusinessRuleException thrown if it does reference
     */
    public void makeSureWLIRNotRefWLLocation(InformationRouteDto wlInfoRouteDto, LocationDto wlLocationDto, String wlDataOwnerCode, Long wlChid) throws BusinessRuleException {
        
        //first find if the common properties in locationDto matched the ones in inforRouteDto
        boolean findCommonPropertiesMatch = this.isCommonMatchBetweenIRAndLocation(wlInfoRouteDto, wlLocationDto);
        if(findCommonPropertiesMatch) {
            if(wlInfoRouteDto.getWorkLocationDataOwnerCode()!=null && wlDataOwnerCode!=null && wlInfoRouteDto.getWorkLocationDataOwnerCode().compareToIgnoreCase(wlDataOwnerCode)==0 &&
                    wlInfoRouteDto.getWorkLocationIdentifier().longValue()==wlChid.longValue()) {
                BusinessRuleKeys key = null;
                if(wlLocationDto instanceof ElectronicAddressDto) {
                    key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASELEADDASSOCIATED;
                }
                if(wlLocationDto instanceof AddressDto) {
                    key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASADDRASSOCIATED;
                }
                if(wlLocationDto instanceof TelecommunicationDto) {
                    key = BusinessRuleKeys.ERROR_CASE_WORKLOCATION_HASTELECOMMASSOCIATED;
                }
                String message = BusinessRuleMessageDao.getMessageResource(key);
                BusinessRuleMessage businessRuleMessage = new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR);
                BusinessRuleResult brr = new BusinessRuleResult(false, Arrays.asList(businessRuleMessage));
                throw new BusinessRuleException(brr);

            }
        }
    }
    
    public void makeSureWLIRListNotRefWLLocation(List<InformationRouteDto> wlInfoRouteDtoList, LocationDto wlLocationDto, String wlDataOwnerCode, Long wlChid) throws BusinessRuleException {
        for(InformationRouteDto wlInfoRouteDto : wlInfoRouteDtoList) {
            this.makeSureWLIRNotRefWLLocation(wlInfoRouteDto, wlLocationDto, wlDataOwnerCode, wlChid);
        }
    }
    
}
