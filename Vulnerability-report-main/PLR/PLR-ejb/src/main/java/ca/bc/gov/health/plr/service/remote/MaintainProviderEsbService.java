package ca.bc.gov.health.plr.service.remote;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.esb.Acknowledgment;
import ca.bc.gov.health.plr.dto.esb.BatchRequest;
import ca.bc.gov.health.plr.dto.esb.BatchResponse;
import ca.bc.gov.health.plr.dto.esb.EsbMessage;
import ca.bc.gov.health.plr.dto.esb.MaintainProviderRequest;
import ca.bc.gov.health.plr.dto.esb.MaintainProviderResponse;
import ca.bc.gov.health.plr.dto.provider.esb.AddressDto;
import ca.bc.gov.health.plr.dto.provider.esb.BatchStatus;
import ca.bc.gov.health.plr.dto.provider.esb.CollegeIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.esb.OrgNameDto;
import ca.bc.gov.health.plr.dto.provider.esb.PersonNameDto;
import ca.bc.gov.health.plr.dto.provider.esb.ProviderDetails;
import ca.bc.gov.health.plr.dto.provider.esb.TelecommunicationDto;
import ca.bc.gov.health.plr.dto.provider.esb.WorkLocationDto;
import ca.bc.gov.health.plr.ejb.entity.GrsCtBooleanTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsIdentifiers;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.interceptors.AccessViolationException;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.producer.type.Authenticated;
import ca.bc.gov.health.plr.producer.type.User;
import ca.bc.gov.health.plr.rule.provider.AcceptableAddressValidator;
import ca.bc.gov.health.plr.rule.provider.AcceptableNameValidator;
import ca.bc.gov.health.plr.rule.provider.AcceptableOrganizationNameValidator;
import ca.bc.gov.health.plr.rule.provider.AcceptableTelecommunicationValidator;
import ca.bc.gov.health.plr.service.JNDIResourceLoader;
import ca.bc.gov.health.plr.service.PLRConfigurationResourceLoader;
import ca.bc.gov.health.plr.service.distribution.RestClient;
import ca.bc.gov.health.plr.util.EsbMessageUtil;
import ca.bc.gov.health.plr.util.MessageCodeHelper;
import ca.bc.gov.health.plr.util.NumberUtils;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import javax.annotation.Resource;
import javax.ejb.Asynchronous;
import javax.ejb.EJB;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;

/**
 * Maintain Provider remote service. Receives calls from HSA-ESB.
 *
 * Methods in this interface will now throw business exceptions. Validation and
 * security errors will be indicated in the response metadata.
 *
 * See interface Javadoc on MaintainProviderServiceRemote for more details.
 *
 * @author David Sharpe <david.a.sharpe@cgi.com>
 */
@Stateless
public class MaintainProviderEsbService implements MaintainProviderServiceRemote {

    @Inject
    @Authenticated
    private Instance<User> user;

    @Resource
    private SessionContext sessionContext;

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;

    @Inject
    private CodesDao codesDao;

    @Inject
    private ProviderMessageValidator providerMessageValidator;

    @Inject
    private MaintainProviderEsbServiceDelegate delegate;

    @Inject
    private ProviderDtoConverter providerDtoConverter;

    @Inject
    private PLRConfigurationResourceLoader plrConfigLoader;

    @EJB
    private EsbMessageUtil esbMessageUtil;

    @EJB
    private BatchTransactionStatusServiceLocal batchTransactionStatusService;

    @Inject
    private RestClient restClient;

    @Inject
    private JNDIResourceLoader jndiResourceLoader;

    private static final String SUCCESS_CODE = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.TX_SUCCESS_CODE);
    private static final String SUCCESS_MSG = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.TX_SUCCESS_MESSAGE);
    private static final String NON_UNIQUE_IDENTIFIERS_CODE = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.NON_UNIQUE_IDENTIFIERS_CODE);
    private static final String NON_UNIQUE_IDENTIFIERS_MESSAGE = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.NON_UNIQUE_IDENTIFIERS_MESSAGE);
    private static final String MESSAGE_TYPE_ADD = "PRPM_IN301010";
    private static final String MESSAGE_TYPE_UPDATE = "PRPM_IN303010";
    private static final Integer DEFAULT_RETRY_INTERVAL_MILLISECONDS = 1000;
    private static final Integer DEFAULT_NUMBER_OF_RETRIES = 5;

    private static final Logger LOG = Logger.getLogger(MaintainProviderEsbService.class.getName());

    /*
     See Javadoc on MaintainProviderServiceRemote interface.
     */
    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public MaintainProviderResponse maintainProvider(MaintainProviderRequest request) {
        MaintainProviderResponse response = new MaintainProviderResponse();
        setResponseMetadata(response, request);

        try {

            user.get().setUserId(request.getRegistryUserOrgId());

            if (user.get().getUserPrincipal() == null) {
                throw new AccessViolationException(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_ACCESS_VIOLATION_NO_AUTHENTICATION_GENERIC));
            }
            providerMessageValidator.validateRequestForNullValues(request, response);

            if (!response.getAcknowledgments().isEmpty()) {
                populateGeneralErrorInResponse(response);
                populateMetadataForAcks(response.getAcknowledgments(), request);
                return response;
            }
        } catch (RuntimeException re) {
            ExceptionHandler.handleException(response, re);
            populateGeneralErrorInResponse(response);
            populateMetadataForAcks(response.getAcknowledgments(), request);
            return response;
        }

        // set the interaction ID based on message type
        if (request.getMessageType() != null && request.getMessageType().equals(MaintainProviderEsbService.MESSAGE_TYPE_ADD)) {
            response.setMessageInteractionId(plrConfigLoader.getValue(PLRConfigurationResourceLoader.ADD_INTERACTIONID_RESPONSE));
        } else if (request.getMessageType() != null && request.getMessageType().equals(MaintainProviderEsbService.MESSAGE_TYPE_UPDATE)) {
            response.setMessageInteractionId(plrConfigLoader.getValue(PLRConfigurationResourceLoader.UPDATE_INTERACTIONID_RESPONSE));
        } else {
            //if we don't know, echo back the one provided
            response.setMessageInteractionId(request.getMessageInteractionId());
        }

        Set<String> changedBlocks = processProviderDetails(request, response);

        if (!response.getAcknowledgments().isEmpty() && !containsOnlyChangeNoChange(response.getAcknowledgments())) {
            sessionContext.setRollbackOnly();
            populateGeneralErrorInResponse(response);
            //Clear out provider & enter provider ID only
            response.setProviderDetails(new ProviderDetails());
            response.getProviderDetails().setIdentifiers(new ArrayList<CollegeIdentifierDto>());
            if (request.getProviderDetails() != null && request.getProviderDetails().getIdentifiers() != null) {
                response.getProviderDetails().getIdentifiers().addAll(request.getProviderDetails().getIdentifiers());
            }
        } else {

            // save the list of acks
            Collection<Acknowledgment> listAcks = response.getAcknowledgments();
            response.setAcknowledgment(new ArrayList<Acknowledgment>());

            // add the success first
            Acknowledgment acknowledgment = new Acknowledgment(SUCCESS_CODE, SUCCESS_MSG);
            acknowledgment.setTypeCode(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.TX_ACK_TYPECODE));
            acknowledgment.setTargetMessageExtension(request.getUniqueMessageId());
            response.addAcknowledgment(acknowledgment);

            // Added for avoiding unwanted iteration of acknowledgements to determine if the tx is success
            response.setIsTransactionSuccess(true);
            if (changedBlocks != null && !changedBlocks.isEmpty()) {
                response.addAcknowledgment(new Acknowledgment(BusinessRuleMessageDao.getMessageResource(
                        BusinessRuleKeys.TX_SUCCESS_CHANGEDBLOCKS_CODE),
                        BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.TX_SUCCESS_CHANGEDBLOCKS_MESSAGE) + StringUtils.join(changedBlocks, ",")));

            }

            // PLRP3-48 HL7 update message - when invalid character(s) were 
            // stripped it will return a warning in Response message
            addIllegalCharacterWarnings(request, response);

            addInvalidandUnknownAddressWarnings(response);

            // add the other messages
            response.addAcknowledgments(listAcks);

            // if there aren't any provider details, no need to filter
            if (response.getProviderDetails() != null) {
                esbMessageUtil.filterInactiveItems(response.getProviderDetails());
            }
        }

        // PLR-1463
        response.setMessageType(request.getMessageType());

        // PLR-1468
        // A very strange issue here when I tried delegating to esbMessageUtil.populateMetadataForAcks, 
        // but invocation kept failing for no meaningful reason; therefore, taking matters into my
        // own hands
        populateMetadataForAcks(response.getAcknowledgments(), request);

        return response;
    }

    /**
     * Checks if the acks list contains only "change no change"s Only change no
     * change is not considered a failed transaction.
     */
    protected boolean containsOnlyChangeNoChange(Collection<Acknowledgment> collection) {
        Iterator<Acknowledgment> it = collection.iterator();
        while (it.hasNext()) {
            Acknowledgment ack = it.next();

            if (ack == null || ack.getMsgCode() == null) {
                return false;
            }
            if (!getChangeNoChangeCode().equals(ack.getMsgCode().trim())) {
                return false;
            }
        }
        return true;
    }

    protected String getAddressInvalidCode() {
        return ((MessageCodeHelper.splitCodeAndMessage(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.WARNING_ADDRESS_INVALID)))[0]).trim();
    }
    protected String getChangeNoChangeCode() {
        return ((MessageCodeHelper.splitCodeAndMessage(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.NO_CHANGE_ON_UPDATE)))[0]).trim();
    }

    /**
     * If there are any errors, add a general error to response.
     *
     * @param response
     */
    private void populateGeneralErrorInResponse(MaintainProviderResponse response) {
        // Add the Transaction has failed acknowledgement ... this is going to break so many unit tests
        Acknowledgment ack = new Acknowledgment();
        List<Acknowledgment> listAcks = new ArrayList<>();
        String[] message = MessageCodeHelper.splitCodeAndMessage(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_GENERAL_TRANSACTION_FAILED));
        ack.setMsgCode(message[0]);
        ack.setMsgText(message[1]);
        listAcks.add(ack);  // must be the first one
        listAcks.addAll(response.getAcknowledgments());
        response.getAcknowledgments().clear();
        response.getAcknowledgments().addAll(listAcks);

    }

    private void setResponseMetadata(EsbMessage response, EsbMessage request) {
        response.setUniqueMessageId(request.getUniqueMessageId());
        response.setProcessingCode(request.getProcessingCode());
        response.setProcessModeCode(request.getProcessModeCode());
        response.setAcceptAckCode(request.getAcceptAckCode());
        response.setSecurityText(request.getSecurityText());
        response.setTargetNetworkAddressChid(request.getTargetNetworkAddressChid());
        response.setTargetEnvironment(request.getTargetEnvironment());
        response.setTargetFacilityId(request.getTargetFacilityId());
        response.setTargetRegistryUserId(request.getTargetRegistryUserId());
        response.setTargetServer(request.getTargetServer());
        response.setTargetOrganizationChid(request.getTargetOrganizationChid());
        response.setSourceNetworkAddressChid(request.getSourceNetworkAddressChid());
        response.setSourceRegistryUserId(request.getSourceRegistryUserId());
        response.setSourceEnvironment(request.getSourceEnvironment());
        response.setSourceFacilityId(request.getSourceFacilityId());
        response.setSourceServer(request.getSourceServer());
        response.setSourceOrganizationChid(request.getSourceOrganizationChid());
        response.setSourceUserId(request.getSourceUserId());
        response.setSourceJurisdiction(request.getSourceJurisdiction());
        response.setResponsiblePersonUserId(request.getResponsiblePersonUserId());
        response.setTargetJurisdiction(request.getTargetJurisdiction());
        response.setOriginalEventDate(request.getOriginalEventDate());
        response.setMessageType(request.getMessageType());
        response.setEsbMetadata(request.getEsbMetadata());
        esbMessageUtil.populateMetadata(response);
    }

    @TransactionAttribute(TransactionAttributeType.NEVER)
    @Asynchronous
    @Override
    public void asyncMaintainProviders(BatchRequest batchRequest) {
        MaintainProviderServiceRemote selfEjb = sessionContext.getBusinessObject(MaintainProviderServiceRemote.class);
        BatchResponse batchResponse = selfEjb.maintainProviders(batchRequest);
        boolean complete = false;
        int iteration = 0;
        Exception ee = null;
        Integer numberRetries = DEFAULT_NUMBER_OF_RETRIES;
        Integer retryInterval = DEFAULT_RETRY_INTERVAL_MILLISECONDS;

        // use the plrConfigLoader to load number of retries property from database
        // if not there use the default
        try {
            numberRetries = NumberUtils.isInteger(plrConfigLoader.getValue(Consts.BATCH_RESPONSE_NUM_RETRIES)) ? Integer.parseInt(plrConfigLoader.getValue(Consts.BATCH_RESPONSE_NUM_RETRIES)) : DEFAULT_NUMBER_OF_RETRIES;
            //verify the numberRetries is updated from the database
            Logger.getLogger(MaintainProviderEsbService.class.getName()).log(Level.INFO, "numberRetries is: {0}.", new Object[]{numberRetries});
        } catch (NumberFormatException ex) {
            // catch and release, use default set above
            Logger.getLogger(MaintainProviderEsbService.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            // catch and release, use default set above
            Logger.getLogger(MaintainProviderEsbService.class.getName()).log(Level.SEVERE, null, ex);
        }

        // use the plrConfigLoader to load interval in milliseconds from database property 
        // if not there use the default
        try {
            retryInterval = NumberUtils.isInteger(plrConfigLoader.getValue(Consts.BATCH_RESPONSE_RETRY_INTERVAL_MILLISECONDS)) ? Integer.parseInt(plrConfigLoader.getValue(Consts.BATCH_RESPONSE_RETRY_INTERVAL_MILLISECONDS)) : DEFAULT_RETRY_INTERVAL_MILLISECONDS;
            //verify the retryInterval is updated from the database
            Logger.getLogger(MaintainProviderEsbService.class.getName()).log(Level.INFO, "retryInterval is: {0}.", new Object[]{retryInterval});
        } catch (NumberFormatException ex) {
            // catch and release, use default set above
            Logger.getLogger(MaintainProviderEsbService.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            // catch and release, use default set above
            Logger.getLogger(MaintainProviderEsbService.class.getName()).log(Level.SEVERE, null, ex);
        }

        // loop until we complete or reach max iterations
        while (!complete && iteration < numberRetries) {
            try {
                restClient.post(batchResponse);
                complete = true;
            } catch (Exception e) {
                ee = e; // keep track of the last exception so we can log it later
                LOG.log(Level.SEVERE, "Failed to deliver to BatchResponse to ESB, iteration #" + iteration);
                try {
                    Thread.sleep(retryInterval);
                } catch (InterruptedException ex) {
                    Logger.getLogger(MaintainProviderEsbService.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            iteration++;
        }

        if (!complete) {
            LOG.log(Level.SEVERE, "Failed to deliver BatchResponse to ESB.", ee);
            batchTransactionStatusService.logStatus(BatchStatus.ESB_UNREACHABLE, batchRequest.getUniqueMessageId(), batchRequest.getClient(), batchResponse);
        }
    }

    /*
     See Javadoc on MaintainProviderServiceRemote interface.
     */
    @TransactionAttribute(TransactionAttributeType.NEVER)
    @Override
    public BatchResponse maintainProviders(BatchRequest batchRequest) {
        Validate.notNull(batchRequest);
        checkForEmptyBatch(batchRequest);
        boolean anyFailed = false;
        long fullStartTime = System.currentTimeMillis();
        Collection<MaintainProviderResponse> maintainProviderResponses = new ArrayList<>();
        int submitted = 0, failed = 0, success = 0;
        LOG.log(Level.INFO, batchRequest.getMaintainProviderRequests().size() + " add/update transaction batch message received.");
        for (MaintainProviderRequest maintainProviderRequest : batchRequest.getMaintainProviderRequests()) {

            long startTime = System.currentTimeMillis();
            // need to reset the user for batch, the user is pulled independently from each request
            user.get().resetUser();

            MaintainProviderServiceRemote selfEjb = sessionContext.getBusinessObject(MaintainProviderServiceRemote.class);
            MaintainProviderResponse maintainProviderResponse = selfEjb.maintainProvider(maintainProviderRequest);
            maintainProviderResponses.add(maintainProviderResponse);
            anyFailed = anyFailed || !maintainProviderResponse.isIsTransactionSuccess();
            submitted++;
            if (maintainProviderResponse.isIsTransactionSuccess()) {
                success++;
            } else {
                failed++;
            }

            LOG.log(Level.INFO, "Provider " + submitted + " of " + batchRequest.getMaintainProviderRequests().size() + " for batch " + batchRequest.getUniqueMessageId() + " saved in " + (System.currentTimeMillis() - startTime) + "ms");

        }

        BatchResponse batchResponse = new BatchResponse();

        batchResponse.setFailedTransactions("" + failed);
        batchResponse.setSubmittedTransactions("" + submitted);
        batchResponse.setSuccessfulTransactions("" + success);

        setResponseMetadata(batchResponse, batchRequest);

        batchResponse.setMaintainProviderResponses(maintainProviderResponses);

        if (anyFailed) {
            batchTransactionStatusService.logStatus(BatchStatus.FAILED, batchRequest.getUniqueMessageId(), batchRequest.getClient());
        } else {
            batchTransactionStatusService.logStatus(BatchStatus.PROCESSED, batchRequest.getUniqueMessageId(), batchRequest.getClient());
        }
        // PLR-1463
        batchResponse.setMessageType(batchRequest.getMessageType());

        //PLR-1719
        batchResponse.setTargetOrganizationChid(plrConfigLoader.getValue("target_organization_chid"));
        batchResponse.setTargetNetworkAddressChid(plrConfigLoader.getValue("target_network_address_chid"));
        batchResponse.setSourceOrganizationChid(plrConfigLoader.getValue("source_organization_chid"));
        batchResponse.setSourceNetworkAddressChid(plrConfigLoader.getValue("source_network_address_chid"));
        batchResponse.setSourceFacilityId(plrConfigLoader.getValue("source_facility_id"));
        batchResponse.setTargetFacilityId(plrConfigLoader.getValue("target_facility_id"));
        batchResponse.setSourceServer(plrConfigLoader.getValue("source_server_id"));
        batchResponse.setTargetServer(plrConfigLoader.getValue("target_server_id"));
        LOG.log(Level.INFO, "Batch transaction completed in " + (System.currentTimeMillis() - fullStartTime) + "ms");
        return batchResponse;
    }

    /**
     * <pre>
     * 1. Check if atleast one college identifier is provided : else throw error
     * 2. Find the providers for the college identifier using the combination of
     * provider chid, role type code
     * 3. If more than one provider is found, reject the message
     * 4. If no provider is found assume it's ADD, else it's UPDATE
     * 5. Calls the delegate method accordingly
     * </pre>
     *
     * @param request
     * @param response
     */
    private Set<String> processProviderDetails(MaintainProviderRequest request, MaintainProviderResponse response) {
        providerMessageValidator.validateMinimumData(request, response);

        if (!response.getAcknowledgments().isEmpty()) {
            return null;
        }
        PrsProviders provider = findProvider(request, response);
        if (!response.getAcknowledgments().isEmpty()) {
            return null;
        }
        try {

            // make sure there aren't too many different kinds of names
            providerMessageValidator.validateMessageNames(request, response, (provider == null));
            if (!response.getAcknowledgments().isEmpty()) {
                return null;
            }

            if (provider != null) {
                if (!response.getAcknowledgments().isEmpty()) {
                    return null;
                }
                return delegate.updateProvider_Message(request, response, providerDtoConverter.toProviderDetails(provider, false));
            } else {
                providerMessageValidator.validateAdd(request, response);
                if (!response.getAcknowledgments().isEmpty()) {
                    return null;
                }
                return delegate.addProvider_Message(request, response);
            }
            // watch for access violation exceptions
        } catch (Exception ex) {
            ExceptionHandler.handleException(response, ex);
        }
        return null;
    }

    private PrsProviders findProvider(MaintainProviderRequest request, MaintainProviderResponse response) {
        PrsProviders provider = null;
        GrsCtBooleanTypes active = codesDao.lookup(GrsCtBooleanTypes.class, CodeTableCodes.GrsCtBooleanTypes.YES);
        String providerRoleType = request.getProviderDetails().getType();
        for (CollegeIdentifierDto collegeIdentifierDto : request.getProviderDetails().getIdentifiers()) {
            providerMessageValidator.validateCollegeIdentifier(collegeIdentifierDto, response);
            TypedQuery<GrsIdentifiers> query = em.createNamedQuery("GrsIdentifiers.findByProviderChidAndType", GrsIdentifiers.class);
            query.setParameter("providerChid", collegeIdentifierDto.getIdentifier());
            query.setParameter("identifierTypeCode", collegeIdentifierDto.getTypeCode());
            query.setParameter("providerRoleType", providerRoleType);
            query.setParameter("active", active);
            List<GrsIdentifiers> identifiers = query.getResultList();
            if (!identifiers.isEmpty()) {
                GrsIdentifiers identifier = identifiers.get(0);
                if (identifiers.size() > 1 || (provider != null && !provider.equals(identifier.getPauthPauthId()))) {
                    //There are conflicting providers
                    response.addAcknowledgment(new Acknowledgment(NON_UNIQUE_IDENTIFIERS_CODE, NON_UNIQUE_IDENTIFIERS_MESSAGE));
                    return null;
                }
                provider = identifier.getPauthPauthId();

                // if the party type of the provider doesn't match that of the request, nothing was found
                // i.e. looking for an IND but found an ORD, return nothing
                if (!provider.getPartyTypeCode().getCtlNameCode().equals(request.getProviderDetails().getProviderType())) {
                    return null;
                }

                // The requested identifier matched an existing identifier, so to avoid trying to recreate it set the IDs.
                // This has interactions with MaintainProviderEsbServiceDelegate::convertAndValidateIdentifiers.
                collegeIdentifierDto.setPauthId(provider.getPauthId());
                collegeIdentifierDto.setId(identifier.getPidId());
            }
        }
        return provider;
    }

    /*
     populate some info for acknowledgements
     */
    private void populateMetadataForAcks(Collection<Acknowledgment> acks, MaintainProviderRequest request) {

        for (Acknowledgment ack : acks) {
            ack.setTargetMessageExtension(request.getUniqueMessageId());
        }

    }

    /**
     * PLR-1776. If the batch is empty, add an empty Maintain Provider Message
     * to trigger error-handling that occurs later in
     * <code>providerMessageValidator.validateRequestForNullValues(request, response);</code>
     * in the <code>maintainProvider</code> method.
     */
    private static void checkForEmptyBatch(BatchRequest batchRequest) {
        if (CollectionUtils.isEmpty(batchRequest.getMaintainProviderRequests())) {
            batchRequest.setMaintainProviderRequests(new ArrayList<MaintainProviderRequest>());
            batchRequest.getMaintainProviderRequests().add(new MaintainProviderRequest());
        }
    }

    private void addInvalidandUnknownAddressWarnings(MaintainProviderResponse response) {
        if (response.getProviderDetails() != null) {
            if (response.getProviderDetails().getAddresses() != null) {
                // filter only inactive addresses data blocks from response provider details
                esbMessageUtil.filterInactiveItemsFromList(response.getProviderDetails().getAddresses());
                            
                for (AddressDto addr : response.getProviderDetails().getAddresses()) {
                    // filter warn response messages only for active addresses 
                    LOG.log(Level.INFO, "MaintainProviderESBService addInvalidandUnknownAddressWarnings "
                            + "addr.isActive() is: {0} and addr.getEndReasonCodeId() is: {1} and addr.getId is: {2}.", 
                            new Object[]{addr.isActive(), addr.getEndReasonCodeId(), addr.getId()});
                    if (addr.isActive() && addr.getEndReasonCodeId() == null) {
                        addUnknownAndInvalidAddressWarnings(addr, response);                        
                    }
                }
            }
            if (response.getProviderDetails().getWorkLocationList() != null) {
                // filter only inactive WL data blocks from response provider details
                esbMessageUtil.filterInactiveItemsFromList(response.getProviderDetails().getWorkLocationList());
                
                for (WorkLocationDto wl : response.getProviderDetails().getWorkLocationList()) {
                    if (wl.getAddresses() != null) {
                        // filter only inactive WL address data blocks from each WL
                        esbMessageUtil.filterInactiveItemsFromList(wl.getAddresses());
                        
                        for (AddressDto addr : wl.getAddresses()) {
                            // filter warn response messages only for active WL addresses 
                            LOG.log(Level.INFO, "MaintainProviderESBService addInvalidandUnknownAddressWarnings "
                                + "WL addr.isActive() is: {0} and WL addr.getEndReasonCodeId() is: {1} and addr.getId is: {2}.", 
                                    new Object[]{addr.isActive(), addr.getEndReasonCodeId(), addr.getId()});
                            if (addr.isActive() && addr.getEndReasonCodeId() == null) {
                                addUnknownAndInvalidAddressWarnings(addr, response);
                            }
                        }
                    }
                }
            }
        }
    }

    private static void addUnknownAndInvalidAddressWarnings(AddressDto addr, MaintainProviderResponse response) {
       // could be null for addresses that haven't been sent to address doctor
        if (addr.getValidationStatus() != null) {
            if (addr.getValidationStatus().equals(CodeTableCodes.PrsCtAddressValidationCodes.INVALID.getValue())) {
                StringBuilder message = new StringBuilder();
                message.append(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_CASE_ADDRESS_INVALID));
                message.append(": " + addr.getFullAddress());
                String[] splitMessage = MessageCodeHelper.splitCodeAndMessage(message.toString());
                response.addAcknowledgment(new Acknowledgment(splitMessage[0], String.format(splitMessage[1])));
            }
            if (addr.getValidationStatus().equals(CodeTableCodes.PrsCtAddressValidationCodes.UNKNOWN.getValue())) {
                StringBuilder message = new StringBuilder();
                message.append(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.WARNING_ADDRESS_VALIDATION_UNKNOWN));
                message.append(": " + addr.getFullAddress());
                String[] splitMessage = MessageCodeHelper.splitCodeAndMessage(message.toString());
                response.addAcknowledgment(new Acknowledgment(splitMessage[0], String.format(splitMessage[1])));
            }
        }
    }

    // PLRP3-6, EA REQ-00320 Rejection of Non-Acceptable Characters
    private static void addIllegalCharacterWarnings(MaintainProviderRequest request, MaintainProviderResponse response) {
        List<ValueToValidate> valuesToValidate = new ArrayList<>();
        for (AddressDto addr : request.getProviderDetails().getAddresses()) {
            valuesToValidate.add(new ValueToValidate(addr.getAddressLineOne(), "Address Line 1", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(addr.getAddressLineTwo(), "Address Line 2", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(addr.getAddressLineThree(), "Address Line 3", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(addr.getAddressLineFour(), "Address Line 4", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(addr.getCity(), "City", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(addr.getPostalCode(), "Postal/Zip Code", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
        }
        for (PersonNameDto name : request.getProviderDetails().getIndNames()) {
            valuesToValidate.add(new ValueToValidate(name.getPrefix(), "Prefix", AcceptableNameValidator.INVALID_NAME_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(name.getFirstName(), "First Name", AcceptableNameValidator.INVALID_NAME_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(name.getSecondName(), "Second Name", AcceptableNameValidator.INVALID_NAME_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(name.getThirdName(), "Third Name", AcceptableNameValidator.INVALID_NAME_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(name.getLastName(), "Last Name", AcceptableNameValidator.INVALID_NAME_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(name.getSuffix(), "Suffix Name", AcceptableNameValidator.INVALID_NAME_CHARACTERS_PATTERN));
        }
        for (TelecommunicationDto tel : request.getProviderDetails().getTelecommunication()) {
            valuesToValidate.add(new ValueToValidate(tel.getAreaCode(), "Area Code", AcceptableTelecommunicationValidator.INVALID_TELECOMMUNICATION_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(tel.getNumber(), "Telecommunication Number", AcceptableTelecommunicationValidator.INVALID_TELECOMMUNICATION_CHARACTERS_PATTERN));
            valuesToValidate.add(new ValueToValidate(tel.getExtension(), "Telecommunication Extension", AcceptableTelecommunicationValidator.INVALID_TELECOMMUNICATION_CHARACTERS_PATTERN));
        }

        // PLRP3-67 allow Organization short/long names to include special characters 0-9a-zA-Z:/-,()
        if (request.getProviderDetails().getOrgNames() != null
                && !request.getProviderDetails().getOrgNames().isEmpty()) {

            for (OrgNameDto orgName : request.getProviderDetails().getOrgNames()) {
                valuesToValidate.add(new ValueToValidate(orgName.getName(), "Organization Name", AcceptableOrganizationNameValidator.VALID_ORGANIZATION_NAME_CHARS_PATTERN));
                valuesToValidate.add(new ValueToValidate(orgName.getLongName(), "Organization Description", AcceptableOrganizationNameValidator.VALID_ORGANIZATION_NAME_CHARS_PATTERN));
            }
        }

        // PLRP3-62 added work locations warning messages for telecom/addresses
        if (request.getProviderDetails().getWorkLocationList() != null
                && !request.getProviderDetails().getWorkLocationList().isEmpty()) {

            for (WorkLocationDto workLocation : request.getProviderDetails().getWorkLocationList()) {
                // display response messages in work location telecom elements with invalid characters
                if (workLocation.getTelecommunications() != null
                        && !workLocation.getTelecommunications().isEmpty()) {
                    for (TelecommunicationDto telecomDto : workLocation.getTelecommunications()) {
                        valuesToValidate.add(new ValueToValidate(telecomDto.getAreaCode(), "Work Location Area Code", AcceptableTelecommunicationValidator.INVALID_TELECOMMUNICATION_CHARACTERS_PATTERN));
                        valuesToValidate.add(new ValueToValidate(telecomDto.getNumber(), "Work Location Telecommunication Number", AcceptableTelecommunicationValidator.INVALID_TELECOMMUNICATION_CHARACTERS_PATTERN));
                        valuesToValidate.add(new ValueToValidate(telecomDto.getExtension(), "Work Location Telecommunication Extension", AcceptableTelecommunicationValidator.INVALID_TELECOMMUNICATION_CHARACTERS_PATTERN));
                    }
                }
                // display response messages in work location address elements with invalid characters
                if (workLocation.getAddresses() != null
                        && !workLocation.getAddresses().isEmpty()) {
                    for (AddressDto addressDto : workLocation.getAddresses()) {
                        valuesToValidate.add(new ValueToValidate(addressDto.getAddressLineOne(), "Work Location Address Line 1", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
                        valuesToValidate.add(new ValueToValidate(addressDto.getAddressLineTwo(), "Work Location Address Line 2", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
                        valuesToValidate.add(new ValueToValidate(addressDto.getAddressLineThree(), "Work Location Address Line 3", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
                        valuesToValidate.add(new ValueToValidate(addressDto.getAddressLineFour(), "Work Location Address Line 4", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
                        valuesToValidate.add(new ValueToValidate(addressDto.getCity(), "Work Location City", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
                        valuesToValidate.add(new ValueToValidate(addressDto.getPostalCode(), "Work Location Postal/Zip Code", AcceptableAddressValidator.INVALID_ADDRESS_CHARACTERS_PATTERN));
                    }
                }
            }
        }

        for (ValueToValidate value : valuesToValidate) {
            if (value.invalid()) {
                String message = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.WARNING_INVALID_CHARS_DELETED);
                String[] splitMessage = MessageCodeHelper.splitCodeAndMessage(message);
                response.addAcknowledgment(new Acknowledgment(splitMessage[0], String.format(splitMessage[1], value.label)));
            }
        }
    }

    private static class ValueToValidate {

        final String value;
        final String label;
        final Pattern invalidCharactersPattern;

        public ValueToValidate(String value, String label, Pattern invalidCharactersPattern) {
            this.value = StringUtils.defaultString(value);
            this.label = label;
            this.invalidCharactersPattern = invalidCharactersPattern;
        }

        public boolean invalid() {
            return invalidCharactersPattern.matcher(value).find();
        }
    }
}
