package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.converter.AddressDtoConverter;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.ejb.entity.GrsAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.interceptors.AccessInterceptor;
import ca.bc.gov.health.plr.interceptors.TestUserInterceptor;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import ca.bc.gov.health.plr.rule.BusinessRuleResult;
import ca.bc.gov.health.plr.rule.provider.AccessRestrictionService;
import ca.bc.gov.health.plr.service.EntityValidatorService;
import ca.bc.gov.health.plr.service.validators.ConfidentialityValidator;
import ca.bc.gov.health.plr.service.validators.EntityChangeDetector;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.CheckEndReasonCode;
import ca.bc.gov.health.plr.service.AddressDoctorService;
import ca.bc.gov.health.plr.dto.AddressValidationStatsDto;
import ca.bc.gov.health.plr.ejb.entity.PrsCtAddressValidTypes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.dto.provider.AddressDto;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.service.AddressDoctorUnavailableException;
import ca.bc.gov.health.plr.service.validators.UserChidGenerator;
import static ca.bc.gov.health.plr.service.validators.UserChidGenerator.USER_SYS_ADDRESS_VALID;
import ca.bc.gov.health.plr.util.AddressDoctorBackgroundProcessorHelper;
import java.util.ArrayList;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;
import javax.inject.Inject;
import javax.interceptor.Interceptors;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

/**
 *
 * @author ian.scott
 */
@Stateless
@Interceptors({TestUserInterceptor.class, AccessInterceptor.class})
@LocalBean
public class MaintainAddressService implements MaintainService<AddressDto> {

    private static final String CLASSNAME = MaintainProviderService.class.getSimpleName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);

    @PersistenceContext(unitName = "PLR-ejbPU")
    protected EntityManager em;

    @EJB
    private AddressDtoConverter addressDtoConverter;
    @EJB
    private JournalService<GrsAddresses> journalService;

    @EJB
    private EntityValidatorService<GrsAddresses> validatorService;

    @EJB
    private ConfidentialityValidator<GrsAddresses> confidentialityValidator;

    @EJB
    private AccessRestrictionService accessRestrictionService;

    @EJB
    private ProviderDtoConverter providerDtoConverter;

    @EJB
    private EntityChangeDetector<AddressDto, GrsAddresses> entityChangeDetector;

    @Inject
    private AddressDoctorService addressDoctorManager;

    @EJB
    CodesDao codesDao;

    @EJB
    UserChidGenerator chidGenerator;

    @EJB
    private MaintainProviderService maintainProviderService;

    @EJB
    CheckEndReasonCode checkEndReasonCode;

    @EJB
    AddressDoctorBackgroundProcessorHelper addressDoctorBackgroundProcessorHelper;

    /**
     * Bulids a dto from a record in the database based on primary key (ID)
     *
     * @param toRefresh - a dto with an ID
     * @return - dto built from database record or null
     */
    public AddressDto refresh(AddressDto toRefresh) {
        GrsAddresses found = em.find(GrsAddresses.class, toRefresh.getId());
        AddressDto toSendBack = providerDtoConverter.buildAddress(found);
        return toSendBack;
    }

    /**
     * Query a fresh complete list of Addresses related to a specific provider
     * or work location.
     *
     * @param addr
     * @return a list of fresh note transfer objects
     */
    public List<AddressDto> refreshAddresses(AddressDto addr) {
        List<GrsAddresses> foundEntities = null;
        boolean ignoreWL = true;
        PrsCtProviderRoleTypes hptCode = null;
        if (addr.getPauthId() != null && addr.getWlWlId() != null && addr.getRuRuID() != null) {
            //TODO - shouldn't happen but what should happen here if it does
            PrsProviders provider = em.find(PrsProviders.class, addr.getPauthId());
            hptCode = provider.getHptCode();
            foundEntities = provider.getGrsAddressesList();
        } else if (addr.getWlWlId() != null) {
            PrsWorkLocations workLocation = em.find(PrsWorkLocations.class, addr.getWlWlId());
            foundEntities = workLocation.getGrsAddressesList();
            hptCode = workLocation.getPauthPauthId().getHptCode();
            ignoreWL = false;
        } else if (addr.getPauthId() != null) {
            PrsProviders provider = em.find(PrsProviders.class, addr.getPauthId());
            foundEntities = provider.getGrsAddressesList();
            hptCode = provider.getHptCode();
        } else if (addr.getRuRuID() != null) {
            GrsRegistryUsers regUser = em.find(GrsRegistryUsers.class, addr.getRuRuID());
            foundEntities = regUser.getGrsAddressesList();
        }
        List<AddressDto> dtos = providerDtoConverter.buildAddresses(foundEntities, ignoreWL);
        if (addr.getPauthId() != null) {
            accessRestrictionService.applyReadRestriction(dtos, hptCode, GrsAddresses.class);
        } else if (addr.getWlWlId() != null) {
            accessRestrictionService.applyWlReadRestriction(dtos, hptCode, GrsAddresses.class);
        }

        return dtos;
    }

    /**
     * Saves an address, assumes confidential validation is ON
     *
     * @param addressToSave adddress to save
     * @return
     * @throws DuplicateRecordException
     * @throws BusinessRuleException
     * @throws EntityValidationException
     */
    public AddressDto save(AddressDto addressToSave) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        return save(addressToSave, true, false);
    }

    public AddressDto save(AddressDto addressToSave, boolean runConfidentialValidator) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        return save(addressToSave, runConfidentialValidator, false);
    }
    /**
     * Persists a DTO to the database
     *
     * @param addressToSave dto to save
     * @return dto with values refreshed from the database
     * @throws ca.bc.gov.health.plr.service.provider.DuplicateRecordException
     * @throws ca.bc.gov.health.plr.rule.BusinessRuleException
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     */
    public AddressDto save(AddressDto addressToSave, boolean runConfidentialValidator, boolean fromBackgroundAddressProcessor) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        LOG.log(Level.INFO, "MaintainAddressService:save TOP");
        GrsAddresses newRecord = addressDtoConverter.toEntity(addressToSave);

        //if the change is to cease an address and the address is referenced by a information route(on provider or work location),
        //the csaeing operation is not allowed
        if (checkEndReasonCode.isCeased(addressToSave)) {
            validateCeaseCondition(newRecord);
        }

        // if ceasing then don't validate the address cause we don't want a new record 
        // created to record address validation stuff
        if (!checkEndReasonCode.isCeased(addressToSave)) {
            //Valiadate address against Address Doctor webservice only if it is a mailing address
            if (newRecord.getCountryCode().getCtlNameCode().equals(CodeTableCodes.PrsCtCountries.CANADA.getValue())) {
                validateAddress(newRecord);
            } else {
                newRecord.setValidationStatus(codesDao.lookup(PrsCtAddressValidTypes.class, "N"));
            }
        }

        // Address line 4 is not to be changed or added.  So grab the original record and populate the existing
        // record with the value ... then check for changes and journal.  This code is here when address line 4
        // is empty or null, if there is a record already, PRS will see that as a change and replace an existing 
        // address line 4 with null.
        GrsAddresses originalRecord = null;
        if (addressToSave.getId() != null) {
            originalRecord = em.find(newRecord.getClass(), addressToSave.getId());
            newRecord.setAddressLine4Txt(originalRecord.getAddressLine4Txt());
            addressToSave.setAddressLineFour(originalRecord.getAddressLine4Txt());
        }
        entityChangeDetector.checkForChanges(addressToSave, newRecord, originalRecord);

        if (addressToSave.isNoChangeOnUpdate()) {
            return addressToSave;
        }
        validate(newRecord, runConfidentialValidator);

        try {
            newRecord = journalService.journal(newRecord);

        } catch (DuplicateRecordException jex) {
            //If the error is duplicate record error, throw record specific error REQ-00916            
            String duplicateAddressMsg;
            if (newRecord.getRuRuId() != null) {
                duplicateAddressMsg = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_DUPLICATE_ADDRESS_REGUSER_DATA_BLOCK);
            } else {
                duplicateAddressMsg = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_DUPLICATE_ADDRESS_PROVIDER_DATA_BLOCK);
            }
            throw new DuplicateRecordException(duplicateAddressMsg + newRecord.getFieldName());
        }

        // handle user chid for admin address batch processing
        if (fromBackgroundAddressProcessor) {
            if (addressToSave.getUserChid() != null && !addressToSave.getUserChid().isEmpty()
                    && addressToSave.getUserChid().startsWith(USER_SYS_ADDRESS_VALID)) {
                newRecord.setUserChid(addressToSave.getUserChid());
            }
        }

        return providerDtoConverter.buildAddress(newRecord);
    }

    /**
     * Validate if the the address can be ceased.
     *
     * @param ga GrsAddresses the GrsAddresses to be ceased.
     * @throws BusinessRuleException thrown if the address can't be ceased.
     */
    private void validateCeaseCondition(GrsAddresses ga) throws BusinessRuleException {

        //cease condition 1: if the address belongs to provider and it i sthe last active address, it can't be ceases
        if (ga.getPauthPauthId() != null && ga.getPauthPauthId().getPauthId() != null) {
            //this address belongs to provider
            TypedQuery<GrsAddresses> addrQuery = em.createNamedQuery("GrsAddresses.findActiveProviderAddress", GrsAddresses.class)
                    .setParameter("pauthId", ga.getPauthPauthId());
            List<GrsAddresses> addrList = addrQuery.getResultList();
            boolean foundTheAddr = false;
            boolean isTheOnlyAddr = false;
            for (GrsAddresses addr : addrList) {
                if (addr.getAddrId().longValue() == ga.getAddrId().longValue()) {
                    foundTheAddr = true;
                }
            }
            if (addrList == null || addrList.size() == 1) {
                isTheOnlyAddr = true;
            }
            if (!foundTheAddr) {
                BusinessRuleKeys key = BusinessRuleKeys.ERROR_CASE_ADDRESS_INACTIVETOCEASE;
                String message = BusinessRuleMessageDao.getMessageResource(key);
                BusinessRuleMessage businessRuleMessage = new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR);
                BusinessRuleResult brr = new BusinessRuleResult(false, Arrays.asList(businessRuleMessage));
                throw new BusinessRuleException(brr);
            }
            if (isTheOnlyAddr) {
                BusinessRuleKeys key = BusinessRuleKeys.ERROR_CASE_ADDRESS_LASTPROVIDERADDRESSTOCEASE;
                String message = BusinessRuleMessageDao.getMessageResource(key);
                BusinessRuleMessage businessRuleMessage = new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR);
                BusinessRuleResult brr = new BusinessRuleResult(false, Arrays.asList(businessRuleMessage));
                throw new BusinessRuleException(brr);
            }

        }
    }

    private void validateAddress(GrsAddresses ga) throws BusinessRuleException {

        try {
            GrsAddresses gaResult = new GrsAddresses();
            boolean valid = addressDoctorManager.isAddressValidWithCorrection(ga, gaResult);
            if (!valid) {
                if (gaResult.getValidationStatus().getCtlNameCode().equals("N")) {
                    ga.setValidationStatus(codesDao.lookup(PrsCtAddressValidTypes.class, codesDao.lookup(PrsCtAddressValidTypes.class, CodeTableCodes.PrsCtAddressValidationCodes.NA.getValue()).getCtlNameCode()));
                } else {
                    ga.setValidationStatus(codesDao.lookup(PrsCtAddressValidTypes.class, codesDao.lookup(PrsCtAddressValidTypes.class, CodeTableCodes.PrsCtAddressValidationCodes.INVALID.getValue()).getCtlNameCode()));
                }
            } else {
                ga.setValidationStatus(codesDao.lookup(PrsCtAddressValidTypes.class, codesDao.lookup(PrsCtAddressValidTypes.class, CodeTableCodes.PrsCtAddressValidationCodes.VALID.getValue()).getCtlNameCode()));
            }
        } catch (AddressDoctorUnavailableException ex) {
            ga.setValidationStatus(codesDao.lookup(PrsCtAddressValidTypes.class, codesDao.lookup(PrsCtAddressValidTypes.class, CodeTableCodes.PrsCtAddressValidationCodes.UNKNOWN.getValue()).getCtlNameCode()));
        }
    }

    public GrsAddresses validateAddressForWarn(ca.bc.gov.health.plr.dto.provider.AddressDto addressDto) {
        GrsAddresses grsAddressesResult = new GrsAddresses();
        try {
            Boolean valid = addressDoctorManager.isAddressValidWithCorrection(addressDto, grsAddressesResult);

            // null means the service was unavailable, mark as unknown
            if (valid == null) {
                grsAddressesResult = new GrsAddresses();
                grsAddressesResult.setValidationStatus(codesDao.lookup(PrsCtAddressValidTypes.class, CodeTableCodes.PrsCtAddressValidationCodes.UNKNOWN.getValue()));
            }
            if (grsAddressesResult.getValidationStatus().getCtlNameCode().equals(CodeTableCodes.PrsCtAddressValidationCodes.INVALID.getValue())) {
                BusinessRuleKeys key = BusinessRuleKeys.ERROR_CASE_ADDRESS_INVALID;
                String message = BusinessRuleMessageDao.getMessageResource(key);
                FacesContext.getCurrentInstance().addMessage("adrMessages", new FacesMessage(FacesMessage.SEVERITY_WARN, message, ""));
                return grsAddressesResult;
            } else if (grsAddressesResult.getValidationStatus().getCtlNameCode().equals(CodeTableCodes.PrsCtAddressValidationCodes.UNKNOWN.getValue())) {
                BusinessRuleKeys key = BusinessRuleKeys.ERROR_CASE_ADDRESS_UNKOWN;
                String message = BusinessRuleMessageDao.getMessageResource(key);
                FacesContext.getCurrentInstance().addMessage("adrUnkMessages", new FacesMessage(FacesMessage.SEVERITY_WARN, message, ""));
                return grsAddressesResult;
            } else {
                return grsAddressesResult;
            }
        } catch (AddressDoctorUnavailableException ex) {
            grsAddressesResult = new GrsAddresses();
            grsAddressesResult.setValidationStatus(codesDao.lookup(PrsCtAddressValidTypes.class, CodeTableCodes.PrsCtAddressValidationCodes.UNKNOWN.getValue()));
            return grsAddressesResult;
        }
    }

    public AddressValidationStatsDto processOldAddresses() throws Exception {
        GrsAddresses address;
        try {
            // get ids of all addresses
            String queryStringUnknown = "select a.addrId from GrsAddresses a where a.validationStatus.ctlNameCode = 'U' AND (a.effectiveEndDate >= FUNCTION('TRUNC', CURRENT_DATE) OR a.effectiveEndDate IS NULL) AND a.endReasonCode IS NULL";
            String queryStringInvalid = "select a.addrId from GrsAddresses a where a.validationStatus.ctlNameCode = 'I' AND (a.effectiveEndDate >= FUNCTION('TRUNC', CURRENT_DATE) OR a.effectiveEndDate IS NULL) AND a.endReasonCode IS NULL";
            List<Long> addressIdsU = em.createQuery(queryStringUnknown).getResultList();
            List<Long> addressIdsI = em.createQuery(queryStringInvalid).getResultList();

            AddressValidationStatsDto addressValidationStatsDto = new AddressValidationStatsDto();

            // set up initial counts
            long unknownCount = addressIdsU.size();
            addressValidationStatsDto.setNumRecordsUnknown(Integer.valueOf((int) unknownCount));
            long invalidCount = addressIdsI.size();
            addressValidationStatsDto.setNumRecordsInvalid(Integer.valueOf((int) invalidCount));
            HashMap<String, Integer> result = new HashMap<String, Integer>();
            LOG.log(Level.INFO, "Address List Size : " + (unknownCount + invalidCount));

            List<Long> allIds = new ArrayList();
            allIds.addAll(addressIdsU);
            allIds.addAll(addressIdsI);

            int count = 0;
            for (Long id : allIds) {
                result = addressDoctorBackgroundProcessorHelper.validateOldAddress(id);
                if (result != null) {
                    count++;
                    addressValidationStatsDto.setNumStatusChanges(result.get(STATUS_CHANGE));
                    addressValidationStatsDto.setNumStatusToValid(result.get(STATUS_TO_VALID));
                    addressValidationStatsDto.setNumStatusToInvalid(result.get(STATUS_TO_INVALID));
                    addressValidationStatsDto.setNumStatusToUnknown(result.get(STATUS_TO_UNKNOWN));
                }
            }

            addressValidationStatsDto.setNumRecordsProcessed(count);

            return addressValidationStatsDto;
        } catch (Exception e) {
            throw e;
        }
    }

    public HashMap<String, Integer> validateOldAddress(GrsAddresses ga) {
        AddressDto auditAddressDto = providerDtoConverter.buildAddress(ga);

        HashMap<String, Integer> addrStat = new HashMap<String, Integer>();
        try {
            boolean valid = false;

            // Somtimes mandatory fields were missing from the database so this
            // code marks those records as invalid, no need to call address doctor
            // as missing city, province or country is automatically invalid.
            // Previous to this method the country is confirmed to be Canada so there
            // must be a postal code as well.
            if (ga.getCityTxt() == null || ga.getProvinceOrStateTxt() == null
                    || ga.getCountryCode() == null || ga.getPostalCodeOrZipTxt() == null
                    || ga.getCityTxt().isEmpty() || ga.getProvinceOrStateTxt().isEmpty()
                    || ga.getPostalCodeOrZipTxt().isEmpty()) {
                valid = false;
            } else {
                valid = addressDoctorManager.isValidAddress(ga);
            }
            if (!valid) {

                if (ga.getValidationStatus().getCtlNameCode().equals(CodeTableCodes.PrsCtAddressValidationCodes.VALID.getValue()) || ga.getValidationStatus().getCtlNameCode().equals(CodeTableCodes.PrsCtAddressValidationCodes.UNKNOWN.getValue())) {
                    if (!ga.getCountryCode().getCtlNameCode().equals(CodeTableCodes.PrsCtCountries.CANADA.getValue())) {
                        addrStat.put(STATUS_CHANGE, 1);
                        addrStat.put(STATUS_TO_INVALID, 0);
                        addrStat.put(STATUS_TO_UNKNOWN, 1);
                    } else {
                        addrStat.put(STATUS_CHANGE, 1);
                        addrStat.put(STATUS_TO_INVALID, 1);
                        addrStat.put(STATUS_TO_UNKNOWN, 0);
                    }
                } else {
                    addrStat.put(STATUS_CHANGE, 0);
                    addrStat.put(STATUS_TO_INVALID, 0);
                    addrStat.put(STATUS_TO_UNKNOWN, 0);
                }
                addrStat.put(STATUS_TO_VALID, 0);

                LOG.log(Level.INFO, "Invalid address ID: " + Long.toString(ga.getAddrId()));
//                ga.setValidationStatus(codesDao.lookup(PrsCtAddressValidTypes.class, "I"));                

                // set validation status from AD service
                auditAddressDto.setValidationStatus(CodeTableCodes.PrsCtAddressValidationCodes.INVALID.getValue());

                // set end reason code CHG and user chid for admin address batch
                populateAuditFieldsAddressDto(auditAddressDto);

                saveAddress(auditAddressDto);
            } else {
                if (ga.getValidationStatus().getCtlNameCode().equals(CodeTableCodes.PrsCtAddressValidationCodes.INVALID.getValue()) || ga.getValidationStatus().getCtlNameCode().equals(CodeTableCodes.PrsCtAddressValidationCodes.UNKNOWN.getValue())) {
                    addrStat.put(STATUS_CHANGE, 1);
                    addrStat.put(STATUS_TO_VALID, 1);
                    addrStat.put(STATUS_TO_UNKNOWN, 0);
                } else {
                    addrStat.put(STATUS_CHANGE, 0);
                    addrStat.put(STATUS_TO_VALID, 0);
                    addrStat.put(STATUS_TO_UNKNOWN, 0);
                }
                addrStat.put(STATUS_TO_INVALID, 0);

                LOG.log(Level.INFO, "Valid address ID: " + Long.toString(ga.getAddrId()));
//                ga.setValidationStatus(codesDao.lookup(PrsCtAddressValidTypes.class, "V"));

                // set validation status from AD service
                auditAddressDto.setValidationStatus(CodeTableCodes.PrsCtAddressValidationCodes.VALID.getValue());

                // set end reason code CHG and user chid for admin address batch
                populateAuditFieldsAddressDto(auditAddressDto);

                saveAddress(auditAddressDto);

            }

        } catch (AddressDoctorUnavailableException ex) {
            LOG.log(Level.INFO, "Unknown address ID: " + Long.toString(ga.getAddrId()));
            // address doctor is unavilable, no status change
            addrStat.put(STATUS_CHANGE, 0);
            addrStat.put(STATUS_TO_VALID, 0);
            addrStat.put(STATUS_TO_INVALID, 0);
            addrStat.put(STATUS_TO_UNKNOWN, 0);
        }
        return addrStat;
    }

    private void saveAddress(AddressDto auditAddressDto) {
        try {
            //persist address record with the validation status value
            // if there is an exception, just continue on to the next
            auditAddressDto = maintainProviderService.save(auditAddressDto, false, true);
        } catch (DuplicateRecordException ex) {
            Logger.getLogger(MaintainAddressService.class.getName()).log(Level.WARNING, null, ex);
        } catch (BusinessRuleException ex) {
            Logger.getLogger(MaintainAddressService.class.getName()).log(Level.WARNING, null, ex);
        } catch (EntityValidationException ex) {
            Logger.getLogger(MaintainAddressService.class.getName()).log(Level.WARNING, null, ex);
        }
    }

    public static final String STATUS_TO_VALID = "statusToValid";
    public static final String STATUS_TO_INVALID = "statusToInvalid";
    public static final String STATUS_CHANGE = "statusChange";
    
    // This string also includes N/A, either changed to N/A or Unknown
    public static final String STATUS_TO_UNKNOWN = "statusToUnknown";

    /**
     * Populate auditing fields w/end reason code and specific user chid for the
     * batch address validation process.
     *
     * @param auditAddressDto AddressDto to be audited.
     */
    public void populateAuditFieldsAddressDto(AddressDto auditAddressDto) {

        // lookup end reason code/type for change from the entities
        auditAddressDto.setEndReasonCode(CodeTableCodes.GrsCtEndReasonTypes.CHANGE.getValue());

        // retrieve the sysadmin org from user chid generator
        String sysAddressValidChid = chidGenerator.findSysAddressValUser();
        if (sysAddressValidChid != null || sysAddressValidChid.isEmpty()) {
            LOG.log(Level.INFO, "populateAuditFieldsAddressDto ysAddressValidChid is: {0}.", new Object[]{sysAddressValidChid});
            auditAddressDto.setUserChid(sysAddressValidChid);
        }

    }

    /**
     * For compatibility assume confidentiality validation is true if not
     * specified
     *
     * @param newRecord address to validate
     * @throws DuplicateRecordException
     * @throws EntityValidationException
     */
    private void validate(GrsAddresses newRecord) throws DuplicateRecordException, EntityValidationException {
        validate(newRecord, true);
    }

    /**
     * Runs validators and optionally adds confidentiality validation
     *
     * @param newRecord address to validate
     * @param runConfidentialValidator toggles confidentiality validation
     *
     * @throws DuplicateRecordException
     * @throws EntityValidationException
     */
    private void validate(GrsAddresses newRecord, boolean runConfidentialValidator) throws DuplicateRecordException, EntityValidationException {
        if (runConfidentialValidator && (newRecord.getPauthPauthId() != null || newRecord.getRuRuId() == null)) {
            validatorService.validate(newRecord, confidentialityValidator);
        } else {
            //Don't add Confidential validator if the save is for Registry Users or it is turned off
            validatorService.validate(newRecord);
        }
    }

}
