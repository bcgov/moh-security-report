package ca.bc.gov.health.plr.rule.provider.search;

import ca.bc.gov.health.plr.dto.provider.search.SearchProviderRequest;
import ca.bc.gov.health.plr.ejb.entity.PrsCtGenderCodes;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import ca.bc.gov.health.plr.rule.BusinessRuleResult;
import java.util.ArrayList;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import org.apache.commons.lang3.StringUtils;

/**
 * Implementation of REQ-00513. Attribute provider searches must adhere to the
 * following rules specified in the method JavaDoc.
 *
 * Note: the following aspects of the requirement are handled elsewhere in the
 * data access code:
 *  * <ul>
 * <li>Non-blank fields are logically combined using 'AND' (not 'OR")</li>
 * <li>The search is always case-insensitive</li>
 * <li>Blank fields will not be included in the search (not search as NULL or
 * blank)</li>
 * </ul>
 *
 * @author Grant.Hodgins
 */
@Stateless
@LocalBean
public class ValidateSearchAttributes {

    @EJB
    private CodesDao codesDao;
    
    /**
     * First Name and Last Name are mandatory unless one of City, Expertise and Language is populated.
     *
     * @param request
     * @return a business rule result. {@link BusinessRuleResult#isValid()} will
     * return <code>true</code> if all mandatory fields are provided.
     */
    public BusinessRuleResult validateMandatoryCriteria(SearchProviderRequest request) {

        String firstName = request.getFirstName();
        String lastName = request.getLastName();
        String city = request.getCity();
        List<Long> expertiseList = request.getExpertiseList();
        List<Long> languageList = request.getLanguageList();

        boolean hasCityOrExptertiseOrLanguage = false;
        if( (city!=null && city.trim().length()>0) || 
            (expertiseList!=null && !expertiseList.isEmpty()) ||
            (languageList!=null && !languageList.isEmpty()) ) {
            hasCityOrExptertiseOrLanguage = true;
        }

        boolean haveBothFirstLastName = false;
        if (StringUtils.isNoneBlank(firstName) && StringUtils.isNoneBlank(lastName)) {
            haveBothFirstLastName = true;
        }

        if (!hasCityOrExptertiseOrLanguage) {
            if (!haveBothFirstLastName) {
                BusinessRuleKeys key = BusinessRuleKeys.ERROR_SEARCH_REQUIRED;
                String message = BusinessRuleMessageDao.getMessageResource(key);
                List<BusinessRuleMessage> messages = new ArrayList<>();
                messages.add(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR));
                BusinessRuleResult result = new BusinessRuleResult(false, messages);
                return result;
            }
        }

        return new BusinessRuleResult();
    }

    /**
     * The wildcard rules are as follows:
     * <ul>
     * <li>Only one wildcard character is allowed in each allowed name
     * field</li>
     * <li>The wildcard character must be trailing.</li>
     * <li>There must be a minimum of 1 characters before the wildcard </li>
     * <li>Only the surname and first name fields will accept wildcard
     * characters</li>
     * <li>The wildcard character is *</li>
     * </ul>
     *
     * @param firstName the first name
     * @param lastName the last name
     * @param city the city
     * @return a business rule result based on the validation rules.
     * {@link BusinessRuleResult#isValid()} will return <code>true</code> if the
     * wildcards are correctly used.
     */
    public BusinessRuleResult validatePractitionerWildcardUsage(String firstName, String lastName, String city) {
        List<BusinessRuleMessage> messages = new ArrayList<>();
        if (city != null && city.contains("*")) {
            BusinessRuleKeys key = BusinessRuleKeys.ERROR_SEARCH_WILDCARD_FIRSTLAST;
            String message = BusinessRuleMessageDao.getMessageResource(key);
            messages.add(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR));
        }

        messages.addAll(validateWildcardField(firstName));
        messages.addAll(validateWildcardField(lastName));

        if (messages.size() > 0) {
            return new BusinessRuleResult(false, messages);
        } else {
            return new BusinessRuleResult();
        }
    }

    /**
     * The wildcard rules are as follows:
     * <ul>
     * <li>Only one wildcard character is allowed in each allowed name
     * field</li>
     * <li>The wildcard character must be trailing.</li>
     * <li>There must be a minimum of 1 characters before the wildcard </li>
     * <li>Only the surname and first name fields will accept wildcard
     * characters</li>
     * <li>The wildcard character is *</li>
     * </ul>
     *
     * @param firstName String the first name
     * @param lastName String the last name
     * @param gender String the gender
     * @param city String the city
     * @param expertise String the expertise
     * @param language String the language
     * @return BusinessRuleResult a business rule result based on the validation rules.
     * {@link BusinessRuleResult#isValid()} will return <code>true</code> if the
     * wildcards are correctly used.
     */
    public BusinessRuleResult validateLocationExpertiseLanguageWildcardUsage(String firstName, String lastName, String gender, String city) {
        List<BusinessRuleMessage> messages = new ArrayList<>();
        if ( (StringUtils.isNoneBlank(gender) && gender.contains("*")) ||
             (StringUtils.isNoneBlank(city) && city.contains("*")) ) {
            BusinessRuleKeys key = BusinessRuleKeys.ERROR_SEARCH_WILDCARD_FIRSTLAST;
            String message = BusinessRuleMessageDao.getMessageResource(key);
            messages.add(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR));
        }

        messages.addAll(validateWildcardField(firstName));
        messages.addAll(validateWildcardField(lastName));

        if (messages.size() > 0) {
            return new BusinessRuleResult(false, messages);
        } else {
            return new BusinessRuleResult();
        }
    }

    /**
     * Same wildcard rules as
     * {@link #validatePractitionerWildcardUsage(java.lang.String, java.lang.String, java.lang.String)}.
     *
     * @param orgName
     * @param orgLongName
     * @param addressCity
     * @return
     */
    public BusinessRuleResult validateOrganizationWildcardUsage(String orgName, String orgLongName, String addressCity) {
        List<BusinessRuleMessage> messages = new ArrayList<>();
        if (addressCity != null && addressCity.contains("*")) {
            BusinessRuleKeys key = BusinessRuleKeys.ERROR_SEARCH_WILDCARD_ORGCITY;
            String message = BusinessRuleMessageDao.getMessageResource(key);
            messages.add(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR));
        }

        if (messages.size() > 0) {
            return new BusinessRuleResult(false, messages);
        } else {
            return new BusinessRuleResult();
        }
    }

    /**
     * General wild card validation method that applies to all applicable
     * fields.
     *
     * @param string the string to validate
     * @return a list of business rule messages pertaining to the validation, or
     * an empty list if all validations pass.
     */
    private List<BusinessRuleMessage> validateWildcardField(String string) {
        List<BusinessRuleMessage> result = new ArrayList<>();
        String message;
        BusinessRuleKeys key;

        if (string != null && string.contains("*")) {

            if (StringUtils.countMatches(string, "*") > 1) {
                //error, more than one
                key = BusinessRuleKeys.ERROR_SEARCH_WILDCARD_ONLYONE;
                message = BusinessRuleMessageDao.getMessageResource(key);
                result.add(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR));
            }

            if (!string.endsWith("*")) {
                //error, not trailing
                key = BusinessRuleKeys.ERROR_SEARCH_WILDCARD_TRAILING;
                message = BusinessRuleMessageDao.getMessageResource(key);
                result.add(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR));

            } else if (string.length() == 1) {
                //error min 1 expected
                key = BusinessRuleKeys.ERROR_SEARCH_WILDCARD_PRECEDED;
                message = BusinessRuleMessageDao.getMessageResource(key);
                result.add(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR));
            }
        }
        return result;
    }

    public BusinessRuleResult validateGender(String gender) {
        if (StringUtils.isBlank(gender)) {
            return new BusinessRuleResult();
        }

        boolean codeExists = codesDao.codeExists(PrsCtGenderCodes.class, gender);

        if (!codeExists) {
            try {
                Long genderID = Long.parseLong(gender);
                codeExists = codesDao.codeExists(PrsCtGenderCodes.class, genderID);
            } catch (NumberFormatException numberFormatException) {
                // ignore exception and return ERROR_SEARCH_GENDER_INVALID.
            }
        }

        List<BusinessRuleMessage> messages = new ArrayList<>();
        if (!codeExists) {
            BusinessRuleKeys key = BusinessRuleKeys.ERROR_SEARCH_GENDER_INVALID;
            String message = BusinessRuleMessageDao.getMessageResource(key);
            messages.add(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.ERROR));
        }

        if (!messages.isEmpty()) {
            return new BusinessRuleResult(false, messages);
        } else {
            return new BusinessRuleResult();
        }
    }
    
}
