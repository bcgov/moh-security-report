package ca.bc.gov.health.plr.rule.provider;

import ca.bc.gov.health.plr.dto.DtoAccessRestrictionData;
import ca.bc.gov.health.plr.dto.OwnableDto;
import ca.bc.gov.health.plr.dto.provider.AbstractProviderDetail;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDetailsUtil;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.ejb.entity.GrsAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsElectronicAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsIdentifiers;
import ca.bc.gov.health.plr.ejb.entity.GrsOrgNames;
import ca.bc.gov.health.plr.ejb.entity.GrsPersonNames;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.GrsTelephones;
import ca.bc.gov.health.plr.ejb.entity.PrsConditions;
import ca.bc.gov.health.plr.ejb.entity.PrsConfidentialityIndicators;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsDemographicDetails;
import ca.bc.gov.health.plr.ejb.entity.PrsDisciplinaryActions;
import ca.bc.gov.health.plr.ejb.entity.PrsInformationRoutes;
import ca.bc.gov.health.plr.ejb.entity.PrsNotes;
import ca.bc.gov.health.plr.ejb.entity.PrsProvRuRelns;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderCredentials;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderExpertises;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderRelationships;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.PrsStatuses;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.interceptors.TestUserInterceptor;
import ca.bc.gov.health.plr.producer.type.Authenticated;
import ca.bc.gov.health.plr.producer.type.User;
import ca.bc.gov.health.plr.service.provider.security.AuthorizationService;
import ca.bc.gov.health.plr.service.provider.security.LeafPermission;
import ca.bc.gov.health.plr.util.PropertyUtils;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.interceptor.Interceptors;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.converters.DateConverter;

/**
 * Populates all the column level and record level restrictions to the dto
 * Removes any record with no READ access
 * @author sumesh.kariyil
 */
@Stateless
@Interceptors({TestUserInterceptor.class})
public class AccessRestrictionService {
    
    @Inject
    @Authenticated
    private Instance<User> user;
    
    @EJB
    AuthorizationService authorizationService;

    
    /**
     * Applies the column level and record level restrictions to the DTO 
     * The difference between UI and Messages is for column restrictions replace the column value with null in messages, but for messages keep the value
     * @param result
     * @param roleType 
     * @param setNullValuesForColumn - Is set true - replace column restricted values to null (applicable to messages)

     */
    public void applyProviderAccessRestrictions(ProviderDto result, PrsCtProviderRoleTypes roleType, boolean setNullValuesForColumn) {
        populateReadRestrictions(result, roleType);
        populateColumnRestrictions(result, roleType, setNullValuesForColumn);
    }

    /**
     * Column level restriction call to the authorizationService
     * @param grsRegUser
     * @param dataObjectName
     * @param recordType
     * @param hptCode
     * @param clientType
     * @param dataOwnerCode
     * @return 
     */
    private DtoAccessRestrictionData getColumnLevelRestrictions(String dataObjectName, String recordType, 
            PrsCtProviderRoleTypes hptCode, String dataOwnerCode, GrsRegistryUsers regUser) {
        return authorizationService.getColumnRestrictions(regUser, dataObjectName, recordType, hptCode, dataOwnerCode);
    }

    /**
     * Apply column restriction to ProviderDto. 
     * This method is used by distribution as the user for distribution stored in distribution profile could be different than the user in this bean.
     * @param result ProviderDto it is to be applied column restriction
     * @param roleType PrsCtProviderRoleTypes
     * @param userEntity GrsRegistryUsers
     * @param setNullValuesForColumn true to make the attribute in ProviderDto to be null
     */
    public void populateColumnRestrictions(ProviderDto result, PrsCtProviderRoleTypes roleType, GrsRegistryUsers userEntity, boolean setNullValuesForColumn) {
        applyColumnRestriction(result.getDemographicDetails(), roleType, PrsDemographicDetails.class, userEntity, setNullValuesForColumn);
        applyColumnRestriction(result.getStatuses(), roleType, PrsStatuses.class, userEntity, setNullValuesForColumn);        
    }
    
    /**
     * As only demographics and statuses  got column level restriction, invoke those for search result
     * @param result
     * @param roleType 
     * @param setNullValuesForColumn - Is set true - replace column restricted values to null
     */
    public void populateColumnRestrictions(ProviderDto result, PrsCtProviderRoleTypes roleType, boolean setNullValuesForColumn) {
        applyColumnRestriction(result.getDemographicDetails(), roleType, PrsDemographicDetails.class, setNullValuesForColumn);
        applyColumnRestriction(result.getStatuses(), roleType, PrsStatuses.class, setNullValuesForColumn);        
    }
    
    /**
     * Apply the column restrictions on the Dto list. 
     * The userEntity could be the user from distribution profile or could be the login user.
     * @param list the list of Dtos
     * @param roleType PrsCtProviderRoleTypes
     * @param dataObjectClass is either PrsDemographicDetails or PrsStatuses
     * @param userEntity GrsRegistryUsers the user
     * @param setNullValuesForColumn true to make the attribute in ProviderDto to be null
     */
    public void  applyColumnRestriction(List<? extends OwnableDto> list, PrsCtProviderRoleTypes roleType, Class<?> dataObjectClass, GrsRegistryUsers userEntity,
            boolean setNullValuesForColumn) {
        if(list != null && !list.isEmpty()){
            String dataObjectName = ProviderDetailsUtil.getDataObjectName(dataObjectClass);            
            for(OwnableDto dto : list){
                DtoAccessRestrictionData columnRestrictionData  = getColumnLevelRestrictions(dataObjectName, null, 
                        roleType, dto.getDataOwnerCode(), userEntity);
                convertDatabaseColumnNameToDtoFieldNames(columnRestrictionData);
                if(setNullValuesForColumn){//replace restricted column values with null
                    replaceValuesWithNull(dto, columnRestrictionData);
                } else {//If setNullValuesForColumn is false, then map the columns and don't set null values for restricted columns                     
                    if(PropertyUtils.doesPropertyExist(dto, "accessRestrictionData")){
                        PropertyUtils.invokeSetter(dto, "accessRestrictionData", columnRestrictionData);
                    }
                }
            }
        }
    }
   
    /**
     * Generic method to apply the column restriction, made as public to call it for each individual for maintain service
     * This will be used by maintainDemographicService and MaintainStatusService
     * @param list
     * @param roleType
     * @param dataObjectClass 
     * @param setNullValuesForColumn - Is set true - replace column restricted values to null
     */
    public void  applyColumnRestriction(List<? extends OwnableDto> list, PrsCtProviderRoleTypes roleType, Class<?> dataObjectClass, 
            boolean setNullValuesForColumn) {
        this.applyColumnRestriction(list, roleType, dataObjectClass, user.get().getUserEntity(), setNullValuesForColumn);
    }
    
    /**
     * Calls the convert methods to convert the column names to field name in the dto, so that a common fragment can be used in jsf page
     * @param accessRestrictionData 
     */
    private void convertDatabaseColumnNameToDtoFieldNames(DtoAccessRestrictionData accessRestrictionData) {
        accessRestrictionData.setUnreadables(convert(accessRestrictionData.getUnreadables()));
        accessRestrictionData.setUnwritables(convert(accessRestrictionData.getUnwritables()));
    }
    
    /**
     * Converts the column names to DTO field names.
     * @param columnNames
     * @return 
     */
    private List<String> convert(List<String> columnNames) {
        if (columnNames == null) {
            return null;
        }
        List<String> fieldNames = new ArrayList<>();
        for (String columnName : columnNames) {
            DataColumnToDtoField columnToField = DataColumnToDtoField.valueOf(columnName);
            fieldNames.add(columnToField.getFieldName());
            fieldNames.addAll(columnToField.getSecondaryFieldNames());
        }
        return fieldNames;
    }

    /**
     * Populates the read restriction for all the children of provider dto
     * It also removes the records which doesn't have permission to view
     * @param result
     * @param roleType 
     */
    public void populateReadRestrictions(ProviderDto result, PrsCtProviderRoleTypes roleType) {
        //If any restriction has been found add the list name to unreadable records 
        if(! applyReadRestriction(result.getAddresses(), roleType, GrsAddresses.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("addresses");
        }
        if(! applyReadRestriction(result.getOrgNames(), roleType, GrsOrgNames.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("orgNames");
        }
        if(! applyReadRestriction(result.getIndNames(), roleType, GrsPersonNames.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("indNames");
        }
        if(! applyReadRestriction(result.getTelecommunication(), roleType, GrsTelephones.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("telecommunication");
        }
        if(! applyReadRestriction(result.getStatuses(), roleType, PrsStatuses.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("statuses");
        }
        if(! applyReadRestriction(result.getDisciplinaryActions(), roleType, PrsDisciplinaryActions.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("disciplinaryActions");
        }
        populateReadRestrictionsConfidentiality(result, roleType);
        
        if(! applyReadRestriction(result.getConditions(), roleType, PrsConditions.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("conditions");
        }
        if(! applyReadRestriction(result.getDemographicDetails(), roleType, PrsDemographicDetails.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("demographicDetails");
        }
        if(! applyReadRestriction(result.getCredentials(), roleType, PrsProviderCredentials.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("credentials");
        }
        if(! applyReadRestriction(result.getExpertise(), roleType, PrsProviderExpertises.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("expertise");
        }
        if(! applyReadRestriction(result.getRegistryUserRelationships(), roleType, PrsProvRuRelns.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("registryUserRelationships");
        }
        if(! applyReadRestriction(result.getInformationRoutes(), roleType, PrsInformationRoutes.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("informationRoutes");
        }
        if(! applyReadRestriction(result.getProviderRelationships(), roleType, PrsProviderRelationships.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("providerRelationships");
        }
        if(! applyReadRestriction(result.getIdentifiers(), roleType, GrsIdentifiers.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("identifiers");
        }
        if(! applyReadRestriction(result.getNotes(), roleType, PrsNotes.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("notes");
        }
        if(! applyReadRestriction(result.getElectronicAddresses(), roleType, GrsElectronicAddresses.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("electronicAddresses");
        }
        //Work locations - Cannot use the above solution for worklocation as work location is not a generic 
        // dto
        applyWorkLocationReadRestrictions(result, roleType, user.get().getUserEntity());
    }

    /**
     * Just do confidentiality as the presence of confidential indicators
     * indicates ownership later in some code logic
     * @param result the updated dto
     * @param roleType the provider record
     */
    public void populateReadRestrictionsConfidentiality(ProviderDto result, PrsCtProviderRoleTypes roleType) {
        if(! applyReadRestriction(result.getConfidentialityIndicators(), roleType, PrsConfidentialityIndicators.class, user.get().getUserEntity())){
            result.getUnReadableRecords().add("confidentialityIndicators");
        }
    }
    
    
    /**
     * Populates the read restriction for all the children of provider dto
     * It also removes the records which doesn't have permission to view
     * @param result
     * @param provider 
     * @param regUser 
     */
    public void populateReadRestrictions(ProviderDto result, PrsProviders provider, GrsRegistryUsers regUser) {
        //If any restriction has been found add the list name to unreadable records 
        if(! applyReadRestriction(result.getAddresses(), provider.getHptCode(), GrsAddresses.class, regUser)){
            result.getUnReadableRecords().add("addresses");
        }
        if(! applyReadRestriction(result.getOrgNames(), provider.getHptCode(), GrsOrgNames.class, regUser)){
            result.getUnReadableRecords().add("orgNames");
        }
        if(! applyReadRestriction(result.getIndNames(), provider.getHptCode(), GrsPersonNames.class, regUser)){
            result.getUnReadableRecords().add("indNames");
        }
        if(! applyReadRestriction(result.getTelecommunication(), provider.getHptCode(), GrsTelephones.class, regUser)){
            result.getUnReadableRecords().add("telecommunication");
        }
        if(! applyReadRestriction(result.getStatuses(), provider.getHptCode(), PrsStatuses.class, regUser)){
            result.getUnReadableRecords().add("statuses");
        }
        if(! applyReadRestriction(result.getDisciplinaryActions(), provider.getHptCode(), PrsDisciplinaryActions.class, regUser)){
            result.getUnReadableRecords().add("disciplinaryActions");
        }
        if(! applyReadRestriction(result.getConfidentialityIndicators(), provider.getHptCode(), PrsConfidentialityIndicators.class, regUser)){
            result.getUnReadableRecords().add("confidentialityIndicators");
        }
        if(! applyReadRestriction(result.getConditions(), provider.getHptCode(), PrsConditions.class, regUser)){
            result.getUnReadableRecords().add("conditions");
        }
        if(! applyReadRestriction(result.getDemographicDetails(), provider.getHptCode(), PrsDemographicDetails.class, regUser)){
            result.getUnReadableRecords().add("demographicDetails");
        }
        if(! applyReadRestriction(result.getCredentials(), provider.getHptCode(), PrsProviderCredentials.class, regUser)){
            result.getUnReadableRecords().add("credentials");
        }
        if(! applyReadRestriction(result.getExpertise(), provider.getHptCode(), PrsProviderExpertises.class, regUser)){
            result.getUnReadableRecords().add("expertise");
        }
        if(! applyReadRestriction(result.getRegistryUserRelationships(), provider.getHptCode(), PrsProvRuRelns.class, regUser)){
            result.getUnReadableRecords().add("registryUserRelationships");
        }
        if(! applyReadRestriction(result.getInformationRoutes(), provider.getHptCode(), PrsInformationRoutes.class, regUser)){
            result.getUnReadableRecords().add("informationRoutes");
        }
        if(! applyReadRestriction(result.getProviderRelationships(), provider.getHptCode(), PrsProviderRelationships.class, regUser)){
            result.getUnReadableRecords().add("providerRelationships");
        }
        if(! applyReadRestriction(result.getIdentifiers(), provider.getHptCode(), GrsIdentifiers.class, regUser)){
            result.getUnReadableRecords().add("identifiers");
        }
        if(! applyReadRestriction(result.getNotes(), provider.getHptCode(), PrsNotes.class, regUser)){
            result.getUnReadableRecords().add("notes");
        }
        if(! applyReadRestriction(result.getElectronicAddresses(), provider.getHptCode(), GrsElectronicAddresses.class, regUser)){
            result.getUnReadableRecords().add("electronicAddresses");
        }
        //Work locations - Cannot use the above solution for worklocation as work location is not a generic 
        // dto
        applyWorkLocationReadRestrictions(result, provider.getHptCode(), regUser);
    }
    
    /**
     * Apply read restriction for the list , will be used by all maintain service except work location
     * @param list
     * @param hptCode
     * @param dataObjectClass 
     */
    public void applyReadRestriction(List<? extends AbstractProviderDetail> list, PrsCtProviderRoleTypes hptCode, 
            Class<?> dataObjectClass) {
        applyReadRestriction(list, hptCode, dataObjectClass, user.get().getUserEntity());
    }
    
    
    /**
     * Apply read restriction for the list , will be used by  work location and its children
     * @param list
     * @param hptCode
     * @param dataObjectClass 
     */
    public void applyWlReadRestriction(List<? extends AbstractProviderDetail> list, PrsCtProviderRoleTypes hptCode, 
            Class<?> dataObjectClass) {
        applyWorkLocationReadRestriction(list, hptCode, dataObjectClass, user.get().getUserEntity());
    }
    
    
    /**
     * Apply read restriction for the list , will be used by  work location and its children
     * @param list
     * @param hptCode
     * @param dataObjectClass 
     * @param regUser 
     */
    public void applyWlReadRestriction(List<? extends AbstractProviderDetail> list, PrsCtProviderRoleTypes hptCode, 
            Class<?> dataObjectClass, GrsRegistryUsers regUser) {
        applyWorkLocationReadRestriction(list, hptCode, dataObjectClass, regUser);
    }
       
     /**
     * Method just to delegate once the current user and client type is derived (except work location)
     * @param <T>
     * @param list
     * @param regUser
     * @param hptCode
     * @param clientType
     * @param dataObjectClass 
     */
    private boolean applyReadRestriction(List<? extends AbstractProviderDetail> list, PrsCtProviderRoleTypes hptCode, 
            Class<?> dataObjectClass, GrsRegistryUsers regUser) {        
        String dataObjectName = ProviderDetailsUtil.getDataObjectName(dataObjectClass);
        return checkIfRecordsReadable(list, hptCode, dataObjectName, regUser);
    }
    
    /**
     * Method just to delegate once the current user and client type is derived (For work location and children)
     * @param <T>
     * @param list
     * @param regUser
     * @param hptCode
     * @param clientType
     * @param dataObjectClass 
     */
    private boolean applyWorkLocationReadRestriction(List<? extends AbstractProviderDetail> list, PrsCtProviderRoleTypes hptCode, 
            Class<?> dataObjectClass, GrsRegistryUsers regUser) {
        String dataObjectName = ProviderDetailsUtil.getWlDataObjectName(dataObjectClass);
        return checkIfRecordsReadable(list, hptCode, dataObjectName, regUser);
    }

    
    /**
     * This method will check if the record is readable, 
     * if any record is found not readable then returns false and will be removed from the list
     * Steps :
     * 1: Get the data owner code from the passed object
     *      1.1 : If found null remove the object from list
     *      1.2 : If not null,
     *          1.2.1 : Get the record types from the detail
     *          1.2.2 : Check if the record type (or ANY) is allowed for READ from authorizationService
     *          1.2.3 : If any of the record type says NOT ALLOWED, then remove the object from list nd process next item in the list
     *          1.2.4 : If the record type (or ANY) is allowed then retain the detail and process next item in the list
     * 
     * 
     * @param <T>
     * @param list
     * @param regUser
     * @param hptCode
     * @param clientType
     * @param dataObjectName
     * @return 
     */
    private boolean checkIfRecordsReadable(List<? extends AbstractProviderDetail> list, PrsCtProviderRoleTypes hptCode, String dataObjectName, GrsRegistryUsers regUser) {
        boolean allRecordsReadable = true;
        Iterator<? extends AbstractProviderDetail> listIter = list.iterator();
        while (listIter.hasNext()) {
            boolean isAllowed = true;
            AbstractProviderDetail detail = listIter.next();
            if (detail.getDataOwnerCode() == null) {
                isAllowed = false;
            } else {
                List<String> recordTypes = ProviderDetailsUtil.getDtoRecordTypeValues(detail);
                List<LeafPermission> permissions = new ArrayList<>();
                for (String recordType : recordTypes) {
                    LeafPermission leafPermission = authorizationService.getLeafPermission(regUser, dataObjectName, recordType, null,
                            hptCode, detail.getDataOwnerCode(), AuthorizationService.AccessType.READ);
                    // There could be a scenario, where the user don't have access to ANY. But have access to recordType (for e.g, BC). 
                    // But if the entity is having more than 1 record types, we cannot expect that there will be permissions defined for rest of the record types
                    // In that case if the user have permission to One record type and don't have RECORDS to others, consider the permission for record type present in the permissions table
                    if(leafPermission != null){
                        permissions.add(leafPermission);
                    }                    
                }
                if(permissions.isEmpty()){
                    isAllowed = false;
                } else {
                    for(LeafPermission permission : permissions){
                        isAllowed = isAllowed && permission.isReadable();
                    }
                }
            }
            if (!isAllowed) {
                listIter.remove();
                allRecordsReadable = false;
            }
        }

        return allRecordsReadable;
    }
    
    /**
     * 
     * @param result
     * @param hptCode 
     */
    public void applyWorkLocationReadRestrictions(ProviderDto result, PrsCtProviderRoleTypes hptCode){
        applyWorkLocationReadRestrictions(result, hptCode, user.get().getUserEntity());
    }
    
    /**
     * Method to handle the read restriction for work location and it's children
     * @param result
     * @param regUser
     * @param hptCode
     * @param clientType 
     */
    private void applyWorkLocationReadRestrictions(ProviderDto result, PrsCtProviderRoleTypes hptCode, GrsRegistryUsers regUser) {
        if(result.getWorkLocationList() != null && !result.getWorkLocationList().isEmpty()){
            Iterator<WorkLocationDto> workLocIter = result.getWorkLocationList().iterator();
            boolean allRecordsReadable = true;
            while(workLocIter.hasNext()){
                // Iterate all the work location and check whether the work location has got READ access
                // If there is no READ access, remove and process next one
                // If there is READ access, then apply the restriction for it's children.
                WorkLocationDto workLocDto = workLocIter.next();
                boolean isAllowed = true;                
                if(workLocDto.getDataOwnerCode() == null){
                    isAllowed = false;
                } else {
                    isAllowed = isAllowed && authorizationService.isAllowed(regUser, ProviderDetailsUtil.getDataObjectName(PrsWorkLocations.class), AuthorizationService.ANY, null, 
                        hptCode, workLocDto.getDataOwnerCode(), AuthorizationService.AccessType.READ);
                }
                if(!isAllowed){
                    workLocIter.remove();
                    allRecordsReadable = false;
                } else {
                    // Here if there is no read access, then the unreadablerecords is added to the worklocation dto's property unlike the other records
                    if(! applyWorkLocationReadRestriction(workLocDto.getAddresses(), hptCode, GrsAddresses.class, regUser)){
                        workLocDto.getUnReadableRecords().add("addresses");
                    }
//                    if(! applyWorkLocationReadRestriction(workLocDto.getWorkLocationDetails(), hptCode, clientType, PrsWorkLocationDetails.class)){
//                        workLocDto.getUnReadableRecords().add("workLocationDetails");
//                    }
                    if(! applyWorkLocationReadRestriction(workLocDto.getTelecommunications(), hptCode, GrsTelephones.class, regUser)){
                        workLocDto.getUnReadableRecords().add("telecommunications");
                    }
                    if(! applyWorkLocationReadRestriction(workLocDto.getElectronicAddresses(), hptCode, GrsElectronicAddresses.class, regUser)){
                        workLocDto.getUnReadableRecords().add("electronicAddresses");
                    }
                    if(! applyWorkLocationReadRestriction(workLocDto.getInformationRoutes(), hptCode, PrsInformationRoutes.class, regUser)){
                        workLocDto.getUnReadableRecords().add("informationRoutes");
                    }
                }
            }
            if(!allRecordsReadable){
                result.getUnReadableRecords().add("workLocationList");
            }
        }
    }

    /**
     * Replaces the dto values with null for unreadable columns
     * 
     * @param dto
     * @param columnRestrictionData 
     */
    private void replaceValuesWithNull(OwnableDto dto, DtoAccessRestrictionData columnRestrictionData) {
        ConvertUtils.register(new DateConverter(null), Date.class);
        for (String dtoFieldName : columnRestrictionData.getUnreadables()) {
            if (PropertyUtils.doesPropertyExist(dto, dtoFieldName)) {
                PropertyUtils.invokeSetter(dto, dtoFieldName, null);
            }
        }
    }    
}
