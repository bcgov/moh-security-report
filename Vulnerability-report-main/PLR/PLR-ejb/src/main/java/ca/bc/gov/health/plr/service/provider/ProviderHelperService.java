package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.ejb.entity.PrsCtStatusClassCodes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtStatusCodes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtStatusReasonCodes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.util.ReflectionUtils;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import org.apache.commons.lang3.StringUtils;

/**
 * Centralized service for maintaining provider details. This class make
 * determinations on whether the maintain operation is intended as an add or
 * update. Once known, it should delegate to the related service(s) responsible
 * for maintaining the data block(s) in context.
 *
 * @author Grant.Hodgins
 */
@Stateless
// DSHARPE TODO: Move this class to CodesDao or a specific facade. It doesn't do what the Javadoc says it does: it just returns codes.
public class ProviderHelperService {

    @PersistenceContext(unitName = "PLR-ejbPU")
    protected EntityManager em;

    @EJB
    protected CodesDao codesDao;

    /**
     * Return the default Status Code.
     *
     * @return the default Status Code.
     */
    public PrsCtStatusCodes getDefaultStatusCode() {
        return codesDao.lookup(PrsCtStatusCodes.class, CodeTableCodes.PrsCtStatusCodes.ACTIVE);
    }

    /**
     * Return the default Status Class Code.
     *
     * @return the default Status Class Code.
     */
    public PrsCtStatusClassCodes getDefaultStatusClassCode() {
        return codesDao.lookup(PrsCtStatusClassCodes.class, CodeTableCodes.PrsCtStatusClassCodes.LICENSURE);
    }

    /**
     * Return the default Status Reason Code for the specified Status Code, or
     * null if there is no default.
     *
     * @param statusCodeId a valid Status Code ID.
     * @return the default Status Reason Code for the specified Status Code, or
     * null if there is no default.
     */
    public PrsCtStatusReasonCodes getDefaultStatusReasonCode(Long statusCodeId) {
        PrsCtStatusCodes statusCode = em.find(PrsCtStatusCodes.class, statusCodeId);
        if (CodeTableCodes.PrsCtStatusCodes.ACTIVE.getValue().equals(statusCode.getCtlNameCode())) {
            return codesDao.lookup(PrsCtStatusReasonCodes.class, CodeTableCodes.PrsCtStatusReasonCodes.GOOD_STANDING);
        } else {
            return null;
        }
    }

    /**
     * Return the Status Reason Codes applicable to the specified Status Code.
     *
     * @param statusCodeId a valid Status Code ID.
     * @return the Status Reason Codes applicable to the specified Status Code
     * or an empty list if an unknown id is provided.
     */
    public List<PrsCtStatusReasonCodes> filterStatusReasonCodes(Long statusCodeId) {
        List<PrsCtStatusReasonCodes> result = new ArrayList<>();

        if (statusCodeId != null) {
            PrsCtStatusCodes statusCode = em.find(PrsCtStatusCodes.class, statusCodeId);
            if (statusCode != null) {
                String statusCodeName = statusCode.getCtlNameCode();
                TypedQuery<PrsCtStatusReasonCodes> query = em.createQuery("SELECT p from PrsCtStatusReasonCodes p order by p.ctlDescTxt", PrsCtStatusReasonCodes.class);
                for (PrsCtStatusReasonCodes statusReasonCode : query.getResultList()) {
                    if (isApplicable(statusCodeName, statusReasonCode.getStatusCode())) {
                        result.add(statusReasonCode);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Returns true if type (e.g. "MD") is within the CSV applicableTypes (e.g.
     * "MD,DEN,RN"), or if applicableTypes is blank.
     *
     * (This odd approach is a quirk of the data model, which uses a CSV field
     * in PrsCtIdentifierTypes containing name codes of applicable
     * PrsCtProvRoleTypes, instead of using a many-to-many relationship between
     * the tables.)
     *
     * @param type a type.
     * @param applicableTypes a CSV list of "applicable types". Can be empty or
     * null.
     * @return true if type is within the CSV applicableTypes.
     */
    private boolean isApplicable(String type, String applicableTypes) {
        if (StringUtils.isBlank(applicableTypes)) {
            return true;
        } else {
            List<String> applicableRoles = Arrays.asList(applicableTypes.split(","));
            if (applicableRoles.contains(type)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Find a provider based on list of DTOs
     *
     * @param objList
     * @return
     * @throws IllegalArgumentException
     */
    public PrsProviders findProvider(List<Object> objList) {
        PrsProviders prov = null;
        Long pauthId = null;
        for (Object obs : objList) {
            if (obs instanceof List) {
                prov = findProvider((List<Object>) obs);
            } else {
                pauthId = (Long) ReflectionUtils.methodInvoke(obs, "getPauthId");
                if (pauthId == null && ReflectionUtils.hasMethod(obs, "getWlWlId") != ReflectionUtils.MethodType.none) {
                    Long wlId = (Long) ReflectionUtils.methodInvoke(obs, "getWlWlId");
                    if (wlId != null) {
                        PrsWorkLocations workLocation = em.find(PrsWorkLocations.class, wlId);
                        prov = (PrsProviders) ReflectionUtils.methodInvoke(workLocation, "getPauthPauthId");
                    }
                }
            }
            if (prov != null || pauthId != null) {
                break;
            }
        }
        if (prov == null && pauthId != null) {
            prov = em.find(PrsProviders.class, pauthId);
        }
        return prov;
    }

    /**
     * Wrapper when you have only a DTO and no list
     *
     * @param obs
     * @return
     */
    public PrsProviders findProvider(final Object obs) {
        return findProvider(new ArrayList<Object>() {
            {
                add(obs);
            }
        });
    }

    /**
     * Returns a list of all the lists within a ProviderDto object
     *
     * @param dto
     * @return
     * @throws IllegalArgumentException
     * @throws IllegalAccessException
     */
    public List getAllListsAsList(ProviderDto dto) throws IllegalArgumentException, IllegalAccessException {

        List<Object> list = new ArrayList<>();

        Field[] fields = ProviderDto.class.getDeclaredFields();

        for (Field f : fields) {
            boolean isAccessible = f.isAccessible();
            try {
                f.setAccessible(true);
                Object item = f.get(dto);
                if (item != null && List.class.isAssignableFrom(item.getClass())) {
                    list.addAll(((List<Object>) item));
                }
            } finally {
                f.setAccessible(isAccessible);
            }
        }

        return list;
    }
}
