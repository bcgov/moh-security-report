package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.converter.TelephoneDtoConverter;
import ca.bc.gov.health.plr.dto.provider.TelecommunicationDto;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.GrsTelephones;
import ca.bc.gov.health.plr.ejb.entity.PrsCtCommunPurposeTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtTelecomNumberTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.ejb.session.PrsCtCommunPurposeTypesFacade;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.provider.AccessRestrictionService;
import ca.bc.gov.health.plr.service.EntityValidatorService;
import ca.bc.gov.health.plr.service.validators.ConfidentialityValidator;
import ca.bc.gov.health.plr.service.validators.EntityChangeDetector;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.faces.model.SelectItem;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

/**
 * Service class for dealing with Telecommunication records
 *
 * @author ian.scott
 * @author greg.perkins
 */
@Stateless
@LocalBean
public class MaintainTelephoneService implements MaintainService<TelecommunicationDto> {

    private static final String CLASSNAME = MaintainTelephoneService.class.getSimpleName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);

    /**
     * EntityManager instance for persisting objects
     */
    @PersistenceContext(unitName = "PLR-ejbPU")
    protected EntityManager em;
    @EJB
    private JournalService<GrsTelephones> journalService;
    /**
     * Converter for switching between entities and DAOs
     */
    @EJB
    private TelephoneDtoConverter telephoneDtoConverter;

    @EJB
    private EntityValidatorService<GrsTelephones> validatorService;

    @EJB
    private ConfidentialityValidator<GrsTelephones> confidentialityValidator;

    @EJB
    private AccessRestrictionService accessRestrictionService;

    @EJB
    protected CodesDao codesDao;

    @EJB
    private ProviderDtoConverter providerDtoConverter;

    @EJB
    private EntityChangeDetector<TelecommunicationDto, GrsTelephones> entityChangeDetector;

    @EJB
    private transient PrsCtCommunPurposeTypesFacade prsCtCommunPurposeTypesFacade;

    /**
     * Query a fresh complete list of telecommunications related to a specific
     * provider. Note this method does not return telecommunication details for
     * work locations.
     *
     * @param tele
     * @return a list of fresh note transfer objects
     */
    public List<TelecommunicationDto> refreshTelecommunications(TelecommunicationDto tele) {
        List<GrsTelephones> foundTele = null;
        boolean ignoreWL = true;
        PrsCtProviderRoleTypes hptCode = null;
        if (tele.getPauthId() != null && tele.getWlWlId() != null && tele.getRuRuId() != null) {
            //TODO - shouldn't happen but what should happen here if it does
            PrsProviders provider = em.find(PrsProviders.class, tele.getPauthId());
            hptCode = provider.getHptCode();
            foundTele = provider.getGrsTelephonesList();
        } else if (tele.getWlWlId() != null) {
            PrsWorkLocations workLocation = em.find(PrsWorkLocations.class, tele.getWlWlId());
            hptCode = workLocation.getPauthPauthId().getHptCode();
            foundTele = workLocation.getGrsTelephonesList();
            ignoreWL = false;
        } else if (tele.getPauthId() != null) {
            PrsProviders provider = em.find(PrsProviders.class, tele.getPauthId());
            hptCode = provider.getHptCode();
            foundTele = provider.getGrsTelephonesList();
        } else if (tele.getRuRuId() != null) {
            GrsRegistryUsers regUser = em.find(GrsRegistryUsers.class, tele.getRuRuId());
            foundTele = regUser.getGrsTelephonesList();
        }
        List<TelecommunicationDto> dtos = providerDtoConverter.buildTelephones(foundTele, ignoreWL);
        if (tele.getPauthId() != null) {
            accessRestrictionService.applyReadRestriction(dtos, hptCode, GrsTelephones.class);
        } else if (tele.getWlWlId() != null) {
            accessRestrictionService.applyWlReadRestriction(dtos, hptCode, GrsTelephones.class);
        }
        return dtos;
    }

    /**
     * Maintain a telecommunication entity. This method determines if this
     * maintain operation is an add or an update.
     *
     * @param telecommunication the telecommunication transfer object to
     * maintain
     * @return a populated list of provider-related transfer objects with
     * refreshed details
     * @throws ca.bc.gov.health.plr.service.provider.DuplicateRecordException
     * @throws ca.bc.gov.health.plr.rule.BusinessRuleException
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     */
    @Override
    public TelecommunicationDto save(TelecommunicationDto telecommunication) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        PrsCtCommunPurposeTypes commPurposeCode = codesDao.lookup(PrsCtCommunPurposeTypes.class, CodeTableCodes.PrsCtCommunPurposeTypes.BUSINESS_CONTACT);

        if (telecommunication.getCommunicationPurposeCode() == null && telecommunication.getCommunicationPurposeId() == null) {
            telecommunication.setCommunicationPurposeId(commPurposeCode.getCtlId());
        }

        GrsTelephones newRecord = telephoneDtoConverter.toEntity(telecommunication);

        entityChangeDetector.checkForChanges(telecommunication, newRecord);
        if (telecommunication.isNoChangeOnUpdate()) {
            return telecommunication;
        }
        validate(newRecord);
        try {
            newRecord = journalService.journal(newRecord);

        } catch (DuplicateRecordException jex) {
            //If the error is duplicate record error, throw record specific error REQ-00916
            String duplicateTeleMsg;
            if (newRecord.getRuRuId() != null) {
                duplicateTeleMsg = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_DUPLICATE_ADDRESS_REGUSER_DATA_BLOCK);
            } else {
                duplicateTeleMsg = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_DUPLICATE_ADDRESS_PROVIDER_DATA_BLOCK);
            }
            throw new DuplicateRecordException(duplicateTeleMsg + newRecord.getFieldName());
        }
        return providerDtoConverter.buildTelephone(newRecord);
    }

    /**
     * Validates the entity. Add all validators for the entity to
     * validatorService and call checkForChanges method
     *
     * @param newRecord GrsTelephones
     * @throws DuplicateRecordException if validation fails
     */
    private void validate(GrsTelephones newRecord) throws DuplicateRecordException, EntityValidationException {
        if (newRecord.getPauthPauthId() != null || newRecord.getRuRuId() == null) {
            validatorService.validate(newRecord, confidentialityValidator);
        } else {
            //Don't add Confidential validator if the save is for Registry Users
            validatorService.validate(newRecord);
        }
    }

    /**
     * Bulids a dto from a record in the database based on primary key (ID)
     *
     * @param toRefresh - a dto with an ID
     * @return - dto built from database record or null
     */
    public TelecommunicationDto refresh(TelecommunicationDto toRefresh) {
        GrsTelephones found = em.find(GrsTelephones.class, toRefresh.getId());
        TelecommunicationDto toSendBack = providerDtoConverter.buildTelephone(found);
        return toSendBack;
    }

    /**
     * Initialize telecom purpose codes dropdown select items for the selected
     * telecom type.
     *
     * @param telecomTypeId Long id associated with the selected telecom type
     * @return List<SelectItem> for purpose codes by telecom type
     *
     */
    public List<SelectItem> initTelecomPurposeCdDropdownByType(Long telecomTypeId) {
        List<SelectItem> temp = new ArrayList<>();
        if (telecomTypeId != null && telecomTypeId.compareTo(new Long(0)) != 0) {
            PrsCtTelecomNumberTypes telecomType = codesDao.lookup(PrsCtTelecomNumberTypes.class, telecomTypeId);
            List<PrsCtCommunPurposeTypes> telecomPurposeCds = new ArrayList<>();
            if (telecomType.getCtlNameCode().equalsIgnoreCase(CodeTableCodes.PrsCtTelecomNumberTypes.TELEPHONE.getValue())
                    || telecomType.getCtlNameCode().equalsIgnoreCase(CodeTableCodes.PrsCtTelecomNumberTypes.MOBILE.getValue())) {
                telecomPurposeCds = prsCtCommunPurposeTypesFacade.findAll();

            } else {
                telecomPurposeCds = prsCtCommunPurposeTypesFacade.findCommunTypesFilterOutEc();
            }

            if (!telecomPurposeCds.isEmpty()) {
                for (PrsCtCommunPurposeTypes telecomPurposeCd : telecomPurposeCds) {
                    temp.add(new SelectItem(telecomPurposeCd.getCtlId(), telecomPurposeCd.getCtlNameCode() + " - " + telecomPurposeCd.getCtlDescTxt()));
                }
            }
        }
        return temp;
    }

}