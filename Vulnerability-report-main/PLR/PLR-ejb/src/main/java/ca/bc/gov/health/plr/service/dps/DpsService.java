/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.service.dps;

import ca.bc.gov.health.plr.dto.dps.AccessProfileGroupDto;
import ca.bc.gov.health.plr.dto.dps.AccessProfileGroupDtoConverter;
import ca.bc.gov.health.plr.dto.dps.DataElementPermissionDto;
import ca.bc.gov.health.plr.dto.dps.DataElementPermissionDtoConverter;
import ca.bc.gov.health.plr.ejb.entity.GrsAccessProfileGroups;
import ca.bc.gov.health.plr.ejb.entity.GrsAccessProfiles;
import ca.bc.gov.health.plr.ejb.entity.GrsDataElementPermissions;
import ca.bc.gov.health.plr.ejb.entity.GrsParties;
import ca.bc.gov.health.plr.ejb.session.AbstractFacade;
import ca.bc.gov.health.plr.ejb.session.GrsPartiesFacade;
import ca.bc.gov.health.plr.service.EntityValidatorService;
import ca.bc.gov.health.plr.service.provider.security.AuthorizationService;
import ca.bc.gov.health.plr.service.validators.DpsUniqueValidator;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import java.util.ArrayList;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import org.apache.commons.lang3.Validate;

/**
 * Service for Managing the data Permission Sets
 *
 * @author sumesh.kariyil
 */
@Stateless
public class DpsService extends AbstractFacade<GrsAccessProfileGroups> {

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;

    @EJB
    private GrsPartiesFacade grsPartiesFacade;

    @EJB
    private DpsConverter converter;

    @EJB
    private EntityValidatorService<GrsAccessProfileGroups> validatorService;

    @EJB
    private DpsUniqueValidator dpsUniqueValidator;

    @EJB
    private DataElementPermissionDtoConverter dataPermissionsConverter;

    @EJB
    private AuthorizationService authorizationService;

    public DpsService() {
        super(GrsAccessProfileGroups.class);
    }

    @Override
    protected EntityManager getEntityManager() {
        return em;
    }

    /**
     * Lists all the Access profile group details
     *
     * @return
     */
    public List<AccessProfileGroupDto> findAllDps() {
        return AccessProfileGroupDtoConverter.toDtos(findAll());
    }

    /**
     * lists all the data element permission the access profile group on the
     * de1Code (data object code id) passed
     *
     * @param apgId
     * @param de1Code - Data Object ID
     * @return
     */
    public List<DataElementPermissionDto> findPermissions(Long apgId, Long de1Code) {
        Validate.notNull(apgId);
        Validate.notNull(de1Code);
        //find all permissions for the Access profile group
        TypedQuery<GrsDataElementPermissions> query = em.createNamedQuery("GrsDataElementPermissions.findByApgAndDe1Code",
                GrsDataElementPermissions.class);
        List<GrsDataElementPermissions> deps = query
                .setParameter(1, apgId)
                .setParameter(2, de1Code)
                .getResultList();
        return dataPermissionsConverter.populateDataObjectPermissions(apgId, de1Code, deps);
    }

    /**
     * DPS is not a journal even though the profile desc is a journal entity in
     * DB. There is no end reason, effective end date and start date(default
     * todays date).
     *
     * @param accessProfileGroupDto
     * @param cloneOrigin
     * @return
     * @throws EntityValidationException
     */
    public AccessProfileGroupDto saveDps(AccessProfileGroupDto accessProfileGroupDto, Long cloneOrigin) throws EntityValidationException {
        GrsAccessProfileGroups accessProfileGroup = converter.toEntity(accessProfileGroupDto);
        validatorService.validate(accessProfileGroup, dpsUniqueValidator);
        accessProfileGroup = em.merge(accessProfileGroup);
        em.flush();
        em.refresh(accessProfileGroup);
        
        if(cloneOrigin != null){//If it's clone then clone the permisions
            TypedQuery<GrsDataElementPermissions> query = em.createNamedQuery("GrsDataElementPermissions.findByApgId",
                GrsDataElementPermissions.class);
            List<GrsDataElementPermissions> permissions = query
                .setParameter(1, cloneOrigin)
                .getResultList();
            
            if(permissions != null){
                for(GrsDataElementPermissions elementPermission : permissions){
                    em.detach(elementPermission);
                    elementPermission.setApgApgId(accessProfileGroup);
                    elementPermission.setCdepId(null);
                    em.merge(elementPermission);
                }
            }
        }

        return AccessProfileGroupDtoConverter.toDto(accessProfileGroup);
    }

    /**
     * To save the data element permissions
     *
     * @param permissions
     */
    public void savePermissions(List<DataElementPermissionDto> permissions) {
        for (DataElementPermissionDto dto : permissions) {
            GrsDataElementPermissions elementPermission;
                // If the existing ANY record is updated as NOT readble and NOT writable, delete the record from table
            // This is done to match up with our understanding regardin DPS,
            // For e.g, An access profile group currently have access to ANY (Read - Y, Update - Y),
            // then the admin thinks to remove all permission and give access to specific type,(unchecks ANY)
            // in that case if we save ANY with Read - N, Update - N then since the permission implementation considers least restrictive the user will not be able to view or update any record
            // to avoid that condition delete the record (so that permission is allowed to only allowed record types
            if (dto.getId() != null && !dto.isReadFlag() && !dto.isUpdateFlag()) {
                elementPermission = em.find(GrsDataElementPermissions.class, dto.getId());
                em.remove(elementPermission);
                continue;
            }
            //Convert to entity and save
            elementPermission = dataPermissionsConverter.toEntity(dto);
            em.merge(elementPermission);

        }
    }

    /**
     * This will initiate clearing the permissions cache which is cached in
     * authorization service. Logical Steps : 1. Find all the access profiles
     * attached to the access profile group. 2. Get the reg user for that access
     * profile 3. clear the cache from authorization service for that reg user
     *
     * This is made asynchronous as cleaning the cache is time consuming process
     * (write lock/unlock), and there could be as many access profiles for an
     * access profile group
     *
     * and clear
     *
     * @param apgId
     */
//    @Asynchronous
    public void clearDpsCache(Long apgId) {
        Validate.notNull(apgId);
        GrsAccessProfileGroups apg = em.find(GrsAccessProfileGroups.class, apgId);
        List<Long> clearedRegUsers = new ArrayList<>();
        for (GrsAccessProfiles ap : apg.getGrsAccessProfilesList()) {
            if(!clearedRegUsers.contains(ap.getRuRuId().getRuId())){
                clearedRegUsers.add(ap.getRuRuId().getRuId());
                authorizationService.removeUserState(ap.getRuRuId());
            }
        }
    }

    /**
     * Returns the list of party names for the criteria suggestRegUserChid
     *
     * @param criteria
     * @return
     */
    public List<String> suggestRegUserChid(String criteria) {
        List<String> suggestNames = new ArrayList<>();
        if (criteria != null && !criteria.trim().isEmpty()) {
            List<GrsParties> parties = grsPartiesFacade.findByRegUserCharIdCriteria(criteria);
            if (parties != null && !parties.isEmpty()) {
                for (GrsParties gp : parties) {
                    suggestNames.add(gp.getRegistryUserOrgChid());
                }
            }
        }
        return suggestNames;
    }

}
