package ca.bc.gov.health.plr.service.remote;

import ca.bc.gov.health.plr.dto.DtoMetaData;
import ca.bc.gov.health.plr.dto.esb.Acknowledgment;
import ca.bc.gov.health.plr.dto.esb.MaintainProviderRequest;
import ca.bc.gov.health.plr.dto.esb.MaintainProviderResponse;
import ca.bc.gov.health.plr.dto.provider.JurisdictionNameCodeDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.dto.provider.esb.ConfidentialityIndicatorDto;
import ca.bc.gov.health.plr.dto.provider.esb.PersonNameDto;
import ca.bc.gov.health.plr.dto.provider.esb.AddressDto;
import ca.bc.gov.health.plr.dto.provider.esb.CollegeIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.esb.ConditionsDto;
import ca.bc.gov.health.plr.dto.provider.esb.CredentialsDto;
import ca.bc.gov.health.plr.dto.provider.esb.DemographicDetailsDto;
import ca.bc.gov.health.plr.dto.provider.esb.DisciplinaryActionDto;
import ca.bc.gov.health.plr.dto.provider.esb.ElectronicAddressDto;
import ca.bc.gov.health.plr.dto.provider.esb.ExpertiseDto;
import ca.bc.gov.health.plr.dto.provider.esb.NoteDto;
import ca.bc.gov.health.plr.dto.provider.esb.OrgNameDto;
import ca.bc.gov.health.plr.dto.provider.esb.ProviderRelationshipDto;
import ca.bc.gov.health.plr.dto.provider.esb.RegistryIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.esb.RegistryUserRelationshipDto;
import ca.bc.gov.health.plr.dto.provider.esb.StatusDto;
import ca.bc.gov.health.plr.dto.provider.esb.TelecommunicationDto;
import ca.bc.gov.health.plr.ejb.entity.GrsAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsElectronicAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsIdentifiers;
import ca.bc.gov.health.plr.ejb.entity.GrsOrgNames;
import ca.bc.gov.health.plr.ejb.entity.GrsPersonNames;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryIdentifiers;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.GrsTelephones;
import ca.bc.gov.health.plr.ejb.entity.PrsConditions;
import ca.bc.gov.health.plr.ejb.entity.PrsConfidentialityIndicators;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsDemographicDetails;
import ca.bc.gov.health.plr.ejb.entity.PrsDisciplinaryActions;
import ca.bc.gov.health.plr.ejb.entity.PrsNotes;
import ca.bc.gov.health.plr.ejb.entity.PrsProvRuRelns;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderCredentials;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderExpertises;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderRelationships;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.PrsStatuses;
import ca.bc.gov.health.plr.interceptors.AccessInterceptor;
import ca.bc.gov.health.plr.interceptors.AccessViolationException;
import ca.bc.gov.health.plr.interceptors.TestUserInterceptor;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodeTableCodes.GrsCtPartyType;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.persistence.ProviderDao;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.service.PlrUserRoleService;
import ca.bc.gov.health.plr.service.provider.DuplicateRecordException;
import ca.bc.gov.health.plr.service.provider.MaintainProviderService;
import ca.bc.gov.health.plr.service.provider.MaintainRegistryUserRelationshipService;
import ca.bc.gov.health.plr.service.provider.MatchHistory;
import ca.bc.gov.health.plr.service.provider.SearchProviderService;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.MessageCodeHelper;
import ca.bc.gov.health.plr.service.AddressDoctorService;
import ca.bc.gov.health.plr.service.AddressDoctorUnavailableException;

import com.google.common.collect.Iterables;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.inject.Inject;
import javax.interceptor.Interceptors;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.apache.commons.lang3.StringUtils;

/**
 * Maintain provider delegate service class This will parse each entities of the
 * provider and then will call the maintain/add services
 *
 * @author sumesh.kariyil
 */
@Stateless
@Interceptors({TestUserInterceptor.class, AccessInterceptor.class})
public class MaintainProviderEsbServiceDelegate {

    private static final Logger logger = Logger.getLogger(MaintainProviderEsbServiceDelegate.class.getName());

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;

    @EJB
    private MaintainRegistryUserRelationshipService registryUserRelationshipService;

    @EJB
    private CodesDao codesDao;

    @EJB
    private ProviderDao providerDao;

    @EJB
    private MaintainProviderService maintainProviderService;

    @Inject
    private SearchProviderService searchProviderService;

    @Inject
    private MaintainProviderEsbProcessor<AddressDto, ca.bc.gov.health.plr.dto.provider.AddressDto> addressProcessor;
    @Inject
    private MaintainProviderEsbProcessor<CollegeIdentifierDto, ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto> identifierProcessor;
    @Inject
    private MaintainProviderEsbProcessor<RegistryIdentifierDto, ca.bc.gov.health.plr.dto.provider.RegistryIdentifierDto> regIdentifierProcessor;
    @Inject
    private MaintainProviderEsbProcessor<PersonNameDto, ca.bc.gov.health.plr.dto.provider.PersonNameDto> personNameProcessor;
    @Inject
    private MaintainProviderEsbProcessor<OrgNameDto, ca.bc.gov.health.plr.dto.provider.OrgNameDto> orgNameProcessor;
    @Inject
    private MaintainProviderEsbProcessor<TelecommunicationDto, ca.bc.gov.health.plr.dto.provider.TelecommunicationDto> teleComProcessor;
    @Inject
    private MaintainProviderEsbProcessor<DemographicDetailsDto, ca.bc.gov.health.plr.dto.provider.DemographicDetailsDto> demographicProcessor;
    @Inject
    private MaintainProviderEsbProcessor<ElectronicAddressDto, ca.bc.gov.health.plr.dto.provider.ElectronicAddressDto> electronicProcessor;
    @Inject
    private MaintainProviderEsbProcessor<StatusDto, ca.bc.gov.health.plr.dto.provider.StatusDto> statusProcessor;
    @Inject
    private MaintainProviderEsbProcessor<ConditionsDto, ca.bc.gov.health.plr.dto.provider.ConditionsDto> conditionProcessor;
    @Inject
    private MaintainProviderEsbProcessor<ExpertiseDto, ca.bc.gov.health.plr.dto.provider.ExpertiseDto> expertiseProcessor;
    @Inject
    private MaintainProviderEsbProcessor<CredentialsDto, ca.bc.gov.health.plr.dto.provider.CredentialsDto> credentialProcessor;
    @Inject
    private MaintainProviderEsbProcessor<DisciplinaryActionDto, ca.bc.gov.health.plr.dto.provider.DisciplinaryActionDto> disciplinaryActionProcessor;
    @Inject
    private MaintainProviderEsbProcessor<ConfidentialityIndicatorDto, ca.bc.gov.health.plr.dto.provider.ConfidentialityIndicatorDto> confidentialityProcessor;
    @Inject
    private MaintainProviderEsbProcessor<ProviderRelationshipDto, ca.bc.gov.health.plr.dto.provider.ProviderRelationshipDto> providerRelationProcessor;
    @Inject
    private MaintainProviderEsbProcessor<RegistryUserRelationshipDto, ca.bc.gov.health.plr.dto.provider.RegistryUserRelationshipDto> regUserRelationProcessor;
    @Inject
    private MaintainProviderEsbProcessor<NoteDto, ca.bc.gov.health.plr.dto.provider.NoteDto> notesProcessor;
    @Inject
    private MaintainProviderEsbProcessor<ProviderDto, ProviderDto> addProviderProcessor;
    @Inject
    private MaintainProviderEsbProcessor<ca.bc.gov.health.plr.dto.provider.esb.JurisdictionNameCodeDto, JurisdictionNameCodeDto> jurisdictionProcessor;
    @Inject
    private MaintainEsbInformationRoutesService informationRouteProcessor;
    @Inject
    private MaintainEsbWorkLocationService workLocationService;

    @Inject
    private MaintainProviderService addProviderService;
    @Inject
    private PlrUserRoleService userRoleService;

    @EJB
    private AddressDoctorService addressDoctorService;

    /**
     * Update a Provider.
     *
     * @param request
     * @param response
     * @param existingProvider this is used as input for later methods. The
     * object should not be modified.
     * @return
     */
    public Set<String> updateProvider_Message(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto existingProvider) {
        try {
            List<List<?>> providerData = convertAndValidate(request, response, existingProvider);
            // verify provider type 'ORG' and Telecom purpose type 'EC' is not allowed to update provider 
            verifyPurposeTypeTelecom(existingProvider, response);

            // update provider only if there are no errors
            if (response.getAcknowledgments().isEmpty()) {
                maintainProviderService.saveMessageUpdate(providerData, existingProvider);
                addProviderDetailsToResponse(existingProvider.getPauthId(), response);
                checkForChangeNoChange(providerData, response);
                return getChangedBlocks(providerData, false);
            }
        } catch (EntityValidationException | DuplicateRecordException | BusinessRuleException ex) {
            ExceptionHandler.handleException(response, ex);
        }

        return Collections.emptySet();
    }

    /**
     * Add a Provider.
     *
     * @param request
     * @param response
     * @return
     */
    public Set<String> addProvider_Message(MaintainProviderRequest request, MaintainProviderResponse response) {
        try {
            //secondary src is not allowed to add provider
            if (this.userRoleService.isSecondarySource()) {
                String msg = String.format(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_ACCESS_VIOLATION));
                logger.log(Level.INFO, "MaintainProviderEsbServiceDelegate.addProvider_Message(): {0}", msg);
                throw new AccessViolationException(msg);
            }
            ProviderDto providerDto = validateAndCreateProviderDto(request, response);
            List<List<?>> providerData = convertAndValidate(request, response, providerDto);
            addRecordsToProviderDto(providerData, providerDto);

            // verify provider type 'ORG' and Telecom purpose type 'EC' is not allowed to add provider 
            verifyPurposeTypeTelecom(providerDto, response);

            // create a provider if there are no errors
            if (response.getAcknowledgments().isEmpty()) {
                PrsProviders provider = addProviderService.addProvider_Save_MessageAndWeb(providerDto);
                addProviderDetailsToResponse(provider.getPauthId(), response);
                return getChangedBlocks(providerData, true);
            }
        } catch (Exception ex) {
            ExceptionHandler.handleException(response, ex);
        }
        return Collections.emptySet();
    }

    private List<List<?>> convertAndValidate(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        List<List<?>> changedBlockLists = new ArrayList<>();
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateIdentifiers(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateAddresses(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateRegistryIdentifiers(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidatePersonNames(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateOrgNames(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateTeleCommunications(request, response, providerDto));
        // we need to ignore demographic details block for provider type 'ORG'
        if ((providerDto.getPartyType() != null
                && !StringUtils.isEmpty(providerDto.getPartyType().getValue()))
                && !providerDto.getPartyType().getValue().equalsIgnoreCase(CodeTableCodes.GrsCtPartyType.ORG.getValue())) {
            addBlockListIfNotEmpty(changedBlockLists, convertAndValdiateDemographics(request, response, providerDto));
        }
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateEletronicAddresses(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateStatuses(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateConditions(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateExpertises(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateCredentails(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateDisciplinaryActions(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateConfidentialityIndicators(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateProviderRelationShip(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateRegistryRelationShip(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, convertAndValidateNotes(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, informationRouteProcessor.process(request, response, providerDto));
        addBlockListIfNotEmpty(changedBlockLists, workLocationService.process(request, response, providerDto));
        return changedBlockLists;
    }

    /**
     * Processes the identifiers, 1. If the identifier id is null (which is set
     * during the query in maintain esb service), then add it 2. If the id is
     * not null and end reason code is not null then update
     *
     * Identifier will be always present in the message, so we cannot add or
     * update for each identifier block we receive
     *
     * @param request
     * @param provider
     * @throws EntityValidationException
     */
    private List<ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto> convertAndValidateIdentifiers(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        List<ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto> list = new ArrayList<>();
        for (CollegeIdentifierDto esbIdentifier : request.getProviderDetails().getIdentifiers()) {
            try {
                if (esbIdentifier.getId() == null || (esbIdentifier.getId() != null && esbIdentifier.getEndReasonCode() != null)) {
                    ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto converted = identifierProcessor.convertAndValidate(esbIdentifier, new ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto());
                    converted.setPauthId(providerDto.getPauthId());

                    // There are times when the provider ID needs to be created or updated.  This will allow PLR
                    // to accept a new Provider ID or change an existing one.
                    list.add(identifierProcessor.setIdsAndDataOwnerCodeOnProviderChild(converted, GrsIdentifiers.class, providerDto, "pidId"));
                }
            } catch (Exception ex) {
                ExceptionHandler.handleException(response, ex);
            }
        }

        return list;
    }

    /**
     * Processes the provider to provider relationship . We cannot follow the
     * generic approach for this, because need to find the targeted provider
     * first and then proceed
     *
     * @param request
     * @param response
     * @param provider
     */
    private List<ca.bc.gov.health.plr.dto.provider.ProviderRelationshipDto> convertAndValidateProviderRelationShip(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) throws EntityValidationException, DuplicateRecordException, BusinessRuleException {
        List<ca.bc.gov.health.plr.dto.provider.ProviderRelationshipDto> list = new ArrayList<>();
        for (ProviderRelationshipDto providerRlnDto : request.getProviderDetails().getProviderRelationships()) {

            LocalDtoConverter<ca.bc.gov.health.plr.dto.provider.ProviderRelationshipDto, ProviderRelationshipDto> converter = new LocalDtoConverter<>();
            ca.bc.gov.health.plr.dto.provider.ProviderRelationshipDto dto = converter.convert(new ca.bc.gov.health.plr.dto.provider.ProviderRelationshipDto(), providerRlnDto);
            providerRelationProcessor.validate(dto);
            if (StringUtils.isEmpty(dto.getIdentifierTypeCode())) {
                throwMandatoryError("Related Provider Identifier Type");
            }
            // Find the target provider id
            List<PrsProviders> targetProviders = providerDao.searchByIdentifer(dto.getIdentifierTypeCode(), dto.getIdentifier(), MatchHistory.NO);
            if (targetProviders.size() != 1) {
                throw new EntityValidationException(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_NONUNIQUE_IDENTIFIER));
            }
            dto.setProviderInRelationWith(targetProviders.get(0).getPauthId());
            //Validate whether message data block fields are there
            providerRelationProcessor.validateMessageDataBlockFields(dto);
            try {
                list.add(providerRelationProcessor.setIdsAndDataOwnerCodeOnProviderChild(dto, PrsProviderRelationships.class, providerDto, "reprId"));
            } catch (Exception ex) {
                ExceptionHandler.handleException(response, ex);
            }
        }
        return list;
    }

    /**
     * Add or update the specified Provider's addresses,
     *
     * Validation failures will <b>not</b> cause a transaction rollback: it is
     * the responsibility of the caller to check the response acknowledgments
     * trigger a rollback if appropriate.
     *
     * @param request specifies a Provider and some addresses to add or update.
     * @param response attach error acknowledgments to this response.
     */
    private List<ca.bc.gov.health.plr.dto.provider.AddressDto> convertAndValidateAddresses(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {

        addressProcessor.validateAddressLineFour(request, response);

        return addressProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getAddresses(),
                ca.bc.gov.health.plr.dto.provider.AddressDto.class,
                GrsAddresses.class, providerDto, "addrId", response);

    }

    private List<ca.bc.gov.health.plr.dto.provider.RegistryIdentifierDto> convertAndValidateRegistryIdentifiers(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        return regIdentifierProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getRegistryIdentifiers(),
                ca.bc.gov.health.plr.dto.provider.RegistryIdentifierDto.class, GrsRegistryIdentifiers.class, providerDto,
                "ridId", response);
    }

    private List<ca.bc.gov.health.plr.dto.provider.PersonNameDto> convertAndValidatePersonNames(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        return personNameProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getIndNames(),
                ca.bc.gov.health.plr.dto.provider.PersonNameDto.class, GrsPersonNames.class, providerDto,
                "nmId", response);
    }

    private List<ca.bc.gov.health.plr.dto.provider.OrgNameDto> convertAndValidateOrgNames(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        return orgNameProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getOrgNames(),
                ca.bc.gov.health.plr.dto.provider.OrgNameDto.class, GrsOrgNames.class, providerDto,
                "nmId", response);
    }

    private List<ca.bc.gov.health.plr.dto.provider.TelecommunicationDto> convertAndValidateTeleCommunications(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        return teleComProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getTelecommunication(),
                ca.bc.gov.health.plr.dto.provider.TelecommunicationDto.class, GrsTelephones.class, providerDto,
                "phonId", response);
    }

    private List<ca.bc.gov.health.plr.dto.provider.DemographicDetailsDto> convertAndValdiateDemographics(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        return demographicProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getDemographicDetails(),
                ca.bc.gov.health.plr.dto.provider.DemographicDetailsDto.class, PrsDemographicDetails.class, providerDto,
                "ddId", response);
    }

    private List<ca.bc.gov.health.plr.dto.provider.ElectronicAddressDto> convertAndValidateEletronicAddresses(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        return electronicProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getElectronicAddresses(),
                ca.bc.gov.health.plr.dto.provider.ElectronicAddressDto.class, GrsElectronicAddresses.class, providerDto,
                "eaddrId", response);
    }

    private List<ca.bc.gov.health.plr.dto.provider.StatusDto> convertAndValidateStatuses(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        return statusProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getStatuses(),
                ca.bc.gov.health.plr.dto.provider.StatusDto.class, PrsStatuses.class, providerDto,
                "as2Id", response);
    }

    private List<ca.bc.gov.health.plr.dto.provider.ConditionsDto> convertAndValidateConditions(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        // Conditions need different processing as the identifier can be null.
        List<ca.bc.gov.health.plr.dto.provider.ConditionsDto> list = new ArrayList<>();
        try {
            for (ConditionsDto conditionDto : request.getProviderDetails().getConditions()) {
                LocalDtoConverter<ca.bc.gov.health.plr.dto.provider.ConditionsDto, ConditionsDto> converter = new LocalDtoConverter<>();
                ca.bc.gov.health.plr.dto.provider.ConditionsDto dto = converter.convert(new ca.bc.gov.health.plr.dto.provider.ConditionsDto(), conditionDto);
                conditionProcessor.validate(dto);
                list.add(conditionProcessor.setIdsAndDataOwnerCodeOnProviderChild(dto, PrsConditions.class, providerDto, "presId"));
            }
        } catch (Exception ex) {
            ExceptionHandler.handleException(response, ex);
        }
        return list;

    }

    private List<ca.bc.gov.health.plr.dto.provider.ExpertiseDto> convertAndValidateExpertises(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        return expertiseProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getExpertise(),
                ca.bc.gov.health.plr.dto.provider.ExpertiseDto.class, PrsProviderExpertises.class, providerDto,
                "as1Id", response);
    }

    private List<ca.bc.gov.health.plr.dto.provider.CredentialsDto> convertAndValidateCredentails(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        return credentialProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getCredentials(),
                ca.bc.gov.health.plr.dto.provider.CredentialsDto.class, PrsProviderCredentials.class, providerDto,
                "pcredId", response);
    }

    private List<ca.bc.gov.health.plr.dto.provider.DisciplinaryActionDto> convertAndValidateDisciplinaryActions(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        // Disciplinary action need different processing as the identifier can be null.
        List<ca.bc.gov.health.plr.dto.provider.DisciplinaryActionDto> list = new ArrayList<>();
        try {
            for (DisciplinaryActionDto disciplinaryActionDto : request.getProviderDetails().getDisciplinaryActions()) {
                LocalDtoConverter<ca.bc.gov.health.plr.dto.provider.DisciplinaryActionDto, DisciplinaryActionDto> converter = new LocalDtoConverter<>();
                ca.bc.gov.health.plr.dto.provider.DisciplinaryActionDto dto = converter.convert(new ca.bc.gov.health.plr.dto.provider.DisciplinaryActionDto(), disciplinaryActionDto);
                disciplinaryActionProcessor.validate(dto);
                list.add(disciplinaryActionProcessor.setIdsAndDataOwnerCodeOnProviderChild(dto, PrsDisciplinaryActions.class, providerDto, "discaId"));
            }
        } catch (Exception ex) {
            ExceptionHandler.handleException(response, ex);
        }
        return list;
    }

    private List<ca.bc.gov.health.plr.dto.provider.ConfidentialityIndicatorDto> convertAndValidateConfidentialityIndicators(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        return confidentialityProcessor.convertAndValidateProviderChildren(request.getProviderDetails().getConfidentialityIndicators(),
                ca.bc.gov.health.plr.dto.provider.ConfidentialityIndicatorDto.class, PrsConfidentialityIndicators.class, providerDto,
                "pconId", response);
    }

    private List<ca.bc.gov.health.plr.dto.provider.NoteDto> convertAndValidateNotes(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) {
        // Notes need different processing as the identifier can be null.
        List<ca.bc.gov.health.plr.dto.provider.NoteDto> list = new ArrayList<>();
        try {
            for (NoteDto noteDto : request.getProviderDetails().getNotes()) {
                LocalDtoConverter<ca.bc.gov.health.plr.dto.provider.NoteDto, NoteDto> converter = new LocalDtoConverter<>();
                ca.bc.gov.health.plr.dto.provider.NoteDto dto = converter.convert(new ca.bc.gov.health.plr.dto.provider.NoteDto(), noteDto);
                notesProcessor.validate(dto);
                list.add(notesProcessor.setIdsAndDataOwnerCodeOnProviderChild(dto, PrsNotes.class, providerDto, "notId"));
            }
        } catch (Exception ex) {
            ExceptionHandler.handleException(response, ex);
        }
        return list;
    }

    private List<ca.bc.gov.health.plr.dto.provider.RegistryUserRelationshipDto> convertAndValidateRegistryRelationShip(MaintainProviderRequest request, MaintainProviderResponse response, ProviderDto providerDto) throws EntityValidationException, DuplicateRecordException, BusinessRuleException {
        List<ca.bc.gov.health.plr.dto.provider.RegistryUserRelationshipDto> list = new ArrayList<>();
        for (RegistryUserRelationshipDto registryUserRelationshipDto : request.getProviderDetails().getRegistryUserRelationships()) {
            LocalDtoConverter<ca.bc.gov.health.plr.dto.provider.RegistryUserRelationshipDto, RegistryUserRelationshipDto> converter = new LocalDtoConverter<>();
            ca.bc.gov.health.plr.dto.provider.RegistryUserRelationshipDto dto = converter.convert(new ca.bc.gov.health.plr.dto.provider.RegistryUserRelationshipDto(), registryUserRelationshipDto);
            regUserRelationProcessor.validate(dto);
            if (StringUtils.isEmpty(dto.getRegUserTypeCode())) {
                throwMandatoryError("Registry User Type");
            }
            // Find the target reg user
            List<GrsRegistryUsers> users = registryUserRelationshipService.getMatchingRegistryUsers(dto);
            if (users.size() != 1) {
                // This is a precondition of using the DTO converter.
                throw new EntityValidationException(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_NONUNIQUE_REG_USER_IDENTIFIER));
            }
            dto.setRegUserRelnId(users.get(0).getRuId());
            //Validate whether message data block fields are there
            regUserRelationProcessor.validateMessageDataBlockFields(dto);
            list.add(regUserRelationProcessor.setIdsAndDataOwnerCodeOnProviderChild(dto, PrsProvRuRelns.class, providerDto, "rurelId"));

        }

        return list;
    }

    /**
     * Creates the add provider dto with minimum data to create provider
     *
     * @param request
     * @return
     */
    public ProviderDto validateAndCreateProviderDto(MaintainProviderRequest request, MaintainProviderResponse response) throws EntityValidationException {
        ProviderDto dto = new ProviderDto();
        dto.setPartyType(GrsCtPartyType.valueOf(request.getProviderDetails().getProviderType()));
        jurisdictionProcessor.convertAndValidate(request.getProviderDetails().getJurisdiction(), dto.getJurisdiction());
        if (request.getProviderDetails().getType() != null) {
            PrsCtProviderRoleTypes hptCode = codesDao.lookup(PrsCtProviderRoleTypes.class, request.getProviderDetails().getType());
            dto.setTypeId(hptCode.getCtlId());

            checkRoleTypeAndPartyType(hptCode, request, response);

        }
        addProviderProcessor.validate(dto);
        return dto;
    }

    private void checkRoleTypeAndPartyType(PrsCtProviderRoleTypes hptCode, MaintainProviderRequest request, MaintainProviderResponse response) {
        if (!hptCode.getPartyType().matches(".*" + request.getProviderDetails().getProviderType() + ".*")) {
            String[] msgCode = MessageCodeHelper.splitCodeAndMessage(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_MESSAGE_PARTYANDROLE));
            Acknowledgment ack = new Acknowledgment(msgCode[0], msgCode[1]);
            response.addAcknowledgment(ack);
        }
    }

    private void addBlockListIfNotEmpty(List<List<?>> changedBlockList, List<?> blockList) {
        if (blockList != null && !blockList.isEmpty()) {
            changedBlockList.add(blockList);
        }
    }

    private void addRecordsToProviderDto(List<List<?>> list, ProviderDto providerDto) throws DuplicateRecordException, EntityValidationException, BusinessRuleException {

        for (List listItem : list) {

            Object dto = listItem.get(0);

            if (dto instanceof ca.bc.gov.health.plr.dto.provider.AddressDto) {
                providerDto.setAddresses(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.ConditionsDto) {
                providerDto.setConditions(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.ConfidentialityIndicatorDto) {
                providerDto.setConfidentialities(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.CredentialsDto) {
                providerDto.setCredentials(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.DemographicDetailsDto
                    && (providerDto.getPartyType() != null
                    && !StringUtils.isEmpty(providerDto.getPartyType().getValue()))
                    && !providerDto.getPartyType().getValue().equalsIgnoreCase(CodeTableCodes.GrsCtPartyType.ORG.getValue())) {
                providerDto.setDemographicDetails(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.DisciplinaryActionDto) {
                providerDto.setDisciplinaryActions(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.ElectronicAddressDto) {
                providerDto.setElectronicAddresses(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.ExpertiseDto) {
                providerDto.setExpertise(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.InformationRouteDto) {
                providerDto.setInformationRoutes(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.RegistryIdentifierDto) {
                providerDto.setRegistryIdentifiers(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.NoteDto) {
                providerDto.setNotes(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.OrgNameDto) {
                providerDto.setOrgNames(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.PersonNameDto) {
                providerDto.setIndNames(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto) {
                providerDto.setIdentifiers(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.ProviderRelationshipDto) {
                providerDto.setProviderRelationships(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.RegistryUserRelationshipDto) {
                providerDto.setRegistryUserRelationships(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.StatusDto) {
                providerDto.setStatuses(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.TelecommunicationDto) {
                providerDto.setTelecommunication(listItem);

            } else if (dto instanceof ca.bc.gov.health.plr.dto.provider.WorkLocationDto) {
                providerDto.setWorkLocationList(listItem);

            }
        }

    }

    private void throwMandatoryError(String field) throws EntityValidationException {
        throw new EntityValidationException(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_MANDATORY_PART1)
                + field
                + BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_MANDATORY_PART2));
    }

    /**
     * Adds the provider details to the response
     *
     * @param pauthId
     * @param response
     */
    private void addProviderDetailsToResponse(Long pauthId, MaintainProviderResponse response) {
        try {
            PrsProviders provider = em.find(PrsProviders.class, pauthId);
            em.refresh(provider);
            response.setProviderDetails(searchProviderService.convertAndApplyFilters(provider).toEsbVersion());
        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException ex) {
            ExceptionHandler.handleException(response, ex);
        }
    }

    private void checkForChangeNoChange(List<List<?>> providerData, MaintainProviderResponse response) {
        for (List<?> listItem : providerData) {
            for (Object item : listItem) {
                if (item instanceof DtoMetaData) {
                    DtoMetaData dto = (DtoMetaData) item;
                    addAckIfChangeNoChange(dto, response);
                } else if (item instanceof WorkLocationDto) {
                    WorkLocationDto wl = (WorkLocationDto) item;
                    @SuppressWarnings("unchecked")
                    Iterable<DtoMetaData> it = Iterables.<DtoMetaData>concat(
                            wl.getWorkLocationDetails(),
                            wl.getAddresses(),
                            wl.getElectronicAddresses(),
                            wl.getInformationRoutes(),
                            wl.getTelecommunications());
                    for (DtoMetaData dto : it) {
                        addAckIfChangeNoChange(dto, response);
                    }
                }
            }
        }
    }

    private void addAckIfChangeNoChange(DtoMetaData dto, MaintainProviderResponse response) {
        String msg = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.NO_CHANGE_ON_UPDATE);
        String[] splitCodeAndMessage = MessageCodeHelper.splitCodeAndMessage(msg);
        if (!dto.isNew() && dto.isNoChangeOnUpdate()) {
            response.addAcknowledgment(new Acknowledgment(splitCodeAndMessage[0], splitCodeAndMessage[1] + " " + dto.getBlockName()));
        }
    }

    private Set<String> getChangedBlocks(List<List<?>> providerData, boolean isCreateProvider) {
        Set<String> changedBlocks = new HashSet<>();
        for (List<?> listItem : providerData) {
            for (Object item : listItem) {
                if (item instanceof DtoMetaData) {
                    addIfChanged((DtoMetaData) item, changedBlocks);
                } else if (item instanceof WorkLocationDto) {
                    addIfChanged((WorkLocationDto) item, changedBlocks);

                    // if this a create provider and one of the blocks is WL
                    // then add to changed blocks
                    if (isCreateProvider) {
                        changedBlocks.add("Work Location");
                        changedBlocks.add("Work Location Details");
                    }

                    // if this is update the wl id (database id) will be 0 or null
                    if (!isCreateProvider && (((WorkLocationDto) item).getId() == null || ((WorkLocationDto) item).getId() == 0)) {
                        changedBlocks.add("Work Location");
                    }
                }
            }
        }
        return changedBlocks;
    }

    private void addIfChanged(WorkLocationDto wl, Set<String> changedBlocks) {
        @SuppressWarnings("unchecked")
        Iterable<DtoMetaData> it = Iterables.<DtoMetaData>concat(
                wl.getWorkLocationDetails(),
                wl.getAddresses(),
                wl.getElectronicAddresses(),
                wl.getInformationRoutes(),
                wl.getTelecommunications());
        addIfChanged(it, changedBlocks);

    }

    private void addIfChanged(Iterable<DtoMetaData> metaData, Set<String> changedBlocks) {
        for (DtoMetaData meta : metaData) {
            addIfChanged(meta, changedBlocks);
        }
    }

    private void addIfChanged(DtoMetaData metaData, Set<String> changedBlocks) {
        if (!metaData.isNoChangeOnUpdate()) {
            changedBlocks.add(metaData.getBlockName());
        }
    }

    /**
     * Validation method for provider type 'ORG' when TelecommunicationDto and
     * to display the corresponding error messages.
     *
     * @param response MaintainProviderResponse
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     */
    public void validatePurposeCdForProviderTypeTelecom(MaintainProviderResponse response) throws EntityValidationException {
        String message = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_COMM_PURPOSE_TYPE_NOT_ALLOWED);
        String[] codeAndMessage = MessageCodeHelper.splitCodeAndMessage(message);
        response.addAcknowledgment(new Acknowledgment(codeAndMessage[0], codeAndMessage[1]));
    }

    /**
     * Verify if provider type 'ORG' has any Emergency Contact type in
     * TelecommunicationDto and display the corresponding error message.
     *
     * @param providerDto ProviderDto
     * @param response MaintainProviderResponse
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     */
    public void verifyPurposeTypeTelecom(ProviderDto providerDto, MaintainProviderResponse response) throws EntityValidationException {
        // validate Emergency Contact code for provider type 'ORG' in ca.bc.gov.health.plr.dto.provider.TelecommunicationDto
        List<String> hasEmergencyContactCds = new ArrayList<>();
        if (providerDto.getPartyType() != null
                && (providerDto.getPartyType().getValue() != null
                && providerDto.getPartyType().getValue().equalsIgnoreCase(CodeTableCodes.GrsCtPartyType.ORG.getValue()))) {
            for (ca.bc.gov.health.plr.dto.provider.TelecommunicationDto telecomDto : providerDto.getTelecommunication()) {
                if (telecomDto.getCommunicationPurposeCode().equalsIgnoreCase(CodeTableCodes.PrsCtCommunPurposeTypes.EMERGENCY_CONTACT.getValue())) {
                    hasEmergencyContactCds.add(telecomDto.getCommunicationPurposeCode());
                }
            }
        }
        if (!hasEmergencyContactCds.isEmpty()) {
            validatePurposeCdForProviderTypeTelecom(response);
        }
        hasEmergencyContactCds.clear();
    }
}
