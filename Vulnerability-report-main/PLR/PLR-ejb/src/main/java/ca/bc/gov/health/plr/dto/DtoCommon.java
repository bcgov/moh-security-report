package ca.bc.gov.health.plr.dto;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes;
import ca.bc.gov.health.plr.rule.provider.AcceptableCodeName;
import ca.bc.gov.health.plr.util.DateUtils;
import java.util.Date;
import java.util.List;
import org.apache.commons.lang3.StringUtils;

/**
 *
 * @author adebiyi.kuseju
 */
public abstract class DtoCommon extends DtoMetaData {

    @AcceptableCodeName(clazz = GrsCtEndReasonTypes.class, code = "End Reason Code")
    private String endReasonCode;
    private Long endReasonCodeId;
    private Long generationNum;

    /*
     The reason these accessors are not implemented here is because (1) we want
     to use Bean Validation to validate the field, and (2) we want to override
     the message to include the datablock type. For example.
    
     @NotNull(message = "Expertise start date cannot be null");
     private Date expertiseStartDate;
    
     Bean Validation annotations cannot be overridden: http://stackoverflow.com/a/9067939/201891
     */
    public abstract Date getEffectiveStartDate();

    public abstract void setEffectiveStartDate(Date date);

    public abstract Date getEffectiveEndDate();

    public abstract void setEffectiveEndDate(Date date);

    public String getEndReasonCode() {
        return endReasonCode;
    }

    public void setEndReasonCode(String endReasonCode) {
        this.endReasonCode = endReasonCode;
    }

    /**
     * @return the generationNum
     */
    public Long getGenerationNum() {
        return generationNum;
    }

    /**
     * @param generationNum the generationNum to set
     */
    public void setGenerationNum(Long generationNum) {
        this.generationNum = generationNum;
    }

    public Long getEndReasonCodeId() {
        return endReasonCodeId;
    }

    public void setEndReasonCodeId(Long endReasonCodeId) {
        this.endReasonCodeId = endReasonCodeId;
    }

    /**
     * Choose the qualified dtos from existingDtoList and add them into newDtoList based on the value of currentOrHistoryView.
     * @param <T> extends DtoCommon
     * @param currentOrHistoryView the view mode which is either current view or history view.
     * @param existingDtoList the list contains existing dtos which are available to be chosen.
     * @param newDtoList the list contains the selected dtos from existingDtoList
     */    
    public static <T extends DtoCommon> void pickAndAddToCurrentOrHistoryView(Consts.PROVIDER_DETAILS_VIEW_MODE currentOrHistoryView, List<T> existingDtoList, List<T> newDtoList) {
        if (currentOrHistoryView != Consts.PROVIDER_DETAILS_VIEW_MODE.PROVIDER_DETAILS_CURRENT_VIEW
                && currentOrHistoryView != Consts.PROVIDER_DETAILS_VIEW_MODE.PROVIDER_DETAILS_HISTORY_VIEW) {
            return;
        }
        if (existingDtoList == null || newDtoList == null) {
            return;
        }
        for (T existingDto : existingDtoList) {
            if (existingDto.isActive()) {
                //for current view: include records having active flag Y, end reason code null and an effective end date in the future.
                //if effectiveEndDate is null, it is treated as a future date
                if (StringUtils.isEmpty(existingDto.getEndReasonCode())
                        && (existingDto.getEffectiveEndDate() == null || DateUtils.isFuture(existingDto.getEffectiveEndDate()))) {
                    newDtoList.add(existingDto);
                }
                //for history view: include current view data and 
                //records having active flag Y and an effective end date in the past.
                if (currentOrHistoryView == Consts.PROVIDER_DETAILS_VIEW_MODE.PROVIDER_DETAILS_HISTORY_VIEW
                        && existingDto.getEffectiveEndDate() != null
                        && (DateUtils.isPast(existingDto.getEffectiveEndDate()) || DateUtils.isPresent(existingDto.getEffectiveEndDate()))) {
                    newDtoList.add(existingDto);
                }
            }
        }
    }
}
