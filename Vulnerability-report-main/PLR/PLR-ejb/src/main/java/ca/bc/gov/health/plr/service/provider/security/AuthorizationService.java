package ca.bc.gov.health.plr.service.provider.security;

import ca.bc.gov.health.plr.dto.DtoAccessRestrictionData;
import ca.bc.gov.health.plr.ejb.entity.GrsDataElementPermissions;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsPermissionsMap;
import static ca.bc.gov.health.plr.ejb.entity.util.DatabaseConstants.PERSISTENCE_CONTEXT_UNIT_NAME;
import ca.bc.gov.health.plr.service.distribution.Serializer;
import java.sql.SQLIntegrityConstraintViolationException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import org.apache.commons.lang3.Validate;
import org.apache.commons.lang3.exception.ExceptionUtils;

/**
 * An instance of this class is provides a means of checking whether a registry
 * user is allowed to perform a given operation.
 *
 * @author Adebiyi Kuseju
 */
@Stateless
public class AuthorizationService {
    
    private static final Logger logger = Logger.getLogger(AuthorizationService.class.getName());

    private static int TABLE_NAME_NDX = 0;
    private static int RECORD_TYPE_NDX = 1;
    private static int COLUMN_NAME_NDX = 2;
    private static int PROVIDER_TYPE_NDX = 3;
    private static int DATA_OWNER_NDX = 4;
    private static int READ_FLAG_NDX = 5;
    private static int UPDATE_FLAG_NDX = 6;

    // Any Record Type
    public static final String ANY = "ANY";
    // All columns
    public static final String ALL = "ALL";
    static final String QUERY = "SELECT OUTERQ.CTL_NAME_CODE,\n"
            + "         OUTERQ.DECL_CODE,\n"
            + "         OUTERQ.DE_CODE,\n"
            + "         OUTERQ.HPT_CODE,\n"
            + "         OUTERQ.DATA_OWNER_CODE,\n"
            + "         OUTERQ.READ_FLAG,\n"
            + "         OUTERQ.UPDATE_FLAG\n"
            + "    FROM (SELECT DISTINCT (MAINQ.DUP_ID),\n"
            + "                          MAINQ.CTL_NAME_CODE,\n"
            + "                          MAINQ.DECL_CODE,\n"
            + "                          MAINQ.DE_CODE,\n"
            + "                          MAINQ.HPT_CODE,\n"
            + "                          MAINQ.DATA_OWNER_CODE,\n"
            + "                          MAINQ.READ_FLAG,\n"
            + "                          MAINQ.UPDATE_FLAG\n"
            + "            FROM (SELECT GDO.CTL_NAME_CODE,\n"
            + "                         DEP.DECL_CODE,\n"
            + "                         DEP.DE_CODE,\n"
            + "                         PRT.CTL_NAME_CODE AS HPT_CODE,\n"
            + "                         PDOC.CTL_NAME_CODE AS DATA_OWNER_CODE,\n"
            + "                         DEP.READ_FLAG,\n"
            + "                         DEP.UPDATE_FLAG,\n"
            + "                         (   GDO.CTL_NAME_CODE\n"
            + "                          || '<#$>'\n"
            + "                          || DEP.DECL_CODE\n"
            + "                          || '<#$>'\n"
            + "                          || DEP.DE_CODE\n"
            + "                          || '<#$>'\n"
            + "                          || AP.HPT_CODE\n"
            + "                          || '<#$>'\n"
            + "                          || AP.DATA_OWNER_CODE)\n"
            + "                            DUP_ID\n"
            + "                    FROM GRS_DATA_ELEMENT_PERMISSIONS DEP\n"
            + "                         JOIN GRS_ACCESS_PROFILE_GROUPS APG\n"
            + "                            ON DEP.APG_APG_ID = APG.APG_ID\n"
            + "                         JOIN GRS_ACCESS_PROFILES AP\n"
            + "                            ON APG.APG_ID = AP.APG_1_APG_ID\n"
            + "                         JOIN GRS_CT_DATA_OBJECTS GDO\n"
            + "                            ON DEP.DE1_CODE = GDO.CTL_ID\n"
            + "                         JOIN GRS_CT_BOOLEAN_TYPES GBT1\n"
            + "                            ON DEP.ACTIVE_FLAG = GBT1.CTL_ID\n"
            + "                         JOIN GRS_CT_BOOLEAN_TYPES GBT2\n"
            + "                            ON APG.ACTIVE_FLAG = GBT2.CTL_ID\n"
            + "                         JOIN GRS_CT_BOOLEAN_TYPES GBT3\n"
            + "                            ON AP.ACTIVE_FLAG = GBT3.CTL_ID\n"
            + "                         JOIN PRS_CT_PROVIDER_ROLE_TYPES PRT\n"
            + "                            ON AP.HPT_CODE = PRT.CTL_ID\n"
            + "                         JOIN PRS_CT_DATA_OWNER_CODES PDOC\n"
            + "                            ON AP.DATA_OWNER_CODE = PDOC.CTL_ID\n"
            + "                   WHERE     AP.RU_RU_ID = ?1\n"
            + "                         AND GBT1.CTL_NAME_CODE = 'Y'\n"
            + "                         AND GBT2.CTL_NAME_CODE = 'Y'\n"
            + "                         AND GBT3.CTL_NAME_CODE = 'Y'\n"
            + "                         AND GDO.ACTIVE_FLAG = 'Y'\n"
            + "                         AND SYSDATE BETWEEN DEP.EFFECTIVE_START_DATE\n"
            + "                                         AND DEP.EFFECTIVE_END_DATE\n"
            + "                         AND AP.END_REASON_CODE IS NULL\n"
            + "                         AND DEP.END_REASON_CODE IS NULL\n"
            + "                         -- AND DEP.DECL_CODE <> 'ANY'\n"
            + "                         -- AND AP.HPT_CODE <> '*'\n"
            + "                         -- AND AP.DATA_OWNER_CODE <> '*'\n"
            + "                 ) MAINQ) OUTERQ\n"
            + "ORDER BY OUTERQ.CTL_NAME_CODE";
    @PersistenceContext(unitName = PERSISTENCE_CONTEXT_UNIT_NAME)
    EntityManager em;

    @Inject
    Serializer<UserContext> serializer;
    
    @EJB
    AuthorizationService self;

    public enum AccessType {

        READ, WRITE;
    }

    /**
     *
     * @param registryUserId The id for the registry user
     * @param tableName The name of the table to check permission on
     * @param recordType The record type to check permission on. If null, it
     * considered as any record type
     * @param columnName the value of columnName
     * @param providerType The provider type to check permission on
     * @param dataOwnerCode The dataOwnerCode to check permission on
     * @param accessType Read or Write permission
     * @return
     */
    public boolean isAllowed(GrsRegistryUsers registryUserId, String tableName, String recordType, String columnName, PrsCtProviderRoleTypes providerType, String dataOwnerCode, AccessType accessType) {
        Validate.notNull(registryUserId);
        Validate.notNull(registryUserId.getRuId());
        Validate.notNull(tableName);
        Validate.notNull(providerType);
        Validate.notNull(providerType.getCtlNameCode());
        Validate.notNull(dataOwnerCode);

        UserContext userContext = getUserContext(registryUserId);
        boolean isAllowed = false;
        LeafPermission derivedPermission = getLeafPermission(userContext, tableName, recordType, columnName, providerType, accessType, dataOwnerCode);
        if (derivedPermission != null) {
            if (AccessType.READ.equals(accessType)) {
                isAllowed = derivedPermission.isReadable();
            } else {
                isAllowed = derivedPermission.isWritable();
            }
        }
        return isAllowed;
    }

    /**
     *
     * @param registryUserId
     * @param tableName
     * @param recordType
     * @param columnName
     * @param providerType
     * @param dataOwnerCode
     * @param accessType
     * @return
     */
    public LeafPermission getLeafPermission(GrsRegistryUsers registryUserId, String tableName, String recordType, String columnName, PrsCtProviderRoleTypes providerType, String dataOwnerCode, AccessType accessType) {

        Validate.notNull(registryUserId);
        Validate.notNull(registryUserId.getRuId());
        Validate.notNull(tableName);
        //  Validate.notNull(recordType);
        Validate.notNull(providerType);
        Validate.notNull(providerType.getCtlNameCode());
        Validate.notNull(dataOwnerCode);

        UserContext userContext = getUserContext(registryUserId);
        LeafPermission derivedPermission = getLeafPermission(userContext, tableName, recordType, columnName, providerType, accessType, dataOwnerCode);
        return derivedPermission;
    }

    /**
     * Retrieve the permission in the permission set. Below is a sample of permission set. 
     * 		"GRS_IDENTIFIER": {
			"MPID": {
				"ALL": {
					"CPSMD": {
						"dataOwner": "CPS",
						"providerType": "MD",
						"readable": true,
						"writable": true
					}
				}
			},
			"ANY": {
				"ALL": {
					"RNARN": {
						"dataOwner": "RNA",
						"providerType": "RN",
						"readable": true,
						"writable": true
					},
					"CPSMD": {
						"dataOwner": "CPS",
						"providerType": "MD",
						"readable": true,
						"writable": true
					},
					"MOHDEN": {
						"dataOwner": "MOH",
						"providerType": "DEN",
						"readable": true,
						"writable": true
					}
				}
			}
		},
     * @param userContext UserContext 
     * @param tableName String is "GRS_IDENTIFIER" for above sample
     * @param recordType String is "MPID" or "ANY" for above sample
     * @param columnName String is "ALL" for the above sample
     * @param providerType PrsCtProviderRoleTypes 
     * @param accessType AccessType is read or write
     * @param dataOwnerCode String 
     * @return LeafPermission the permission found
     */
    private LeafPermission getLeafPermission(UserContext userContext, String tableName, String recordType, String columnName,
            PrsCtProviderRoleTypes providerType, AccessType accessType, String dataOwnerCode) {

        Map<String, Map<String, Map<String, Map<String, LeafPermission>>>> permissions = userContext.getPermissions();
        Map<String, Map<String, Map<String, LeafPermission>>> recordTypeToPermissionSetMap = permissions.get(tableName);
        Map<String, Map<String, LeafPermission>> columnToPermissionSetMap;

        // Does the current user have access to tableName
        if (recordTypeToPermissionSetMap != null) {
            if (recordType != null) {
                // Does the user have permission for specific recordType
                columnToPermissionSetMap = recordTypeToPermissionSetMap.get(recordType);
                if (columnToPermissionSetMap != null) {
                    LeafPermission leafPermission = getLeafPermission(columnToPermissionSetMap, columnName, dataOwnerCode, providerType, accessType);
                    if (leafPermission != null) {
                        return leafPermission;
                    }
                }
            }
            // Permission for specific recordType was not found so read permission from recordType ANY
            columnToPermissionSetMap = recordTypeToPermissionSetMap.get(ANY);
            return getLeafPermission(columnToPermissionSetMap, columnName, dataOwnerCode, providerType, accessType);
        }

        return null;
    }
    
    /**
     * Read leaf permission from columnToPermissionSetMap. Please refer to the sample in the overloaded method's JavaDoc
     * @param columnToPermissionSetMap permission extracted for the specific record type
     * @param columnName the column name
     * @param dataOwnerCode the data owner code
     * @param providerType the provider type
     * @param accessType the accessType
     * @return LeafPermission returns LeafPermission extracted based on the combination of dataOwnerCode+providerType
     */
    private LeafPermission getLeafPermission(Map<String, Map<String, LeafPermission>> columnToPermissionSetMap, String columnName, String dataOwnerCode, PrsCtProviderRoleTypes providerType, AccessType accessType) {
        
        if (columnToPermissionSetMap != null) {
            Map<String, LeafPermission> permissionSet;
            if (columnName != null) {
                permissionSet = columnToPermissionSetMap.get(columnName);
                // If a record type is available and still no
                // columnToPermissionSetMap, then we need to check
                // if user has ANY permission entry provided
                if (permissionSet == null) {
                    permissionSet = columnToPermissionSetMap.get(ALL);
                }
            } else {
                permissionSet = columnToPermissionSetMap.get(ALL);
            }
            
            // Does the current user have any userToPermissionsMap at all
            if (permissionSet != null) {
                // Is there a matching leaf permission that is logically equal to this request                    
                return permissionSet.get(LeafPermission.makeKey(providerType.getCtlNameCode(), dataOwnerCode));
            }
        }
        return null;
    }

    // convert string Y or N to true or false respectively
    private boolean makeBoolean(String yesNo) {
        return yesNo.equalsIgnoreCase("Y");
    }

    private UserContext populatePermissions(GrsRegistryUsers registryUserId) {
        List<Object[]> result = getData(registryUserId);

        Iterator<Object[]> itr = result.iterator();
        Object[] temp;
        Set<String> updatableTableSet = new HashSet<>();
        Map<String, Map<String, Map<String, Map<String, LeafPermission>>>> tableToRecordTypesPermissionMap;
        Map<String, Map<String, Map<String, LeafPermission>>> recordTypeToColumnsPermissionMap;
        String recordType;
        String columnName;
        Map<String, Map<String, LeafPermission>> columnToProviderTypesPermissionMap;
        Map<String, LeafPermission> providerTypeToPermissionMap;
        LeafPermission leafPermission;
        UserContext userContext = new UserContext();

        while (itr.hasNext()) {
            temp = itr.next();

            tableToRecordTypesPermissionMap = userContext.getPermissions();

            // create permission map is it does not already exist
            if (tableToRecordTypesPermissionMap == null) {
                tableToRecordTypesPermissionMap = new ConcurrentHashMap<>();
                userContext.setPermissions(tableToRecordTypesPermissionMap);
            }

            recordTypeToColumnsPermissionMap = tableToRecordTypesPermissionMap.get(temp[TABLE_NAME_NDX].toString());

            // Initialize tableToPermissionSetMap if we are processing the userToPermissionsMap
            // for a new table (data object)
            if (recordTypeToColumnsPermissionMap == null) {
                recordTypeToColumnsPermissionMap = new ConcurrentHashMap<>();
                tableToRecordTypesPermissionMap.put(temp[TABLE_NAME_NDX].toString(), recordTypeToColumnsPermissionMap);
            }

//            Get all the record type values and out inside the 
            // if value is = delimited, use the string after the = sign as the record type
            recordType = temp[RECORD_TYPE_NDX].toString().equalsIgnoreCase(ANY) ? temp[RECORD_TYPE_NDX].toString().toUpperCase() : temp[RECORD_TYPE_NDX].toString().substring(temp[RECORD_TYPE_NDX].toString().indexOf("=") + 1);

            columnToProviderTypesPermissionMap = recordTypeToColumnsPermissionMap.get(recordType);

            // Initialize columnToProviderTypesPermissionMap if we are processing the permission 
            // for a new column
            if (columnToProviderTypesPermissionMap == null) {
                columnToProviderTypesPermissionMap = new ConcurrentHashMap<>();
                recordTypeToColumnsPermissionMap.put(recordType, columnToProviderTypesPermissionMap);
            }

            columnName = temp[COLUMN_NAME_NDX].toString();
            providerTypeToPermissionMap = columnToProviderTypesPermissionMap.get(columnName);

            // Initialize providerTypeToPermissionMap if we are processing the permission 
            // for a new provider type
            if (providerTypeToPermissionMap == null) {
                providerTypeToPermissionMap = new ConcurrentHashMap<>();
                columnToProviderTypesPermissionMap.put(columnName, providerTypeToPermissionMap);
            }

            leafPermission = new LeafPermission(temp[PROVIDER_TYPE_NDX].toString(), temp[DATA_OWNER_NDX].toString(), makeBoolean(temp[READ_FLAG_NDX].toString()), makeBoolean(temp[UPDATE_FLAG_NDX].toString()));
            LeafPermission transientPerm = providerTypeToPermissionMap.get(leafPermission.getKey());;

            if (transientPerm == null) {
                providerTypeToPermissionMap.put(leafPermission.getKey(), leafPermission);
            } else if (leafPermission.isMoreRestrictive(transientPerm)) {
                providerTypeToPermissionMap.put(leafPermission.getKey(), leafPermission);

            }

            // We need to keep track of all the tables that this
            // user can update to determine if the user is allowed to 
            // add a producer
            if (leafPermission.isWritable()) {
                updatableTableSet.add(temp[TABLE_NAME_NDX].toString().toUpperCase());
                userContext.addProviderType(leafPermission.getProviderType(), ProviderTypeAccess.WRITABLE);
            }

            if (leafPermission.isReadable()) {
                userContext.addProviderType(leafPermission.getProviderType(), ProviderTypeAccess.READBLE);
            }
        }

        userContext.setProviderAdditionAllowed(canAddAprovider(updatableTableSet));
        return userContext;
    }

    /**
     * Removes permission details for a registry user from the cache
     *
     * Method should be called when session is terminating to ensure efficient
     * memory use
     *
     * @param regUser The id for the registry user permission to be removed
     */
    public void removeUserState(GrsRegistryUsers regUser) {
        Validate.notNull(regUser);
        Validate.notNull(regUser.getRuId());
        PrsPermissionsMap permissionMap = em.find(PrsPermissionsMap.class, regUser.getRuId(), LockModeType.PESSIMISTIC_WRITE);
        if (permissionMap != null) {
            em.remove(permissionMap);
        }
    }

    private List<Object[]> getData(GrsRegistryUsers userId) {
        return em.createNativeQuery(QUERY).setParameter(1, userId.getRuId()).getResultList();
    }

    private boolean canAddAprovider(Set<String> updatableTableSet) {
        // Providers require certain data blocks, so to add a Provider the user must have update permissions on these tables.
        List<String> mandatoryTables = Arrays.asList(
                "GRS_ADDRESS",
                "PRS_DEMOGRAPHIC_DETAIL",
                "GRS_IDENTIFIER",
                "PRS_STATUS",
                "GRS_PERSONAL_NAME");
        return updatableTableSet.containsAll(mandatoryTables);
    }

    /**
     * Checks to see if a user is allowed to add a provider
     *
     * @param regUser a valid registry user
     * @return A boolean to determine user can add a provider
     */
    public boolean isProviderAdditionAllowed(GrsRegistryUsers regUser) {
        UserContext userContext = getUserContext(regUser);
        return userContext.isProviderAdditionAllowed();
    }

    /**
     * Fetches the provider codes a user is allowed to access.
     *
     * @param regUser a valid registry user
     * @return A Set of string that contains the provider types this user is
     * allowed to access.
     */
    public Set<String> getAllowedProviderTypes(GrsRegistryUsers regUser) {
        UserContext userContext = getUserContext(regUser);
        return userContext.getAllowedProviderTypes();
    }

    /**
     * Fetches the provider codes a user is allowed to access.
     *
     * @param regUser a valid registry user
     * @return A Set of string that contains the provider types this user is
     * allowed to access.
     */
    public Set<String> getReadableProviderTypes(GrsRegistryUsers regUser) {
        UserContext userContext = getUserContext(regUser);
        return userContext.getReadableProviderTypes();
    }

    /**
     * Checks if a user is given access to a provider
     *
     * @param regUser a valid registry user
     * @param providerType The provider type on which to check permission
     * @return A boolean to determine access is given
     */
    public boolean hasPermissionToAddProviderOfRoleType(GrsRegistryUsers regUser, PrsCtProviderRoleTypes providerType) {
        UserContext userContext = getUserContext(regUser);
        return userContext.hasPermissionToAddProviderOfRoleType(providerType);
    }

    /**
     * Gets the UPDATE data element permissions of the given registry user for
     * the specified provider type on the specified table.
     *
     * @param regUser a valid registry user
     * @param tableName a valid table name (corresponding to table names in
     * GRS_CT_DATA_OBJECTS; not actual table names)
     * @param hptCode the provider type
     * @return the data element permissions of the specified registry user for
     * the specified provider type on the specified table
     */
    public List<GrsDataElementPermissions> getDataElementPermissions(GrsRegistryUsers regUser, String tableName, PrsCtProviderRoleTypes hptCode) {
        TypedQuery<GrsDataElementPermissions> query = em.createQuery(
                "select distinct(dep) from GrsDataElementPermissions dep "
                + "  join dep.apgApgId apg "
                + "  join apg.grsAccessProfilesList ap "
                + "  where "
                + "    ap.ruRuId = :regUser "
                + "    and dep.de1Code.ctlNameCode = :tableName "
                + "    and dep.updateFlag = 'Y' "
                + "    and ap.hptCode.ctlNameCode = :hptCodeName"
                + "    and ap.endReasonCode is null "
                + "    and dep.endReasonCode is null", GrsDataElementPermissions.class);
        query.setParameter("regUser", regUser);
        query.setParameter("tableName", tableName);
        query.setParameter("hptCodeName", hptCode.getCtlNameCode());
        return query.getResultList();
    }

    /**
     * Permission map is built and stored in permissions map table. If it is
     * found return the de-serialized string else build, persist and return
     *
     * @param regUser     
     * @return
     */
    private UserContext getUserContext(GrsRegistryUsers regUser) {
        PrsPermissionsMap permissionMap = em.find(PrsPermissionsMap.class, regUser.getRuId());
        if (permissionMap == null) {
            UserContext context = self.createPermissionMapIgnoringRaceCondition(regUser);
            if (context != null) {
                return context;
            } else {
                permissionMap = em.find(PrsPermissionsMap.class, regUser.getRuId());
            }
        } 
        return serializer.deserialize(permissionMap.getPermissions(), UserContext.class);
    }

    /**
     * Create the PrsPermissionsMap for the given user and return the associated
     * UserContext. Return null if a PrsPermissionsMap for the user already exists.
     * 
     * In a clustered environment, there may be a race condition to create the
     * PrsPermissionsMap. This method returns null if a PrsPermissionsMap for
     * the given user already exists.
     * 
     * @param regUser create a PrsPermissionsMap for this user.
     * @return the UserContext associated with the newly created PrsPermissionsMap,
     * or null if a PrsPermissionsMap for the given user already exists.
     */
    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public UserContext createPermissionMapIgnoringRaceCondition(GrsRegistryUsers regUser) {
        try {
            PrsPermissionsMap permissionMap = new PrsPermissionsMap(regUser.getRuId());
            UserContext context = populatePermissions(regUser);
            permissionMap.setPermissions(serializer.serialize(context));
            em.persist(permissionMap);
            // Call flush to force the SQLIntegrityConstraintViolationException.
            em.flush();
            return context;
        } catch (Exception e) {
            Throwable rootCause = ExceptionUtils.getRootCause(e);
            if (rootCause instanceof SQLIntegrityConstraintViolationException && rootCause.getMessage().contains("ORA-00001: unique constraint")) {
                logger.info("Ignoring expected constraint violation on PRS_PERMISSIONS_MAP_PK.");
                return null;
            } else {
                throw e;
            }
        }
    }
    
    /**
     * Method return the details of the read and write access on column level
     * for the logged in user. DtoAccessRestrictionData : holds the details all
     * readable and writable columns If recordType is passed as null, then the
     * method check against ANY record type
     *
     * @param registryUserId
     * @param tableName
     * @param recordType
     * @param providerType
     * @param dataOwnerCode
     * @return
     */
    public DtoAccessRestrictionData getColumnRestrictions(GrsRegistryUsers registryUserId, String tableName, String recordType,
            PrsCtProviderRoleTypes providerType, String dataOwnerCode) {
        Validate.notNull(registryUserId);
        Validate.notNull(registryUserId.getRuId());
        Validate.notNull(tableName);
        Validate.notNull(providerType);
        Validate.notNull(providerType.getCtlNameCode());

        UserContext userContext = getUserContext(registryUserId);
        DtoAccessRestrictionData accessRestrictionData = new DtoAccessRestrictionData();

        Map<String, Map<String, Map<String, Map<String, LeafPermission>>>> permissions = userContext.getPermissions();
        Map<String, Map<String, Map<String, LeafPermission>>> recordTypeToPermissionSetMap = permissions.get(tableName);
        Map<String, Map<String, LeafPermission>> columnToPermissionSetMap;
        Map<String, LeafPermission> permissionSet;
        if (recordTypeToPermissionSetMap == null || dataOwnerCode == null) {
            return accessRestrictionData;
        }

        columnToPermissionSetMap = recordType != null ? recordTypeToPermissionSetMap.get(recordType)
                : recordTypeToPermissionSetMap.get(ANY);
        if (columnToPermissionSetMap != null) {
            for (Entry<String, Map<String, LeafPermission>> currentEntry : columnToPermissionSetMap.entrySet()) {
                permissionSet = columnToPermissionSetMap.get(currentEntry.getKey());
                if (permissionSet != null) {
                    LeafPermission leafPermRequest = new LeafPermission(providerType.getCtlNameCode(),
                            dataOwnerCode, true, true);
                    LeafPermission leafPerm = permissionSet.get(leafPermRequest.getKey());
                    if (leafPerm != null) {
                        if (!currentEntry.getKey().equals(ALL)) {//Only check the column type
                            if (!leafPerm.isReadable()) {
                                accessRestrictionData.getUnreadables().add(currentEntry.getKey());
                            }
                            if (!leafPerm.isWritable()) {
                                accessRestrictionData.getUnwritables().add(currentEntry.getKey());
                            }
                        }
                    }
                }
            }

        }

        return accessRestrictionData;
    }
    
    /**
     * Checks if the user can search for a provider
     *
     * @param regUser a valid registry user
     * @param providerType The provider type on which to check permission
     * @return A boolean to determine access is given
     */
    public boolean hasPermissionToSearchProviderOfRoleType(GrsRegistryUsers regUser, PrsCtProviderRoleTypes providerType) {
        UserContext userContext = getUserContext(regUser);
        return userContext.hasPermissionToSearchProviderOfRoleType(providerType);
    }
}
