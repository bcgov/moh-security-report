package ca.bc.gov.health.plr.service.distribution;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.AbstractProviderDetail;
import ca.bc.gov.health.plr.dto.provider.AddressDto;
import ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.ConditionsDto;
import ca.bc.gov.health.plr.dto.provider.ConfidentialityIndicatorDto;
import ca.bc.gov.health.plr.dto.provider.CredentialsDto;
import ca.bc.gov.health.plr.dto.provider.DemographicDetailsDto;
import ca.bc.gov.health.plr.dto.provider.DisciplinaryActionDto;
import ca.bc.gov.health.plr.dto.provider.ElectronicAddressDto;
import ca.bc.gov.health.plr.dto.provider.ExpertiseDto;
import ca.bc.gov.health.plr.dto.provider.InformationRouteDto;
import ca.bc.gov.health.plr.dto.provider.NoteDto;
import ca.bc.gov.health.plr.dto.provider.OrgNameDto;
import ca.bc.gov.health.plr.dto.provider.PersonNameDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.ProviderRelationshipDto;
import ca.bc.gov.health.plr.dto.provider.RegistryIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.RegistryUserRelationshipDto;
import ca.bc.gov.health.plr.dto.provider.StatusDto;
import ca.bc.gov.health.plr.dto.provider.TelecommunicationDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDetailsDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.ejb.entity.GrsAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsCtTransactionTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsDistribEvent;
import ca.bc.gov.health.plr.ejb.entity.GrsElectronicAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsIdentifiers;
import ca.bc.gov.health.plr.ejb.entity.GrsOrgNames;
import ca.bc.gov.health.plr.ejb.entity.GrsPersonNames;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryIdentifiers;
import ca.bc.gov.health.plr.ejb.entity.GrsTelephones;
import ca.bc.gov.health.plr.ejb.entity.PrsConditions;
import ca.bc.gov.health.plr.ejb.entity.PrsConfidentialityIndicators;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsDemographicDetails;
import ca.bc.gov.health.plr.ejb.entity.PrsDisciplinaryActions;
import ca.bc.gov.health.plr.ejb.entity.PrsInformationRoutes;
import ca.bc.gov.health.plr.ejb.entity.PrsNotes;
import ca.bc.gov.health.plr.ejb.entity.PrsProvRuRelns;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderCredentials;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderExpertises;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderRelationships;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.PrsStatuses;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocationDetails;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.events.DistributionEvent;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.service.JNDIResourceLoader;
import ca.bc.gov.health.plr.service.PLRConfigurationResourceLoader;
import ca.bc.gov.health.plr.service.provider.ProviderHelperService;
import ca.bc.gov.health.plr.service.remote.FindMessageDataBlockService;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.MetaDataUtil;
import ca.bc.gov.health.plr.util.ReflectionUtils;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.ejb.AsyncResult;
import javax.ejb.Asynchronous;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.enterprise.event.Observes;
import javax.enterprise.event.TransactionPhase;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

/**
 *
 * @author adebiyi.kuseju
 */
@Stateless
public class DistributionEventConsumer {

    private static final Logger LOGGER = Logger.getLogger(DistributionEventConsumer.class.getName());

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;

    @EJB
    private ProviderDtoConverter providerDtoConverter;

    @Inject
    private JNDIResourceLoader prod;

    @EJB
    private ProcessDistributionService distService;

    @EJB
    private MetaDataUtil metaDataUtil;

    @EJB
    private ProviderHelperService providerHelperService;

    @Inject
    private FindMessageDataBlockService findMessageDataBlockService;

    @Inject
    private PLRConfigurationResourceLoader plrConfigLoader;

    /**
     * Processes distribution event
     *
     * @param distEvent
     * @return
     */
    @Asynchronous
    public Future<GrsDistribEvent> processEvent(@Observes(during = TransactionPhase.AFTER_SUCCESS) DistributionEvent distEvent) {
        GrsDistribEvent distributionEvent = null;
        try {
            DistributableItemWrapper<PrsProviders> distItemWrapper = buildWrapper(distEvent.getArguments(), distEvent.getOutput());

            if (distItemWrapper != null) {
                if (!distItemWrapper.getSubChanges().isEmpty()) {
                    distributionEvent = distService.processDistribution(distItemWrapper, distEvent.getRequester());
                }
            } else {
                throw new IllegalArgumentException("Supplied arguments cannot be used to proces distribution");
            }

        } catch (Exception ex) {
            LOGGER.log(Level.SEVERE, null, ex);
        }

        return new AsyncResult<>(distributionEvent);
    }

    /**
     * Builds the wrapper for distribution data
     *
     * @param args
     * @param output
     * @return
     * @throws Exception
     */
    private DistributableItemWrapper<PrsProviders> buildWrapper(final Object[] args, Object output) throws Exception {

        DistributableItemWrapper<PrsProviders> distItemWrapper = null;

        // Should distribution be processed? i.e. sent to the queue
        if (Boolean.parseBoolean(plrConfigLoader.getValue(Consts.PROCESS_DISTRIBUTION))) {

            LOGGER.log(Level.INFO, "DistributionEventConsumer buildWrapper is: {0}.",
                    new Object[]{Boolean.parseBoolean(plrConfigLoader.getValue(Consts.PROCESS_DISTRIBUTION))});

            try {

                GrsCtTransactionTypes tranxType;

                if (args.length > 0) {

                    PrsProviders beforeProviderChange;

                    // If we are creating a provider
                    // MESSAGE/WEB CREATE PROVIDER 
                    // [PrsProviders addProvider_Save_MessageAndWeb(ProviderDto providerDto)]
                    // [PrsProviders saveWebProvider(ProviderDto providerDto) ]
                    if (args[0] instanceof ProviderDto && (args.length == 1 || (args.length == 2 && !(args[1] instanceof WorkLocationDetailsDto)))) {
                        //this if logic is for all methods with first parameter of ProviderDto in MaintainProviderService but except
                        //updateWorkLocationDetail(ProviderDto, WorkLocationDetailsDto) which is processed by the last if block

                        beforeProviderChange = providerHelperService.findProvider(providerHelperService.getAllListsAsList((ProviderDto) args[0]));
                        List<DistributableItemWrapper<?>> distributableWrappers = generateDistributableWrappers(providerDtoConverter.toProviderDetails((PrsProviders) output, false));
                        distItemWrapper = new DistributableItemWrapper<>(beforeProviderChange, (PrsProviders) output, distributableWrappers, null, DistributableItemWrapper.ChangeType.CREATE_PROVIDER);

                        // WEB UPDATE WLD, WLADDR [AbstractProviderDetail save(AbstractProviderDetail apd)]
                    } else if (args[0] instanceof AbstractProviderDetail) {
                        // If we are creating or modifying a provider data block other than WorkLocation
                        // first we check that block was truly changed, not just the same data being saved
                        beforeProviderChange = providerHelperService.findProvider(args[0]);
                        DistributableItemWrapper<? extends AbstractProviderDetail> subItemWrapper = null;
                        tranxType = metaDataUtil.getTransactionType(args[0], false);

                        if (!isNoChange(output)) {
                            subItemWrapper = new DistributableItemWrapper<>(getPreviousState((AbstractProviderDetail) args[0]), (AbstractProviderDetail) output, null, tranxType, null);
                        }

                        distItemWrapper = new DistributableItemWrapper<>(beforeProviderChange, providerHelperService.findProvider(output), distributableitemWrapperToList(subItemWrapper), tranxType, DistributableItemWrapper.ChangeType.UPDATE_PROVIDER);

                        // MESSAGE UPDATE [List<List<?>> saveMessageUpdate(List<List<?>> dtoBlocksToSave, ProviderDto existingProvider)]
                    } else if (args[0] instanceof List<?>) {

                        beforeProviderChange = providerHelperService.findProvider((List<Object>) args[0]);

                        // A number of changes on a provider data blocks. Typically expected for messaging
                        List<DistributableItemWrapper<?>> changedBlocks = getWrapperList((List) args[0], (List) output, beforeProviderChange.getHptCode());

                        // Create distribution only if there is at least a true change in one of the blocks
                        distItemWrapper = new DistributableItemWrapper<>(beforeProviderChange, providerHelperService.findProvider(output), changedBlocks, null, DistributableItemWrapper.ChangeType.UPDATE_PROVIDER);

                        // WEB ADD WL [WorkLocationDto saveNewWorkLocationAndDetail(WorkLocationDto workLocationDto, WorkLocationDetailsDto workLocationDetailsDto)]
                    } else if (args[0] instanceof WorkLocationDto && args.length == 2 && args[1] instanceof WorkLocationDetailsDto) {

                        beforeProviderChange = providerHelperService.findProvider(args[1]);

                        // If we are creating or modifying a provider work location
                        WorkLocationDto changesWLDto = (WorkLocationDto) output;
                        List<DistributableItemWrapper<?>> subItemWrapperList = new ArrayList<>();
                        tranxType = metaDataUtil.getTransactionType(args[1], false);
                        for (WorkLocationDetailsDto wldDto : changesWLDto.getWorkLocationDetails()) {
                            subItemWrapperList.add(new DistributableItemWrapper<>(getPreviousState((AbstractProviderDetail) args[1]), wldDto, null, tranxType, null));
                        }
                        distItemWrapper = new DistributableItemWrapper<>(beforeProviderChange, providerHelperService.findProvider(output), subItemWrapperList, tranxType, DistributableItemWrapper.ChangeType.UPDATE_PROVIDER);

                        // update work location detail
                        // [WorkLocationDetailsDto updateWorkLocationDetail(ProviderDto providerDetails, WorkLocationDetailsDto workLocationDetailsDto)]
                    } else if (args[0] instanceof ProviderDto && args.length == 2 && args[1] instanceof WorkLocationDetailsDto) {
                        //this if logic is for MaintainProviderService.updateWorkLocationDetail(ProviderDto, WorkLocationDetailsDto)

                        beforeProviderChange = providerHelperService.findProvider(args[1]);

                        WorkLocationDetailsDto changesWLDetailsDto = (WorkLocationDetailsDto) output;
                        List<DistributableItemWrapper<?>> subItemWrapperList = new ArrayList<>();
                        tranxType = metaDataUtil.getTransactionType(args[1], false);
                        subItemWrapperList.add(new DistributableItemWrapper<>(getPreviousState((AbstractProviderDetail) args[1]), changesWLDetailsDto, null, tranxType, null));
                        distItemWrapper = new DistributableItemWrapper<>(beforeProviderChange, providerHelperService.findProvider(output), subItemWrapperList, tranxType, DistributableItemWrapper.ChangeType.UPDATE_PROVIDER);
                    }

                }
            } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
                // Swallow and log his exceptin as we do not want distribution causing application failure
                LOGGER.log(Level.SEVERE, null, ex);
            }

        }

        return distItemWrapper;
    }

    /**
     * For when creating a provider.
     *
     * @param providerDto This dto holds the changed provider data.
     * @return
     * @throws NoSuchMethodException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     */
    private List<DistributableItemWrapper<?>> generateDistributableWrappers(ProviderDto providerDto) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        List<DistributableItemWrapper<?>> distributableItemWrapperList = new ArrayList<>();

        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getAddresses", CodeTableCodes.GrsCtTransactionTypes.CREATE_ADDRESS));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getConditions", CodeTableCodes.GrsCtTransactionTypes.CREATE_CONDITION));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getConfidentialityIndicators", CodeTableCodes.GrsCtTransactionTypes.CREATE_CONFIDENTIALITY));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getCredentials", CodeTableCodes.GrsCtTransactionTypes.CREATE_CREDENTIAL));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getDemographicDetails", CodeTableCodes.GrsCtTransactionTypes.CREATE_DEMOGRAPHIC));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getDisciplinaryActions", CodeTableCodes.GrsCtTransactionTypes.CREATE_DISCIPLINARY_ACTION));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getElectronicAddresses", CodeTableCodes.GrsCtTransactionTypes.CREATE_E_ADDRESS));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getExpertise", CodeTableCodes.GrsCtTransactionTypes.CREATE_EXPERTISE));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getInformationRoutes", CodeTableCodes.GrsCtTransactionTypes.CREATE_INFORMATION_ROUTE));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getNotes", CodeTableCodes.GrsCtTransactionTypes.CREATE_NOTE));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getOrgNames", CodeTableCodes.GrsCtTransactionTypes.CREATE_ORGANIZATION_NAME));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getIndNames", CodeTableCodes.GrsCtTransactionTypes.CREATE_PERSONAL_NAME));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getIdentifiers", CodeTableCodes.GrsCtTransactionTypes.CREATE_IDENTIFIER));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getProviderRelationships", CodeTableCodes.GrsCtTransactionTypes.CREATE_RELATIONSHIP));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getRegistryIdentifiers", CodeTableCodes.GrsCtTransactionTypes.CREATE_REGISTRY_IDENTIFIER));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getRegistryUserRelationships", CodeTableCodes.GrsCtTransactionTypes.CREATE_REGISTRY_USER_RELATIONSHIP));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getStatuses", CodeTableCodes.GrsCtTransactionTypes.CREATE_STATUS));
        addItems(distributableItemWrapperList, getWrappersForDataBlock(providerDto, "getTelecommunication", CodeTableCodes.GrsCtTransactionTypes.CREATE_TELEPHONE));
        for (WorkLocationDto wlDto : providerDto.getWorkLocationList()) {
            addItems(distributableItemWrapperList, getWrappersForDataBlock(wlDto, "getWorkLocationDetails", CodeTableCodes.GrsCtTransactionTypes.CREATE_WORK_LOCATION_DETAIL));
            addItems(distributableItemWrapperList, getWrappersForDataBlock(wlDto, "getAddresses", CodeTableCodes.GrsCtTransactionTypes.CREATE_WORK_LOCATION_ADDRESS));
            addItems(distributableItemWrapperList, getWrappersForDataBlock(wlDto, "getTelecommunications", CodeTableCodes.GrsCtTransactionTypes.CREATE_WORK_LOCATION_TELEPHONE));
            addItems(distributableItemWrapperList, getWrappersForDataBlock(wlDto, "getElectronicAddresses", CodeTableCodes.GrsCtTransactionTypes.CREATE_WORK_LOCATION_E_ADDRESS));
            addItems(distributableItemWrapperList, getWrappersForDataBlock(wlDto, "getInformationRoutes", CodeTableCodes.GrsCtTransactionTypes.CREATE_WORK_LOCATION_INFORMATION_ROUTE));
        }

        return distributableItemWrapperList;
    }

    private void addItems(List<DistributableItemWrapper<?>> dist, List<DistributableItemWrapper<?>> source) {
        if (isNotEmpty(source)) {
            dist.addAll(source);
        }
    }

    // Creates a list of wrapper that individually tracks all the changes made to a data block
    private List<DistributableItemWrapper<?>> getWrappersForDataBlock(Object dto, String propertyName, CodeTableCodes.GrsCtTransactionTypes tranxType) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        List<?> relatedItems = (List) ReflectionUtils.methodInvoke(dto, propertyName);
        List<DistributableItemWrapper<?>> wrapperList = null;

        if (isNotEmpty(relatedItems)) {
            wrapperList = new ArrayList<>();

            for (Object i : relatedItems) {
                wrapperList.add(new DistributableItemWrapper<>(null, i, null, metaDataUtil.getSpecificTransactionType(tranxType), null));
            }
        }

        return wrapperList;
    }

    /**
     * This is the worst code ever. I'd love to rewrite those whole class ...
     *
     * This method tries to construct the wrapper list for provider updates that
     * come in, in the form of a list of lists. There are a couple pit falls and
     * different lists.
     *
     * @param toChangeBlocks input blocks with changed data
     * @param changedBlocks output blocks with changed data
     * @param role provider role
     * @return list for distributions of changed blocks
     *
     * @throws NoSuchMethodException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     * @throws EntityValidationException
     */
    private List<DistributableItemWrapper<?>> getWrapperList(List<List<?>> toChangeBlocks, List<List<?>> changedBlocks, PrsCtProviderRoleTypes role) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, EntityValidationException {

        List<DistributableItemWrapper<?>> wrapperList = new ArrayList<>();
        Object toChangeBlockItem;
        for (int x = 0; x < toChangeBlocks.size(); x++) {
            List<?> toChangeBlock = toChangeBlocks.get(x);
            for (int y = 0; y < toChangeBlock.size(); y++) {

                toChangeBlockItem = toChangeBlock.get(y);

                if (toChangeBlockItem instanceof WorkLocationDto) {
                    // In this case the changeBlocks at [x] has
                    // the updates to the work location, like some
                    // details or addresses.

                    // So changedBlocks.get(x).get(y) is likely details
                    // or telecoms.  But is definitely not a work location dto.
                    // We are assuming any change to a work location child
                    // as a change to the whole.  So we want to determine if any
                    // of WL children have changes and then create the
                    // wrapper.
                    // So let's finish the y loop and break out and create a 
                    // wrapper if necessary.  This is all very crazy.
                    boolean isChange = false;
                    for (int z = y; z < changedBlocks.get(x).size(); z++) {
                        if (!isNoChange(changedBlocks.get(x).get(z))) {
                            isChange = true;
                            break;
                        }
                    }
                    if (isChange) {

                        // find the work location ID, could be in a couple places
                        Long WLid = null;
                        if (((WorkLocationDto) toChangeBlockItem).getId() == null) {
                            if (changedBlocks.get(x).get(0) instanceof WorkLocationDto) {
                                WLid = ((WorkLocationDto) changedBlocks.get(x).get(0)).getId();
                            }
                        } else {
                            WLid = ((WorkLocationDto) toChangeBlockItem).getId();
                        }

                        for (int z = y; z < changedBlocks.get(x).size(); z++) {
                            AbstractProviderDetail prevDto = null;
                            DistributableItemWrapper<? extends AbstractProviderDetail> distItemWrapper = null;
                            if (changedBlocks.get(x).get(z) instanceof WorkLocationDto) {
                                WorkLocationDetailsDto wlDDto = ((WorkLocationDto) changedBlocks.get(x).get(z)).getWorkLocationDetails().get(0);
                                if (!wlDDto.isNoChangeOnUpdate()) {
                                    prevDto = findMessageDataBlockService.getOriginalAbsProvDetailRecord((AbstractProviderDetail) wlDDto, WLid, role);
                                    distItemWrapper = new DistributableItemWrapper<>(prevDto, (AbstractProviderDetail) wlDDto, null, metaDataUtil.getTransactionType(changedBlocks.get(x).get(z), false), null);
                                    wrapperList.add(distItemWrapper);
                                }
                            } else {
                                if (!((AbstractProviderDetail) changedBlocks.get(x).get(z)).isNoChangeOnUpdate()) {
                                    prevDto = findMessageDataBlockService.getOriginalAbsProvDetailRecord((AbstractProviderDetail) changedBlocks.get(x).get(z), WLid, role);
                                    distItemWrapper = new DistributableItemWrapper<>(prevDto, (AbstractProviderDetail) changedBlocks.get(x).get(z), null, metaDataUtil.getTransactionType(changedBlocks.get(x).get(z), false), null);
                                    wrapperList.add(distItemWrapper);
                                }
                            }
                        }
                    }
                    break; // out of the y loop, we are done
                }
                // if the break just above didn't happen, keep going ... not work location
                // Is there a true change on this block?
                if (!isNoChange(changedBlocks.get(x).get(y))) {

                    if (toChangeBlockItem instanceof AbstractProviderDetail) {
                        DistributableItemWrapper<? extends AbstractProviderDetail> distItemWrapper = new DistributableItemWrapper<>(getPreviousState((AbstractProviderDetail) toChangeBlockItem), (AbstractProviderDetail) changedBlocks.get(x).get(y), null, metaDataUtil.getTransactionType(toChangeBlockItem, false), null);
                        wrapperList.add(distItemWrapper);

                    } else {
                        DistributableItemWrapper<WorkLocationDto> distItemWrapper = new DistributableItemWrapper<>(getPreviousState((WorkLocationDto) toChangeBlockItem), (WorkLocationDto) changedBlocks.get(x).get(y), null, metaDataUtil.getTransactionType(toChangeBlockItem, false), null);
                        wrapperList.add(distItemWrapper);
                    }
                }

            }
        }

        return wrapperList;
    }

    private boolean isNotEmpty(List<?> itemList) {
        return itemList != null && !itemList.isEmpty();
    }

    private List<DistributableItemWrapper<?>> distributableitemWrapperToList(DistributableItemWrapper<?> subItemWrapper) {
        List<DistributableItemWrapper<?>> subChanges = new ArrayList<>();
        if (subItemWrapper != null) {
            subChanges.add(subItemWrapper);
        }

        return subChanges;
    }

    private AbstractProviderDetail getPreviousState(AbstractProviderDetail dto) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {

        AbstractProviderDetail detail = null;

        if (!metaDataUtil.isNew(dto)) {
            if (dto instanceof AddressDto) {
                GrsAddresses beforeEntityChange = em.find(GrsAddresses.class, dto.getId());
                detail = providerDtoConverter.buildAddress(beforeEntityChange);

            } else if (dto instanceof ConditionsDto) {
                PrsConditions beforeEntityChange = em.find(PrsConditions.class, dto.getId());
                detail = providerDtoConverter.buildCondition(beforeEntityChange);

            } else if (dto instanceof ConfidentialityIndicatorDto) {
                PrsConfidentialityIndicators beforeEntityChange = em.find(PrsConfidentialityIndicators.class, dto.getId());
                detail = providerDtoConverter.buildConfidentialityIndicator(beforeEntityChange);

            } else if (dto instanceof CredentialsDto) {
                PrsProviderCredentials beforeEntityChange = em.find(PrsProviderCredentials.class, dto.getId());
                detail = providerDtoConverter.buildCredential(beforeEntityChange);

            } else if (dto instanceof DemographicDetailsDto) {
                PrsDemographicDetails beforeEntityChange = em.find(PrsDemographicDetails.class, dto.getId());
                detail = providerDtoConverter.buildDemographicDetail(beforeEntityChange);

            } else if (dto instanceof DisciplinaryActionDto) {
                PrsDisciplinaryActions beforeEntityChange = em.find(PrsDisciplinaryActions.class, dto.getId());
                detail = providerDtoConverter.buildDisciplinaryAction(beforeEntityChange);

            } else if (dto instanceof ElectronicAddressDto) {
                GrsElectronicAddresses beforeEntityChange = em.find(GrsElectronicAddresses.class, dto.getId());
                detail = providerDtoConverter.buildElectronicAddress(beforeEntityChange);

            } else if (dto instanceof ExpertiseDto) {
                PrsProviderExpertises beforeEntityChange = em.find(PrsProviderExpertises.class, dto.getId());
                detail = providerDtoConverter.buildExpertise(beforeEntityChange);

            } else if (dto instanceof InformationRouteDto) {
                PrsInformationRoutes beforeEntityChange = em.find(PrsInformationRoutes.class, dto.getId());
                detail = providerDtoConverter.buildInformationRoute(beforeEntityChange);

            } else if (dto instanceof NoteDto) {
                PrsNotes beforeEntityChange = em.find(PrsNotes.class, dto.getId());
                detail = providerDtoConverter.buildNote(beforeEntityChange);

            } else if (dto instanceof OrgNameDto) {
                GrsOrgNames beforeEntityChange = em.find(GrsOrgNames.class, dto.getId());
                detail = providerDtoConverter.buildOrgName(beforeEntityChange);

            } else if (dto instanceof PersonNameDto) {
                GrsPersonNames beforeEntityChange = em.find(GrsPersonNames.class, dto.getId());
                detail = providerDtoConverter.buildPersonName(beforeEntityChange);

            } else if (dto instanceof CollegeIdentifierDto) {
                GrsIdentifiers beforeEntityChange = em.find(GrsIdentifiers.class, dto.getId());
                detail = providerDtoConverter.buildIdentifier(beforeEntityChange);

            } else if (dto instanceof ProviderRelationshipDto) {
                PrsProviderRelationships beforeEntityChange = em.find(PrsProviderRelationships.class, dto.getId());
                detail = providerDtoConverter.buildProviderRelationship(beforeEntityChange);

            } else if (dto instanceof RegistryIdentifierDto) {
                GrsRegistryIdentifiers beforeEntityChange = em.find(GrsRegistryIdentifiers.class, dto.getId());
                detail = providerDtoConverter.buildRegistryIdentifier(beforeEntityChange);

            } else if (dto instanceof RegistryUserRelationshipDto) {
                PrsProvRuRelns beforeEntityChange = em.find(PrsProvRuRelns.class, dto.getId());
                detail = providerDtoConverter.buildRegistryUserRelationship(beforeEntityChange);

            } else if (dto instanceof StatusDto) {
                PrsStatuses beforeEntityChange = em.find(PrsStatuses.class, dto.getId());
                detail = providerDtoConverter.buildStatus(beforeEntityChange);

            } else if (dto instanceof TelecommunicationDto) {
                GrsTelephones beforeEntityChange = em.find(GrsTelephones.class, dto.getId());
                detail = providerDtoConverter.buildTelephone(beforeEntityChange);

            } else if (dto instanceof WorkLocationDetailsDto) {
                PrsWorkLocationDetails beforeEntityChange = em.find(PrsWorkLocationDetails.class, dto.getId());
                detail = providerDtoConverter.buildWorkLocationDetail(beforeEntityChange);

            }
        }
        return detail;
    }

    private WorkLocationDto getPreviousState(WorkLocationDto dto) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {

        WorkLocationDto detail = null;

        if (!metaDataUtil.isNew(dto)) {
            PrsWorkLocations beforeEntityChange = em.find(PrsWorkLocations.class, dto.getId());
            detail = providerDtoConverter.buildWorkLocation(beforeEntityChange);

        }
        return detail;
    }

    private boolean isNoChange(Object dto) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        try {
            return (Boolean) dto.getClass().getMethod("isNoChangeOnUpdate").invoke(dto);
        } catch (Exception e) {
            //WorkLocationDtos can't change, and don't have a isNoChangeOnUpdate method, so just return TRUE in this case.
            return Boolean.TRUE;
        }
    }
}
