package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.OrgNameDto;
import ca.bc.gov.health.plr.dto.provider.PersonNameDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.comparator.ProviderDtoLastFirstNameComparator;
import ca.bc.gov.health.plr.dto.provider.ProviderType;
import ca.bc.gov.health.plr.dto.provider.search.SearchProviderRequest;
import ca.bc.gov.health.plr.dto.provider.search.SearchProviderResult;
import ca.bc.gov.health.plr.ejb.entity.GrsCtRegIdentifierTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtIdentifierTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.interceptors.TestUserInterceptor;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.persistence.ConfigurationDao;
import ca.bc.gov.health.plr.persistence.ProviderDao;
import ca.bc.gov.health.plr.producer.type.Authenticated;
import ca.bc.gov.health.plr.producer.type.User;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import ca.bc.gov.health.plr.rule.BusinessRuleResult;
import ca.bc.gov.health.plr.rule.provider.AccessRestrictionService;
import ca.bc.gov.health.plr.rule.provider.ProviderConfidentiality;
import ca.bc.gov.health.plr.rule.provider.search.SearchLogger;
import ca.bc.gov.health.plr.rule.provider.search.ValidateSearchAttributes;
import ca.bc.gov.health.plr.rule.provider.search.ValidateSearchProviderTypePermission;
import ca.bc.gov.health.plr.rule.provider.search.ValidateSearchResultSize;
import ca.bc.gov.health.plr.service.provider.security.AuthorizationService;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.interceptor.Interceptors;
import org.apache.commons.lang3.Validate;

/**
 *
 * @author Grant.Hodgins
 */
@Stateless
@Interceptors({TestUserInterceptor.class})
public class SearchProviderService {

    @EJB
    private ConfigurationDao configurationDao;
    @EJB
    private ProviderDao providerDao;
    @EJB
    private CodesDao codesDao;
    @EJB
    private ValidateSearchAttributes validateSearchAttributes;
    @EJB
    private ValidateSearchResultSize validateSearchResultSize;
    @EJB
    private ValidateSearchProviderTypePermission validateSearchProviderTypePermission;
    @EJB
    private ProviderConfidentiality providerConfidentiality;
    @EJB
    private AuthorizationService authorizationService;
    @EJB
    private SearchLogger searchLogger;

    @EJB
    private AccessRestrictionService accessRestrictionService;

    @EJB
    private ProviderDtoConverter providerDtoConverter;

    @Inject
    @Authenticated
    private Instance<User> user;

    private ProviderDtoNameComparator comparator = new ProviderDtoNameComparator();

    /**
     * Query for provider details based on the provided primary key.
     *
     * @param pauthId the primary key for a provider record. Cannot be null.
     * @return the matching provider details or null if no match.
     */
    public ProviderDto searchByProviderId(Long pauthId) {
        Validate.notNull(pauthId);

        PrsProviders provider = providerDao.searchByProviderId(pauthId);
        if (provider != null) {
            return convertAndApplyFilters(provider);
        }
        return null;

    }

    /**
     * converts the PrsProviders and applies the read restriction and
     * confidentiality filters.
     *
     * @param provider
     * @return ProviderDto
     */
    public ProviderDto convertAndApplyFilters(PrsProviders provider) {
        ProviderDto result = providerDtoConverter.toProviderDetails(provider, false);
        accessRestrictionService.applyProviderAccessRestrictions(result, provider.getHptCode(), false);
        providerDtoConverter.buildPrimaryWorkLocation(result.getWorkLocationList());
        return providerConfidentiality.applyConfidentiality(result);
    }

    /**
     * Query for providers based on a provided identifier.
     *
     * @param request
     * @return the ca.bc.gov.health.plr.dto.provider.search.SearchProviderResult
     */
    public SearchProviderResult searchByIdentifier(SearchProviderRequest request) {
        Long identifierTypeId = request.getIdentifierTypeId();
        if (identifierTypeId == null && request.getIdentifierTypeCode() != null) {
            identifierTypeId = codesDao.lookup(PrsCtIdentifierTypes.class, request.getIdentifierTypeCode()).getCtlId();
        }
        MatchHistory matchHistory = doMatchHistory(request.isHistoryFlag());
        List<PrsProviders> providers = providerDao.searchByIdentifer(identifierTypeId, request.getIdentifier(), matchHistory, request.isIsMessage());
        SearchProviderResult searchResult = applyFilters(providers, request.isIsMessage(), true);
        searchLogger.logSearchForCollegeId(searchResult, identifierTypeId, request.getIdentifier(), matchHistory);
        return searchResult;
    }

    /**
     * Query for providers based on a provided registry identifier.
     *
     * @param request
     * @return the ca.bc.gov.health.plr.dto.provider.search.SearchProviderResult
     */
    public SearchProviderResult searchByRegistryIdentifier(SearchProviderRequest request) {
        Validate.notBlank(request.getRegistryIdentifier());
        String identifier = request.getRegistryIdentifier()
                + (request.getRegistryIdentifierPostfix() != null ? request.getRegistryIdentifierPostfix() : "");

        MatchHistory matchHistory = doMatchHistory(request.isHistoryFlag());
        GrsCtRegIdentifierTypes regIdTypeCode = null;
        if (request.getRegistryIdentifierTypeCodeId() != null) {
            regIdTypeCode = codesDao.lookup(GrsCtRegIdentifierTypes.class, request.getRegistryIdentifierTypeCodeId());
        } else if (request.getRegistryIdentifierTypeCode() != null) {
            regIdTypeCode = codesDao.lookup(GrsCtRegIdentifierTypes.class, request.getRegistryIdentifierTypeCode());
        }
        identifier = regIdTypeCode.getCtlNameCode() + "." + identifier;
        List<PrsProviders> providerResults = providerDao.searchByRegistryIdentifier(identifier, matchHistory);

        List<PrsProviders> providers = new ArrayList<>();
        if (providerResults != null) {
            providers.addAll(providerResults);
        } else {
            providers = Collections.emptyList();
        }
        SearchProviderResult searchResult = applyFilters(providers, false, false);
        searchLogger.logSearchForRegId(searchResult, regIdTypeCode.getCtlId(), identifier, matchHistory);
        return searchResult;
    }

    /**
     * Applies filters and builds a DTO containing search results and relevant
     * messages.
     *
     * @param prsProviders the list of Providers to filter
     * @param isFromMessage true, if request is from messages
     * @param findSurvivor true, if the request is from identifier search. For
     * registry identifier it will be false : reason being survivor record will
     * be already there in the query result list
     * @return the ca.bc.gov.health.plr.dto.provider.search.SearchProviderResult
     */
    private SearchProviderResult applyFilters(List<PrsProviders> prsProviders, boolean isFromMessage, boolean findSurvivor) {
        SearchProviderResult searchResult = new SearchProviderResult();

        filterOutDisallowedProviders(prsProviders, searchResult);

        List<ProviderDto> providerDetails = new ArrayList<>();
        for (PrsProviders provider : prsProviders) {
            ProviderDto details = providerDtoConverter.toProviderDetails(provider, !isFromMessage);
            details = details.copyAndRemoveNonUpdateableData(true);//remove audit data
            //Apply DPS - if from messages
            if (isFromMessage) {
                accessRestrictionService.applyProviderAccessRestrictions(details, provider.getHptCode(), true);
            } else {
                // Need to remove the confidentiality indicator records as the applyConfidential method
                // relies on the presence of conf. indicators as a test
                accessRestrictionService.populateReadRestrictionsConfidentiality(details, provider.getHptCode());
            }
            providerDtoConverter.buildPrimaryWorkLocation(details.getWorkLocationList());
            details = providerConfidentiality.applyConfidentiality(details);
            providerDetails.add(details);
        }
        Collections.sort(providerDetails, comparator);
        filterLogicallyDeletedAndAddSurvivors(searchResult, providerDetails, isFromMessage, findSurvivor);

        // Apply web DPS here after filtering for logical deletion
        if (!isFromMessage) {
            for (ProviderDto provDto : providerDetails) {
                accessRestrictionService.applyProviderAccessRestrictions(provDto, codesDao.lookup(PrsCtProviderRoleTypes.class, provDto.getType()), true);

            }
        }
        BusinessRuleResult validationResult = validateSearchResultSize.validateMaxSearchResults(providerDetails.size(), getMaxResultsToReturn());
        if (!validationResult.isValid()) {
            searchResult.addMessages(validationResult.getMessages());
            providerDetails = capSearchResult(providerDetails);
        }

        searchResult.setSearchResults(providerDetails);
        return searchResult;
    }

    private void filterOutDisallowedProviders(List<PrsProviders> prsProviders, SearchProviderResult searchResult) {
        Set<String> allowedProviderTypes = new HashSet<>();
        if (user.get().getUserEntity() != null) {
            allowedProviderTypes = authorizationService.getAllowedProviderTypes(user.get().getUserEntity());
        }
        boolean isFiltered = false;
        Iterator<PrsProviders> it = prsProviders.iterator();
        while (it.hasNext()) {
            if (!allowedProviderTypes.contains(it.next().getHptCode().getCtlNameCode())) {
                it.remove();
                isFiltered = true;
            }
        }
        if (isFiltered) {
            BusinessRuleKeys key = BusinessRuleKeys.INFO_PROVIDER_FILTERED_DPS;
            String message = BusinessRuleMessageDao.getMessageResource(key);
            searchResult.addMessage(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.INFO));
        }
    }

    /**
     * Query for organization providers.
     *
     * @param request
     * @return the ca.bc.gov.health.plr.dto.provider.search.SearchProviderResult
     */
    public SearchProviderResult searchForOrganization(SearchProviderRequest request) {
        // Long providerRoleTypeId, String orgName, String addressCity, boolean historyFlag
        MatchHistory matchHistory = doMatchHistory(request.isHistoryFlag());
        SearchProviderResult searchResult = new SearchProviderResult();

        String providerRoleTypeName = codesDao.lookup(PrsCtProviderRoleTypes.class, request.getProviderRoleTypeId()).getCtlNameCode();
        BusinessRuleResult validationResult = validateSearchProviderTypePermission.validate(providerRoleTypeName);
        searchResult.addMessages(validationResult.getMessages());

        validationResult = validateSearchAttributes.validateOrganizationWildcardUsage(request.getOrganizationProviderName(), request.getOrganizationProviderLongName(), request.getCity());
        searchResult.addMessages(validationResult.getMessages());

        if (!searchResult.getMessages().isEmpty()) {
            searchLogger.logSearchForOrganization(searchResult, request.getProviderRoleTypeId(), request.getOrganizationProviderName(), request.getOrganizationProviderLongName(), request.getCity(), matchHistory);
            return searchResult;
        }

        /*
         The query's ORDER BY clause includes non-PrsProviders fields, and so
         "SELECT DISTINCT" does not return distinct Providers, it returns distinct
         combinations of Providers and everything else in the ORDER BY clause.
         Put the Providers into a set to filter out duplicates, and use a
         LinkedHashSet to maintain the order. The query orders active names
         first, so non-active names will be filtered-out.
         */
        List<PrsProviders> providers = new ArrayList<>(new LinkedHashSet<>(providerDao.searchOrgByCriteria(request.getProviderRoleTypeId(), request.getOrganizationProviderName(), request.getOrganizationProviderLongName(), request.getCity(), matchHistory)));
        filterOutDisallowedProviders(providers, searchResult);
        List<ProviderDto> providerDetails = assembleSearchResults(providers, false);
        removeConfidential(providerDetails, searchResult);
        filterLogicallyDeletedRecords(providerDetails);

        // apply DPS after filtering for locially deleted
        for (ProviderDto s : providerDetails) {
            accessRestrictionService.applyProviderAccessRestrictions(s, codesDao.lookup(PrsCtProviderRoleTypes.class, s.getProviderRoleTypeCode()), true);
        }

        validationResult = validateSearchResultSize.validateMaxSearchResults(providerDetails.size(), getMaxResultsToReturn());
        if (!validationResult.isValid()) {
            searchResult.addMessages(validationResult.getMessages());
            providerDetails = providerDetails.subList(0, getMaxResultsToReturn());
        }

        searchResult.setSearchResults(providerDetails);
        searchLogger.logSearchForOrganization(searchResult, request.getProviderRoleTypeId(), request.getOrganizationProviderName(), request.getOrganizationProviderLongName(), request.getCity(), matchHistory);
        return searchResult;
    }

    public SearchProviderResult searchForPractitioner(SearchProviderRequest request) {
        Logger.getLogger(SearchProviderService.class.getName()).log(Level.INFO, request.toString());
        Long providerRoleTypeId = request.getProviderRoleTypeId();
        if (providerRoleTypeId == null && request.getProviderRoleTypeCode() != null && !request.getProviderRoleTypeCode().isEmpty()) {
            providerRoleTypeId = codesDao.lookup(PrsCtProviderRoleTypes.class, request.getProviderRoleTypeCode()).getCtlId();
        }
        MatchHistory matchHistory = doMatchHistory(request.isHistoryFlag());
        SearchProviderResult result = new SearchProviderResult();

        BusinessRuleResult validationResult = validateSearchAttributes.validateMandatoryCriteria(request);
        result.addMessages(validationResult.getMessages());

        validationResult = validateSearchAttributes.validateLocationExpertiseLanguageWildcardUsage(request.getFirstName(), request.getLastName(), request.getGender(), request.getCity());
        result.addMessages(validationResult.getMessages());
        validationResult = validateSearchAttributes.validateGender(request.getGender());
        result.addMessages(validationResult.getMessages());

        if (!result.getMessages().isEmpty()) {
            searchLogger.logSearchForPractitioner(result, providerRoleTypeId, request.getFirstName(), request.getLastName(), request.getCity(), matchHistory, request.getExpertiseList(), request.getLanguageList());
            return result;
        }

        List<PrsProviders> queryResults = providerDao.findIndividualByCriteria(
                providerRoleTypeId, request.getFirstName(), request.getLastName(), 
                request.getGender(), request.getCity(), 
                request.getLicenseStatusCd(), request.getLicenseStatusReasonCd(),
                request.getExpertiseList(), request.getLanguageList(), 
                configurationDao.getMaxResultsFromDatabase(), matchHistory);

        Logger.getLogger(SearchProviderService.class.getName()).log(Level.INFO, "found N providers: " + queryResults.size());
        filterOutDisallowedProviders(queryResults, result);
        List<ProviderDto> searchResult = assembleSearchResults(queryResults, request.isIsMessage());
        removeConfidential(searchResult, result);
        filterLogicallyDeletedRecords(searchResult);

        // apply DPS after filtering for locially deleted
        for (ProviderDto s : searchResult) {
            accessRestrictionService.applyProviderAccessRestrictions(s, codesDao.lookup(PrsCtProviderRoleTypes.class, s.getProviderRoleTypeCode()), true);
        }
        validationResult = validateSearchResultSize.validateMaxSearchResults(searchResult.size(), getMaxResultsToReturn());
        if (!validationResult.isValid()) {
            result.addMessages(validationResult.getMessages());
            searchResult = capSearchResult(searchResult);
        }
        Collections.sort(searchResult, new ProviderDtoLastFirstNameComparator());
        result.setSearchResults(searchResult);
        searchLogger.logSearchForLocationExpertiseLanaguage(result, providerRoleTypeId, request.getFirstName(), request.getLastName(), request.getGender(), request.getCity(), request.getExpertisesInString(), request.getLanguagesInString(), matchHistory);
        Logger.getLogger(SearchProviderService.class.getName()).log(Level.INFO, "N providers after filtering: " + searchResult.size());

        return result;
    }

    /**
     * Remove the search results in excess of the configured maximum.
     *
     * @param searchResult
     * @return
     */
    private List<ProviderDto> capSearchResult(List<ProviderDto> searchResult) {
        /*
         When the SearchProvider.xhtml page tried to execute the following EL:
        
         `searchProviderManager.searchResult.searchResults.size()`
        
         An error appeared in the server log:
        
         Severe: javax.el.ELException: /SearchProvider.xhtml @164,103 value="#{searchProviderManager.searchResult.searchResults.size()}": java.lang.IllegalAccessException: Class javax.el.BeanELResolver can not access a member of class java.util.ArrayList$SubList with modifiers "public"
        
         This occurred only when the search results exceeded the configured max.
         Note the reference to "SubList" in the error message.
         The error does not occur is we create a new list instead of using
         a view on the original, which is what subList returns.
         */
        searchResult = new ArrayList<>(searchResult.subList(0, getMaxResultsToReturn()));
        return searchResult;
    }

    private int getMaxResultsToReturn() {
        return configurationDao.getMaxSearchResults();
    }

    private List<ProviderDto> assembleSearchResults(List<PrsProviders> queryResults, boolean isFromMessage) {
        List<ProviderDto> searchResult = new ArrayList<>();
        for (PrsProviders provider : queryResults) {
            //if isFromMessage is true, construct all details. So negating the isFromMessage flag
            ProviderDto resultRecord = providerDtoConverter.toProviderDetails(provider, !isFromMessage);
            resultRecord.sortIndNamesAscending();
            resultRecord = resultRecord.copyAndRemoveNonUpdateableData(true);//remove audit data
            providerDtoConverter.buildPrimaryWorkLocation(resultRecord.getWorkLocationList());
            searchResult.add(resultRecord);
        }

        return searchResult;
    }

    private void removeConfidential(List<ProviderDto> searchResult, SearchProviderResult result) {
        // REQ-00781 - exclude all confidential results
        boolean confidentialFound = false;
        Iterator<ProviderDto> iterator = searchResult.iterator();
        while (iterator.hasNext()) {
            if (iterator.next().isConfidential()) {
                iterator.remove();
                confidentialFound = true;
            }
        }
        if (confidentialFound) {
            // REQ-00785 return warning message that confidential results are filtered.
            BusinessRuleKeys key = BusinessRuleKeys.WARNING_SEARCH_CONFIDENTIAL_FOUND;
            String message = BusinessRuleMessageDao.getMessageResource(key);
            result.addMessage(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.WARNING));
        }
    }

    /**
     * Deletes the logically deleted record from the search result
     *
     * @param result
     */
    private void filterLogicallyDeletedAndAddSurvivors(SearchProviderResult searchProviderResult,
            List<ProviderDto> result, boolean isFromMessage, boolean findSurvivor) {
        // REQ-00501 - Exlcude logically deleted records
        BusinessRuleKeys key = BusinessRuleKeys.SURVIVOR_RECORDS_FOUND;
        String message = BusinessRuleMessageDao.getMessageResource(key);
        if (result != null && !result.isEmpty()) {
            ListIterator<ProviderDto> iterator = result.listIterator();
            while (iterator.hasNext()) {
                ProviderDto providerDetails = iterator.next();
                if (checkIfLogicallyDeleted(providerDetails)) {
                    // If the provider is logically deleted remove the non-survivor and add survivor records                    
                    iterator.remove();
                    List<PrsProviders> survivors = providerDao.findSurvivorRecords(providerDetails);
                    if (!survivors.isEmpty()) {
                        searchProviderResult.addMessage(new BusinessRuleMessage(message, BusinessRuleMessage.Severity.INFO));
                        // Add the survivor record only if the flag is true. This will be true for identifier search
                        if (findSurvivor) {
                            for (PrsProviders survivor : survivors) {
                                if (!ifAlreadyIncluded(survivor, result)) {
                                    ProviderDto survivorDto = providerDtoConverter.toProviderDetails(survivor, !isFromMessage);
                                    if (!checkIfLogicallyDeleted(survivorDto)) {
                                        iterator.add(survivorDto);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Deletes the logically deleted record from the search result
     *
     * @param result
     */
    private void filterLogicallyDeletedRecords(List<ProviderDto> result) {
        // REQ-00501 - Exlcude logically deleted records
        if (result != null && !result.isEmpty()) {
            Iterator<ProviderDto> iterator = result.iterator();
            while (iterator.hasNext()) {
                ProviderDto providerDetails = iterator.next();
                if (checkIfLogicallyDeleted(providerDetails)) {
                    iterator.remove();
                }
            }
        }
    }

    /**
     * Method to check whether the provider is logically deleted
     *
     * @param resultRecord
     * @return
     */
    public boolean checkIfLogicallyDeleted(ProviderDto resultRecord) {
        // For a logically deleted record :
        // 1. All the college identifiers should be ceased
        // 2. All the person names should be ceased or All organization names should be ceased        
        for (CollegeIdentifierDto collegeIdentifierDto : resultRecord.getIdentifiers()) {
            if (collegeIdentifierDto.isUpdatable()) {
                return false;
            }
        }
        if (resultRecord.getProviderType().equals(ProviderType.PRACTITIONER)) {
            for (PersonNameDto personNameDto : resultRecord.getIndNames()) {
                if (personNameDto.isUpdatable()) {
                    return false;
                }
            }
        } else {
            for (OrgNameDto orgNameDto : resultRecord.getOrgNames()) {
                if (orgNameDto.isUpdatable()) {
                    return false;
                }
            }
        }
        Logger.getLogger(SearchProviderService.class.getName()).log(Level.INFO, "Removing logically deleted record.");
        return true;

    }

    /**
     *
     * @param dataAccessEventId - Primary Key of the data access event table
     * @param primaryChid
     */
    public void updatePrimaryChid(Long dataAccessEventId, String primaryChid) {
        searchLogger.updatePrimaryChid(dataAccessEventId, primaryChid);
    }

    private MatchHistory doMatchHistory(boolean historyFlag) {
        return historyFlag ? MatchHistory.YES : MatchHistory.NO;
    }

    /**
     * Returns true if the provider is already included in the existing search
     * result list.
     *
     * @param survivor
     * @param result
     * @return
     */
    private boolean ifAlreadyIncluded(PrsProviders survivor, List<ProviderDto> result) {
        for (ProviderDto dto : result) {
            if (dto.getPauthId().equals(survivor.getPauthId())) {
                return true;
            }
        }
        return false;
    }
    
    public List<PrsCtProviderRoleTypes> retrieveProviderRoleTypeSearchOrg() {
        List<PrsCtProviderRoleTypes> providersSearchOrg = new ArrayList<>();
        providersSearchOrg = codesDao.getProviderRoleTypeForSearchORG(user.get().getUserEntity());
        return providersSearchOrg;
    }
}
