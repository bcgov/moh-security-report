package ca.bc.gov.health.plr.service.remote;

import ca.bc.gov.health.plr.dto.MessageDataBlockDto;
import ca.bc.gov.health.plr.dto.MessageDataBlockDtoNullable;
import ca.bc.gov.health.plr.dto.OwnableDto;
import ca.bc.gov.health.plr.dto.esb.Acknowledgment;
import ca.bc.gov.health.plr.dto.esb.MaintainProviderRequest;
import ca.bc.gov.health.plr.dto.esb.MaintainProviderResponse;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDto;
import ca.bc.gov.health.plr.dto.provider.esb.AddressDto;
import ca.bc.gov.health.plr.ejb.entity.MessageDataBlock;
import ca.bc.gov.health.plr.ejb.entity.PrsCtDataOwnerCodes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.provider.AcceptableCodeName;
import ca.bc.gov.health.plr.service.ErrorMessage;
import ca.bc.gov.health.plr.service.provider.DuplicateRecordException;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.MessageCodeHelper;
import ca.bc.gov.health.plr.util.PropertyUtils;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import javax.ejb.Stateless;
import javax.inject.Inject;
import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import org.apache.commons.lang3.StringUtils;

/**
 * 1. Convert between ESB DTOs and PLR dtos.
 * 2. Do the constraint validation on the converted dtos.
 *
 * @author sumesh.kariyil
 * @param <A> - The ESB Dto type
 * @param <R> - The PLR Dto type
 */
@Stateless
public class MaintainProviderEsbProcessor<A, R> {

    private static final Validator VALIDATOR = Validation.buildDefaultValidatorFactory().getValidator();

    @Inject
    private FindMessageDataBlockService findMessageDataBlock;

    @Inject
    private CodesDao codesDao;

    /**
     *  converts and validates the dto for contraint violation and message data block field validation.
     * 
     * @param request    - list of ESB dtos
     * @param receivable - An empty object of the plr dto
     * @return - List of converted PLR dtos
     * @throws EntityValidationException - If any constraint violation is found
     */
    public R convertAndValidate(A request, R receivable) throws EntityValidationException {
        if (request == null) {
            return null;
        }        
        LocalDtoConverter<R, A> converter = new LocalDtoConverter<>();
        receivable = converter.convert(receivable, request);
        validate(receivable);
        if(receivable instanceof MessageDataBlockDto){
            validateMessageDataBlockFields(receivable);
        }
        return receivable;
    }
    
    /**
     * Validation method 
     *
     * @param receivable
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     */
    public void validate(R receivable) throws EntityValidationException {
        List<ErrorMessage> errorMessages = new ArrayList<>();
        Set<ConstraintViolation<R>> violations = VALIDATOR.validate(receivable);
        if (!violations.isEmpty()) {
            String[] codeAndMessage;
            for (ConstraintViolation<R> violation : violations) {
                // TODO: Set error code. Currently Bean Validation exceptions do not have error codes.
                codeAndMessage = MessageCodeHelper.splitCodeAndMessage(violation.getMessage());
                errorMessages.add(new ErrorMessage(codeAndMessage[0], codeAndMessage[1]));
            }
        }
        if (!errorMessages.isEmpty()) {
            throw new EntityValidationException(errorMessages);
        }
    }

    /**
     * Process the list which is child of provider
     *
     * @param request - List of ESB dtos
     * @param receivableType A type for PLR dto to be used to copy values
     * @param entity - class type of the targetted entity. For e.g,
     * GrsAddresses.class for Address
     * @param providerDto
     * @param idFieldName - the primary id field of the entity. Could be done
     * using reflection, but it has got performance overhead
     * @param response
     * @return 
     */
    public List<R> convertAndValidateProviderChildren(List<A> request, Class<R> receivableType, Class<? extends MessageDataBlock> entity, ProviderDto providerDto,
            String idFieldName, MaintainProviderResponse response) {
        List<R> list = new ArrayList<>();
        for (A a : request) {
            
            try {
                R receivable = receivableType.newInstance();
                receivable = MaintainProviderEsbProcessor.this.convertAndValidate(a, receivable);
                list.add(setIdsAndDataOwnerCodeOnProviderChild(receivable, entity, providerDto, idFieldName));
            } catch (Exception ex) {
                ExceptionHandler.handleException(response, ex);
            }
        }

        return list;
    }

    /**
     * Process the list which is child of work location
     *
     * @param request - List of ESB dtos
     * @param receivableType - a type of PLR dto - to copy the values
     * @param entity - class type of the targetted entity. For e.g,
     * GrsAddresses.class for Address
     * @param workLocation
     * @param providerDto
     * @param idFieldName - the primary id field of the entity. Could be done
     * using reflection, but it has got performance overhead
     * @param response
     * @return
     */
    public List<R> convertAndValidateWorkLocationChildren(List<A> request, Class<R> receivableType, Class<? extends MessageDataBlock> entity, PrsWorkLocations workLocation, ProviderDto providerDto,
            String idFieldName, MaintainProviderResponse response) {
        if (request == null) {
            return null;
        }

        List<R> list = new ArrayList<>();
        for (A a : request) {
            try {
                R receivable = receivableType.newInstance();
                receivable = MaintainProviderEsbProcessor.this.convertAndValidate(a, receivable);
                list.add(setIdsAndDataOwnerCodeOnWorkLocationChild(receivable, entity, workLocation, providerDto, idFieldName));
            } catch (Exception ex) {
                ExceptionHandler.handleException(response, ex);
            }
        }

        return list;
    }

    /**
     * Process the dto which is child of provider
     *
     * @param receivable
     * @param entity
     * @param providerDto
     * @param idFieldName
     * @return 
     * @throws EntityValidationException
     * @throws DuplicateRecordException
     * @throws BusinessRuleException
     */
    public R setIdsAndDataOwnerCodeOnProviderChild(R receivable, Class<? extends MessageDataBlock> entity, ProviderDto providerDto,
            String idFieldName) throws EntityValidationException, DuplicateRecordException, BusinessRuleException {
        PropertyUtils.invokeSetter(receivable, "pauthId", providerDto.getPauthId());
        PrsCtProviderRoleTypes hptCode = codesDao.lookup(PrsCtProviderRoleTypes.class, providerDto.getTypeId());
        return setIdAndOwnerCodeIfUpdatingExisting(receivable, entity, hptCode, idFieldName, providerDto, null);
    }

    /**
     * Process the dto which is child of work location
     *
     * @param receivable
     * @param entity
     * @param workLocation
     * @param providerDto
     * @param idFieldName
     * @return 
     * @throws EntityValidationException
     * @throws DuplicateRecordException
     * @throws BusinessRuleException
     */
    public R setIdsAndDataOwnerCodeOnWorkLocationChild(R receivable, Class<? extends MessageDataBlock> entity, PrsWorkLocations workLocation, ProviderDto providerDto,
            String idFieldName) throws EntityValidationException, DuplicateRecordException, BusinessRuleException {
        if (workLocation != null && workLocation.getWlId() != null) {
            PropertyUtils.invokeSetter(receivable, "wlWlId", workLocation.getWlId());
        }
        
        PrsCtProviderRoleTypes hptCode = providerDto != null ? codesDao.lookup(PrsCtProviderRoleTypes.class, providerDto.getTypeId()) : (workLocation != null ? workLocation.getPauthPauthId().getHptCode() : null);
        return setIdAndOwnerCodeIfUpdatingExisting(receivable, entity, hptCode, idFieldName, null, workLocation != null ? workLocation.getWlId() : null);
    }

    private R setIdAndOwnerCodeIfUpdatingExisting(R receivable, Class<? extends MessageDataBlock> entity, PrsCtProviderRoleTypes hpt,
            String idFieldName, ProviderDto providerDto, Long wlId) throws EntityValidationException, DuplicateRecordException, BusinessRuleException {
        if (!(receivable instanceof OwnableDto)) {
            return receivable;
        }
        //Check if any existing record is there for the provided values
        MessageDataBlock existingEntity = null;

        // Check for existing block only if we are attempting to update
        // if no pauthid and no wlId, this must be a new work location
        if ((providerDto != null && providerDto.getPauthId() != null) || wlId != null) {
            existingEntity = findMessageDataBlock.find(providerDto != null ? providerDto.getPauthId() : null, wlId, (MessageDataBlockDto) receivable, entity, hpt);
        }

        OwnableDto dto = (OwnableDto) receivable;
        checkEndReasonCode(dto, existingEntity);
        if (existingEntity != null) {
            dto.setId((Long) PropertyUtils.invokeGetter(existingEntity, idFieldName));
            PrsCtDataOwnerCodes existingDataOwner = (PrsCtDataOwnerCodes) PropertyUtils.invokeGetter(existingEntity, "dataOwnerCode");
            if (existingDataOwner != null) {
                dto.setDataOwnerCode(existingDataOwner.getCtlNameCode());
            }
        } else {
            dto.setId(null);
            dto.setDataOwnerCode(null);
        }
        return receivable;
    }

    /**
     * This method checks if any existing record is found, and no end reason
     * code is provided in the message.
     *
     * @param <T> - Entity type
     * @param dto - the instance of plr dto
     * @param foundEntity - the existing entity if found
     * @param idFieldName - The primary key field name in entity
     *
     * @throws EntityValidationException - if no end reason code is provided and
     * an existing record is found
     */
     <T> void checkEndReasonCode(ca.bc.gov.health.plr.dto.DtoCommon dto, T foundEntity) throws DuplicateRecordException {
        if (foundEntity != null) {
            if (StringUtils.isBlank(dto.getEndReasonCode())) {
                String messageResource = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_DUPLICATE_DATA_BLOCK);
                throw new DuplicateRecordException(messageResource + PropertyUtils.invokeGetter(foundEntity, "fieldName"));                
            }            
        }
    }

     /**
      * Validates for null values message data block fields
      * 
      * @param receivable
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
      */
    public void validateMessageDataBlockFields(R receivable) throws EntityValidationException {
        List<ErrorMessage> errorMessages = new ArrayList<>();
        String errorMessage = BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_CODE_INVALID);
        String[] codeAndMessage = MessageCodeHelper.splitCodeAndMessage(errorMessage);
        // Validate if the message data block fields are null
        if(receivable instanceof MessageDataBlockDto){
            MessageDataBlockDto dto = (MessageDataBlockDto)receivable;
            String [] nullableFields = null;
            if(receivable instanceof MessageDataBlockDtoNullable) {
                nullableFields = ((MessageDataBlockDtoNullable)receivable).getMessageDataBlockFieldsNullable();
            }
            for(String dataBlockField : dto.getMessageDataBlockFields()){
                //if the field can be null, there is no need to check it
                if(nullableFields!=null && Arrays.asList(nullableFields).contains(dataBlockField)) {
                    continue;
                }
                Object obj = PropertyUtils.invokeGetter(receivable, dataBlockField);
                if(obj == null || StringUtils.isEmpty(obj.toString())){
                    try {
                        Field field = receivable.getClass().getDeclaredField(dataBlockField);
                        String fieldName;
                        // Get the Code table Join column annotation
                        if(field.isAnnotationPresent(AcceptableCodeName.class)){
                            AcceptableCodeName codeName = field.getAnnotation(AcceptableCodeName.class);
                            fieldName = codeName.code();
                        } else {
                            fieldName = dataBlockField;
                        }
                        errorMessages.add(new ErrorMessage(codeAndMessage[0], codeAndMessage[1] + " " + fieldName));
                    } catch (NoSuchFieldException nse) {
                        errorMessages.add(new ErrorMessage(codeAndMessage[0], codeAndMessage[1] + " " + dataBlockField));
                    } catch ( SecurityException ex ) {
                        throw new IllegalStateException(ex.getMessage());
                    }
                }
            }
            if (!errorMessages.isEmpty()) {
                throw new EntityValidationException(errorMessages);
            }
        }
    }

    /**
     * Validate that there isn't an address line four -- only for messages, not web.
     * @param request message request
     * @param response message response
     */
    public void validateAddressLineFour(MaintainProviderRequest request, MaintainProviderResponse response) {
        this.validateAddressLineFour(request.getProviderDetails().getAddresses() ,response);
    }
    
    /**
     * Validate that there isn't an address line four -- only for messages, not web.
     * @param addressDtoList the list of esb address dto
     * @param response message response
     */
    public void validateAddressLineFour(List<AddressDto> addressDtoList, MaintainProviderResponse response) {
        if(addressDtoList!=null) {
            for (AddressDto addrDto : addressDtoList) {
                if (addrDto.getAddressLineFour() != null && !addrDto.getAddressLineFour().isEmpty()) {
                    String[] msg = MessageCodeHelper.splitCodeAndMessage(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_ADDRESS_LINE4));
                    response.addAcknowledgment(new Acknowledgment(msg[0], msg[1]));
                }
            }
        }
    }

}
