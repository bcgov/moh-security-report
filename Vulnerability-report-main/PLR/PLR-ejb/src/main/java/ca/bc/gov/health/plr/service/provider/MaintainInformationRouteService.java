package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.converter.InformationRouteDtoConverter;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.InformationRouteDto;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsInformationRoutes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.rule.provider.AccessRestrictionService;
import ca.bc.gov.health.plr.service.EntityValidatorService;
import ca.bc.gov.health.plr.service.validators.ConfidentialityValidator;
import ca.bc.gov.health.plr.service.validators.EntityChangeDetector;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

/**
 *
 * @author ian.scott
 */
@Stateless
@LocalBean
public class MaintainInformationRouteService implements MaintainService<InformationRouteDto>{

    @PersistenceContext(unitName = "PLR-ejbPU")
    private EntityManager em;
    @EJB
    private InformationRouteDtoConverter informationRouteDtoConverter;
    @EJB
    private JournalService<PrsInformationRoutes> journalService;
    
    @EJB
    private EntityValidatorService<PrsInformationRoutes> validatorService;

    @EJB
    private ConfidentialityValidator<PrsInformationRoutes> confidentialityValidator;
    
    @EJB
    protected CodesDao codesDao;

    @EJB
    private AccessRestrictionService accessRestrictionService;
    
    @EJB
    private ProviderDtoConverter providerDtoConverter;
    
    @EJB
    private EntityChangeDetector<InformationRouteDto, PrsInformationRoutes> entityChangeDetector;

    /**
     * Persists an InformationRoute to the database
     *
     * @param infoRoute the information Route
     * @throws ca.bc.gov.health.plr.service.provider.DuplicateRecordException
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException
     */
    @Override
    public InformationRouteDto save(InformationRouteDto infoRoute) throws DuplicateRecordException, EntityValidationException {
        PrsInformationRoutes newEntity = informationRouteDtoConverter.toEntity(infoRoute);
        entityChangeDetector.checkForChanges(infoRoute, newEntity);
        if (infoRoute.isNoChangeOnUpdate()) {
            return infoRoute;
        }
        validatorService.validate(newEntity, confidentialityValidator);
        newEntity = journalService.journal(newEntity);
        
        return providerDtoConverter.buildInformationRoute(newEntity);
    }
    

    /**
     * Query a fresh complete list of Routes related to a specific provider.
     * Note this method does not return Routes details for work locations.
     *
     * @param infoRoute the Information Route to getInformationRoutes from
     * @return a list of fresh transfer objects
     */
    public List<InformationRouteDto> getInformationRoutes(InformationRouteDto infoRoute) {
        if ((infoRoute.getPauthId() != null && infoRoute.getWlWlId() != null)
                || (infoRoute.getPauthId() == null && infoRoute.getWlWlId() == null)) {
            throw new UnsupportedOperationException("One of providerDetails or workLocation must be set, but not both.");
        }
        List<InformationRouteDto> dtos = null;
        PrsCtProviderRoleTypes hptCode = null;
        if (infoRoute.getWlWlId() != null) {
            PrsWorkLocations workLocation = em.find(PrsWorkLocations.class, infoRoute.getWlWlId());
            hptCode = workLocation.getPauthPauthId().getHptCode();
            List<PrsInformationRoutes> foundInfoR = workLocation.getPrsInformationRoutesList();
            dtos = providerDtoConverter.buildInformationRoutes(foundInfoR, false);
            accessRestrictionService.applyWlReadRestriction(dtos, hptCode, PrsInformationRoutes.class);
        } else if (infoRoute.getPauthId() != null) {
            PrsProviders provider = em.find(PrsProviders.class, infoRoute.getPauthId());
            hptCode = provider.getHptCode();
            List<PrsInformationRoutes> foundInfoR = provider.getPrsInformationRoutesList();
            dtos = providerDtoConverter.buildInformationRoutes(foundInfoR, true);
            accessRestrictionService.applyReadRestriction(dtos, hptCode, PrsInformationRoutes.class);
        }
        
        return dtos;
    }
}
