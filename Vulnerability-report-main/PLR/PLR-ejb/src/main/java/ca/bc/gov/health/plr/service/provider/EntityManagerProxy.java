package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.ejb.entity.GrsAccessProfiles;
import ca.bc.gov.health.plr.ejb.entity.GrsCtTransactionTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsDistribEvent;
import ca.bc.gov.health.plr.ejb.entity.GrsIdentifiers;
import ca.bc.gov.health.plr.ejb.entity.GrsOrgNames;
import ca.bc.gov.health.plr.ejb.entity.GrsPersonNames;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.ejb.entity.util.EntityUtils;
import ca.bc.gov.health.plr.persistence.CodesDao;
import java.util.ArrayList;
import java.util.List;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TransactionRequiredException;
import javax.persistence.TypedQuery;
import org.apache.poi.ss.formula.functions.T;

/**
 * A test proxy for wrapping the entity manager. This provides unit tests with a
 * way of setting up and removing entities without adding such functions to the
 * service interface. Note: this is not to be used outside of testing.
 *
 * @author Grant.Hodgins
 */
@Stateless
public class EntityManagerProxy {

    @PersistenceContext(unitName = "PLR-ejbPU")
    protected EntityManager em;
    
    @EJB
    private CodesDao codesDao;
    
    /**
     * Flush ....
     */
    public void flush() {
        em.flush();
    }
    
    /**
     * Stores an entity in the DB
     * 
     * @param entity 
     */
    public void create(Object entity) {
        em.persist(entity);
    }

    /**
     * Wraps javax.persistence.EntityManager. Remove the entity instance.
     *
     * @param entity the entity to remove (delete) from the database.
     * @throws IllegalStateException if this EntityManager has been closed.
     * @throws IllegalArgumentException if not an entity or if a detached entity
     * @throws TransactionRequiredException if invoked on a container-managed
     * entity manager of type PersistenceContextType.TRANSACTION and there is no
     * transaction.
     * @see javax.persistence.EntityManager
     */
    public void remove(Object entity) {
        em.flush();
        entity = em.merge(entity);
        em.remove(entity);
    }

    /**
     * Wraps javax.persistence.EntityManager. Find by named query.
     *
     * @param entityClass the entity class type to retrieve
     * @param primaryKey the unique primary key identifier
     * @return the found entity instance or null if the entity does not exist
     * @throws IllegalStateException if this EntityManager has been closed.
     * @throws IllegalArgumentException if the first argument does not denote an
     * entity type or the second argument is not a valid type for that entity's
     * primary key
     * @see javax.persistence.EntityManager
     */
    public <T> T find(Class<T> entityClass, Object primaryKey) {
        return em.find(entityClass, primaryKey);
    }

    /**
     * Executes a named query
     *
     * @param <T> type
     * @param namedQuery query to execute
     * @return the results list
     */
    public <T> List<T> namedQuery(String namedQuery) {
        return  em.createNamedQuery(namedQuery).getResultList();
    }
        /**
     * Executes a named query
     *
     * @param <T> type
     * @param namedQuery query to execute
     * @return the results list
     */
    public List<PrsProviders> findProvidersWithNameAndCity(String namedQuery, String p1, String p2) {
        return em.createNamedQuery(namedQuery, PrsProviders.class).setParameter("orgName", p1).setParameter("cityTxt", p2).getResultList();
    }
 
    /**
     * Create a named query
     * @param name
     * @return 
     */
    public <T> List<T> namedQuery(String name, Long param) {
        return em.createNamedQuery(name).setParameter(1, param).getResultList();
    }
    
    /**
     * Executes a query.
     * @param <T> type
     * @param query query to execute
     * @return the results list
     */
    public <T> List<T> query(String query) {
        return em.createQuery(query).getResultList();   
    }
    
    public Object nativeUpdate(String query) {
        return em.createNativeQuery(query).executeUpdate();   
    }
    
    /**
     * Executes a query.
     * @param query query to execute
     */
    public void executeUpdateQuery(String query) {
        em.createQuery(query).executeUpdate();   
    }

    /**
     * Executes a named query with parameters
     *
     * @param <T> type
     * @param namedQuery query with numbered parameters
     * @param parameters parameters
     * @return list of entities found
     */
    public <T> List<T> namedQuery(String namedQuery, String[] parameters) {
        Query q = em.createNamedQuery(namedQuery);
        int position = 1;
        for (String param : parameters) {
            q.setParameter(position, param);
            position++;
        }
        return q.getResultList();
    }

    public List<Long> findAllProviderIds() {
        String queryString = "select p.pauthId from PrsProviders p";
        TypedQuery<Long> query = em.createQuery(queryString, Long.class);

        return query.getResultList();
    }
    
    public List<PrsProviders> findAllActiveProviders() {
        TypedQuery<PrsProviders> query = em.createNamedQuery("PrsProviders.findAllByActive", PrsProviders.class).setParameter("active", EntityUtils.toGrsCtBooleanType(true, codesDao));

        return query.getResultList();
    }
    
    public <T> T merge(T entity) {
        return em.merge(entity);
    }
    
    public <T> void refresh(T entity) {
        em.refresh(entity);
    }
    
    public <T> void detach(T entity) {
        em.detach(entity);
    }
    
    public List<PrsProviders> findProvidersByID(String id) {
        List<GrsIdentifiers> ids = em.createNamedQuery("GrsIdentifiers.findByProviderChid").setParameter("providerChid", id).getResultList();
        List<PrsProviders> providers = new ArrayList<>();
        for(GrsIdentifiers pID : ids) {
            providers.add(pID.getPauthPauthId());
        }
        return providers;
    }
    public List<PrsProviders> findProvidersByLastName(String lastName) {
        List<GrsPersonNames> names = em.createNamedQuery("GrsPersonNames.findByFirstName").setParameter("lastName", lastName).getResultList();
        List<PrsProviders> providers = new ArrayList<>();
        for(GrsPersonNames pName : names) {
            providers.add(pName.getPauthPauthId());
        }
        return providers;
     }
    
    public List<PrsProviders> findProvidersByOrgShortName(String shortName) {
        List<GrsOrgNames> names = em.createNamedQuery("GrsOrgNames.findByShortName").setParameter("shortName", shortName).getResultList();
        List<PrsProviders> providers = new ArrayList<>();
        for(GrsOrgNames oName : names) {
            providers.add(oName.getPauthPauthId());
        }
        return providers;
    }
    public List<GrsDistribEvent> findDistributionEvent(GrsCtTransactionTypes grsCtTransactionType) {
        return em.createNamedQuery("GrsDistribEvent.findByTx").setParameter("txType", grsCtTransactionType).getResultList();
    }
    
    public List<GrsAccessProfiles> findAccessProfiles(GrsRegistryUsers regUser, PrsProviders provider, String dataOwner) {
        return em.createNamedQuery("GrsAccessProfiles.findByCriteria")
                .setParameter("regUser", regUser)
                .setParameter("providerType", provider.getHptCode().getCtlNameCode())
                .setParameter("providerCat", provider.getCategoryCode())
                .setParameter("dataOwner", dataOwner)
                .setParameter("active", EntityUtils.toGrsCtBooleanType(true, codesDao)).getResultList();
    }
}
