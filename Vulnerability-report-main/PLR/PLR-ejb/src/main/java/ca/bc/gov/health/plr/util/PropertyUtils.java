/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.util;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.beanutils.BeanUtils;
import org.apache.commons.beanutils.NestedNullException;

/**
 *
 * @author adebiyi.kuseju
 */
public class PropertyUtils {
    
    private static final Logger logger = Logger.getLogger(PropertyUtils.class.getName());
    
    /**
     * Uses reflection to invoke a "setter" method
     *
     * @param entity Object to call the setter on
     * @param fieldName Name of the field to set
     * @param value value to set
     * @throws Exception
     */
    public static void invokeSetter(Object entity, String fieldName, Object value) {
        try {        
            BeanUtils.setProperty(entity, fieldName, value);
        } catch (IllegalAccessException | InvocationTargetException ex) {
            log(fieldName, entity.getClass().getName());
        }
        
    }

    /**
     * Uses reflection to invoke a "getter" method
     *
     * @param entity Object to call the getter on
     * @param fieldName Name of the field to get
     * @return value of the filed
     * @throws Exception
     */
    public static Object invokeGetter(Object entity, String fieldName) {
        Object obj = null;
        try {
            obj = org.apache.commons.beanutils.PropertyUtils.getProperty(entity, fieldName);
        } catch(NestedNullException nne) {
            return null;
        } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException ex) {
            log(fieldName, entity.getClass().getName());
        }
        
        return obj;
    }
    
    public static boolean doesPropertyExist(Object entity, String property) {
        try {
            org.apache.commons.beanutils.PropertyUtils.getProperty(entity, property);
        } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException ex) {
            return false;
        }

        return true;
    }
    
    public static boolean isEmpty(Object provDetailsAfterChange) throws IllegalArgumentException, IllegalAccessException {
        
        boolean empty = true;
        Field[] fields = provDetailsAfterChange.getClass().getDeclaredFields();
        boolean isAccessible = false;
        for (Field f : fields) {
            try {
                isAccessible = f.isAccessible();
                f.setAccessible(true);
                if (List.class.isAssignableFrom(f.getType()) && !((List) f.get(provDetailsAfterChange)).isEmpty()) {
                    empty = false;
                    break;
                }
                
            } finally {
                f.setAccessible(isAccessible);
            }
        }
        return empty;
    }
    
    private static void log(String fieldName, String className) {
        logger.log(Level.FINE, String.format("%s does not exist on instance of %s", fieldName, className));
    }
    
    public static int compareString(String x, String y) {
        if(x!=null) {
            if(y!=null) {
                return x.compareTo(y);
            } else {
                return 1;
            }
        } else {
            if(y!=null) {
                return -1;
            } else {
                return 0;
            }
        }
    }
    
    public static int compareLong(Long x, Long y) {
        if(x!=null) {
            if(y!=null) {
                return x.compareTo(y);
            } else {
                return 1;
            }
        } else {
            if(y!=null) {
                return -1;
            } else {
                return 0;
            }
        }
    }
    
}
