/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.rule.provider;

import ca.bc.gov.health.plr.ejb.entity.PrsCtCountries;
import ca.bc.gov.health.plr.ejb.entity.PrsCtJurisdictions;
import ca.bc.gov.health.plr.ejb.entity.PrsCtStatusClassCodes;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.service.provider.IntegrationSetup;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.codesDao;
import javax.validation.ConstraintValidatorContext;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 *
 * @author jonathan.wiebe
 */
public class AcceptableCodeIdValidatorTest extends IntegrationSetup {

    private ConstraintValidatorContext mockContext;
    private ConstraintValidatorContext.ConstraintViolationBuilder mockConstraintViolationBuilder;

    /**
     * Override pesky DAO problem where it can't find EJB without IntegrationSetup
     */
    private final AcceptableCodeIdValidator codeValidator = new AcceptableCodeIdValidator() {
        @Override
        CodesDao getCodesDao() {
            return codesDao;
        }
    };

    private AcceptableCodeId mockAcceptableCode;

    @Before
    public void setUp() {
        mockContext = mock(ConstraintValidatorContext.class);
        mockConstraintViolationBuilder = mock(ConstraintValidatorContext.ConstraintViolationBuilder.class);
        when(mockContext.buildConstraintViolationWithTemplate(Mockito.anyString())).thenReturn(mockConstraintViolationBuilder);

    }

    @Test
    public void testValidJurisdiction() {
        Class<?> classes = PrsCtJurisdictions.class;
        mockUpAnnotationAttributes(classes);

        assertTrue(codeValidator.isValid(1272l, mockContext));
        verify(mockConstraintViolationBuilder, times(0)).addConstraintViolation();
    }

    @Test
    public void testInValidJurisdiction() {
        Class<?> classes = PrsCtJurisdictions.class;
        mockUpAnnotationAttributes(classes);

        assertFalse(codeValidator.isValid(2l, mockContext));
        verify(mockConstraintViolationBuilder, times(1)).addConstraintViolation();
    }

    @Test
    public void testValidCountry() {
        Class<?> classes = PrsCtCountries.class;
        mockUpAnnotationAttributes(classes);

        assertTrue(codeValidator.isValid(2634l, mockContext));
        verify(mockConstraintViolationBuilder, times(0)).addConstraintViolation();
    }

    @Test
    public void testInValidCountry() {
        Class<?> classes = PrsCtCountries.class;
        mockUpAnnotationAttributes(classes);

        assertFalse(codeValidator.isValid(4l, mockContext));
        verify(mockConstraintViolationBuilder, times(1)).addConstraintViolation();
    }

    @Test
    public void testValidStatusClass() {
        Class<?> classes = PrsCtStatusClassCodes.class;
        mockUpAnnotationAttributes(classes);

        assertTrue(codeValidator.isValid(4304l, mockContext));
        verify(mockConstraintViolationBuilder, times(0)).addConstraintViolation();
    }

    @Test
    public void testInValidStatusClass() {
        Class<?> classes = PrsCtStatusClassCodes.class;
        mockUpAnnotationAttributes(classes);

        assertFalse(codeValidator.isValid(6l, mockContext));
        verify(mockConstraintViolationBuilder, times(1)).addConstraintViolation();
    }

    @Test
    public void testNullAllowed() {
        Class<?> classes = PrsCtStatusClassCodes.class;
        mockUpAnnotationAttributes(classes);

        assertTrue(codeValidator.isValid(null, mockContext));
        verify(mockConstraintViolationBuilder, times(0)).addConstraintViolation();
    }

    private void mockUpAnnotationAttributes(Class classes) {
        mockAcceptableCode = mock(AcceptableCodeId.class);
        when(mockAcceptableCode.clazz()).thenReturn(classes);
        when(mockAcceptableCode.message()).thenReturn(BusinessRuleKeys.ERROR_CODE_INVALID.getKey());
        when(mockAcceptableCode.code()).thenReturn("any string");
        codeValidator.initialize(mockAcceptableCode);
    }

//    GP - Commented out as the lookup no longer fails. Not sure if still a relevant test
//    @Test
//    public void testAnnotation() {
//        MockDto someFieldDto = new MockDto();
//        someFieldDto.somefield = 2892l;
//
//        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
//        Validator validator = factory.getValidator();
//        Set<ConstraintViolation<MockDto>> violations = validator.validate(someFieldDto);
//
//        // the DAOs are not found by lookup ... so this test always has
//        // one violation, there should be one for bad code not for DAO lookup issue
//        assertEquals(1, violations.size());
//    }

    private class MockDto {

        @AcceptableCodeId(clazz = PrsCtStatusClassCodes.class,
                code = "Status Class")
        public Long somefield;
    }
}
