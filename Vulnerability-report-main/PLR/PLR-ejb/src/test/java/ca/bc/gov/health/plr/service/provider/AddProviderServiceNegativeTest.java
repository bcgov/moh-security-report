package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.provider.CredentialsDto;
import ca.bc.gov.health.plr.dto.provider.ExpertiseDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.ejb.entity.GrsCtRegIdentifierTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryIdentifiers;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.PrsCtAddressTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtCommunPurposeTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtCountries;
import ca.bc.gov.health.plr.ejb.entity.PrsCtElectronicAddrTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtGenderCodes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtIdentifierTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProvCredentialTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProvExpertiseTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProvState;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtStatusClassCodes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtStatusCodes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtStatusReasonCodes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import ca.bc.gov.health.plr.rule.BusinessRuleResult;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.maintainProviderService;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.codesDao;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.DateUtils;
import ca.bc.gov.health.plr.util.SpoofedUserHelper;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import javax.naming.NamingException;
import org.junit.AfterClass;
import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 *
 * @author David Sharpe <david.a.sharpe@cgi.com>
 */
public class AddProviderServiceNegativeTest extends IntegrationSetup {

    private static final List<PrsProviders> providersToDelete = new ArrayList<>();
    private static PrsCtIdentifierTypes identifierType;
    private static PrsCtProviderRoleTypes nurse;
    private static PrsCtStatusClassCodes assignedEntity;
    private static PrsCtStatusCodes statusCode;
    private static PrsCtStatusReasonCodes statusReasonCode;
    private static final Date date = new Date();
    private static PrsCtCommunPurposeTypes addressPurpose;
    private static PrsCtAddressTypes addressType;
    private static PrsCtElectronicAddrTypes eAddressType;
    private static PrsCtCountries countryAddress;
    private static PrsCtProvCredentialTypes bachelorDegree;
    private static PrsCtProvExpertiseTypes acupuncture;
    private static PrsCtGenderCodes genderCode;
    private static PrsCtProvState provinceCredential;
    private static GrsCtRegIdentifierTypes cpnType;
    private static GrsCtRegIdentifierTypes ipcType;
    private static PrsCtProviderRoleTypes dentist;
    private static PrsCtStatusClassCodes licensure;
    private static PrsCtIdentifierTypes dentistId;
    private static PrsCtGenderCodes gender;

    @BeforeClass
    public static void setUpClass() throws NamingException {

        identifierType = codesDao.lookup(PrsCtIdentifierTypes.class, "RNID");
        nurse = codesDao.lookup(PrsCtProviderRoleTypes.class, "RN");
        assignedEntity = codesDao.lookup(PrsCtStatusClassCodes.class, CodeTableCodes.PrsCtStatusClassCodes.ASSIGNED_ENTITY);
        statusCode = codesDao.lookup(PrsCtStatusCodes.class, CodeTableCodes.PrsCtStatusCodes.ACTIVE);
        statusReasonCode = codesDao.lookup(PrsCtStatusReasonCodes.class, CodeTableCodes.PrsCtStatusReasonCodes.GOOD_STANDING);
        addressPurpose = codesDao.lookup(PrsCtCommunPurposeTypes.class, CodeTableCodes.PrsCtCommunPurposeTypes.BUSINESS_CONTACT);
        addressType = codesDao.lookup(PrsCtAddressTypes.class, CodeTableCodes.PrsCtAddressTypes.MAILING_ADDRESS);
        eAddressType = codesDao.lookup(PrsCtElectronicAddrTypes.class, CodeTableCodes.PrsCtElectronicAddrTypes.FTP);
        countryAddress = codesDao.lookup(PrsCtCountries.class, "AF");
        bachelorDegree = codesDao.lookup(PrsCtProvCredentialTypes.class, "BD");
        acupuncture = codesDao.lookup(PrsCtProvExpertiseTypes.class, "AMD1");
        genderCode = codesDao.lookup(PrsCtGenderCodes.class, "F");
        provinceCredential = codesDao.lookup(PrsCtProvState.class, "ABE");

        cpnType = codesDao.lookup(GrsCtRegIdentifierTypes.class, CodeTableCodes.GrsCtRegIdentifierTypes.COMMON_PROVIDER_NUMBER);
        ipcType = codesDao.lookup(GrsCtRegIdentifierTypes.class, CodeTableCodes.GrsCtRegIdentifierTypes.INTERNAL_PROVIDER_ID);

        dentist = codesDao.lookup(PrsCtProviderRoleTypes.class, "DEN");
        licensure = codesDao.lookup(PrsCtStatusClassCodes.class, CodeTableCodes.PrsCtStatusClassCodes.LICENSURE);
        dentistId = codesDao.lookup(PrsCtIdentifierTypes.class, "DENID");

        gender = codesDao.lookup(PrsCtGenderCodes.class, "F");
    }

    @AfterClass
    public static void tearDownClass() {
        ArrayList<Exception> exceptions = new ArrayList<>();
        providersToDelete.removeAll(Collections.singleton(null));
        for (PrsProviders prsProviders : providersToDelete) {
            try {
                entityManagerProxy.remove(prsProviders);
            } catch (Exception e) {
                e.printStackTrace();
                exceptions.add(e);
            }
        }
        if (!exceptions.isEmpty()) {
            throw new IllegalStateException("Exceptions occurred while deleting entities. Check log for details.");
        }
    }
    @Before
    public void setUpRegUser(){
        SpoofedUserHelper.currentUser="plr-reg-admin";
    }
    /**
     * Test that AddProviderService persists a provider when only the mandatory
     * attributes are provided.
     *
     * @throws ca.bc.gov.health.plr.rule.BusinessRuleException
     */
    
    @Test(expected = EntityValidationException.class)
    public void testSave_disallowedIdentifierType_noPermissionsOnRole() throws BusinessRuleException, EntityValidationException, DuplicateRecordException {
        // A REGISTERED_NURSE, identifier type REGISTERED_NURSE_ID_NUMBER:
        ProviderDto providerDto = buildMinimiumProviderDto(nurse, identifierType, assignedEntity);
        // Registry User 3 has permissions on MD only.
        GrsRegistryUsers regUser = new GrsRegistryUsers(3l);
        SpoofedUserHelper.currentUser="plr-restricted";
        try {
            PrsProviders brr = maintainProviderService.addProvider_Save_MessageAndWeb(providerDto);
            providersToDelete.add(brr);
        } catch (BusinessRuleException ex) {
            BusinessRuleResult result = ex.getResults().get(0);
            assertEquals(2, result.getMessages().size());
            Set<String> messageCodes = new HashSet<>();
            for (BusinessRuleMessage msg : result.getMessages()) {
                messageCodes.add(msg.getMessageCode());
            }
            assertTrue(messageCodes.contains(BusinessRuleKeys.ERROR_DISALLOWED_IDENTIFIER_TYPE.getKey()));
            assertTrue(messageCodes.contains(BusinessRuleKeys.ERROR_DISALLOWED_STATUS_CLASS_CODE.getKey()));
            throw ex;
        } 
    }

    @Test(expected = EntityValidationException.class)
    public void testSave_disallowedIdentifierType_noPermissionsOnType() throws BusinessRuleException, EntityValidationException, DuplicateRecordException {
        PrsCtIdentifierTypes idType = codesDao.lookup(PrsCtIdentifierTypes.class, "CREGID");
        ProviderDto providerDto = buildMinimiumProviderDto(dentist, idType, assignedEntity);
        // Registry User 8 has permissions on DEN only, Identifier Type DENID and ACPID.
        GrsRegistryUsers regUser = new GrsRegistryUsers(8l);
        SpoofedUserHelper.currentUser="plr-restricted";
        try {
            PrsProviders brr = maintainProviderService.addProvider_Save_MessageAndWeb(providerDto);
            providersToDelete.add(brr);
        } catch (BusinessRuleException ex) {
            assertEquals(1, ex.getResults().get(0).getMessages().size());
            assertEquals(BusinessRuleKeys.ERROR_DISALLOWED_IDENTIFIER_TYPE.getKey(), ex.getResults().get(0).getMessages().get(0).getMessageCode());
            throw ex;
        }
    }

    @Test(expected = EntityValidationException.class)
    public void testSave_disallowedStatusClassCode_noPermissionsOnType() throws BusinessRuleException, EntityValidationException, DuplicateRecordException {

        ProviderDto providerDto = buildMinimiumProviderDto(dentist, dentistId, licensure);
        // Registry User 8 has permissions on DEN only, Status Class Code AE.
        GrsRegistryUsers regUser = new GrsRegistryUsers(8l);
        SpoofedUserHelper.currentUser="plr-restricted";
        try {
            PrsProviders provider = maintainProviderService.addProvider_Save_MessageAndWeb(providerDto);
            providersToDelete.add(provider);
        } catch (BusinessRuleException ex) {
            assertEquals(1, ex.getResults().get(0).getMessages().size());
            assertEquals(BusinessRuleKeys.ERROR_DISALLOWED_STATUS_CLASS_CODE.getKey(), ex.getResults().get(0).getMessages().get(0).getMessageCode());
            throw ex;
        }

    }

    @Test(expected = EntityValidationException.class)
    public void testSave_disallowedAddressCommunicationPurposeType_noPermissionsOnType() throws BusinessRuleException, EntityValidationException, DuplicateRecordException {
        ProviderDto providerDto = buildMinimiumProviderDto(nurse, dentistId, assignedEntity);
        PrsCtCommunPurposeTypes doctorsContact = codesDao.lookup(PrsCtCommunPurposeTypes.class, CodeTableCodes.PrsCtCommunPurposeTypes.DOCTORS_CONTACT);
        providerDto.getAddresses().get(0).setTypeId(addressType.getCtlId());
        providerDto.getAddresses().get(0).setDataOwnerCode("ACOP");
        
        providerDto.getAddresses().get(0).setCommunicationPurposeId(doctorsContact.getCtlId());
        // Registry User 8 has permissions on DEN only, Address Communication Purpose Code BC and CC.
        GrsRegistryUsers regUser = new GrsRegistryUsers(8l);
        SpoofedUserHelper.currentUser="plr-restricted";
        try {
            PrsProviders provider = maintainProviderService.addProvider_Save_MessageAndWeb(providerDto);
            providersToDelete.add(provider);
        } catch (BusinessRuleException ex) {
            assertEquals(1, ex.getResults().get(0).getMessages().size());
            assertEquals(BusinessRuleKeys.ERROR_DISALLOWED_ADDRESS_COMMUNICATION_PURPOSE_TYPE.getKey(), ex.getResults().get(0).getMessages().get(0).getMessageCode());
            throw ex;
        } 

    }

    @Test(expected = EntityValidationException.class)
    public void testSave_disallowedEmailAddressCommunicationPurposeType_noPermissionsOnType() throws BusinessRuleException, EntityValidationException, DuplicateRecordException {
        ProviderDto providerDto = buildMinimiumProviderDto(nurse, dentistId, assignedEntity);
        //not included because set automatically during save process - PrsCtCommunPurposeTypes doctorsContact = codesDao.lookup(PrsCtCommunPurposeTypes.class, CodeTableCodes.PrsCtCommunPurposeTypes.DOCTORS_CONTACT);
        providerDto.getElectronicAddresses().get(0).setTypeId(eAddressType.getCtlId());
        //not included because set automatically during save process - providerDto.getEmail().setCommunicationPurposeId(doctorsContact.getCtlId());
        providerDto.getElectronicAddresses().get(0).setAddress("fake@fake.com");
        // Registry User 8 has permissions on DEN only, Address Communication Purpose Code BC a
        GrsRegistryUsers regUser = new GrsRegistryUsers(8l);
        providerDto.getElectronicAddresses().get(0).setDataOwnerCode("ACOP");
        SpoofedUserHelper.currentUser="plr-restricted";
        try {
            PrsProviders provider = maintainProviderService.addProvider_Save_MessageAndWeb(providerDto);
            providersToDelete.add(provider);
        } catch (BusinessRuleException ex) {
            assertEquals(1, ex.getResults().get(0).getMessages().size());
            assertEquals(BusinessRuleKeys.ERROR_DISALLOWED_EMAILADDRESS_COMMUNICATION_PURPOSE_TYPE.getKey(), ex.getResults().get(0).getMessages().get(0).getMessageCode());
            throw ex;
        } 
    }

    @Test(expected = EntityValidationException.class)
    public void testSave_disallowedCredentialType_noPermissionsOnType() throws BusinessRuleException, EntityValidationException, DuplicateRecordException {
        ProviderDto providerDto = buildMinimiumProviderDto(dentist, dentistId, assignedEntity);
        providerDto.getCredentials().add(new CredentialsDto());
        providerDto.getCredentials().get(0).setTypeId(bachelorDegree.getCtlId());
        providerDto.getCredentials().get(0).setDesignation("some desig");
        providerDto.getCredentials().get(0).setEquivalencyFlag(true);
        // Registry User 8 has permissions on DEN only, Credential Type BDS and DMD.
        GrsRegistryUsers regUser = new GrsRegistryUsers(8l);
        SpoofedUserHelper.currentUser="plr-restricted";
        try {
            PrsProviders provider = maintainProviderService.addProvider_Save_MessageAndWeb(providerDto);
            providersToDelete.add(provider);
        } catch (BusinessRuleException ex) {
            assertEquals(1, ex.getResults().get(0).getMessages().size());
            assertEquals(BusinessRuleKeys.ERROR_DISALLOWED_CREDENTIAL_TYPE.getKey(), ex.getResults().get(0).getMessages().get(0).getMessageCode());
            throw ex;
        }
    }

    @Test(expected = EntityValidationException.class)
    public void testSave_disallowedExpertiseType_noPermissionsOnType() throws BusinessRuleException, EntityValidationException, DuplicateRecordException {
        ProviderDto providerDto = buildMinimiumProviderDto(nurse, dentistId, assignedEntity);
        providerDto.getExpertise().add(new ExpertiseDto());
        providerDto.getExpertise().get(0).setTypeId(acupuncture.getCtlId());
        providerDto.getExpertise().get(0).setSourcesCode("some source");
        providerDto.getExpertise().get(0).setEffectiveStartDate(new Date());
        // Registry User 8 has permissions on DEN only, Expertise Type - Provider Role Type MD and DEN.
        GrsRegistryUsers regUser = new GrsRegistryUsers(8l);
        SpoofedUserHelper.currentUser="plr-restricted";
        try {
            PrsProviders provider = maintainProviderService.addProvider_Save_MessageAndWeb(providerDto);
            providersToDelete.add(provider);
        } catch (BusinessRuleException ex) {
            /*
             RU 8 has permission on DEN only, Expertise Type - Provider Role Type MD and DEN only, but in order
             to test this we need to try to add a Provider of a different type, which violates more than just
             the DPS check we're trying to test.
             */
            assertEquals(3, ex.getResults().get(0).getMessages().size());
            boolean containsExpertiseTypeMessage = false;
            for (BusinessRuleMessage message : ex.getResults().get(0).getMessages()) {
                if (message.getMessageCode().equals(BusinessRuleKeys.ERROR_DISALLOWED_EXPERTISE_TYPE.getKey())) {
                    containsExpertiseTypeMessage = true;
                    break;
                }
            }
            assertTrue(containsExpertiseTypeMessage);
            throw ex;
        }
    }
    /**
     * Returns a Provider DTO containing the minimum about of data required to
     * pass validation and persist the Provider.
     *
     * Provider is a REGISTERED_NURSE, identifier type
     * REGISTERED_NURSE_ID_NUMBER..
     *
     * @return a Provider DTO containing the minimum about of data required to
     * pass validation and persist the Provider.
     */
    private static ProviderDto buildMinimiumProviderDto(PrsCtProviderRoleTypes prType, PrsCtIdentifierTypes idType, PrsCtStatusClassCodes classCode) {
        ProviderDto providerDto = new ProviderDto(true);

        providerDto.setJurisdictionType(CodeTableCodes.PrsCtJurisdictions.BRITISH_COLUMBIA);
        providerDto.setPartyType(CodeTableCodes.GrsCtPartyType.IND);
        providerDto.setTypeId(prType.getCtlId());
        providerDto.getIdentifiers().get(0).setTypeId(idType.getCtlId());
        providerDto.getIdentifiers().get(0).setIdentifier("david1");
        providerDto.getIdentifiers().get(0).setEffectiveStartDate(date);
        providerDto.getDemographicDetails().get(0).setBirthDate(date);
        providerDto.getStatuses().get(0).setClassCodeId(classCode.getCtlId());
        providerDto.getStatuses().get(0).setTypeId(statusCode.getCtlId());
        providerDto.getStatuses().get(0).setReasonCodeId(statusReasonCode.getCtlId());
        providerDto.getStatuses().get(0).setEffectiveStartDate(date);
        providerDto.getIndNames().get(0).setFirstName("David");
        providerDto.getIndNames().get(0).setLastName("Sharpe");
        providerDto.getIndNames().get(0).setEffectiveStartDate(date);
        providerDto.getDemographicDetails().get(0).setGenderId(gender.getCtlId());

        Calendar cal = Calendar.getInstance();
        DateUtils.truncateTime(cal);

        providerDto.getDemographicDetails().get(0).setBirthDate(cal.getTime());
        return providerDto;
    }

    private static ProviderDto buildMinimiumOrganizationProvider() {
        ProviderDto providerDto = new ProviderDto(true);

        providerDto.setJurisdictionType(CodeTableCodes.PrsCtJurisdictions.BRITISH_COLUMBIA);
        providerDto.setPartyType(CodeTableCodes.GrsCtPartyType.ORG);
        providerDto.setTypeId(nurse.getCtlId());
        providerDto.getIdentifiers().get(0).setTypeId(identifierType.getCtlId());
        providerDto.getIdentifiers().get(0).setIdentifier("david1");
        providerDto.getIdentifiers().get(0).setEffectiveStartDate(date);
        providerDto.getStatuses().get(0).setClassCodeId(assignedEntity.getCtlId());
        providerDto.getStatuses().get(0).setTypeId(statusCode.getCtlId());
        providerDto.getStatuses().get(0).setReasonCodeId(statusReasonCode.getCtlId());
        providerDto.getStatuses().get(0).setEffectiveStartDate(date);
        providerDto.getOrgNames().get(0).setName("short name");
        providerDto.getOrgNames().get(0).setEffectiveStartDate(date);
        return providerDto;
    }
    
    private GrsRegistryIdentifiers getCPNRegIdentifier(List<GrsRegistryIdentifiers> grsRegistryIdentifiersList) {
        
        Iterator<GrsRegistryIdentifiers> itr = grsRegistryIdentifiersList.iterator();
        GrsRegistryIdentifiers cpnRegId = null;
        
        GrsRegistryIdentifiers temp;
        while(itr.hasNext()) {
            temp = itr.next();
            
            if (temp.getIdentifierTypeCode().equals(cpnType)) {
                cpnRegId = temp;
            }
        }
        
        return cpnRegId;
    }
}