/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.service.auditing;

import ca.bc.gov.health.plr.constants.Consts;
import ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.NoteDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.WorkLocationDetailsDto;
import ca.bc.gov.health.plr.ejb.entity.GrsChangedRecords;
import ca.bc.gov.health.plr.ejb.entity.PlrConfigurationProperties;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.rule.provider.ProviderTestDataBuilder;
import ca.bc.gov.health.plr.service.provider.IntegrationSetup;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.container;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.entityManagerProxy;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.plrConfigurationResourceLoader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.naming.Context;
import javax.naming.NamingException;
import org.junit.After;
import org.junit.AfterClass;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 *
 * @author adebiyi.kuseju
 */
public class AuditingServiceTest extends IntegrationSetup {

    private static final Logger logger = Logger.getLogger(AuditingServiceTest.class.getName());
    private static final int WAIT_TIME = 60000;
    private static Map<String, Object> appResource;
    private static final int MAX_ITERATION_FOR_TIMING_SENSITIVE_TESTS = 10;
    static String auditState = "false";

    public AuditingServiceTest() {
    }

    @BeforeClass
    public static void setUpClass() throws NamingException, InterruptedException {
        Context initContext = container.getContext();

        auditState = plrConfigurationResourceLoader.getValue(Consts.ENABLE_AUDITING);
        PlrConfigurationProperties  audit = entityManagerProxy.find(PlrConfigurationProperties.class, "enable_auditing");
        audit.setValue("true");
        entityManagerProxy.merge(audit);
        entityManagerProxy.flush();

        logger.log(Level.INFO, String.format("Waiting for %sms to ensure auditing is fully enabled", WAIT_TIME));
        Thread.sleep(WAIT_TIME); // Sleep for WAIT_TIME to ensure we have reloaded configuration to enable auditing processing
        removeAuditingInfo();
    }

    @AfterClass
    public static void tearDownClass() throws NamingException {
        setupJNDIResources();
        PlrConfigurationProperties  audit = entityManagerProxy.find(PlrConfigurationProperties.class, "enable_auditing");
        audit.setValue(auditState);
        entityManagerProxy.merge(audit);
        entityManagerProxy.flush();

    }

    @Before
    public void setup() {
        // removeAuditingInfo();
    }

    @After
    public void clean() {
        removeAuditingInfo();
    }

    private static void removeAuditingInfo() {
        // delete all trasnactions first before deleteing the changed records to avoid
        // referential integrity violation
        entityManagerProxy.executeUpdateQuery("Delete FROM GrsTransactions");
        entityManagerProxy.executeUpdateQuery("Delete FROM GrsChangedRecords");
    }

    /**
     * Test of processDistribution method, of class DistributionService.
     */
    @Test
    public void testAudit_addProvider() throws Exception {

        PrsProviders provider = null;
        try {
            provider = createProviderCommon();

            List<GrsChangedRecords> changedRecords = null;

            // We try to check for updates at most three times waiting for LOCAL_WAIT_TIME on each ocassion
            // to allow asynchronous processing of change event consumer to complete
            for (int i = 0; i < MAX_ITERATION_FOR_TIMING_SENSITIVE_TESTS; i++) {
                Thread.sleep(WAIT_TIME);
                changedRecords = entityManagerProxy.namedQuery("GrsChangedRecords.findAll");

                if (!changedRecords.isEmpty()) {
                    break;
                }
            }

            assertFalse(changedRecords.isEmpty());
            assertTrue(changedRecords.get(0).getPauthChangedPauthId().equals(provider.getPauthId()));
            assertTrue(changedRecords.get(0).getCreateUpdateCode().equals(Consts.CREATE_PROVIDER));
            assertFalse(changedRecords.get(0).getGrsTransactionsList().isEmpty());

        } finally {
            if (provider != null) {
                provider = entityManagerProxy.find(PrsProviders.class, provider.getPauthId());
                entityManagerProxy.remove(provider);
            }
        }
    }

    /**
     * Test of processDistribution method, of class DistributionService.
     */
    @Test
    public void testAuditing_addBlock() throws Exception {

        NoteDto noteDto = makeNote();
        PrsProviders provider = null;

        try {

            provider = createProviderCommon();
            // Remove changed record entry added after creating a new provider
            Thread.sleep(WAIT_TIME);
            removeAuditingInfo();
            noteDto.setPauthId(provider.getPauthId());

            maintainProviderService.save(noteDto);

            List<GrsChangedRecords> changedRecords = null;
            
            // We try to check for updates at most three times waiting for LOCAL_WAIT_TIME on each ocassion
            // to allow asynchronous processing of change event consumer to complete
            for (int i = 0; i < MAX_ITERATION_FOR_TIMING_SENSITIVE_TESTS; i++) {
                Thread.sleep(WAIT_TIME);
                changedRecords = entityManagerProxy.namedQuery("GrsChangedRecords.findAll");

                if (!changedRecords.isEmpty()) {
                    break;
                }
            }
            
            assertEquals(1, changedRecords.size());
            assertTrue(changedRecords.get(0).getPauthChangedPauthId().equals(provider.getPauthId()));
            assertTrue(changedRecords.get(0).getCreateUpdateCode().equals(Consts.UPDATE_PROVIDER));
            assertEquals(1, changedRecords.get(0).getGrsTransactionsList().size());

        } finally {
            if (provider != null) {
                provider = entityManagerProxy.find(PrsProviders.class, provider.getPauthId());
                entityManagerProxy.remove(provider);
            }
        }

    }

    private PrsProviders createProviderCommon() throws Exception {
        ProviderDto provDto = ProviderTestDataBuilder.initFullProvider();
        provDto.setPauthId(null);
        provDto.setPartyType(CodeTableCodes.GrsCtPartyType.IND);
        provDto.setType("DEN");
        provDto.getRegistryIdentifiers().clear();
        provDto.getInformationRoutes().clear();
        provDto.getWorkLocationList().get(0).setWorkLocationDetails(new ArrayList<WorkLocationDetailsDto>());
        provDto.getWorkLocationList().get(0).getWorkLocationDetails().add(ProviderTestDataBuilder.getWorkLocationDetails());

        for (CollegeIdentifierDto dto : provDto.getIdentifiers()) {
            dto.setTypeCode("DENID");
            dto.setIdentifier("234-567U");
        }

        return maintainProviderService.addProvider_Save_MessageAndWeb(provDto);

    }

    private NoteDto makeNote() {
        NoteDto noteDto = ProviderTestDataBuilder.getNote();
        noteDto.setIdentifier(String.valueOf(System.currentTimeMillis()));
        return noteDto;
    }
}
