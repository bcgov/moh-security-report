/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.provider.ConfidentialityIndicatorDto;
import ca.bc.gov.health.plr.dto.provider.TelecommunicationDto;
import ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.GrsTelephones;
import ca.bc.gov.health.plr.ejb.entity.PrsConfidentialityIndicators;
import ca.bc.gov.health.plr.ejb.entity.PrsCtTelecomNumberTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.ejb.entity.util.DatabaseConstants;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.provider.ProviderTestDataBuilder;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.codesDao;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.entityManagerProxy;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.maintainTelephoneService;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.joda.time.LocalDate;
import org.junit.After;
import static org.junit.Assert.assertEquals;
import org.junit.Before;
import org.junit.Test;

/**
 * Tests JournalService via MaintainTelephoneService.
 *
 * @author David Sharpe
 */
public class JournalServiceTest extends IntegrationSetup {

    private static long PAUTH_ID = 276l;

    @Before
    public void setUp() {
        PAUTH_ID = 276l;
    }

    @After
    public void tearDown() {
        List<Exception> exceptions = new ArrayList<>();

        PrsProviders provider = entityManagerProxy.find(PrsProviders.class, PAUTH_ID);
        for (GrsTelephones telephone : provider.getGrsTelephonesList()) {
            try {
                entityManagerProxy.remove(telephone);
            } catch (Exception e) {
                e.printStackTrace();
                exceptions.add(e);
            }
        }
        for (PrsConfidentialityIndicators conf : provider.getPrsConfidentialityIndicatorsList()) {
            try {
                entityManagerProxy.remove(conf);
            } catch (Exception e) {
                e.printStackTrace();
                exceptions.add(e);
            }
        }
        if (!exceptions.isEmpty()) {
            throw new IllegalStateException("Exceptions occurred while deleting entities. Check log for details.");
        }
    }

    /**
     * When we CHANGE a record, it inserts two new records: (1) an intermediate
     * record which is a copy of the original with minor differences (2) the new
     * record
     *
     * Generation number should increment: 
     * - 1 (original record)
     * - 2 (intermediate record)
     * - 3 (new record)
     *
     * @throws DuplicateRecordException
     */
    @Test
    public void testJournal_CHANGE_genNumIncrements() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        GrsCtEndReasonTypes endReason = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CHANGE);

        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto = maintainTelephoneService.save(telephoneDto);

        telephoneDto.setEndReasonCodeId(endReason.getCtlId());
        telephoneDto.setAreaCode("123");
        maintainTelephoneService.save(telephoneDto);

        List<GrsTelephones> telephones = getTelephones(PAUTH_ID);
        assertEquals(3, telephones.size());
        assertEquals(1, telephones.get(0).getGenerationNum());
        assertEquals(2, telephones.get(1).getGenerationNum());
        assertEquals(3, telephones.get(2).getGenerationNum());
    }

    /**
     * When we CEASE a record, it inserts a new record.
     *
     * Generation number should increment 1, 2.
     *
     * @throws DuplicateRecordException
     */
    @Test
    public void testJournal_CEASE_genNumIncrements() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        GrsCtEndReasonTypes endReason = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CEASE);

        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto = maintainTelephoneService.save(telephoneDto);

        telephoneDto.setEndReasonCodeId(endReason.getCtlId());
        maintainTelephoneService.save(telephoneDto);
        List<GrsTelephones> telephones = getTelephones(PAUTH_ID);

        assertEquals(2, telephones.size());
        assertEquals(1, telephones.get(0).getGenerationNum());
        assertEquals(2, telephones.get(1).getGenerationNum());
    }

    /**
     * When we CORRECT a record, it inserts a new record.
     *
     * Generation number should increment 1, 2.
     *
     * @throws DuplicateRecordException
     */
    @Test
    public void testJournal_CORRECT_genNumIncrements() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        GrsCtEndReasonTypes endReason = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CORRECT);

        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto = maintainTelephoneService.save(telephoneDto);

        telephoneDto.setEndReasonCodeId(endReason.getCtlId());
        telephoneDto.setAreaCode("ABCD");
        maintainTelephoneService.save(telephoneDto);

        List<GrsTelephones> telephones = getTelephones(PAUTH_ID);
        assertEquals(2, telephones.size());
        assertEquals(1, telephones.get(0).getGenerationNum());
        assertEquals(2, telephones.get(1).getGenerationNum());
    }

    /**
     * When we CORRECT a record, it inserts a new record with an
     * effective start date.
     *
     * @throws DuplicateRecordException
     */
    @Test
    public void testJournal_CORRECT_effectiveStartDate() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        GrsCtEndReasonTypes endReason = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CORRECT);

        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto = maintainTelephoneService.save(telephoneDto);

        telephoneDto.setEndReasonCodeId(endReason.getCtlId());
        telephoneDto.setAreaCode("ABCD");
        maintainTelephoneService.save(telephoneDto);

        List<GrsTelephones> telephones = getTelephones(PAUTH_ID);
        assertEquals(telephones.get(0).getEffectiveStartDate().getTime(), telephoneDto.getEffectiveStartDate().getTime());
    }

    /**
     * When we CHANGE a record and change the record type, the generation number
     * sequence should reset for the new record type.
     *
     * Generation number should increment:
     * - 1 (original record)
     * - 2 (intermediate record)
     * - 1 (new record, new type)
     *
     * @throws DuplicateRecordException
     */
    @Test
    public void testJournal_changeRecordType_genNumResets() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        PrsCtTelecomNumberTypes fax = codesDao.lookup(PrsCtTelecomNumberTypes.class, CodeTableCodes.PrsCtTelecomNumberTypes.FAX);
        PrsCtTelecomNumberTypes mobile = codesDao.lookup(PrsCtTelecomNumberTypes.class, CodeTableCodes.PrsCtTelecomNumberTypes.MOBILE);
        GrsCtEndReasonTypes endReason = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CHANGE);

        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto.setTypeId(fax.getCtlId());
        telephoneDto = maintainTelephoneService.save(telephoneDto);

        telephoneDto.setEndReasonCodeId(endReason.getCtlId());
        // Change the record type to MOBILE.
        telephoneDto.setTypeId(mobile.getCtlId());
        telephoneDto.setAreaCode("123");
        maintainTelephoneService.save(telephoneDto);

        List<GrsTelephones> telephones = getTelephones(PAUTH_ID);
        assertEquals(3, telephones.size());
        assertEquals(1, telephones.get(0).getGenerationNum());
        assertEquals(2, telephones.get(1).getGenerationNum());
        // GENERATION_NUM of the new record should start at 1.
        assertEquals(1, telephones.get(2).getGenerationNum());
    }
    
    
    /**
     * We verify that the EffectiveEndDate of the existing record is updated correctly when
     * a change is made and the new effective start date is set to be greater than the original end date
     *
     * This method simply verifies that all the dates remain the same
     * 
     * @throws DuplicateRecordException
     */
    @Test
    public void testJournal_changeRecord_EffectiveDateGap() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        PrsCtTelecomNumberTypes fax = codesDao.lookup(PrsCtTelecomNumberTypes.class, CodeTableCodes.PrsCtTelecomNumberTypes.FAX);
        PrsCtTelecomNumberTypes mobile = codesDao.lookup(PrsCtTelecomNumberTypes.class, CodeTableCodes.PrsCtTelecomNumberTypes.MOBILE);
        GrsCtEndReasonTypes endReason = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CHANGE);

        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        
        //The end date of the new telephone
        Calendar calOriginalEndDate = Calendar.getInstance();
        calOriginalEndDate.add(Calendar.DATE, 10);
        
        //The start date and end date of the CHG update
        //GAP CASE
        Calendar calNewStartDateGap = Calendar.getInstance();
        calNewStartDateGap.setTime(calOriginalEndDate.getTime());
        calNewStartDateGap.add(Calendar.DATE, 2);
        Calendar calNewEndDateGap = Calendar.getInstance();
        calNewEndDateGap.setTime(calNewStartDateGap.getTime());
        calNewEndDateGap.add(Calendar.DATE, 2);
        
        //First we had the telephone
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto.setTypeId(fax.getCtlId());
        telephoneDto.setEffectiveEndDate(calOriginalEndDate.getTime());
        telephoneDto = maintainTelephoneService.save(telephoneDto);
        
        //Then we perform a CHG update
        telephoneDto.setEffectiveStartDate(calNewStartDateGap.getTime());
        telephoneDto.setEffectiveEndDate(calNewEndDateGap.getTime());
        telephoneDto.setTypeId(mobile.getCtlId());
        telephoneDto.setAreaCode("123");
        telephoneDto.setEndReasonCodeId(endReason.getCtlId());
        maintainTelephoneService.save(telephoneDto);
     
        List<GrsTelephones> telephones = getTelephones(PAUTH_ID);
        assertEquals(3, telephones.size());
        //The intermediate record should have the same end date as the original one
        assertEquals(0, telephones.get(0).getEffectiveEndDate().compareTo(telephones.get(1).getEffectiveEndDate()));
        //The new record should have the given start and end date. Nothing changed
        //Note: had to use a formatter as the Date method compareTo would return that the dates are different. 
        //With the formatter we make sure that we don't care about the time
        DateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
        assertEquals(true, formatter.format(calNewStartDateGap.getTime()).equals(formatter.format(telephones.get(2).getEffectiveStartDate())));
        assertEquals(true, formatter.format(calNewEndDateGap.getTime()).equals(formatter.format(telephones.get(2).getEffectiveEndDate())));
    }
    
    
    /**
     * We verify that the EffectiveEndDate of the existing record is updated correctly when
     * a change is made and the new effective start date is set to be lower than the original end date
     *
     * @throws DuplicateRecordException
     */
    @Test
    public void testJournal_changeRecord_EffectiveDateOverlap() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        PrsCtTelecomNumberTypes fax = codesDao.lookup(PrsCtTelecomNumberTypes.class, CodeTableCodes.PrsCtTelecomNumberTypes.FAX);
        PrsCtTelecomNumberTypes mobile = codesDao.lookup(PrsCtTelecomNumberTypes.class, CodeTableCodes.PrsCtTelecomNumberTypes.MOBILE);
        GrsCtEndReasonTypes endReason = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CHANGE);

        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        
        //The end date of the new telephone
        Calendar calOriginalEndDate = Calendar.getInstance();
        calOriginalEndDate.add(Calendar.DATE, 10);
        
        //The start date and end date of the CHG update
        //OVERLAP CASE
        Calendar calNewStartDateGap = Calendar.getInstance();
        calNewStartDateGap.setTime(calOriginalEndDate.getTime());
        calNewStartDateGap.add(Calendar.DATE, -2);
        Calendar calNewEndDateGap = Calendar.getInstance();
        calNewEndDateGap.setTime(calNewStartDateGap.getTime());
        calNewEndDateGap.add(Calendar.DATE, 4);
        
        //First we had the telephone
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto.setTypeId(fax.getCtlId());
        telephoneDto.setEffectiveEndDate(calOriginalEndDate.getTime());
        telephoneDto = maintainTelephoneService.save(telephoneDto);
        
        //Then we perform a CHG update
        telephoneDto.setEffectiveStartDate(calNewStartDateGap.getTime());
        telephoneDto.setEffectiveEndDate(calNewEndDateGap.getTime());
        telephoneDto.setTypeId(mobile.getCtlId());
        telephoneDto.setAreaCode("123");
        telephoneDto.setEndReasonCodeId(endReason.getCtlId());
        maintainTelephoneService.save(telephoneDto);
     
        List<GrsTelephones> telephones = getTelephones(PAUTH_ID);
        assertEquals(3, telephones.size());
        
        //Note: had to use a formatter as the Date method compareTo would return that the dates are different. 
        //With the formatter we make sure that we don't care about the time
        DateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
        
        //The intermediate record should have a new end date set to one day before the effective start date of the new record
        Calendar calNewOriginalEndDate = Calendar.getInstance();
        calNewOriginalEndDate.setTime(calNewStartDateGap.getTime());
        calNewOriginalEndDate.add(Calendar.DATE,-1);
        assertEquals(true, formatter.format(telephones.get(1).getEffectiveEndDate()).equals(formatter.format(calNewOriginalEndDate.getTime())));
        
        //The new record should have the given start and end date. Nothing changed
        assertEquals(true, formatter.format(calNewStartDateGap.getTime()).equals(formatter.format(telephones.get(2).getEffectiveStartDate())));
        assertEquals(true, formatter.format(calNewEndDateGap.getTime()).equals(formatter.format(telephones.get(2).getEffectiveEndDate())));
    }

    /**
     * We should be able to add a new record of the same type after we have
     * CEASED all active records of that type.
     * 
     * Generation number should increment:
     * - 1 (original record)
     * - 2 (record created by cease)
     * - 3 (new active record)
     *
     * @throws DuplicateRecordException
     */
    @Test
    public void testJournal_addCeasedType_genNumIncrements() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        PrsCtTelecomNumberTypes fax = codesDao.lookup(PrsCtTelecomNumberTypes.class, CodeTableCodes.PrsCtTelecomNumberTypes.FAX);
        GrsCtEndReasonTypes endReason = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CEASE);

        // Add the first record
        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto.setTypeId(fax.getCtlId());
        telephoneDto = maintainTelephoneService.save(telephoneDto);

        // Cease that record
        telephoneDto.setEndReasonCodeId(endReason.getCtlId());
        maintainTelephoneService.save(telephoneDto);

        // Add a new record of the same type
        telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto.setTypeId(fax.getCtlId());
        maintainTelephoneService.save(telephoneDto);

        List<GrsTelephones> telephones = getTelephones(PAUTH_ID);
        assertEquals(3, telephones.size());
        assertEquals(1, telephones.get(0).getGenerationNum());
        assertEquals(2, telephones.get(1).getGenerationNum());
        assertEquals(3, telephones.get(2).getGenerationNum());
    }

    @Test
    public void testJournal_CEASE_invalidatedHighDate() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        GrsCtEndReasonTypes endReason = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CEASE);

        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto = maintainTelephoneService.save(telephoneDto);

        telephoneDto.setEndReasonCodeId(endReason.getCtlId());
        maintainTelephoneService.save(telephoneDto);
        List<GrsTelephones> telephones = getTelephones(PAUTH_ID);

        assertEquals(2, telephones.size());
        LocalDate expectedToday = new LocalDate(telephones.get(0).getInvalidatedDts());
        LocalDate expectedHighDate = new LocalDate(telephones.get(1).getInvalidatedDts());
        assertEquals(new LocalDate(), expectedToday);
        assertEquals(DatabaseConstants.SYSTEM_HIGH_DATE, expectedHighDate);
    }

    @Test(expected = EntityValidationException.class)
    public void testJournal_Confidential_updateRejected() throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        ConfidentialityIndicatorDto conf = ProviderTestDataBuilder.getConfidentialityIndicator();
        conf.setPauthId(PAUTH_ID);
        maintainConfidentialityService.save(conf);

        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setPauthId(PAUTH_ID);
        maintainTelephoneService.save(telephoneDto);
    }

    @Test(expected = EntityValidationException.class)
    public void testJournalAdd_disallowedTable_addRejected() throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        // PAUTH_ID=260 is an MD.
        PAUTH_ID = 260l;

        // Reg user 4 is in APG 2, which has *read* permissions only. Applies to MD, DATA_OWNER_CODE='SHARED'.
        GrsRegistryUsers regUser = new GrsRegistryUsers(4l);

        ConfidentialityIndicatorDto conf = ProviderTestDataBuilder.getConfidentialityIndicator();
        conf.setPauthId(PAUTH_ID);
        conf.setDataOwnerCode("PHSA");

        maintainConfidentialityService.save(conf);
    }

    @Test(expected = EntityValidationException.class)
    public void testJournalAdd_disallowedProviderType_addRejected() throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        // Reg user 8 has permissions on DEN only.
        GrsRegistryUsers regUser = new GrsRegistryUsers(8l);

        ConfidentialityIndicatorDto conf = ProviderTestDataBuilder.getConfidentialityIndicator();
        // PAUTH_ID=276 is an HA.
        conf.setPauthId(95l);
        maintainConfidentialityService.save(conf);
    }

    /**
     * 1. Add a Confidentiality Indicator to a Provider. The Data Owner Code
     * will be the one set by the ProviderTestDataBuilder, which is 'HA3'.
     * 
     * 2. Try to update that CI with Registry User 8. That registry user
     * has Data Owner Code 'PLR_TEST', not 'HA3', so the update will fail.
     * 
     * @throws DuplicateRecordException 
     * @throws ca.bc.gov.health.plr.rule.BusinessRuleException 
     * @throws ca.bc.gov.health.plr.service.validators.EntityValidationException 
     */
    @Test(expected = EntityValidationException.class)
    public void testJournalUpdate_disallowedDataOwnerCode_updateRejected() throws DuplicateRecordException, BusinessRuleException, EntityValidationException {

        // PAUTH_ID=265 is a DEN.
        PAUTH_ID = 265;
        ConfidentialityIndicatorDto confInd = ProviderTestDataBuilder.getConfidentialityIndicator();
        confInd.setPauthId(PAUTH_ID);

        // Reg user 1 has all permissions, but not DATA_OWNER_CODE='PLR_TEST'.
        GrsRegistryUsers regUser = new GrsRegistryUsers(1l);
        // Add a Confidentiality Indicator with DATA_OWNER_CODE='HA3'.
        List<ConfidentialityIndicatorDto> result;

        try {
            maintainConfidentialityService.save(confInd);
            result = maintainConfidentialityService.refreshConfidentialityIndicators(PAUTH_ID);
            confInd = result.get(0);
        } catch (DuplicateRecordException | BusinessRuleException | EntityValidationException ex) {
            Logger.getLogger(JournalServiceTest.class.getName()).log(Level.SEVERE, null, ex);
        }

        GrsCtEndReasonTypes code = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CEASE);
        confInd.setEndReasonCodeId(code.getCtlId());
        confInd.setDataOwnerCode("PHSA");
        // Reg user 8 has permissions on DEN, DATA_OWNER_CODE='PLR_TEST'.
        regUser = new GrsRegistryUsers(8l);
        maintainConfidentialityService.save(confInd);

    }
    
    /*
     * Test to see effective end date on or after current date is acceptabable
     */
    public void testJournal_EffectiveEndDate_updateAccepted() throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setId(Long.MAX_VALUE);
        telephoneDto.setPauthId(PAUTH_ID);

        telephoneDto.setEffectiveEndDate(new Date());
        maintainTelephoneService.save(telephoneDto);
    }
    
    /**
     * When we CEASE a record, it inserts a new record.
     *
     * Generation number should increment 1, 2.
     *
     * @throws DuplicateRecordException
     */
    @Test
    public void testJournal_CEASE_And_AddNew_Should_InactivateExisting() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {
        GrsCtEndReasonTypes endReason = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CEASE);

        TelecommunicationDto telephoneDto = ProviderTestDataBuilder.getTelecommunication();
        telephoneDto.setPauthId(PAUTH_ID);
        telephoneDto = maintainTelephoneService.save(telephoneDto);

        telephoneDto.setEndReasonCodeId(endReason.getCtlId());
        maintainTelephoneService.save(telephoneDto);
        List<GrsTelephones> telephones = getTelephones(PAUTH_ID);
        assertEquals(2, telephones.size());
        assertEquals(1, telephones.get(0).getGenerationNum());
        assertEquals(2, telephones.get(1).getGenerationNum());
        assertEquals(CodeTableCodes.GrsCtBooleanTypes.NO.getValue(), telephones.get(0).getActiveFlag().getCtlNameCode());
        assertEquals(CodeTableCodes.GrsCtBooleanTypes.YES.getValue(), telephones.get(1).getActiveFlag().getCtlNameCode());
        
        telephoneDto.setEndReasonCodeId(null);
        telephoneDto.setId(null);
        maintainTelephoneService.save(telephoneDto);
        telephones = getTelephones(PAUTH_ID);
        assertEquals(3, telephones.size());
        assertEquals(1, telephones.get(0).getGenerationNum());
        assertEquals(2, telephones.get(1).getGenerationNum());
        assertEquals(3, telephones.get(2).getGenerationNum());
        assertEquals(CodeTableCodes.GrsCtBooleanTypes.NO.getValue(), telephones.get(0).getActiveFlag().getCtlNameCode());
        assertEquals(CodeTableCodes.GrsCtBooleanTypes.NO.getValue(), telephones.get(1).getActiveFlag().getCtlNameCode());
        assertEquals(CodeTableCodes.GrsCtBooleanTypes.YES.getValue(), telephones.get(2).getActiveFlag().getCtlNameCode());
        
    }
    
    /**
     * Get the GrsTelephones of the specified provider, ordered by ID (and
     * therefore ordered by the order they were created).
     *
     * @param pauthId specifies a valid Provider.
     * @return the GrsTelephones of the specified provider, ordered by ID (and
     * therefore ordered by the order they were created).
     */
    private List<GrsTelephones> getTelephones(long pauthId) {
        List<GrsTelephones> telephones = entityManagerProxy.query(
                "select t from GrsTelephones t where t.pauthPauthId.pauthId = " + pauthId + " order by t.phonId");
        return telephones;
    }
}
