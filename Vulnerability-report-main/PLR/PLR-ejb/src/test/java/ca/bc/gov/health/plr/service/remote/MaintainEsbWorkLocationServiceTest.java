/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.service.remote;

import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.esb.WorkLocationDto;
import ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocationDetails;
import ca.bc.gov.health.plr.ejb.entity.PrsWorkLocations;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import org.mockito.Mockito;
import static org.mockito.Mockito.mock;

/**
 *
 * @author jonathan.wiebe
 */
public class MaintainEsbWorkLocationServiceTest {

    public MaintainEsbWorkLocationServiceTest() {
    }

    @Before
    public void setUp() {
    }

    @After
    public void tearDown() {
    }

    @Test
    public void testFindWorkLocation_happyPath() throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        MaintainEsbWorkLocationService wlEsbService = new MaintainEsbWorkLocationService();

        // set the em which is normally private
        Field emField = MaintainEsbWorkLocationService.class.getDeclaredField("em");
        emField.setAccessible(true);

        // make sure we can invoke the private method
        Method findWorkLocationMethod = MaintainEsbWorkLocationService.class.getDeclaredMethod("findWorkLocation", WorkLocationDto.class, ProviderDto.class);
        findWorkLocationMethod.setAccessible(true);

        // mock out the em
        EntityManager emMock = mock(EntityManager.class);
        emField.set(wlEsbService, emMock);

        // mock out the query 
        TypedQuery<PrsWorkLocations> mockQuery = mock(TypedQuery.class);
        Mockito.doReturn(mockQuery).when(emMock).createQuery(anyString(), any(Class.class));
        List<PrsWorkLocations> listWl = new ArrayList();
        listWl.add(new PrsWorkLocations() {
            {
                setPrsWorkLocationDetailsList(new ArrayList<PrsWorkLocationDetails>() {
                    {
                        add(new PrsWorkLocationDetails());
                    }
                });
            }
        });
        Mockito.doReturn(listWl).when(mockQuery).getResultList();

        // setup input to findWorkLocaiton
        WorkLocationDto wlDto = new WorkLocationDto();
        wlDto.setIdentifier(12314434l);
        ProviderDto provDto = new ProviderDto();
        provDto.setPauthId(2342l);

        //call the method
        PrsWorkLocations wl = (PrsWorkLocations)findWorkLocationMethod.invoke(wlEsbService, wlDto, provDto);
        assertTrue(wl!=null);
    }
    
    // only return the work location detail that has no end reason code
    @Test
    public void testFindWorkLocation_moreThanOneWLDReturned() throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        MaintainEsbWorkLocationService wlEsbService = new MaintainEsbWorkLocationService();

        // set the em which is normally private
        Field emField = MaintainEsbWorkLocationService.class.getDeclaredField("em");
        emField.setAccessible(true);

        // make sure we can invoke the private method
        Method findWorkLocationMethod = MaintainEsbWorkLocationService.class.getDeclaredMethod("findWorkLocation", WorkLocationDto.class, ProviderDto.class);
        findWorkLocationMethod.setAccessible(true);

        // mock out the em
        EntityManager emMock = mock(EntityManager.class);
        emField.set(wlEsbService, emMock);

        // mock out the query 
        TypedQuery<PrsWorkLocations> mockQuery = mock(TypedQuery.class);
        Mockito.doReturn(mockQuery).when(emMock).createQuery(anyString(), any(Class.class));
        List<PrsWorkLocations> listWl = new ArrayList();
        listWl.add(new PrsWorkLocations() {
            {
                setPrsWorkLocationDetailsList(new ArrayList<PrsWorkLocationDetails>() {
                    {
                        // only the one without an end reason code should be returned
                        add(new PrsWorkLocationDetails(){{ setEndReasonCode(new GrsCtEndReasonTypes());}});
                        add(new PrsWorkLocationDetails());
                        add(new PrsWorkLocationDetails(){{ setEndReasonCode(new GrsCtEndReasonTypes());}});
                    }
                });
            }
        });
        Mockito.doReturn(listWl).when(mockQuery).getResultList();

        // setup input to findWorkLocaiton
        WorkLocationDto wlDto = new WorkLocationDto();
        wlDto.setIdentifier(12314434l);
        ProviderDto provDto = new ProviderDto();
        provDto.setPauthId(2342l);

        //call the method
        PrsWorkLocations wl = (PrsWorkLocations)findWorkLocationMethod.invoke(wlEsbService, wlDto, provDto);
        assertTrue(wl!=null);
        assertTrue(wl.getPrsWorkLocationDetailsList().size()==1);
    }

    // if more than 1 work location is found, return null
    @Test
    public void testFindWorkLocation_toManyWorkLocationsReturned() throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        MaintainEsbWorkLocationService wlEsbService = new MaintainEsbWorkLocationService();

        // set the em which is normally private
        Field emField = MaintainEsbWorkLocationService.class.getDeclaredField("em");
        emField.setAccessible(true);

        // make sure we can invoke the private method
        Method findWorkLocationMethod = MaintainEsbWorkLocationService.class.getDeclaredMethod("findWorkLocation", WorkLocationDto.class, ProviderDto.class);
        findWorkLocationMethod.setAccessible(true);

        // mock out the em
        EntityManager emMock = mock(EntityManager.class);
        emField.set(wlEsbService, emMock);

        // mock out the query 
        TypedQuery<PrsWorkLocations> mockQuery = mock(TypedQuery.class);
        Mockito.doReturn(mockQuery).when(emMock).createQuery(anyString(), any(Class.class));
        List<PrsWorkLocations> listWl = new ArrayList();
        
        // add two work locations - the first
        listWl.add(new PrsWorkLocations() {
            {
                setPrsWorkLocationDetailsList(new ArrayList<PrsWorkLocationDetails>() {
                    {
                        add(new PrsWorkLocationDetails());
                    }
                });
            }
        });
        // add two work locations - the second one
        listWl.add(new PrsWorkLocations() {
            {
                setPrsWorkLocationDetailsList(new ArrayList<PrsWorkLocationDetails>() {
                    {
                        add(new PrsWorkLocationDetails());
                    }
                });
            }
        });
        Mockito.doReturn(listWl).when(mockQuery).getResultList();

        // setup input to findWorkLocaiton
        WorkLocationDto wlDto = new WorkLocationDto();
        wlDto.setIdentifier(12314434l);
        ProviderDto provDto = new ProviderDto();
        provDto.setPauthId(2342l);

        //call the method
        PrsWorkLocations wl = (PrsWorkLocations)findWorkLocationMethod.invoke(wlEsbService, wlDto, provDto);
        assertTrue(wl==null);
    }
}
