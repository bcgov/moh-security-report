/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.provider.AddressDto;
import ca.bc.gov.health.plr.dto.provider.InformationRouteDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.ejb.entity.GrsAddresses;
import ca.bc.gov.health.plr.ejb.entity.GrsCtEndReasonTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsInformationRoutes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.provider.ProviderTestDataBuilder;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.codesDao;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.entityManagerProxy;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.maintainAddressService;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.maintainInformationRouteService;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.plrConfigurationResourceLoader;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.providerDtoConverter;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.RecordAndRestoreConfig;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.naming.NamingException;
import org.junit.After;
import org.junit.AfterClass;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 *
 * @author ian.scott
 */
public class MaintainAddressServiceTest extends IntegrationSetup {

    @BeforeClass
    public static void setUpClass() throws NamingException, InterruptedException {
        RecordAndRestoreConfig.record(60000, plrConfigurationResourceLoader, "false", "false", "false", "false");
    }

    @AfterClass
    public static void tearDownClass() throws NamingException, InterruptedException {
        RecordAndRestoreConfig.restore(60000);
    }

    private static final long PAUTH_ID = 3313l;

    @Before
    public void setUp() {
        List<Exception> exceptions = new ArrayList<>();

        PrsProviders provider = entityManagerProxy.find(PrsProviders.class, PAUTH_ID);
        for (PrsInformationRoutes route : provider.getPrsInformationRoutesList()) {
            try {
                entityManagerProxy.remove(route);
            } catch (Exception e) {
                e.printStackTrace();
                exceptions.add(e);
            }
        }
        for (GrsAddresses address : provider.getGrsAddressesList()) {
            try {
                entityManagerProxy.remove(address);
            } catch (Exception e) {
                e.printStackTrace();
                exceptions.add(e);
            }
        }
        if (!exceptions.isEmpty()) {
            throw new IllegalStateException("Exceptions occurred while deleting entities. Check log for details.");
        }
    }

    /**
     * Test of save method .
     */
    @Test
    public void testAddAddress() throws EntityValidationException, BusinessRuleException {

        AddressDto newEntity = ProviderTestDataBuilder.getAddress();
        newEntity.setPauthId(PAUTH_ID);

        PrsProviders provider = entityManagerProxy.find(PrsProviders.class, newEntity.getPauthId());
        List<GrsAddresses> originalEntityList = provider.getGrsAddressesList();
        int originalEntityListSize = originalEntityList.size();
        AddressDto result = null;
        try {
            result = maintainAddressService.save(newEntity);
        } catch (DuplicateRecordException dre) {
            assertTrue(dre.getMessage().equals(""));
        }

        assertNotNull(result);
        provider = entityManagerProxy.find(PrsProviders.class, newEntity.getPauthId());
        assertEquals(originalEntityListSize + 1, provider.getGrsAddressesList().size());
        entityManagerProxy.remove(entityManagerProxy.find(GrsAddresses.class, result.getId()));
    }

    /**
     * Test of save method with out Canada as country. The address validation
     * status should be N for not applicable
     */
    @Test
    public void testAddAddress_NotCanada() throws EntityValidationException, BusinessRuleException {

        AddressDto newEntity = ProviderTestDataBuilder.getAddress();
        newEntity.setCountry(null);
        newEntity.setCountryCode("CM");
        newEntity.setCountryId(null);
        newEntity.setPauthId(PAUTH_ID);

        PrsProviders provider = entityManagerProxy.find(PrsProviders.class, newEntity.getPauthId());
        List<GrsAddresses> originalEntityList = provider.getGrsAddressesList();
        int originalEntityListSize = originalEntityList.size();
        AddressDto result = null;
        try {
            result = maintainAddressService.save(newEntity);
        } catch (DuplicateRecordException dre) {
            assertTrue(dre.getMessage().equals(""));
        }

        assertNotNull(result);
        assertEquals(result.getValidationStatus().charAt(0), CodeTableCodes.PrsCtAddressValidationCodes.NA.getValue().charAt(0));
        provider = entityManagerProxy.find(PrsProviders.class, newEntity.getPauthId());
        assertEquals(originalEntityListSize + 1, provider.getGrsAddressesList().size());

        entityManagerProxy.remove(entityManagerProxy.find(GrsAddresses.class, result.getId()));
    }

    @Test
    public void testAddressMultiplicityForRegUser() throws DuplicateRecordException, EntityValidationException, BusinessRuleException {

        AddressDto newEntity = ProviderTestDataBuilder.getAddress();
        newEntity.setRuRuID(6l);
        List<AddressDto> addressDtos = maintainAddressService.refreshAddresses(newEntity);
        AddressDto addressDto = null;
        if (addressDtos == null || addressDtos.isEmpty()) {
            addressDto = maintainAddressService.save(newEntity);
        } else {
            for (AddressDto dto : addressDtos) {
                if (dto.isActive()) {
                    dto.setId(null);
                    addressDto = dto;
                    break;
                }
            }
        }
        boolean exceptionThrown = false;
        try {
            addressDto = maintainAddressService.save(addressDto);
        } catch (DuplicateRecordException dre) {
            exceptionThrown = true;
        } finally {
            try {
                entityManagerProxy.remove(entityManagerProxy.find(GrsAddresses.class, addressDto.getId()));
            } catch (Exception e) {
            }
        }
        assertTrue(exceptionThrown);
    }

    @Test
    public void testCeaseProviderAddress() throws BusinessRuleException, DuplicateRecordException, EntityValidationException {

        AddressDto address = ProviderTestDataBuilder.getAddress();
        address.setPauthId(PAUTH_ID);
        AddressDto savedAddressDto = maintainAddressService.save(address);
        //have to create second Address as provider has to have one active address associated it.
        AddressDto address2 = ProviderTestDataBuilder.getAddress2();
        address2.setPauthId(PAUTH_ID);
        maintainAddressService.save(address2);

        //the information route is associated with the first AddressDto
        InformationRouteDto newInfoRoute = ProviderTestDataBuilder.getInformationRoute();
        newInfoRoute.setPauthId(PAUTH_ID);
        newInfoRoute.setDocumentTypeCode(CodeTableCodes.GrsCtDocumentTypes.EGG.getValue());
        newInfoRoute.setMechanismTypeCode(CodeTableCodes.GrsCtMechanisms.COURIER__TEST_CODE.getValue());
        newInfoRoute.setAddressDto(savedAddressDto);
        maintainInformationRouteService.save(newInfoRoute);

        GrsCtEndReasonTypes ceaseEndReasonTypes = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CEASE);
        savedAddressDto.setEndReasonCodeId(ceaseEndReasonTypes.getCtlId());
        boolean caughtBusinessRuleException = false;
        try {
            ProviderDto providerDto = providerDtoConverter.toProviderDetails(entityManagerProxy.find(PrsProviders.class, PAUTH_ID), false);
            maintainProviderServiceHelper.processLocation(savedAddressDto, providerDto, maintainAddressService);
        } catch (EntityValidationException bre) {
            caughtBusinessRuleException = true;
            assertTrue(bre.getMessage().matches(".*PRS.SYS.ELE.UNK.1.0.7039.*"));
        }
        assertTrue(caughtBusinessRuleException);

    }

    @Test
    public void testCeaseLastProviderAddress() throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        AddressDto address = ProviderTestDataBuilder.getAddress();
        address.setPauthId(PAUTH_ID);
        AddressDto savedAddressDto = maintainAddressService.save(address);
        GrsCtEndReasonTypes ceaseEndReasonTypes = codesDao.lookup(GrsCtEndReasonTypes.class, CodeTableCodes.GrsCtEndReasonTypes.CEASE);
        savedAddressDto.setEndReasonCodeId(ceaseEndReasonTypes.getCtlId());
        boolean caughtBusinessRuleException = false;
        try {
            ProviderDto providerDto = providerDtoConverter.toProviderDetails(entityManagerProxy.find(PrsProviders.class, PAUTH_ID), false);
            maintainProviderServiceHelper.processLocation(savedAddressDto, providerDto, maintainAddressService);
        } catch (BusinessRuleException bre) {
            caughtBusinessRuleException = true;
        } catch (EntityValidationException | DuplicateRecordException ex) {
            Logger.getLogger(MaintainAddressServiceTest.class.getName()).log(Level.SEVERE, null, ex);
        }
        assertTrue(caughtBusinessRuleException);

    }

}
