/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.rule.provider;

import ca.bc.gov.health.plr.ejb.entity.PrsCtCountries;
import ca.bc.gov.health.plr.ejb.entity.PrsCtJurisdictions;
import ca.bc.gov.health.plr.ejb.entity.PrsCtStatusClassCodes;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.service.provider.IntegrationSetup;
import java.util.Set;
import javax.validation.ConstraintValidatorContext;
import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 *
 * @author jonathan.wiebe
 */
public class AcceptableCodeNameValidatorTest extends IntegrationSetup {

    private ConstraintValidatorContext mockContext;
    private ConstraintValidatorContext.ConstraintViolationBuilder mockConstraintViolationBuilder;

    /**
     * Override pesky DAO problem where it can't find EJB without IntegrationSetup
     */
    private final AcceptableCodeNameValidator codeValidator = new AcceptableCodeNameValidator() {
        @Override
        CodesDao getCodesDao() {
            return codesDao;
        }
    };

    private AcceptableCodeName mockAcceptableCode;

    @Before
    public void setUp() {
        mockContext = mock(ConstraintValidatorContext.class);
        mockConstraintViolationBuilder = mock(ConstraintValidatorContext.ConstraintViolationBuilder.class);
        when(mockContext.buildConstraintViolationWithTemplate(Mockito.anyString())).thenReturn(mockConstraintViolationBuilder);

    }

    @Test
    public void testValidJurisdiction() {
        Class classes = PrsCtJurisdictions.class;
        mockUpAnnotationAttributes(classes);

        assertTrue(codeValidator.isValid(CodeTableCodes.PrsCtJurisdictions.BRITISH_COLUMBIA.getValue(), mockContext));
        verify(mockConstraintViolationBuilder, times(0)).addConstraintViolation();
    }

    @Test
    public void testInValidJurisdiction() {
        Class classes = PrsCtJurisdictions.class;
        mockUpAnnotationAttributes(classes);

        assertFalse(codeValidator.isValid("C", mockContext));
        verify(mockConstraintViolationBuilder, times(1)).addConstraintViolation();
    }

    @Test
    public void testValidCountry() {
        Class classes = PrsCtCountries.class;
        mockUpAnnotationAttributes(classes);

        assertTrue(codeValidator.isValid("AX", mockContext));
        verify(mockConstraintViolationBuilder, times(0)).addConstraintViolation();
    }

    @Test
    public void testInValidCountry() {
        Class classes = PrsCtCountries.class;
        mockUpAnnotationAttributes(classes);

        assertFalse(codeValidator.isValid("BX", mockContext));
        verify(mockConstraintViolationBuilder, times(1)).addConstraintViolation();
    }

    @Test
    public void testValidStatusClass() {
        Class classes = PrsCtStatusClassCodes.class;
        mockUpAnnotationAttributes(classes);

        assertTrue(codeValidator.isValid("LIC", mockContext));
        verify(mockConstraintViolationBuilder, times(0)).addConstraintViolation();
    }

    @Test
    public void testInValidStatusClass() {
        Class classes = PrsCtStatusClassCodes.class;
        mockUpAnnotationAttributes(classes);

        assertFalse(codeValidator.isValid("BXX", mockContext));
        verify(mockConstraintViolationBuilder, times(1)).addConstraintViolation();
    }

    @Test
    public void testNullAllowed() {
        Class classes = PrsCtStatusClassCodes.class;
        mockUpAnnotationAttributes(classes);

        assertTrue(codeValidator.isValid(null, mockContext));
        verify(mockConstraintViolationBuilder, times(0)).addConstraintViolation();
    }

    private void mockUpAnnotationAttributes(Class classes) {
        mockAcceptableCode = mock(AcceptableCodeName.class);
        when(mockAcceptableCode.clazz()).thenReturn(classes);
        when(mockAcceptableCode.message()).thenReturn(BusinessRuleKeys.ERROR_CODE_INVALID.getKey());
        when(mockAcceptableCode.code()).thenReturn("any string");
        codeValidator.initialize(mockAcceptableCode);
    }

    @Test
    public void testAnnotation() {
        MockDto someFieldDto = new MockDto();
        someFieldDto.somefield = "someField";

        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        Validator validator = factory.getValidator();
        Set<ConstraintViolation<MockDto>> violations = validator.validate(someFieldDto);

        // the DAOs are not found by lookup ... so this test always has
        // one violation, there should be one for bad code not for DAO lookup issue
        assertEquals(1, violations.size());
    }

    private class MockDto {

        @AcceptableCodeName(clazz = PrsCtStatusClassCodes.class,
                code = "Status Class")
        public String somefield;
    }
}
