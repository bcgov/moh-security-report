/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.AddressValidationStatsDto;
import ca.bc.gov.health.plr.dto.converter.ProviderDtoConverter;
import ca.bc.gov.health.plr.dto.provider.AddressDto;
import ca.bc.gov.health.plr.ejb.entity.GrsAddresses;
import ca.bc.gov.health.plr.ejb.entity.PrsCtAddressValidTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtCountries;
import ca.bc.gov.health.plr.persistence.CodesDao;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.service.AddressDoctorService;
import ca.bc.gov.health.plr.service.AddressDoctorUnavailableException;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.service.validators.UserChidGenerator;
import ca.bc.gov.health.plr.util.AddressDoctorBackgroundProcessorHelper;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;
import static org.junit.Assert.assertTrue;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 *
 * @author jonathan.wiebe
 */
public class MaintainAddressServiceNonIntegrationTest {

    MaintainAddressService maintainAddressService = new MaintainAddressService();
    AddressDoctorBackgroundProcessorHelper addressDoctorBackgroundProcessorHelper = new AddressDoctorBackgroundProcessorHelper();
    
//    {
//        @Override
//        protected void auditAdminBatchAddressValidChange(GrsAddresses ga) throws DuplicateRecordException {
//            //stub out this method to do nothing
//        }
//    };

    GrsAddresses addr = mock(GrsAddresses.class);
    AddressDoctorService ADSrv = mock(AddressDoctorService.class);
    MaintainProviderService pSrv = mock(MaintainProviderService.class);
    ProviderDtoConverter converter = mock(ProviderDtoConverter.class);

    PrsCtCountries CA = new PrsCtCountries() {
        {
            this.setCtlNameCode("CA");
            this.setCtlDescTxt("Canada");
        }
    };

    PrsCtAddressValidTypes N = new PrsCtAddressValidTypes() {
        {
            this.setCtlNameCode("N");
        }
    };

    PrsCtAddressValidTypes V = new PrsCtAddressValidTypes() {
        {
            this.setCtlNameCode("V");
        }
    };
    PrsCtAddressValidTypes U = new PrsCtAddressValidTypes() {
        {
            this.setCtlNameCode("U");
        }
    };
    PrsCtAddressValidTypes I = new PrsCtAddressValidTypes() {
        {
            this.setCtlNameCode("I");
        }
    };
    CodesDao codesDao = mock(CodesDao.class);
    EntityManager em = mock(EntityManager.class);
    UserChidGenerator userChidGenerator = mock(UserChidGenerator.class);

    @Before
    public void before() throws NoSuchMethodException, AddressDoctorUnavailableException, DuplicateRecordException, BusinessRuleException, EntityValidationException {

        Field emField;
        Field codesDaoField;
        Field addrDField;
        Field mProviderField;
        Field dtoConv;
        Field chidGen;
        Field bkgdProcessor;
        
        try {
            
            bkgdProcessor = MaintainAddressService.class.getDeclaredField("addressDoctorBackgroundProcessorHelper");
            bkgdProcessor.setAccessible(true);
            bkgdProcessor.set(maintainAddressService, addressDoctorBackgroundProcessorHelper);
            
            Field maintainAddressServiceField = AddressDoctorBackgroundProcessorHelper.class.getDeclaredField("maintainAddressService");
            maintainAddressServiceField.setAccessible(true);
            maintainAddressServiceField.set(addressDoctorBackgroundProcessorHelper, maintainAddressService);
            
            emField = MaintainAddressService.class.getDeclaredField("em");
            emField.setAccessible(true);
            emField.set(maintainAddressService, em);

            doNothing().when(em).persist(anyObject());

            chidGen = MaintainAddressService.class.getDeclaredField("chidGenerator");
            chidGen.setAccessible(true);
            chidGen.set(maintainAddressService, userChidGenerator);

            when(userChidGenerator.findSysAddressValUser()).thenReturn("syschid@ere");

            mProviderField = MaintainAddressService.class.getDeclaredField("maintainProviderService");
            mProviderField.setAccessible(true);
            mProviderField.set(maintainAddressService, pSrv);

            when(pSrv.save(isA(AddressDto.class))).thenReturn(new AddressDto());

            dtoConv = MaintainAddressService.class.getDeclaredField("providerDtoConverter");
            dtoConv.setAccessible(true);
            dtoConv.set(maintainAddressService, converter);

            when(converter.buildAddress(isA(GrsAddresses.class))).thenReturn(new AddressDto());

            addrDField = MaintainAddressService.class.getDeclaredField("addressDoctorManager");
            addrDField.setAccessible(true);
            addrDField.set(maintainAddressService, ADSrv);
            when(ADSrv.isValidAddress(eq(addr))).thenReturn(true);

            codesDaoField = MaintainAddressService.class.getDeclaredField("codesDao");
            codesDaoField.setAccessible(true);
            codesDaoField.set(maintainAddressService, codesDao);
            when(codesDao.lookup(PrsCtAddressValidTypes.class, "V")).thenReturn(V);
            when(codesDao.lookup(PrsCtAddressValidTypes.class, "I")).thenReturn(I);
            when(codesDao.lookup(PrsCtAddressValidTypes.class, "U")).thenReturn(U);
            when(codesDao.lookup(PrsCtAddressValidTypes.class, "N")).thenReturn(N);

            when(addr.getCityTxt()).thenReturn("Victoria");
            when(addr.getPostalCodeOrZipTxt()).thenReturn("V8V 8V8");
            when(addr.getCountryCode()).thenReturn(CA);
            when(addr.getProvinceOrStateTxt()).thenReturn("BC");

        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException ex) {
            Logger.getLogger(MaintainAddressServiceNonIntegrationTest.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    @Test
    public void testValidateOldAddresses_ValidAddressStillValid() throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AddressDoctorUnavailableException {

        Method validateOldAddressesMethod = MaintainAddressService.class.getDeclaredMethod("validateOldAddress", GrsAddresses.class);
        validateOldAddressesMethod.setAccessible(true);

        when(ADSrv.isValidAddress(org.mockito.Matchers.eq(addr))).thenReturn(true);
        addr.setValidationStatus(V);
        when(addr.getValidationStatus()).thenReturn(V);

        HashMap<String, Integer> results = (HashMap<String, Integer>) validateOldAddressesMethod.invoke(maintainAddressService, addr);

        assertTrue(results.containsKey(MaintainAddressService.STATUS_CHANGE));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_VALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_INVALID));
        assertTrue(results.get(MaintainAddressService.STATUS_CHANGE) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_VALID) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_INVALID) == 0);
    }

    @Test
    public void testValidateOldAddresses_InValidAddressStillInValid() throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AddressDoctorUnavailableException {

        Method validateOldAddressesMethod = MaintainAddressService.class.getDeclaredMethod("validateOldAddress", GrsAddresses.class);
        validateOldAddressesMethod.setAccessible(true);

        when(ADSrv.isValidAddress(org.mockito.Matchers.eq(addr))).thenReturn(false);
        addr.setValidationStatus(I);
        when(addr.getValidationStatus()).thenReturn(I);

        HashMap<String, Integer> results = (HashMap<String, Integer>) validateOldAddressesMethod.invoke(maintainAddressService, addr);

        assertTrue(results.containsKey(MaintainAddressService.STATUS_CHANGE));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_VALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_INVALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_UNKNOWN));
        assertTrue(results.get(MaintainAddressService.STATUS_TO_UNKNOWN) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_CHANGE) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_VALID) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_INVALID) == 0);
    }

    @Test
    public void testValidateOldAddresses_InValidAddressBecomesValid() throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AddressDoctorUnavailableException {

        Method validateOldAddressesMethod = MaintainAddressService.class.getDeclaredMethod("validateOldAddress", GrsAddresses.class);
        validateOldAddressesMethod.setAccessible(true);

        when(ADSrv.isValidAddress(org.mockito.Matchers.eq(addr))).thenReturn(true);
        addr.setValidationStatus(I);
        when(addr.getValidationStatus()).thenReturn(I);

        HashMap<String, Integer> results = (HashMap<String, Integer>) validateOldAddressesMethod.invoke(maintainAddressService, addr);

        assertTrue(results.containsKey(MaintainAddressService.STATUS_CHANGE));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_VALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_INVALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_UNKNOWN));
        assertTrue(results.get(MaintainAddressService.STATUS_TO_UNKNOWN) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_CHANGE) == 1);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_VALID) == 1);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_INVALID) == 0);
    }

    @Test
    public void testValidateOldAddresses_ValidAddressBecomesInValid() throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AddressDoctorUnavailableException {

        Method validateOldAddressesMethod = MaintainAddressService.class.getDeclaredMethod("validateOldAddress", GrsAddresses.class);
        validateOldAddressesMethod.setAccessible(true);

        when(ADSrv.isValidAddress(org.mockito.Matchers.eq(addr))).thenReturn(false);
        addr.setValidationStatus(V);
        when(addr.getValidationStatus()).thenReturn(V);

        HashMap<String, Integer> results = (HashMap<String, Integer>) validateOldAddressesMethod.invoke(maintainAddressService, addr);

        assertTrue(results.containsKey(MaintainAddressService.STATUS_CHANGE));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_VALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_INVALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_UNKNOWN));
        assertTrue(results.get(MaintainAddressService.STATUS_TO_UNKNOWN) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_CHANGE) == 1);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_VALID) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_INVALID) == 1);
    }

    @Test
    public void testValidateOldAddresses_UnknownAddressBecomesInValid() throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AddressDoctorUnavailableException {

        Method validateOldAddressesMethod = MaintainAddressService.class.getDeclaredMethod("validateOldAddress", GrsAddresses.class);
        validateOldAddressesMethod.setAccessible(true);

        when(ADSrv.isValidAddress(org.mockito.Matchers.eq(addr))).thenReturn(false);
        addr.setValidationStatus(U);
        when(addr.getValidationStatus()).thenReturn(U);

        HashMap<String, Integer> results = (HashMap<String, Integer>) validateOldAddressesMethod.invoke(maintainAddressService, addr);

        assertTrue(results.containsKey(MaintainAddressService.STATUS_CHANGE));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_VALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_INVALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_UNKNOWN));
        assertTrue(results.get(MaintainAddressService.STATUS_TO_UNKNOWN) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_CHANGE) == 1);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_VALID) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_INVALID) == 1);
    }

    @Test
    public void testValidateOldAddresses_UnknownAddressBecomesValid() throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AddressDoctorUnavailableException {

        Method validateOldAddressesMethod = MaintainAddressService.class.getDeclaredMethod("validateOldAddress", GrsAddresses.class);
        validateOldAddressesMethod.setAccessible(true);

        when(ADSrv.isValidAddress(org.mockito.Matchers.eq(addr), anyObject())).thenReturn(true);
        addr.setValidationStatus(U);
        when(addr.getValidationStatus()).thenReturn(U);

        HashMap<String, Integer> results = (HashMap<String, Integer>) validateOldAddressesMethod.invoke(maintainAddressService, addr);

        assertTrue(results.containsKey(MaintainAddressService.STATUS_CHANGE));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_VALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_INVALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_UNKNOWN));
        assertTrue(results.get(MaintainAddressService.STATUS_TO_UNKNOWN) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_CHANGE) == 1);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_VALID) == 1);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_INVALID) == 0);
    }

    @Test
    public void testValidateOldAddresses_UnknownAddressStaysUnknown() throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AddressDoctorUnavailableException {

        Method validateOldAddressesMethod = MaintainAddressService.class.getDeclaredMethod("validateOldAddress", GrsAddresses.class);
        validateOldAddressesMethod.setAccessible(true);

        when(ADSrv.isValidAddress(org.mockito.Matchers.eq(addr))).thenThrow(new AddressDoctorUnavailableException());
        addr.setValidationStatus(U);
        when(addr.getValidationStatus()).thenReturn(U);

        HashMap<String, Integer> results = (HashMap<String, Integer>) validateOldAddressesMethod.invoke(maintainAddressService, addr);

        assertTrue(results.containsKey(MaintainAddressService.STATUS_CHANGE));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_VALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_INVALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_UNKNOWN));
        assertTrue(results.get(MaintainAddressService.STATUS_TO_UNKNOWN) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_CHANGE) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_VALID) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_INVALID) == 0);
    }

    @Test
    public void testValidateOldAddresses_ValidAddressStaysValid() throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AddressDoctorUnavailableException {

        Method validateOldAddressesMethod = MaintainAddressService.class.getDeclaredMethod("validateOldAddress", GrsAddresses.class);
        validateOldAddressesMethod.setAccessible(true);

        when(ADSrv.isValidAddress(org.mockito.Matchers.eq(addr))).thenThrow(new AddressDoctorUnavailableException());
        addr.setValidationStatus(V);
        when(addr.getValidationStatus()).thenReturn(V);

        HashMap<String, Integer> results = (HashMap<String, Integer>) validateOldAddressesMethod.invoke(maintainAddressService, addr);

        assertTrue(results.containsKey(MaintainAddressService.STATUS_CHANGE));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_VALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_INVALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_UNKNOWN));
        assertTrue(results.get(MaintainAddressService.STATUS_TO_UNKNOWN) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_CHANGE) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_VALID) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_INVALID) == 0);
    }

    @Test
    public void testValidateOldAddresses_InValidAddressStaysInValid() throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AddressDoctorUnavailableException {

        Method validateOldAddressesMethod = MaintainAddressService.class.getDeclaredMethod("validateOldAddress", GrsAddresses.class);
        validateOldAddressesMethod.setAccessible(true);

        when(ADSrv.isValidAddress(org.mockito.Matchers.eq(addr))).thenThrow(new AddressDoctorUnavailableException());
        addr.setValidationStatus(I);
        when(addr.getValidationStatus()).thenReturn(I);

        HashMap<String, Integer> results = (HashMap<String, Integer>) validateOldAddressesMethod.invoke(maintainAddressService, addr);

        assertTrue(results.containsKey(MaintainAddressService.STATUS_CHANGE));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_VALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_INVALID));
        assertTrue(results.containsKey(MaintainAddressService.STATUS_TO_UNKNOWN));
        assertTrue(results.get(MaintainAddressService.STATUS_TO_UNKNOWN) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_CHANGE) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_VALID) == 0);
        assertTrue(results.get(MaintainAddressService.STATUS_TO_INVALID) == 0);
    }


    @Ignore
    @Test
    public void testprocessOldAddresses_AllValid() throws NoSuchMethodException, AddressDoctorUnavailableException, Exception {

        when(ADSrv.isValidAddress(any(GrsAddresses.class))).thenReturn(true);

        // this give me a list of 6 addresses, 2 valid, 2 invalid and 2 unknown
        List<GrsAddresses> list = grsAddressesList(6, "Victoria", "BC", CA, "V8V 8V8");
        TypedQuery<GrsAddresses> typedQ = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(GrsAddresses.class))).thenReturn(typedQ);
        when(typedQ.getResultList()).thenReturn(list);

        AddressValidationStatsDto results = maintainAddressService.processOldAddresses();

        assertTrue(results.getNumStatusChanges() == 4);
        assertTrue(results.getNumStatusToInvalid() == 0);
        assertTrue(results.getNumStatusToValid() == 4);
    }


    @Ignore
    @Test
    public void testprocessOldAddresses_AllInValid() throws NoSuchMethodException, AddressDoctorUnavailableException, Exception {

        when(ADSrv.isValidAddress(any(GrsAddresses.class))).thenReturn(false);

        // this give me a list of 6 addresses, 2 valid, 2 invalid and 2 unknown
        List<GrsAddresses> list = grsAddressesList(6, "Victoria", null, CA, null);
        TypedQuery<GrsAddresses> typedQ = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(GrsAddresses.class))).thenReturn(typedQ);
        when(typedQ.getResultList()).thenReturn(list);

        AddressValidationStatsDto results = maintainAddressService.processOldAddresses();

        assertTrue(results.getNumStatusChanges() == 4);
        assertTrue(results.getNumStatusToInvalid() == 4);
        assertTrue(results.getNumStatusToValid() == 0);
    }


    @Ignore
    @Test
    public void testprocessOldAddresses_Exception() throws NoSuchMethodException, AddressDoctorUnavailableException, Exception {

        when(ADSrv.isValidAddress(any(GrsAddresses.class))).thenThrow(new AddressDoctorUnavailableException());

        // this give me a list of 6 addresses, 2 valid, 2 invalid and 2 unknown
        List<GrsAddresses> list = grsAddressesList(6, "Victoria", "BC", CA, "V8V 8V8");
        TypedQuery<GrsAddresses> typedQ = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(GrsAddresses.class))).thenReturn(typedQ);
        when(typedQ.getResultList()).thenReturn(list);

        AddressValidationStatsDto results = maintainAddressService.processOldAddresses();

        assertTrue(results.getNumStatusChanges() == 0);
        assertTrue(results.getNumStatusToInvalid() == 0);
        assertTrue(results.getNumStatusToValid() == 0);
    }


    @Ignore
    @Test
    public void testprocessOldAddresses_NullCity() throws NoSuchMethodException, AddressDoctorUnavailableException, Exception {

        when(ADSrv.isValidAddress(any(GrsAddresses.class))).thenReturn(false);

        // this give me a list of 6 addresses, 2 valid, 2 invalid and 2 unknown
        List<GrsAddresses> list = grsAddressesList(6, null, "BC", CA, "V8V 8V8");
        TypedQuery<GrsAddresses> typedQ = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(GrsAddresses.class))).thenReturn(typedQ);
        when(typedQ.getResultList()).thenReturn(list);

        AddressValidationStatsDto results = maintainAddressService.processOldAddresses();

        assertTrue(results.getNumStatusChanges() == 4);
        assertTrue(results.getNumStatusToInvalid() == 4);
        assertTrue(results.getNumStatusToValid() == 0);
    }


    @Ignore
    @Test
    public void testprocessOldAddresses_EmptyCity() throws NoSuchMethodException, AddressDoctorUnavailableException, Exception {

        when(ADSrv.isValidAddress(any(GrsAddresses.class))).thenReturn(false);

        // this give me a list of 6 addresses, 2 valid, 2 invalid and 2 unknown
        List<GrsAddresses> list = grsAddressesList(6, "", "BC", CA, "V8V 8V8");
        TypedQuery<GrsAddresses> typedQ = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(GrsAddresses.class))).thenReturn(typedQ);
        when(typedQ.getResultList()).thenReturn(list);

        AddressValidationStatsDto results = maintainAddressService.processOldAddresses();

        assertTrue(results.getNumStatusChanges() == 4);
        assertTrue(results.getNumStatusToInvalid() == 4);
        assertTrue(results.getNumStatusToValid() == 0);
    }


    @Ignore
    @Test
    public void testprocessOldAddresses_NullProvince() throws NoSuchMethodException, AddressDoctorUnavailableException, Exception {

        when(ADSrv.isValidAddress(any(GrsAddresses.class))).thenReturn(false);

        // this give me a list of 6 addresses, 2 valid, 2 invalid and 2 unknown
        List<GrsAddresses> list = grsAddressesList(6, "Victoria", null, CA, "V8V 8V8");
        TypedQuery<GrsAddresses> typedQ = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(GrsAddresses.class))).thenReturn(typedQ);
        when(typedQ.getResultList()).thenReturn(list);

        AddressValidationStatsDto results = maintainAddressService.processOldAddresses();

        assertTrue(results.getNumStatusChanges() == 4);
        assertTrue(results.getNumStatusToInvalid() == 4);
        assertTrue(results.getNumStatusToValid() == 0);
    }


    @Ignore
    @Test
    public void testprocessOldAddresses_EmptyProvince() throws NoSuchMethodException, AddressDoctorUnavailableException, Exception {

        when(ADSrv.isValidAddress(any(GrsAddresses.class))).thenReturn(false);

        // this give me a list of 6 addresses, 2 valid, 2 invalid and 2 unknown
        List<GrsAddresses> list = grsAddressesList(6, "Victoria", "", CA, "V8V 8V8");
        TypedQuery<GrsAddresses> typedQ = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(GrsAddresses.class))).thenReturn(typedQ);
        when(typedQ.getResultList()).thenReturn(list);

        AddressValidationStatsDto results = maintainAddressService.processOldAddresses();

        assertTrue(results.getNumStatusChanges() == 4);
        assertTrue(results.getNumStatusToInvalid() == 4);
        assertTrue(results.getNumStatusToValid() == 0);
    }


    @Ignore
    @Test
    public void testprocessOldAddresses_NullCountry() throws NoSuchMethodException, AddressDoctorUnavailableException, Exception {

        when(ADSrv.isValidAddress(any(GrsAddresses.class))).thenReturn(false);

        // this give me a list of 6 addresses, 2 valid, 2 invalid and 2 unknown
        List<GrsAddresses> list = grsAddressesList(6, "Victoria", "BC", null, "V8V 8V8");
        TypedQuery<GrsAddresses> typedQ = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(GrsAddresses.class))).thenReturn(typedQ);
        when(typedQ.getResultList()).thenReturn(list);

        AddressValidationStatsDto results = maintainAddressService.processOldAddresses();

        assertTrue(results.getNumStatusChanges() == 0);
        assertTrue(results.getNumStatusToInvalid() == 0);
        assertTrue(results.getNumStatusToValid() == 0);
    }

    @Ignore
    @Test
    public void testprocessOldAddresses_NullPostal() throws NoSuchMethodException, AddressDoctorUnavailableException, Exception {

        when(ADSrv.isValidAddress(any(GrsAddresses.class))).thenReturn(false);

        // this give me a list of 6 addresses, 2 valid, 2 invalid and 2 unknown
        List<GrsAddresses> list = grsAddressesList(6, "Victoria", "BC", CA, null);
        TypedQuery<GrsAddresses> typedQ = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(GrsAddresses.class))).thenReturn(typedQ);
        when(typedQ.getResultList()).thenReturn(list);

        AddressValidationStatsDto results = maintainAddressService.processOldAddresses();

        assertTrue(results.getNumStatusChanges() == 4);
        assertTrue(results.getNumStatusToInvalid() == 4);
        assertTrue(results.getNumStatusToValid() == 0);
    }


    @Ignore
    @Test
    public void testprocessOldAddresses_EmptyPostal() throws NoSuchMethodException, AddressDoctorUnavailableException, Exception {

        when(ADSrv.isValidAddress(any(GrsAddresses.class))).thenReturn(false);

        // this give me a list of 6 addresses, 2 valid, 2 invalid and 2 unknown
        List<GrsAddresses> list = grsAddressesList(6, "Victoria", "BC", CA, "");
        TypedQuery<GrsAddresses> typedQ = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(GrsAddresses.class))).thenReturn(typedQ);
        when(typedQ.getResultList()).thenReturn(list);

        AddressValidationStatsDto results = maintainAddressService.processOldAddresses();

        assertTrue(results.getNumStatusChanges() == 4);
        assertTrue(results.getNumStatusToInvalid() == 4);
        assertTrue(results.getNumStatusToValid() == 0);
    }

    private List<GrsAddresses> grsAddressesList(int number) {
        return grsAddressesList(number, null, null, null, null);
    }

    private List<GrsAddresses> grsAddressesList(int number, String city, String province, PrsCtCountries country, String postal) {
        List<GrsAddresses> list = new ArrayList<GrsAddresses>();

        for (int i = 0; i < number; i++) {
            GrsAddresses addr = mock(GrsAddresses.class);
            when(addr.getCityTxt()).thenReturn(city);
            when(addr.getProvinceOrStateTxt()).thenReturn(province);
            when(addr.getCountryCode()).thenReturn(country);
            when(addr.getPostalCodeOrZipTxt()).thenReturn(postal);
            addr.setValidationStatus((i % 3 == 0 ? V : (i % 3 == 1 ? I : U)));
            when(addr.getValidationStatus()).thenReturn((i % 3 == 0 ? V : (i % 3 == 1 ? I : U)));
            list.add(addr);
        }
        return list;
    }
}
