package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.provider.ProviderRelationshipDto;
import ca.bc.gov.health.plr.ejb.entity.PrsCtRelationshipTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsProviderRelationships;
import ca.bc.gov.health.plr.ejb.entity.PrsProviders;
import ca.bc.gov.health.plr.persistence.BusinessRuleKeys;
import ca.bc.gov.health.plr.persistence.BusinessRuleMessageDao;
import ca.bc.gov.health.plr.rule.BusinessRuleException;
import ca.bc.gov.health.plr.rule.BusinessRuleMessage;
import ca.bc.gov.health.plr.rule.provider.ProviderTestDataBuilder;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.entityManagerProxy;
import ca.bc.gov.health.plr.service.validators.EntityValidationException;
import ca.bc.gov.health.plr.util.MessageCodeHelper;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.junit.After;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import org.junit.Test;

/**
 * Test class for MaintainProviderRelationshipService.
 *
 * @author David Sharpe <david.a.sharpe@cgi.com>
 */
public class MaintainProviderRelationshipServiceTest extends IntegrationSetup {

    private static final long PAUTH_ID = 12l;

    @After
    public void tearDown() {
        List<Exception> exceptions = new ArrayList<>();

        PrsProviders provider = entityManagerProxy.find(PrsProviders.class, PAUTH_ID);
        for (PrsProviderRelationships relationship : provider.getPrsProviderRelationshipsList1()) {
            try {
                entityManagerProxy.remove(relationship);
            } catch (Exception e) {
                e.printStackTrace();
                exceptions.add(e);
            }
        }
        if (!exceptions.isEmpty()) {
            throw new IllegalStateException("Exceptions occurred while deleting entities. Check log for details.");
        }
    }

    @Test
    public void testAddProviderRelationship() throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        ProviderRelationshipDto newRelationship = ProviderTestDataBuilder.getProviderRelationship();
        newRelationship.setPauthId(PAUTH_ID);

        PrsProviders provider = entityManagerProxy.find(PrsProviders.class, PAUTH_ID);
        int originalCount = provider.getPrsProviderRelationshipsList1().size();

        maintainProviderRelationshipService.save(newRelationship);
        provider = entityManagerProxy.find(PrsProviders.class, PAUTH_ID);
        
        int newCount = provider.getPrsProviderRelationshipsList1().size();
        assertEquals(originalCount + 1, newCount);
    }
    
    // PLR-1745
    @Test
    public void testTargetRelationshipIsReverseOfSpecifiedRelationship() throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        testAddProviderRelationship();
        
        Long newRelationshipTypeId = ProviderTestDataBuilder.getProviderRelationship().getRelationshipTypeId();
        PrsCtRelationshipTypes newRelationshipType = codesDao.lookup(PrsCtRelationshipTypes.class, newRelationshipTypeId);
        String expectedType = newRelationshipType.getReverseRelationship();
        
        PrsProviders provider = entityManagerProxy.find(PrsProviders.class, PAUTH_ID);
        String actualType = provider.getPrsProviderRelationshipsList1().get(0).getTargetProvRelnTypeCode().getCtlNameCode();
        
        assertEquals(expectedType, actualType);
    }
    
    /**
     * When updating a Relationship, the Target Relationship Type should be set
     * to the existing value if the new record does not have it set.
     * 
     * When a user updates a Relationship on the web, the Target Relationship
     * Type will be populated with the existing value, but when a Relationship
     * is updated via messaging, the incoming Relationship will not have Target
     * Relationship Type set, because the HL7 specification does not support 
     * this attribute. 
     */
    @Test
    public void testUpdateProviderRelationship_nullTargetRelationshipType() throws DuplicateRecordException, BusinessRuleException, EntityValidationException {
        testAddProviderRelationship();
        
        PrsProviders provider = entityManagerProxy.find(PrsProviders.class, PAUTH_ID);
        Long reprId = provider.getPrsProviderRelationshipsList1().get(0).getReprId();
        
        ProviderRelationshipDto newRelationship = ProviderTestDataBuilder.getProviderRelationship();
        newRelationship.setPauthId(PAUTH_ID);
        newRelationship.setId(reprId);
        newRelationship.setEndReasonCode("CHG");
        newRelationship.setEffectiveStartDate(new Date());
        
        newRelationship.setTargetRelationshipTypeId(null);
        newRelationship.setTargetRelationshipTypeCode(null);
        
        maintainProviderRelationshipService.save(newRelationship);
    }

    @Test(expected = BusinessRuleException.class)
    public void testNonExistentIdentifier() throws BusinessRuleException, DuplicateRecordException, EntityValidationException {

        ProviderRelationshipDto newRelationship = ProviderTestDataBuilder.getProviderRelationship();
        newRelationship.setPauthId(PAUTH_ID);
        newRelationship.setIdentifier(Long.toString(Long.MAX_VALUE));

        try {
            maintainProviderRelationshipService.save(newRelationship);
        } catch (BusinessRuleException ex) {
            boolean expectedErrorFound = false;
            List<BusinessRuleMessage> messages = ex.getResults().get(0).getMessages();
            for (BusinessRuleMessage businessRuleMessage : messages) {
                if (businessRuleMessage.getMessage().equals(MessageCodeHelper.splitCodeAndMessage(BusinessRuleMessageDao.getMessageResource(BusinessRuleKeys.ERROR_NONUNIQUE_IDENTIFIER))[1])) {
                    expectedErrorFound = true;
                }
            }
            assertTrue(expectedErrorFound);
            throw ex;
        }
    }
    
}
