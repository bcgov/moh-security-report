package ca.bc.gov.health.plr.service.provider;

import ca.bc.gov.health.plr.dto.provider.CollegeIdentifierDto;
import ca.bc.gov.health.plr.dto.provider.OrgNameDto;
import ca.bc.gov.health.plr.dto.provider.PersonNameDto;
import ca.bc.gov.health.plr.dto.provider.ProviderDto;
import ca.bc.gov.health.plr.dto.provider.ProviderType;
import ca.bc.gov.health.plr.dto.provider.search.SearchProviderRequest;
import ca.bc.gov.health.plr.dto.provider.search.SearchProviderResult;
import ca.bc.gov.health.plr.ejb.entity.GrsCtRegIdentifierTypes;
import ca.bc.gov.health.plr.ejb.entity.GrsRegistryUsers;
import ca.bc.gov.health.plr.ejb.entity.PrsCtIdentifierTypes;
import ca.bc.gov.health.plr.ejb.entity.PrsCtProviderRoleTypes;
import ca.bc.gov.health.plr.persistence.CodeTableCodes;
import static ca.bc.gov.health.plr.service.provider.IntegrationSetup.searchProviderService;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.ejb.EJBException;
import static org.hamcrest.Matchers.greaterThan;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import org.junit.Ignore;
import org.junit.Test;

/**
 *
 * @author Grant.Hodgins
 */
public class SearchProviderServiceTest extends IntegrationSetup {

    @Test
    public void testSearchByRegistryIdentifier_dps_noResults() {
        // 00000270 is an HA.
        String identifier = "00000270.BC.PRS";
        // Reg user 3 is RU_TYPE_CODE PSRC, party 3. Permissions on MD.
        GrsRegistryUsers user = new GrsRegistryUsers(3l);
        Long regTypeCodeId = codesDao.lookup(GrsCtRegIdentifierTypes.class, CodeTableCodes.GrsCtRegIdentifierTypes.COMMON_PROVIDER_NUMBER.getValue()).getCtlId();
        List<ProviderDto> result = searchProviderService.searchByRegistryIdentifier(RegistryIdSearch(regTypeCodeId, identifier, false)).getSearchResults();
        assertTrue(result.isEmpty());
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByRegistryIdentifier_dps_results() {
        // 00000265 is a dentist.
        String identifier = "00000265.BC.PRS";
        // Reg user 1 is RU_TYPE_CODE RA, party 1. Permissions on *, HA.
        GrsRegistryUsers user = new GrsRegistryUsers(1l);
        Long regTypeCodeId = codesDao.lookup(GrsCtRegIdentifierTypes.class, CodeTableCodes.GrsCtRegIdentifierTypes.COMMON_PROVIDER_NUMBER.getValue()).getCtlId();
        List<ProviderDto> result = searchProviderService.searchByRegistryIdentifier(RegistryIdSearch(regTypeCodeId, identifier, true)).getSearchResults();
        assertFalse(result.isEmpty());
    }

    @Test
    @Ignore // Needs to be fixed in new sprint
    public void testSearchByIdentifier_twoResults() {
        // 0544786 is an RNID.
        String identifierValue = "99998";
        // Reg user 3 is RU_TYPE_CODE PSRC, party 3. Permissions on MD.
        GrsRegistryUsers user = new GrsRegistryUsers(3l);
        Long idTypeCodeId = codesDao.lookup(PrsCtIdentifierTypes.class, "CPSID").getCtlId();
        List<ProviderDto> results = searchProviderService.searchByIdentifier(CollegeIdSearch(idTypeCodeId, identifierValue, true)).getSearchResults();
        assertTrue(2 == results.size());
    }

    @Test
    public void testSearchByIdentifier_dps_resultsDoNotHaveRnid() {
        // 0544786 is an RNID.
        String identifierValue = "0544786";
        // Reg user 3 is RU_TYPE_CODE PSRC, party 3. Permissions on MD.        
        Long idTypeCodeId = codesDao.lookup(PrsCtIdentifierTypes.class, "PHID").getCtlId();
        List<ProviderDto> result = searchProviderService.searchByIdentifier(CollegeIdSearch(idTypeCodeId, identifierValue, true)).getSearchResults();
        for (ProviderDto provider : result) {
            List<CollegeIdentifierDto> identifiers = provider.getIdentifiers();
            boolean foundRnid = false;
            for (CollegeIdentifierDto identifier : identifiers) {
                String identifierName = identifier.getTypeCode();
                if (identifierName.equals("RNID")) {
                    foundRnid = true;
                }
            }
            assertFalse(String.format("Provider '%d' (PAUTH_ID) has an RNID identifier", provider.getPauthId()), foundRnid);
        }
    }

    @Test
    public void testSearchByIdentifier_dps_resultsHaveRnid() {
        // 0544786 is an RNID.
        String identifierValue = "0544786";
        // Reg user 1 is RU_TYPE_CODE RA, party 1. Permissions on *, HA.
        GrsRegistryUsers user = new GrsRegistryUsers(1l);
        Long idTypeCodeId = codesDao.lookup(PrsCtIdentifierTypes.class, "RNID").getCtlId();
        List<ProviderDto> result = searchProviderService.searchByIdentifier(CollegeIdSearch(idTypeCodeId, identifierValue, true)).getSearchResults();
        for (ProviderDto provider : result) {
            List<CollegeIdentifierDto> identifiers = provider.getIdentifiers();
            boolean foundRnid = false;
            for (CollegeIdentifierDto identifier : identifiers) {
                String identifierName = identifier.getTypeCode();
                if (identifierName.equals("RNID")) {
                    foundRnid = true;
                }
            }
            assertTrue(String.format("Provider '%d' (PAUTH_ID) does not have an RNID identifier", provider.getPauthId()), foundRnid);
        }
    }

    @Test
    public void testSearchByCriteria_dps_noResults() {
        // Reg user 1 No Permissions on RNP.
        long providerTypeId = codesDao.lookup(PrsCtProviderRoleTypes.class, "RNP").getCtlId();
        // Dorothy is an RN.
        SearchProviderResult result = searchProviderService.searchForPractitioner(PractitionerSearch(providerTypeId, "Park", "Juliana", null, true));
        boolean foundDorthy = false;
        for (ProviderDto providerDetails : result.getSearchResults()) {
            for (PersonNameDto name : providerDetails.getIndNames()) {
                if (name.getFirstName().equals("Park") && name.getLastName().equals("Juliana")) {
                    foundDorthy = true;
                }
            }
        }
        assertFalse(foundDorthy);
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByCriteria_dps_results() {
        // Reg user 1 is RU_TYPE_CODE RA, party 1. Permissions on *, HA.
        GrsRegistryUsers regUser = new GrsRegistryUsers(1l);
        long providerTypeId = codesDao.lookup(PrsCtProviderRoleTypes.class, "RN").getCtlId();
        // Dorothy is an RN.
        SearchProviderResult result = searchProviderService.searchForPractitioner(PractitionerSearch(providerTypeId, "Dorothy", "Sargeant", null, true));
        boolean foundDorthy = false;
        for (ProviderDto providerDetails : result.getSearchResults()) {
            for (PersonNameDto name : providerDetails.getIndNames()) {
                if (name.getFirstName().equals("Dorothy") && name.getLastName().equals("Sargeant")) {
                    foundDorthy = true;
                }
            }
        }
        assertTrue("Dorothy Sargeant not found", foundDorthy);
    }

    /**
     * Test that Search finds Providers without addresses associated with them.
     *
     * Test for bug, https://jira.vic.cgi.com/browse/PLR-535.
     */
    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByCriteria_noAddressAssociated() {
        // Reg user 1 is RU_TYPE_CODE RA, party 1. Permissions on *, HA.
        GrsRegistryUsers regUser = new GrsRegistryUsers(1l);
        long providerTypeId = codesDao.lookup(PrsCtProviderRoleTypes.class, "MD").getCtlId();
        // Tao has no addresses associated with him.
        SearchProviderResult result = searchProviderService.searchForPractitioner(PractitionerSearch(providerTypeId, "T*", "X*", null, true));
        boolean foundTao = false;
        for (ProviderDto providerDetails : result.getSearchResults()) {
            for (PersonNameDto name : providerDetails.getIndNames()) {
                if (name.getFirstName().equals("Tao") && name.getLastName().equals("Xiong")) {
                    foundTao = true;
                    assertEquals(Collections.emptyList(), providerDetails.getAddresses());
                }
            }
        }
        assertTrue("Tao Xiong not found", foundTao);
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchForOrganization_dps_noResults() {
        // Reg user 3 is RU_TYPE_CODE PSRC, party 3. Permissions on MD.
        GrsRegistryUsers regUser = new GrsRegistryUsers(3l);
        long providerTypeId = codesDao.lookup(PrsCtProviderRoleTypes.class, "HA").getCtlId();
        // VIHA is an HA.
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerTypeId, "VIHA", "Victoria", true));
        boolean foundViha = false;
        for (ProviderDto providerDetails : result.getSearchResults()) {
            for (OrgNameDto orgName : providerDetails.getOrgNames()) {
                if (orgName.getName().equals("VIHA")) {
                    foundViha = true;
                }
            }
        }
        assertFalse(foundViha);
    }

    @Test
    public void testSearchForOrganization_confidential() {
        // Reg user 3 is RU_TYPE_CODE PSRC, party 3. Permissions on MD.
        GrsRegistryUsers regUser = new GrsRegistryUsers(3l);
        long providerTypeId = codesDao.lookup(PrsCtProviderRoleTypes.class, "HA").getCtlId();
        // VIHA is an HA.
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerTypeId, "oadekvBEFHIJNOQRZ", "orgcit", true));
        assertTrue(result.getMessages().size() == 1);
        assertTrue(result.getSearchResults().isEmpty());
    }

    @Test
    public void testSearchForOrganization_caseInsensitive_andConfidential() {
        // Reg user 1 is RU_TYPE_CODE RA, party 1. Permissions on *, HA.
        GrsRegistryUsers regUser = new GrsRegistryUsers(1l);
        long providerTypeId = codesDao.lookup(PrsCtProviderRoleTypes.class, "HA").getCtlId();
        // VIHA is an HA.
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerTypeId, "oaDekvBEFHIJNOQRZ", "orgCIT", true));
        assertTrue(result.getMessages().size() == 1);
        assertTrue(result.getSearchResults().isEmpty());
    }

    @Test
    public void testSearchForOrganization_dps_results() {
        // Reg user 1 is RU_TYPE_CODE RA, party 1. Permissions on *, HA.
        GrsRegistryUsers regUser = new GrsRegistryUsers(1l);
        long providerTypeId = codesDao.lookup(PrsCtProviderRoleTypes.class, "HA").getCtlId();
        // VIHA is an HA.
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerTypeId, "VIHA", "Victoria", true));
        boolean foundViha = false;
        for (ProviderDto providerDetails : result.getSearchResults()) {
            for (OrgNameDto orgName : providerDetails.getOrgNames()) {
                if (orgName.getName().equals("VIHA")) {
                    foundViha = true;
                }
            }
        }
        assertTrue(foundViha);
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByIdentifier_knownPostive_oneResult() {
        long identifierTypeId = 1504l;
        String identifier = "0718596";
        List<ProviderDto> result = searchProviderService.searchByIdentifier(CollegeIdSearch(identifierTypeId, identifier, true)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.size() == 1);
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByIdentifier_noDuplicates() {
        // 3298 is DENIS on WEB9D.
        long identifierTypeId = 3298l;
        String identifier = "1234567890";
        SearchProviderResult result = searchProviderService.searchByIdentifier(CollegeIdSearch(identifierTypeId, identifier, true));
        List<ProviderDto> resultList = result.getSearchResults();
        assertNotNull(resultList);
        assertEquals(1, resultList.size());
    }

    @Test
    public void testSearchByIdentifier_excludeHistory() {
        // 4261 is HAID on WEB9D.
        long identifierTypeId = 4261l;
        String identifier = "HA1";
        List<ProviderDto> result = searchProviderService.searchByIdentifier(CollegeIdSearch(identifierTypeId, identifier, false)).getSearchResults();
        assertNotNull(result);
        assertEquals(1, result.size());
    }

    @Test
    public void testSearchByIdentifier_includeHistory() {
        // 4261 is HAID on WEB9D.
        long identifierTypeId = 4261l;
        String identifier = "HA1";
        List<ProviderDto> result = searchProviderService.searchByIdentifier(CollegeIdSearch(identifierTypeId, identifier, true)).getSearchResults();
        assertNotNull(result);
        //Logically deleted records will not be returned when searching with identifier, so changing expected from 2 to 1
        assertEquals(1, result.size());
    }

    @Test
    public void testSearchByIdentifier_knownNegative_noResults() {
        String identifier = "Beeef";
        long identifierTypeId = 1504l;
        List<ProviderDto> result = searchProviderService.searchByIdentifier(CollegeIdSearch(identifierTypeId, identifier, true)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testSearchByProviderId_knownInput_withResult() {
        Long providerId = 11L;
        ProviderDto result = searchProviderService.searchByProviderId(providerId);
        assertNotNull(result);
    }

    @Test
    public void testSearchByProviderId_knownInput_withConfidentialResult() {
        Long providerId = 3301L;
        ProviderDto result = searchProviderService.searchByProviderId(providerId);
        assertNotNull(result);
        assertTrue(result.isConfidential());
        //this provider has address records however they are removed based on the confidentiality rules.
        assertTrue(result.getAddresses().isEmpty());
    }

    @Test
    public void testSearchByProviderId_unknownInput_noResult() {
        Long providerId = 23847239423L;
        ProviderDto result = searchProviderService.searchByProviderId(providerId);
        assertNull(result);
    }

    @Test
    public void testSearchByProviderId_nullInput_noResult() {
        Long providerId = null;
        ProviderDto result = null;
        try {
            result = searchProviderService.searchByProviderId(providerId);
        } catch (EJBException e) {
            Exception theCause = e.getCausedByException();
            assertTrue(theCause instanceof NullPointerException);
        }
        assertNull(result);
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByRegistryIdentifier_knownPositive_oneResult() {
        String identifier = "00000008.BC.PRS";
        Long regTypeCodeId = codesDao.lookup(GrsCtRegIdentifierTypes.class, CodeTableCodes.GrsCtRegIdentifierTypes.COMMON_PROVIDER_NUMBER.getValue()).getCtlId();
        List<ProviderDto> result = searchProviderService.searchByRegistryIdentifier(RegistryIdSearch(regTypeCodeId, identifier, true)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.size() == 1);
    }

    @Test
    public void testSearchByRegistryIdentifier_excludeHistory() {
        String identifier = "00000271.BC.PRS";
        Long regTypeCodeId = codesDao.lookup(GrsCtRegIdentifierTypes.class, CodeTableCodes.GrsCtRegIdentifierTypes.COMMON_PROVIDER_NUMBER.getValue()).getCtlId();
        List<ProviderDto> result = searchProviderService.searchByRegistryIdentifier(RegistryIdSearch(regTypeCodeId, identifier, false)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testSearchByRegistryIdentifier_includeHistory() {
        String identifier = "00000001.BC.PRS";
        Long regTypeCodeId = codesDao.lookup(GrsCtRegIdentifierTypes.class, CodeTableCodes.GrsCtRegIdentifierTypes.COMMON_PROVIDER_NUMBER.getValue()).getCtlId();
        List<ProviderDto> result = searchProviderService.searchByRegistryIdentifier(RegistryIdSearch(regTypeCodeId, identifier, true)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.size() == 1);
    }

    @Test
    public void testSearchByRegistryIdentifier_knownNegative_noResults() {
        String identifier = "Pumpkin";
        Long regTypeCodeId = codesDao.lookup(GrsCtRegIdentifierTypes.class, CodeTableCodes.GrsCtRegIdentifierTypes.COMMON_PROVIDER_NUMBER.getValue()).getCtlId();
        List<ProviderDto> result = searchProviderService.searchByRegistryIdentifier(RegistryIdSearch(regTypeCodeId, identifier, true)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByCriteria_knownPositive_oneResult() {
        long providerRoleTypeId = 817l;
        String firstName = "Lise";
        String lastName = "Olsen";
        String city = "Vancouver";
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.size() == 1);
    }

    @Test
    public void testSearchByCritiera_excludeHistory_firstName() {
        long providerRoleTypeId = 817l;
        String firstName = "Sarah";
        String lastName = "N*";
        String city = null;
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, false)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByCritiera_includeHistory_firstName() {
        long providerRoleTypeId = 817l;
        String firstName = "Sarah";
        String lastName = "N*";
        String city = null;
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true)).getSearchResults();
        assertNotNull(result);
        assertTrue(!result.isEmpty());
    }

    @Test
    public void testSearchByCritiera_excludeHistory_city() {
        // 1176 is MD on WEB9D.
        long providerRoleTypeId = 1176l;
        String firstName = "First00001";
        String lastName = "Provider00001";
        String city = "Yale00001";
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, false)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByCritiera_includeHistory_city() {
        // 1176 is MD on WEB9D.
        long providerRoleTypeId = 1176l;
        String firstName = "FirstZeroZeroZeroZeroOne";
        String lastName = "ProviderZeroZeroZeroZeroOne";
        String city = "YaleZeroZeroZeroZeroOne";
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true)).getSearchResults();
        assertNotNull(result);
        assertTrue(!result.isEmpty());
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByCriteria_wildcard_multipleResults() {
        // 817 is RN on WEB9D.
        long providerRoleTypeId = 817l;
        String firstName = "D*";
        String lastName = "S*";
        String city = null;
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true)).getSearchResults();
        assertNotNull(result);
        assertThat(Long.valueOf(result.size()), greaterThan(Long.valueOf(1)));
    }

    @Test
    public void testSearchByCriteria_knownNegative_noResults() {
        // 1176 is MD on WEB9D.
        long providerRoleTypeId = 1176l;
        String firstName = "Garbage";
        String lastName = "Mcgillicuddy";
        String city = "Whoville";
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testSearchByCriteria_nullInputs_nullResults_message() {
        Long providerRoleTypeId = null;
        String firstName = null;
        String lastName = null;
        String city = null;
        SearchProviderResult result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true));
        assertFalse(result.getMessages().isEmpty());
        assertTrue(result.getSearchResults().isEmpty());
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByCriteria_manyResults_truncateResults() {
        long providerRoleTypeId = 1176l;
        String firstName = "z*";
        String lastName = "a*";
        String city = "";
        SearchProviderResult result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true));
        assertNotNull(result);
        assertEquals(configurationDao.getMaxSearchResults(), result.getSearchResults().size());
        assertFalse(result.getMessages().isEmpty());
    }

    /**
     * Test that only trailing wild cards are processed: wild cards anywhere
     * else should be treated literally.
     */
    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByCriteria_lastName_middleWildcard_noResults() {
        long providerRoleTypeId = 817l;
        String firstName = "G*";
        String lastName = "B*";
        String city = "Victoria";
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true)).getSearchResults();
        assertNotNull(result);
        assertEquals(2, result.size());

        // If the middle wild-card is processed, the same results would be returned.
        lastName = "B*y*";
        result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true)).getSearchResults();
        assertTrue(result.isEmpty());
    }

    /**
     * Test that only trailing wild cards are processed: wild cards anywhere
     * else should be treated literally.
     */
    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByCriteria_firstName_middleWildcard_noResults() {
        long providerRoleTypeId = 817l;
        String firstName = "G*";
        String lastName = "B*";
        String city = "Victoria";
        SearchProviderResult result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true));
        assertEquals(2, result.getSearchResults().size());
        assertTrue(result.getMessages().isEmpty());

        // If the middle wild-card is processed, the same results would be returned.
        firstName = "G*n*";
        result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true));
        assertTrue(result.getSearchResults().isEmpty());
        assertFalse(result.getMessages().isEmpty());
    }

    @Test
    public void testSearchByCriteria_wildCardOnly_nullResults_message() {
        long providerRoleTypeId = 817l;
        String firstName = "*";
        String lastName = "B*";
        String city = "Victoria";
        SearchProviderResult result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true));
        assertTrue(result.getSearchResults().isEmpty());
        assertFalse(result.getMessages().isEmpty());
    }

    @Test
    /** The query approves the search results have records found and is not empty.
     * select * from PRS_PROVIDERS p left join PRS_CT_PROVIDER_ROLE_TYPES r on P.HPT_CODE=R.CTL_ID
     * left join GRS_PERSON_NAMES n on N.PAUTH_PAUTH_ID=P.PAUTH_ID
     * left join GRS_ADDRESSES addr on ADDR.PAUTH_PAUTH_ID=P.PAUTH_ID
     * where N.PRSN_SURNAME_TXT like 'B%' and  ADDR.CITY_TXT='Victoria' and P.HPT_CODE=817;
     */
    public void testSearchByCriteria_missingFirstName_nullResults_message() {
        long providerRoleTypeId = 817l;
        String firstName = null;
        String lastName = "B*";
        String city = "Victoria";
        SearchProviderResult result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true));
        assertFalse(result.getSearchResults().isEmpty());
        assertTrue(result.getMessages().isEmpty());
    }

    @Test
    public void testSearchByCritiera_noDuplicatesSecondTest() {
        // 1176 is MD on WEB9D.
        long providerRoleTypeId = 1176l;
        String firstName = "B*";
        String lastName = "H*";
        String city = null;
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true)).getSearchResults();
        Set<Long> ids = new HashSet<>();
        for (ProviderDto providerDetails : result) {
            ids.add(providerDetails.getPauthId());
        }
        assertEquals(ids.size(), result.size());
    }

    @Test
    public void testSearchByCritiera_noDuplicates() {
        // 1176 is MD on WEB9D.
        long providerRoleTypeId = 1176l;
        String firstName = "FirstZeroZeroZeroZeroOne";
        String lastName = "ProviderZeroZeroZeroZeroOne";
        String city = null;
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true)).getSearchResults();
        Set<Long> ids = new HashSet<>();
        for (ProviderDto providerDetails : result) {
            ids.add(providerDetails.getPauthId());
        }
        assertEquals(ids.size(), result.size());
    }

    @Test
    public void testSearchForOrganization() {
        // 5490 is "HA", "Health Authority" in WEB9D.
        long providerRoleType = 5490l;
        String orgName = "VIHA";
        String addressCity = "Victoria";
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerRoleType, orgName, addressCity, true));
        assertEquals(1, result.getSearchResults().size());
        assertEquals(443l, (long) result.getSearchResults().get(0).getPauthId());
    }

    @Test
    public void testSearchForOrganization_withDescription() {
        // 5490 is "HA", "Health Authority" in WEB9D.
        long providerRoleType = 5490l;
        String orgName = "oadghiklmorxyEKNORWX";
        String addressCity = "Orgcit";
        String orgLongName = "afhloqrsyzBCDEGHNPRTUVX";
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerRoleType, orgName, addressCity, true));
        assertEquals(1, result.getSearchResults().size());
        assertEquals(3504l, (long) result.getSearchResults().get(0).getPauthId());
    }

    @Test
    public void testSearchForOrganization_withDescription_noCity() {
        // 5490 is "HA", "Health Authority" in WEB9D.
        long providerRoleType = 5490l;
        String orgName = "oadghiklmorxyEKNORWX";
        String orgLongName = "afhloqrsyzBCDEGHNPRTUVX";
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerRoleType, orgName, null, true));
        assertEquals(1, result.getSearchResults().size());
        assertEquals(3504l, (long) result.getSearchResults().get(0).getPauthId());
    }

    @Test
    public void testSearchForOrganization_withDescription_wildCards() {
        // 5490 is "HA", "Health Authority" in WEB9D.
        long providerRoleType = 5490l;
        String orgName = "oadghiklmorxyEKNORW*";
        String orgLongName = "af*";
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerRoleType, orgName, null, true));
        assertEquals(1, result.getSearchResults().size());
        assertEquals(3504l, (long) result.getSearchResults().get(0).getPauthId());
    }

    @Test
    public void testSearchForOrganization_excludeHistory() {
        // 5490 is "HA", "Health Authority" in WEB9D.
        long providerRoleType = 5490l;
        String orgName = "VIHA";
        String addressCity = "Lud";
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerRoleType, orgName, addressCity, false));
        assertTrue(result.getSearchResults().isEmpty());
    }

    @Test
    public void testSearchForOrganization_includeHistory() {
        // 5490 is "HA", "Health Authority" in WEB9D.
        long providerRoleType = 5490l;
        String orgName = "oadghiklmorxyEKNORWX";
        String addressCity = "Orgcit";
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerRoleType, orgName, addressCity, true));
        assertEquals(1, result.getSearchResults().size());
        assertEquals(3504, (long) result.getSearchResults().get(0).getPauthId());
    }
    
    @Test
    public void testSearchForOrganization_wildcard_someResults() {
        // 5490 is "HA", "Health Authority" in WEB9D.
        long providerRoleType = 5490l;
        String orgName = "VIH*";
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerRoleType, orgName, null, true));
        assertFalse(result.getSearchResults().isEmpty());
    }
    
    @Test
    public void testSearchForOrganization_middleWildcard_someResults() {
        // 5490 is "HA", "Health Authority" in WEB9D.
        long providerRoleType = 5490l;
        // Each wildcard should match 0 or more characters
        String orgName = "VI*H*";
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerRoleType, orgName, null, true));
        assertFalse(result.getSearchResults().isEmpty());
    }
    
    @Test
    public void testSearchForOrganization_middleWildcard_noResults() {
        // 5490 is "HA", "Health Authority" in WEB9D.
        long providerRoleType = 5490l;
        String orgName = "L*rd*OfTheRing*";
        SearchProviderResult result = searchProviderService.searchForOrganization(OrgSearch(providerRoleType, orgName, null, true));
        assertTrue(result.getSearchResults().isEmpty());
    }

    @Test
    @Ignore  // Test needs to be fixed to reflect fropping support for * in user permission
    public void testSearchByCriteria_searchLogged() {
        long searchLogSize = getSearchLogCount();

        long providerRoleTypeId = 817l;
        String firstName = "L*";
        String lastName = "O*";
        String city = "Vancouver";
        searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, city, true)).getSearchResults();

        assertEquals(searchLogSize + 1, getSearchLogCount());
    }

    @Test
    public void testSearchByRegistryIdentifier_searchLogged() {
        long searchLogSize = getSearchLogCount();

        String identifier = "00000008.BC.PRS";
        Long regTypeCodeId = codesDao.lookup(GrsCtRegIdentifierTypes.class, CodeTableCodes.GrsCtRegIdentifierTypes.COMMON_PROVIDER_NUMBER.getValue()).getCtlId();
        searchProviderService.searchByRegistryIdentifier(RegistryIdSearch(regTypeCodeId, identifier, true)).getSearchResults();

        assertEquals(searchLogSize + 1, getSearchLogCount());
    }

    @Test
    public void testSearchByIdentifier_searchLogged() {
        long searchLogSize = getSearchLogCount();

        String identifierValue = "99998";
        // Reg user 3 is RU_TYPE_CODE PSRC, party 3. Permissions on MD.
        GrsRegistryUsers user = new GrsRegistryUsers(3l);
        Long idTypeCodeId = codesDao.lookup(PrsCtIdentifierTypes.class, "CPSID").getCtlId();
        searchProviderService.searchByIdentifier(CollegeIdSearch(idTypeCodeId, identifierValue, true)).getSearchResults();

        assertEquals(searchLogSize + 1, getSearchLogCount());
    }

    @Test
    public void testSearchForOrganization_searchLogged() {
        long searchLogSize = getSearchLogCount();

        // 5490 is "HA", "Health Authority" in WEB9D.
        long providerRoleType = 5490l;
        String orgName = "VIHA";
        String addressCity = "Victoria";
        searchProviderService.searchForOrganization(OrgSearch(providerRoleType, orgName, addressCity, true));

        assertEquals(searchLogSize + 1, getSearchLogCount());
    }

    @Ignore
    @Test
    public void testSearchAllAvailableProviders() {
        List<Long> providerIds = entityManagerProxy.findAllProviderIds();
        System.out.println("Found " + providerIds.size() + " providers");
        for (Long id : providerIds) {
            ProviderDto details = searchProviderService.searchByProviderId(id);
            if (details != null) {
                System.out.println("Assembled pauth_id: " + id);
            } else {
                System.out.println("Failed to assemble pauth_id: " + id);
                break;
            }
            assertNotNull(details);
        }
    }
    
    @Test
    public void testCheckIfLogicallyDeletedCollegeIds_Individual_False() {
        ProviderDto details = new ProviderDto();
        details.setProviderType(ProviderType.PRACTITIONER);
        details.setIdentifiers(new ArrayList<CollegeIdentifierDto>());
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 1, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 2, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CHANGE, 3, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CORRECT, 4, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 1, "HA3"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 2, "HA3"));
        details.setIndNames(new ArrayList<PersonNameDto>());
        details.getIndNames().add(buildPerson(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 1, "MOH"));
        details.getIndNames().add(buildPerson(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 2, "MOH"));
        details.getIndNames().get(1).setUpdatable(true);
        boolean deleted = searchProviderService.checkIfLogicallyDeleted(details);
        assertFalse(deleted);        
    }
    
    @Test
    public void testCheckIfLogicallyDeletedCollegeIds_Individual_True() {
        ProviderDto details = new ProviderDto();
        details.setProviderType(ProviderType.PRACTITIONER);
        details.setIdentifiers(new ArrayList<CollegeIdentifierDto>());
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CHANGE, 1, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CHANGE, 2, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CHANGE, 3, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 4, "MOH"));
        details.getIdentifiers().add(buildCollegeId(null, 1, "HA3"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 2, "HA3"));
        details.setIndNames(new ArrayList<PersonNameDto>());
        details.getIndNames().add(buildPerson(null, 1, "MOH"));
        details.getIndNames().add(buildPerson(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 2, "MOH"));
        boolean deleted = searchProviderService.checkIfLogicallyDeleted(details);
        assertTrue(deleted);        
    }
    
    @Test
    public void testCheckIfLogicallyDeletedCollegeIds_Organization_False() {
        ProviderDto details = new ProviderDto();
        details.setProviderType(ProviderType.ORGANIZATION);
        details.setIdentifiers(new ArrayList<CollegeIdentifierDto>());
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 1, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 2, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CHANGE, 3, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CORRECT, 4, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 1, "HA3"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 2, "HA3"));
        details.getIdentifiers().get(1).setUpdatable(true);
        details.setOrgNames(new ArrayList<OrgNameDto>());
        details.getOrgNames().add(buildOrg(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 1, "MOH"));
        details.getOrgNames().add(buildOrg(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 2, "MOH"));
        
        boolean deleted = searchProviderService.checkIfLogicallyDeleted(details);
        assertFalse(deleted);        
    }
    
    @Test
    public void testCheckIfLogicallyDeletedCollegeIds_Organization_True() {
        ProviderDto details = new ProviderDto();
        details.setProviderType(ProviderType.ORGANIZATION);
        details.setIdentifiers(new ArrayList<CollegeIdentifierDto>());
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CHANGE, 1, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CHANGE, 2, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CHANGE, 3, "MOH"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 4, "MOH"));
        details.getIdentifiers().add(buildCollegeId(null, 1, "HA3"));
        details.getIdentifiers().add(buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 2, "HA3"));
        details.setOrgNames(new ArrayList<OrgNameDto>());
        details.getOrgNames().add(buildOrg(null, 1, "MOH"));
        details.getOrgNames().add(buildOrg(CodeTableCodes.GrsCtEndReasonTypes.CEASE, 2, "MOH"));
        boolean deleted = searchProviderService.checkIfLogicallyDeleted(details);
        assertTrue(deleted);        
    }
    
    @Test
    public void testSearchByCriteria_licenseStatusCancel_noResults() {
        // 1176 is MD on WEB9D.
        long providerRoleTypeId = 1176l;
        String firstName = "Garbage";
        String lastName = "Mcgillicuddy";
        long licenseStatusCd = 4273; // CANCELLED
        String licenseStatusReasonCd = null;
        List<ProviderDto> result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, licenseStatusCd, licenseStatusReasonCd, true)).getSearchResults();
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testSearchByCriteria_nullInputs_ForlicenseStatusReason_nullResults() {
        Long providerRoleTypeId = null;
        String firstName = null;
        String lastName = null;
        long licenseStatusCd = 4268; // ACTIVE
        String licenseStatusReasonCd = null;
        SearchProviderResult result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, licenseStatusCd, licenseStatusReasonCd, true));
        assertFalse(result.getMessages().isEmpty());
        assertTrue(result.getSearchResults().isEmpty());
    }
    
    @Test
    public void testSearchByCriteria_licenseStatusReason_WithnullInputs_nullResults_message() {
        Long providerRoleTypeId = null;
        String firstName = null;
        String lastName = null;
        Long licenseStatusCd = null;
        String licenseStatusReasonCd = null;
        SearchProviderResult result = searchProviderService.searchForPractitioner(PractitionerSearch(providerRoleTypeId, firstName, lastName, licenseStatusCd, licenseStatusReasonCd, true));
        assertFalse(result.getMessages().isEmpty());
        assertTrue(result.getSearchResults().isEmpty());
    }

    private long getSearchLogCount() {
        return (long) entityManagerProxy.query("select count(e) from GrsDataAccessEvents e").get(0);
    }

    private CollegeIdentifierDto buildCollegeId(CodeTableCodes.GrsCtEndReasonTypes endreason, long genNum, String dataOwner) {
        CollegeIdentifierDto dto = new CollegeIdentifierDto();
        dto.setDataOwnerCode(dataOwner);
        dto.setTypeId(1l);
        dto.setEndReasonCode(endreason!=null?endreason.getValue():null);
        dto.setGenerationNum(genNum);
        dto.setUpdatable(false);
        return dto;
    }
    private PersonNameDto buildPerson(CodeTableCodes.GrsCtEndReasonTypes endreason, long genNum, String dataOwner) {
        PersonNameDto dto = new PersonNameDto();
        dto.setDataOwnerCode(dataOwner);
        dto.setTypeId(1l);
        dto.setEndReasonCode(endreason!=null?endreason.getValue():null);
        dto.setGenerationNum(genNum);
        dto.setUpdatable(false);
        return dto;
    }
    private OrgNameDto buildOrg(CodeTableCodes.GrsCtEndReasonTypes endreason, long genNum, String dataOwner) {
        OrgNameDto dto = new OrgNameDto();
        dto.setDataOwnerCode(dataOwner);
        dto.setTypeId(1l);
        dto.setEndReasonCode(endreason!=null?endreason.getValue():null);
        dto.setGenerationNum(genNum);
        dto.setUpdatable(false);
        return dto;
    }
    
    private SearchProviderRequest RegistryIdSearch(Long regTypeCodeId,String identifier, boolean historyFlag){
        SearchProviderRequest providerRequest = new SearchProviderRequest();
        providerRequest.setRegistryIdentifierTypeCodeId(regTypeCodeId);
        providerRequest.setRegistryIdentifier(identifier);
        providerRequest.setHistoryFlag(historyFlag);
        return providerRequest;
    }
    private SearchProviderRequest CollegeIdSearch(Long identifierTypeId,String identifier, boolean historyFlag){
        SearchProviderRequest providerRequest = new SearchProviderRequest();
        providerRequest.setIdentifierTypeId(identifierTypeId);
        providerRequest.setIdentifier(identifier);
        providerRequest.setHistoryFlag(historyFlag);
        return providerRequest;
    }
    private SearchProviderRequest PractitionerSearch(Long providerTypeId,String firstName, String lastName, String city, boolean historyFlag){
        SearchProviderRequest providerRequest = new SearchProviderRequest();
        providerRequest.setProviderRoleTypeId(providerTypeId);
        providerRequest.setCity(city);
        providerRequest.setFirstName(firstName);
        providerRequest.setLastName(lastName);
        providerRequest.setHistoryFlag(historyFlag);
        return providerRequest;
    }
    
    private SearchProviderRequest PractitionerSearch(Long providerTypeId, String firstName, String lastName, Long licenseStatusCd, String licenseStatusReasonCd, boolean historyFlag) {
        SearchProviderRequest providerRequest = new SearchProviderRequest();
        providerRequest.setProviderRoleTypeId(providerTypeId);
        providerRequest.setFirstName(firstName);
        providerRequest.setLastName(lastName);
        providerRequest.setLicenseStatusCd(licenseStatusCd);
        providerRequest.setLicenseStatusReasonCd(licenseStatusReasonCd);
        providerRequest.setHistoryFlag(historyFlag);
        return providerRequest;
    }
    
    private SearchProviderRequest OrgSearch(Long providerTypeId,String orgName, String orgLongName, String city, boolean historyFlag){
        SearchProviderRequest providerRequest = new SearchProviderRequest();
        providerRequest.setProviderRoleTypeId(providerTypeId);
        providerRequest.setCity(city);
        providerRequest.setOrganizationProviderName(orgName);
        providerRequest.setOrganizationProviderLongName(orgLongName);
        providerRequest.setHistoryFlag(historyFlag);
        return providerRequest;
    }
    
    private SearchProviderRequest OrgSearch(Long providerTypeId,String orgName, String city, boolean historyFlag){
        return OrgSearch(providerTypeId, orgName, null, city, historyFlag);
    }

}
