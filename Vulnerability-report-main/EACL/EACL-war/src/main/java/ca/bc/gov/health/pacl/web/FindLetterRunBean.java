/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.pacl.web;

import ca.bc.gov.health.jsf.BaseBean;
import static ca.bc.gov.health.jsf.BaseBean.addErrorMessage;
import static ca.bc.gov.health.jsf.BaseBean.addInfoMessage;
import ca.bc.gov.health.pacl.ejb.entity.AdminOptionsMsp;
import ca.bc.gov.health.pacl.ejb.entity.ApplicationAuditDtlLog;
import ca.bc.gov.health.pacl.ejb.entity.ApplicationAuditLog;
import ca.bc.gov.health.pacl.ejb.entity.CodesProjectStatus;
import ca.bc.gov.health.pacl.ejb.entity.LetterMspDetail;
import ca.bc.gov.health.pacl.ejb.entity.PracSvaProject;
import ca.bc.gov.health.pacl.ejb.entity.Project;
import ca.bc.gov.health.pacl.ejb.session.AdminOptionsMspFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.ApplicationAuditLogFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.CodesProjectStatusFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.CodesProjectTypeFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.PracSvaProjectFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.ProjectFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.ProjectSvaFacadeLocal;
import ca.bc.gov.health.pacl.service.EmailService;
import ca.bc.gov.health.pacl.util.PaclConstants;
import ca.bc.gov.health.pacl.util.Util;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.enterprise.context.SessionScoped;
import jakarta.faces.context.FacesContext;
import jakarta.inject.Named;
import jakarta.servlet.http.HttpServletResponse;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import org.primefaces.component.datatable.DataTable;
import org.primefaces.event.CellEditEvent;
import org.primefaces.model.DefaultStreamedContent;
import org.primefaces.model.StreamedContent;

/**
 * Backing bean for finding letter run and displaying letter run summary.
 *
 * @author michael.tremblay
 */
@Named("findLetterRun")
@SessionScoped
public class FindLetterRunBean extends BaseBean {

    private static ResourceBundle bundle = ResourceBundle.getBundle("MessageResources", FacesContext.getCurrentInstance().getViewRoot().getLocale());

    @EJB
    private AdminOptionsMspFacadeLocal adminOptionsMspFacade;

    private static Logger logger = Logger.getLogger(FindLetterRunBean.class.getName());
    /**
     * new value for the practitioner code.
     */
    private String pracCode;
    /**
     * new value for the SVA project code.
     */
    private String svaProjectCode;
    /**
     * new value for the practitioner last name.
     */
    private String pracLastName;
    /**
     * new value for the practitioner first name.
     */
    private String pracFirstName;
    /**
     * new value for the letter run date.
     */
    private Date letterRunDate;
    /**
     * new value for the letter run year.
     */
    private String letterRunYear;
    /**
     * new value for the letter run status.
     */
    private Long letterRunStatus;

    private String auditReasonDesc;

    private StringBuilder ReportCSV;

    private StreamedContent ReportCSVfile;


    /*
     * Email service instance for editing.
     */
    private EmailService emailService = new EmailService(PaclConstants.SERVER_EMAIL_HOST, PaclConstants.EACL_SYSTEM_NAME);

    /**
     * Facade for persistence.
     */
    @EJB
    private transient ProjectSvaFacadeLocal projectSvaFacade;
    @EJB
    private transient ProjectFacadeLocal projectFacade;
    @EJB
    private transient PracSvaProjectFacadeLocal pracSvaProjectFacade;
    @EJB
    private transient CodesProjectTypeFacadeLocal codesProjectTypeFacade;
    @EJB
    private transient ApplicationAuditLogFacadeLocal applicationAuditLogFacade;
    @EJB
    private transient CodesProjectStatusFacadeLocal codesProjectStatusFacade;
    /**
     * The instances we're currently editing.
     */
    private Project project;


    /**
     * Values to display in Statistical Report
     */
    private int letterMailedTotal;
    private int letterNotDeliverTotal;
    private int letterDeliverTotal;
    private int letterReturnsTotal;
    private int letterAnomalyPercentageTotal;
    private int letterReturnsPercentageTotal;
    private int letterAnomalyTotal;
    private int svaProjectListSize;

    /**
     * This index is set from the screen when the user selects a search result
     * item the index is used to retrieve the letter run details from the letter
     * run(s) list.
     */
    private Integer selectedIndex;
    /**
     * List of search results to display.
     */
    private List<Project> letterRunResults = new ArrayList<>();
    private List<Project> letterRunResultsSelected = new ArrayList<>();

    /**
     * new value for letter run selection checkbox.
     */
    private boolean letterRunSelected = false;

    /**
     * Value that allows the Statistical report to be displayed
     */
    private Boolean displayStats = false;

    /**
     * Default constructor.
     */
    public FindLetterRunBean() {
        super();
    }

    /**
     * Initializes this bean after injection is complete.
     */
    @PostConstruct
    public void init() {
        clear();
    }

    /**
     * Clears the state of this bean.
     *
     * @return
     */
    public String clear() {
        project = new Project();
        project.setProjectTypeId(codesProjectTypeFacade.findByName("Random Monthly Audit"));
        project.setStatusId(new CodesProjectStatus());
        letterRunResults = projectSvaFacade.findRecentSVA();

        letterRunResultsSelected = new ArrayList<>();

        logger.log(Level.INFO, "letter runs size = ".concat(String.valueOf(letterRunResults.size())));
        return null;
    }

    /**
     * Function that resets the datatable to it's initial state
     */
    public void resetTable() {
        if (!FacesContext.getCurrentInstance().getPartialViewContext().isAjaxRequest()) {
            DataTable dataTable = (DataTable) FacesContext.getCurrentInstance().getViewRoot().findComponent("manageProjectForm:resultsTable");
     
            letterRunResults = projectSvaFacade.findRecentSVA();
            
            dataTable.reset();
        }
    }

    /**
     * Retrieves the project records based on the user selection criteria.
     *
     * @return String
     */
    public String findLetterRun() {

        DataTable dataTable = (DataTable) FacesContext.getCurrentInstance().getViewRoot().findComponent("manageProjectForm:resultsTable");
        dataTable.reset();

        // validate the form fields
        if (!validateFindLetterRun()) {
            return null;
        }
        String letterRunDateString = letterRunDate != null ? letterRunDate.toString() : "";
        logger.log(Level.INFO, "search param before query = "
                .concat(" pracLastName = ").concat(pracLastName)
                .concat(" pracFirstName = ").concat(pracFirstName)
                .concat(" pracCode = ").concat(pracCode)
                .concat(" svaProjectCode = ").concat(svaProjectCode)
                .concat(" letterRunYear = ").concat(String.valueOf(letterRunYear))
                .concat(" letterRunStatus = ").concat(String.valueOf(letterRunStatus))
                .concat(" letterRun date = ").concat(letterRunDateString));
        letterRunResults = projectSvaFacade.findLetterRunBySearchCriteria(
                pracLastName, pracFirstName, pracCode, svaProjectCode, letterRunDate,
                letterRunYear, letterRunStatus);

        // add info message if there are no project records to display
        if (letterRunResults.isEmpty()) {
            addWarnMessage(bundle.getString("letterRun.Search.NoResult"));
        }
        letterRunDate = null;
        return null;
    }

    /**
     * Code to format the date to the specific format
     *
     * @param dateToFormat
     * @return String
     */
    public String dateFormatter(Date dateToFormat) {

        if (dateToFormat != null) {
            return new SimpleDateFormat("yyyy-MM-dd").format(dateToFormat);
        } else {
            return "";
        }
    }

    /**
     * Validates user input search criteria and practitioner code format from
     * HI.
     *
     * @return boolean
     */
    public boolean validateFindLetterRun() {

        boolean isNotError = true;

        // verify that search criteria has at least one input field value
        if (Util.notEmpty(pracLastName) || Util.notEmpty(pracFirstName)
                || Util.notEmpty(pracCode)
                || Util.notEmpty(letterRunYear)
                || Util.notEmpty(svaProjectCode)
                || letterRunStatus != null
                || letterRunDate != null) {

            // TODO! validate the practitioner code format from HI
            if (Util.notEmpty(pracCode)) {
                if (pracCode.length() != 5 && pracCode.length() != 6) {
                    addErrorMessage(bundle.getString("letterRun.Search.PracFormat"));
                    isNotError = false;
                }
            }

            //Validates sva project format
            Pattern p = Pattern.compile("[MSms][0-9]{2}\\d");
            if (Util.notEmpty(svaProjectCode)) {
                if (!p.matcher(svaProjectCode).lookingAt()) {
                    addErrorMessage(bundle.getString("letterRun.Search.SvaNameFormat"));
                    isNotError = false;
                }
            }
        } else {
            addErrorMessage(bundle.getString("letterRun.Search.NoInput"));
            isNotError = false;
        }
        return isNotError;
    }

    /**
     * Nullifies any child objects which don't have valid PKs set.
     */
    private void nullify() {
        if (project.getProjectTypeId() != null && project.getProjectTypeId().getId() == null) {
            project.setProjectTypeId(null);
        }
        if (project.getStatusId() != null && project.getStatusId().getId() == null) {
            project.setStatusId(null);
        }
    }

    /**
     * Method used to save the date when a datatable cell is edited
     *
     * @param event
     */
    public void onCellEdit(CellEditEvent event) {

        Project projectEdit = (Project) ((DataTable) event.getComponent()).getRowData();
        projectSvaFacade.edit(projectEdit);

        addInfoMessage(bundle.getString("letterRun.Search.AuditReasonSaved"));
    }

    /**
     * Method to disable the Audit reason modification depending on project type
     *
     * @param p
     * @return
     */
    public boolean disableAuditReason(Project p) {

        boolean disableAudit = true;

        if (p.getProjectTypeId().getName().equals(PaclConstants.RANDOM_MONTHLY_TYPE)) {
            disableAudit = false;
        }

        return disableAudit;
    }

    /**
     * Method that redirects the user to the Letter Run details page
     *
     * @param projectToView
     * @return String
     */
    public final String showDetailsForSvaProjectAction(Project projectToView) {

        if (projectToView != null) {
            FacesContext.getCurrentInstance().getExternalContext().getFlash().put("projectToView", (long) projectToView.getId());
            

            // Create Audit log
            ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("View Letter Run Details");
            List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Application Username", findUserName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Details: Name", projectToView.getName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Details: Month", projectToView.getProjectMonth()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Details: Year", projectToView.getProjectYear()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Details: Id", (projectToView.getId().toString())));

            applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
            applicationAuditLogFacade.create(applicationAuditLog);
            return "LetterRunDetails.xhtml?faces-redirect=true";
        }

        return "manageLetterRuns.xhtml";
    }

    /**
     * Method used to close the selected letter runs
     *
     * @return String
     */
    public String closeLetterRun() {
        nullify();

        // verify if the project was already archived when select close function
        if (verifyProjectArchived()) {
            return null;
        }

        // Create Audit log
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Letter Run(s) Closed Details");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Application Username", findUserName()));

        Date closedDate = new Date();
        for (Project projectForUpdate : letterRunResultsSelected) {
            if (!validateOpenSvaProject(projectForUpdate)) {
                projectForUpdate.setClosedDate(closedDate);
                projectForUpdate.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_CLOSE));
                projectFacade.editWithReturn(projectForUpdate);

                // auditing log project close details
                logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Close Details: Name", projectForUpdate.getName()));
                logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Close Details: Month", projectForUpdate.getProjectMonth()));
                logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Close Details: Year", projectForUpdate.getProjectYear()));
                logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Close Details: Id", (projectForUpdate.getId().toString())));

                //Check if the project has exceed daysBeforeArchive or is due to expired in less than SECOND_REMINDER_EMAIL
                Date projectCreateDate = project.getCreatedOnDtm();
                AdminOptionsMsp adminOptions = adminOptionsMspFacade.findDefaultPatientLimit().get(0);
                // get system admin email
                String serverAdminEmail = adminOptions.getServerAdminEmail();

                Calendar cal = Calendar.getInstance();
                cal.setTime(projectCreateDate);
                // get total days until the project is archived
                cal.add(Calendar.HOUR, 24 * (int) (adminOptions.getDaysBeforeArchive()));
                Date projectTimeoutDate = cal.getTime();
                Date todayDate = new Date();

                //Get number of day before the project will be archived
                int dayBeforeArchive = (int) ((projectTimeoutDate.getTime() - todayDate.getTime()) / (1000 * 60 * 60 * 24));

                //if project should already been archived, set the value to 0
                if (dayBeforeArchive < 0) {
                    dayBeforeArchive = 0;
                }
                //Check if the project will be archive in less than the number of day that the second Email reminder is send
                if (dayBeforeArchive < adminOptions.getSecondReminderEmail()) {
                    emailService.sendEmailNotifications(
                            project,
                            dayBeforeArchive, serverAdminEmail);
                }
            } else {
                addErrorMessage(bundle.getString("letterRun.Search.CloseError"));
                return null;
            }

        }

        // set auditing detail logs and saved audit records in database for closed projects
        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        // display info message for closing the selected projects
        addInfoMessage(bundle.getString("letterRun.Search.CloseSuccess"));

        init();
        return null;
    }

    /**
     * Validates if the letter run contains SVA projects thats are still open
     *
     * @param p
     * @return boolean
     */
    public boolean validateOpenSvaProject(Project p) {

        boolean isOpen = false;

        List<PracSvaProject> listSva = pracSvaProjectFacade.findSvaByProjectId(p);

        for (PracSvaProject sva : listSva) {
            if (sva.getSvaProjectStatusId().getName().equals(PaclConstants.PROJECT_STATUS_OPEN)) {
                isOpen = true;

                return isOpen;
            }
        }
        return isOpen;
    }

    /**
     * Method used to archive a letter run
     *
     * @return boolean
     */
    public String archiveLetterRun() {
        nullify();

        // verify if the project was closed before archive
        if (!verifyProjectClose()) {
            return null;
        }

        // Create Audit log
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Letter Run(s) Archive Details");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Application Username", findUserName()));

        Date archiveDate = new Date();
        for (Project projectForUpdate : letterRunResultsSelected) {

            projectForUpdate.setArchivedDate(archiveDate);
            projectForUpdate.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_ARCHIVE));
            projectFacade.editWithReturn(projectForUpdate);

            // auditing log project close details
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Archive Details:Name", projectForUpdate.getName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Archive Details:Month", projectForUpdate.getProjectMonth()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Archive Details:Year", projectForUpdate.getProjectYear()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Archive Details:Id", (projectForUpdate.getId().toString())));

        }

        // set auditing detail logs and saved audit records in database for archived projects
        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        addInfoMessage(bundle.getString("letterRun.Search.ArchiveSuccess"));
        letterRunResultsSelected = new ArrayList<>();

        init();
        return null;
    }

    public final boolean verifyProjectClose() {

        boolean isNotError = true;
        // check if selected project status is 'Closed'
        List<Project> projectsToArchive = new ArrayList<>();
        List<Project> projectSelections = new ArrayList<>();
        for (Project projectForUpdate : letterRunResultsSelected) {

            projectSelections.add(projectForUpdate);
            if (projectForUpdate.getClosedDate() == null && !PaclConstants.PROJECT_STATUS_CLOSE.equals(projectForUpdate.getStatusId().getName())) {
                projectsToArchive.add(projectForUpdate);
            }
        }
        // check if projects were not selected and display warn message
        if (projectSelections.isEmpty()) {
            addWarnMessage(bundle.getString("letterRun.Search.NoSelectedRun"));
            isNotError = false;
        }
        // display an error message if selected project status is not 'Closed'
        if (!projectsToArchive.isEmpty()) {
            addErrorMessage(bundle.getString("letterRun.Search.ArchiveError"));
            isNotError = false;
        }

        return isNotError;
    }

    /**
     * Verify if project is archived when user re-select to close it.
     *
     * @return boolean
     */
    public final boolean verifyProjectArchived() {

        boolean isError = false;
        // create new lists for project selections/archived/closed
        List<Project> projectsArchived = new ArrayList<>();
        List<Project> projectSelections = new ArrayList<>();
        List<Project> projectsClosed = new ArrayList<>();
        for (Project projectForUpdate : letterRunResultsSelected) {

            projectSelections.add(projectForUpdate);
            if (projectForUpdate.getArchivedDate() == null && PaclConstants.PROJECT_STATUS_ARCHIVE.equals(projectForUpdate.getStatusId().getName())) {
                projectsArchived.add(projectForUpdate);
            }
            if (projectForUpdate.getClosedDate() != null && PaclConstants.PROJECT_STATUS_CLOSE.equals(projectForUpdate.getStatusId().getName())) {
                projectsClosed.add(projectForUpdate);
            }
        }
        // check if projects were not selected and display warn message
        if (projectSelections.isEmpty()) {
            addWarnMessage(bundle.getString("letterRun.Search.NoSelectedRun"));
            isError = true;
        }
        // display an error message if selected project status is 'Archived'
        // and user selects Close function
        if (!projectsArchived.isEmpty()) {
            addErrorMessage(bundle.getString("letterRun.Search.ArchiveButAlreadyClosed"));
            isError = true;
        }
        // display an error message if selected projects were already closed
        if (!projectsClosed.isEmpty()) {
            addErrorMessage(bundle.getString("letterRun.Search.AlreadyClosed"));
            isError = true;
        }
        return isError;
    }

    /**
     * Verify if project archived when user selects statistical report function.
     *
     * @return boolean
     */
    public final boolean verifyIfArchived() {

        boolean isError = false;
        // create new lists for project selections/archived
        List<Project> projectsArchived = new ArrayList<>();
        List<Project> projectSelections = new ArrayList<>();
        for (Project projectForUpdate : letterRunResultsSelected) {

            projectSelections.add(projectForUpdate);
            if (projectForUpdate.getArchivedDate() == null && PaclConstants.PROJECT_STATUS_ARCHIVE.equals(projectForUpdate.getStatusId().getName())) {
                projectsArchived.add(projectForUpdate);
            }
        }
        // check if projects were not selected and display warn message
        if (projectSelections.isEmpty()) {
            addWarnMessage(bundle.getString("letterRun.Search.NoSelectedRun"));
            isError = true;
        }
        // display an error message if selected project status is 'Archived'
        // and user selects Close function
        if (!projectsArchived.isEmpty()) {
            addErrorMessage(bundle.getString("letterRun.Search.ArchiveButAlreadyClosed"));
            isError = true;
        }
        return isError;
    }

    /**
     * Show statistical report for the selected projects.
     *
     * @return String
     */
    public String showStatisticalReport() {
        nullify();
        if (letterRunResultsSelected.isEmpty()) {
            setDisplayStats(false);
            addWarnMessage(bundle.getString("letterRun.Search.NoSelectedRun"));
            return null;
        }
        setDisplayStats(true);
        // verify if the project was already archived when selecting
        // statistical report function
        if (verifyIfArchived()) {
            return null;
        }

        // Create Audit log for Statistical Report
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Statistical Report Project(s)");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Statistical Report Username", findUserName()));

        // test statistical report
        // calculate statistical data for the selected projects
        calculateStatisticalInfo(letterRunResultsSelected, logDetailList, applicationAuditLog);

        // set auditing detail logs and create audit records in database for
        // Statistical Report projects selected
        logger.log(Level.INFO, "logDetailList size = ".concat(String.valueOf(logDetailList.size())));
        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        // display info message for statistical reports selected projects
        addInfoMessage(bundle.getString("letterRun.Search.StatisticalReportDisplayed"));
        generateReportCSV();
        return null;
    }

    /**
     * Sub-method to calculate statistical data and audit logs for the selected
     * projects.
     *
     * @param projectsForStatistics List<Project> - list of selected projects to
     * calculate statistics
     * @param logDetailList List<ApplicationAuditDtlLog> - list of auditing
     * detail logs for the selected project
     * @param applicationAuditLog ApplicationAuditLog - application audit log
     * object when create new record for statistics
     *
     */
    public void calculateStatisticalInfo(
            List<Project> projectsForStatistics,
            List<ApplicationAuditDtlLog> logDetailList,
            ApplicationAuditLog applicationAuditLog) {
        letterMailedTotal = 0;
        letterNotDeliverTotal = 0;
        letterDeliverTotal = 0;
        letterReturnsTotal = 0;
        letterAnomalyPercentageTotal = 0;
        letterReturnsPercentageTotal = 0;
        letterAnomalyTotal = 0;
        svaProjectListSize = 0;
        int letterAnomalyPercentageTotalTemp = 0;
        int letterReturnsPercentageTotalTemp = 0;

        for (Project projectForUpdate : letterRunResultsSelected) {

            project = projectForUpdate;
            List<PracSvaProject> svaPerProject = projectForUpdate.getPracSvaProjectList();
            if (!svaPerProject.isEmpty()) {
                project.setPracSvaProjectList(svaPerProject);
            }
            logger.log(Level.INFO, "Sva Project List size = ".concat(String.valueOf(project.getPracSvaProjectList().size())));
            int totalMailed = 0;
            int totalNotDelivered = 0;
            int totalAnomalies = 0;
            int totalDelivered = 0;
            int totalReturnsPerProject = 0;
            for (PracSvaProject svaProject : project.getPracSvaProjectList()) {

                List<LetterMspDetail> lettersSvaProject = svaProject.getLetterMspDetailList();
                List<LetterMspDetail> lettersMailed = new ArrayList<>();
                List<LetterMspDetail> lettersNonDelivered = new ArrayList<>();
                List<LetterMspDetail> lettersConfirmed = new ArrayList<>();
                List<LetterMspDetail> lettersAnomaly = new ArrayList<>();
                logger.log(Level.INFO, "letter list size = ".concat(String.valueOf(lettersSvaProject.size())));
                if (!lettersSvaProject.isEmpty()) {
                    for (LetterMspDetail statLetter : lettersSvaProject) {

                        // add Letter to lettersMailed list
                        if (statLetter.getLetterPrintedFlag() == PaclConstants.LETTER_PRINTED_FLAG
                                && statLetter.getLetterDate() != null) {
                            lettersMailed.add(statLetter);
                        }

                        // add Letter to lettersNonDelivered list
                        if (PaclConstants.LETTER_NON_DELIVERED.equals(statLetter.getStatusId().getName())) {
                            lettersNonDelivered.add(statLetter);
                        }

                        // add Letter to lettersConfirmed list
                        if (PaclConstants.LETTER_CONFIRMED.equals(statLetter.getStatusId().getName())) {
                            lettersConfirmed.add(statLetter);
                        }

                        // add Letter to lettersAnomaly list
                        if (PaclConstants.LETTER_ANOMALY.equals(statLetter.getStatusId().getName())) {
                            lettersAnomaly.add(statLetter);
                        }

                        logger.log(Level.INFO, "lettersMailed list size = ".concat(String.valueOf(lettersMailed.size())));
                        logger.log(Level.INFO, "lettersNonDelivered list size = ".concat(String.valueOf(lettersNonDelivered.size())));
                        logger.log(Level.INFO, "lettersConfirmedlist size = ".concat(String.valueOf(lettersConfirmed.size())));
                        logger.log(Level.INFO, "lettersAnomaly list size = ".concat(String.valueOf(lettersAnomaly.size())));
                    }
                    if (!lettersMailed.isEmpty()) {
                        svaProject.setLetterMailed(lettersMailed.size());
                    }
                    if (!lettersNonDelivered.isEmpty()) {
                        svaProject.setLetterNonDelivered(lettersNonDelivered.size());
                    }

                    // add condition for negative numbers
                    int letterDeliver;
                    if (lettersNonDelivered.size() < lettersMailed.size()) {
                        letterDeliver = lettersMailed.size() - lettersNonDelivered.size();
                    } else {
                        letterDeliver = 0; // temp for percentage calculations
                    }
                    svaProject.setLetterDelivered(letterDeliver);

                    // setup total letters returned with status Confirmed and Anomaly
                    int letterTotalReturn = 0;
                    if (!lettersConfirmed.isEmpty() || !lettersAnomaly.isEmpty()) {
                        letterTotalReturn = lettersConfirmed.size() + lettersAnomaly.size();
                    } else if (!lettersConfirmed.isEmpty() && !lettersAnomaly.isEmpty()) {
                        letterTotalReturn = 0;
                    }
                    svaProject.setLetterTotalReturns(letterTotalReturn);

                    // setup total letters returned with Anomaly
                    int letterReturnAnomaly;
                    if (!lettersAnomaly.isEmpty()) {
                        letterReturnAnomaly = lettersAnomaly.size();
                    } else {
                        letterReturnAnomaly = 0; // temp for percentage calculations
                    }
                    svaProject.setLetterTotalAnomaly(letterReturnAnomaly);

                    // setup total percentage of letters returned and for
                    // total letters percentage with anomaly
                    int letterTotalPercentReturn;
                    int letterTotalPercentAnomaly;
                    if (letterDeliver > 0) {
                        letterTotalPercentReturn = (int) Math.round((100.0 * letterTotalReturn) / letterDeliver);
                        logger.log(Level.INFO, "letterTotalPercentReturn = ".concat(String.valueOf(letterTotalPercentReturn)));
                        letterTotalPercentAnomaly = (int) Math.round((100.0 * letterReturnAnomaly) / letterDeliver);
                        logger.log(Level.INFO, "letterTotalPercentAnomaly = ".concat(String.valueOf(letterTotalPercentAnomaly)));
                    } else {
                        letterTotalPercentReturn = 0;
                        letterTotalPercentAnomaly = 0;
                    }
                    svaProject.setLetterTotalPercentReturns(letterTotalPercentReturn);
                    svaProject.setLetterTotalPercentAnomaly(letterTotalPercentAnomaly);
                }
                //Calculate all Total per Letter Run
                totalMailed += svaProject.getLetterMailed();
                totalNotDelivered += svaProject.getLetterNonDelivered();
                totalDelivered += svaProject.getLetterDelivered();
                totalAnomalies += svaProject.getLetterTotalAnomaly();
                logger.log(Level.INFO, "totalMailed size = ".concat(String.valueOf(totalMailed)));
                logger.log(Level.INFO, "totalNotDelivered size = ".concat(String.valueOf(totalNotDelivered)));
                logger.log(Level.INFO, "totalDelivered size = ".concat(String.valueOf(totalDelivered)));
                logger.log(Level.INFO, "totalDelivered size = ".concat(String.valueOf(totalAnomalies)));
                totalReturnsPerProject += svaProject.getLetterTotalReturns();
            }
            if (totalMailed != 0) {
                letterReturnsPercentageTotalTemp = (int) Math.round((100.0 * totalReturnsPerProject) / totalMailed);
                letterAnomalyPercentageTotalTemp = (int) Math.round((100.0 * totalAnomalies) / totalMailed);
            } else {
                project.setLetterAnomalyPercentageTotal(0);
                project.setLetterReturnsPercentageTotal(0);
            }
            project.setLetterAnomalyPercentageTotal(letterAnomalyPercentageTotalTemp);
            project.setLetterReturnsPercentageTotal(letterReturnsPercentageTotalTemp);
            project.setLetterMailedTotal(totalMailed);
            project.setLetterNotDeliverTotal(totalNotDelivered);
            project.setLetterDeliverTotal(totalDelivered);
            project.setLetterReturnsPerProjectTotal(totalReturnsPerProject);
            project.setLetterAnomalyTotal(totalAnomalies);

            // auditing log for Statistical Report on selected projects
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Statistical Report Project: Id", project.getId().toString()));

            //Calulate Grand Total
            letterMailedTotal += totalMailed;
            letterNotDeliverTotal += totalNotDelivered;
            letterDeliverTotal += totalDelivered;
            letterReturnsTotal += totalReturnsPerProject;

            letterAnomalyTotal += totalAnomalies;
        }
        if (letterMailedTotal != 0) {
            letterAnomalyPercentageTotal = ((int) Math.round((100.0 * letterAnomalyTotal) / letterMailedTotal));
            letterReturnsPercentageTotal = ((int) Math.round((100.0 * letterReturnsTotal) / letterMailedTotal));
        } else {
            letterAnomalyPercentageTotal = 0;
            letterReturnsPercentageTotal = 0;
        }

    }

    /**
     * Method to round the percentages to 1 decimal
     *
     * @param value
     * @param precision
     * @return
     */
    private static double round(double value, int precision) {
        int scale = (int) Math.pow(10, precision);
        return (double) Math.round(value * scale) / scale;
    }

    /**
     *
     * Pre-generate the CSV Report
     */
    public void generateReportCSV() {
        ReportCSV = new StringBuilder();
        ReportCSV.append("sep=,\n");
        ReportCSV.append("\"Letter Run Name\",\"Practitioner Code-SVA Project\","
                + "\"Letters Mailed\",\"Letters Not Delivered\","
                + "\"Letters Delivered\",\"Total Returns\",\"% Total Returns\","
                + "\"Total Anomalies\",\"% Total Anomalies\"\n");

//Display the Grand Total
        ReportCSV.append("\"Grand Total" + "\",");
        ReportCSV.append("\"" + "\",");
        ReportCSV.append("\"").append(letterMailedTotal).append("\",");
        ReportCSV.append("\"").append(letterNotDeliverTotal).append("\",");
        ReportCSV.append("\"").append(letterDeliverTotal).append("\",");
        ReportCSV.append("\"").append(letterReturnsTotal).append("\",");
        ReportCSV.append("\"").append(letterReturnsPercentageTotal).append("%\",");
        ReportCSV.append("\"").append(letterAnomalyTotal).append("\",");
        ReportCSV.append("\"").append(letterAnomalyPercentageTotal).append("%\"\n");
        for (Project projectForUpdate : letterRunResultsSelected) {

            project = projectForUpdate;
            // exporting report totals summary values for each project
            ReportCSV.append("\"Letter Run Summary Totals" + "\",");
            ReportCSV.append("\"").append(project.getName()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterMailedTotal()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterNotDeliverTotal()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterDeliverTotal()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterReturnsPerProjectTotal()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterReturnsPercentageTotal()).append("%\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterAnomalyTotal()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterAnomalyPercentageTotal()).append("%\"\n");
            for (PracSvaProject svaProject : project.getPracSvaProjectList()) {

                // exporting report for each Sva Project per selected project
                ReportCSV.append("\"").append(project.getName()).append("\",");
                ReportCSV.append("\"").append(svaProject.getPracBllgNum()).append("-").append(svaProject.getSvaProjectCode()).append("\",");
                ReportCSV.append("\"").append(svaProject.getLetterMailed()).append("\",");
                ReportCSV.append("\"").append(svaProject.getLetterNonDelivered()).append("\",");
                ReportCSV.append("\"").append(svaProject.getLetterDelivered()).append("\",");
                ReportCSV.append("\"").append(svaProject.getLetterTotalReturns()).append("\",");
                ReportCSV.append("\"").append(svaProject.getLetterTotalPercentReturns()).append("%\",");
                ReportCSV.append("\"").append(svaProject.getLetterTotalAnomaly()).append("\",");
                ReportCSV.append("\"").append(svaProject.getLetterTotalPercentAnomaly()).append("%\"\n");
            }

        }
        byte[] bytes = ReportCSV.toString().getBytes();
        /*
                 * Get ByteArrayInputStream from byte array.
         */
        InputStream inputStream = new ByteArrayInputStream(bytes);
        ReportCSVfile = DefaultStreamedContent.builder().contentType("text/csv").name("StatisticalReportExport.csv").stream(() -> (inputStream)).build();

    }

    /**
     * Export statistical report for selected projects as CSV.
     *
     * @return String
     */
    public String exportReportCSV() {
        setDisplayStats(false);
        HttpServletResponse response = (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();
        response.setContentType("text/csv");
        response.setHeader("content-disposition", "attachment;filename=StatisticalReportExport.csv");
        try (PrintWriter out = response.getWriter()) {
            out.print(ReportCSV.toString());
            addInfoMessage(bundle.getString("letterRun.Search.StatisticalReportExported"));

        } catch (Exception e) {
            addErrorMessage(bundle.getString("letterRun.Search.StatisticalReportExportError") + e.getMessage());
        }
        return null;
    }

    /* Getters and Setters */
    public Project getProject() {
        return project;
    }

    public void setProject(Project project) {
        this.project = project;
    }

    public Integer getSelectedIndex() {
        return selectedIndex;
    }

    public void setSelectedIndex(Integer selectedIndex) {
        this.selectedIndex = selectedIndex;
    }

    public String getPracCode() {
        return pracCode;
    }

    public void setPracCode(String pracCode) {
        this.pracCode = pracCode;
    }

    public String getPracLastName() {
        return pracLastName;
    }

    public void setPracLastName(String pracLastName) {
        this.pracLastName = pracLastName;
    }

    public String getPracFirstName() {
        return pracFirstName;
    }

    public void setPracFirstName(String pracFirstName) {
        this.pracFirstName = pracFirstName;
    }

    public Date getLetterRunDate() {
        return letterRunDate;
    }

    public void setLetterRunDate(Date letterRunDate) {
        this.letterRunDate = letterRunDate;
    }

    public String getLetterRunYear() {
        return letterRunYear;
    }

    public void setLetterRunYear(String letterRunYear) {
        this.letterRunYear = letterRunYear;
    }

    public Long getLetterRunStatus() {
        return letterRunStatus;
    }

    public void setLetterRunStatus(Long letterRunStatus) {
        this.letterRunStatus = letterRunStatus;
    }

    public List<Project> getLetterRunResults() {
        return letterRunResults;
    }

    public void setLetterRunResults(List<Project> letterRunResults) {
        this.letterRunResults = letterRunResults;
    }

    public boolean isLetterRunSelected() {
        return letterRunSelected;
    }

    public void setLetterRunSelected(boolean letterRunSelected) {
        this.letterRunSelected = letterRunSelected;
    }

    public String getSvaProjectCode() {
        return svaProjectCode;
    }

    public void setSvaProjectCode(String svaProjectCode) {
        this.svaProjectCode = svaProjectCode;
    }

    public String getAuditReasonDesc() {
        return auditReasonDesc;
    }

    public void setAuditReasonDesc(String auditReasonDesc) {
        this.auditReasonDesc = auditReasonDesc;
    }

    public List<Project> getLetterRunResultsSelected() {
        return letterRunResultsSelected;
    }

    public void setLetterRunResultsSelected(List<Project> letterRunResultsSelected) {
        this.letterRunResultsSelected = letterRunResultsSelected;
    }

    public Boolean getDisplayStats() {
        return displayStats;
    }

    public void setDisplayStats(Boolean displayStats) {
        this.displayStats = displayStats;
    }

    public int getLetterMailedTotal() {
        return letterMailedTotal;
    }

    public void setLetterMailedTotal(int letterMailedTotal) {
        this.letterMailedTotal = letterMailedTotal;
    }

    public int getLetterNotDeliverTotal() {
        return letterNotDeliverTotal;
    }

    public void setLetterNotDeliverTotal(int letterNotDeliverTotal) {
        this.letterNotDeliverTotal = letterNotDeliverTotal;
    }

    public int getLetterDeliverTotal() {
        return letterDeliverTotal;
    }

    public void setLetterDeliverTotal(int letterDeliverTotal) {
        this.letterDeliverTotal = letterDeliverTotal;
    }

    public int getLetterReturnsTotal() {
        return letterReturnsTotal;
    }

    public void setLetterReturnsTotal(int letterReturnsTotal) {
        this.letterReturnsTotal = letterReturnsTotal;
    }

    public int getLetterAnomalyPercentageTotal() {
        return letterAnomalyPercentageTotal;
    }

    public void setLetterAnomalyPercentageTotal(int letterAnomalyPercentageTotal) {
        this.letterAnomalyPercentageTotal = letterAnomalyPercentageTotal;
    }

    public int getLetterReturnsPercentageTotal() {
        return letterReturnsPercentageTotal;
    }

    public void setLetterReturnsPercentageTotal(int letterReturnsPercentageTotal) {
        this.letterReturnsPercentageTotal = letterReturnsPercentageTotal;
    }

    public int getLetterAnomalyTotal() {
        return letterAnomalyTotal;
    }

    public void setLetterAnomalyTotal(int letterAnomalyTotal) {
        this.letterAnomalyTotal = letterAnomalyTotal;
    }

    public int getSvaProjectListSize() {
        return svaProjectListSize;
    }

    public void setSvaProjectListSize(int svaProjectListSize) {
        this.svaProjectListSize = svaProjectListSize;
    }

    public StreamedContent getReportCSVfile() {
        return ReportCSVfile;
    }

    public void setReportCSVfile(StreamedContent ReportCSVfile) {
        this.ReportCSVfile = ReportCSVfile;
    }

}
