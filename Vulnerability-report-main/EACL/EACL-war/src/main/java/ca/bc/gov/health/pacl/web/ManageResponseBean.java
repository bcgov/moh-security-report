package ca.bc.gov.health.pacl.web;

import ca.bc.gov.health.jsf.BaseBean;
import ca.bc.gov.health.pacl.ejb.entity.*;
import ca.bc.gov.health.pacl.ejb.session.*;
import ca.bc.gov.health.pacl.util.Util;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.context.FacesContext;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;

/**
 * Backing bean for manage letter responses.
 *
 * @author dan.stepanov
 */
@Named("manageResponseBean")
@ViewScoped
public class ManageResponseBean extends BaseBean {

    private static ResourceBundle bundle = ResourceBundle.getBundle("MessageResources", FacesContext.getCurrentInstance().getViewRoot().getLocale());
    private static Logger logger = Logger.getLogger(ManageResponseBean.class.getName());
    /**
     * EJB to handle persistence.
     */
    @EJB
    private transient LetterFacadeLocal letterFacade;
    @EJB
    private transient LetterMspDetailFacadeLocal letterMspFacade;
    @EJB
    private transient ApplicationAuditLogFacadeLocal applicationAuditLogFacade;
    /**
     * The instance we're currently editing.
     */
    private Letter letter;
    private LetterMspDetail letterMsp;
    /**
     * new value for the input letter codes.
     */
    private String inputLetterCodes;
    private String inputLetterCodesMsp;
    /**
     * Lists letter barcodes verified in database.
     */
    private List<String> letterCodes = new ArrayList<>();

    /**
     * Default Constructor.
     */
    public ManageResponseBean() {
        super();
    }

    /**
     * Initializes this bean.
     */
    @PostConstruct
    public void init() {
        clear();
        letter = new Letter();
        letterMsp = new LetterMspDetail();

        if (letter.getStatusId() == null) {
            letter.setStatusId(new CodesLetterStatus());
        }

        if (letterMsp.getStatusId() == null) {
            letterMsp.setStatusId(new CodesLetterStatus());
        }
    }

    /**
     * form validation method when create a new project.
     *
     * @return boolean
     */
    public final boolean validateLetter() {

        boolean isNotError = true;
        // verify other fields
        // check if letter status was selected before save
        if (letter.getStatusId().getId().equals(new Long("-1"))
                || letter.getStatusId() == null) {
            addErrorMessage(bundle.getString("manageResponse.letterStatusSelected"));
            isNotError = false;
        }

        // check if letter barcodes input has values before save
        if (!Util.notEmpty(inputLetterCodes)) {
            addErrorMessage(bundle.getString("manageResponse.letterBarcodeSelected"));
            isNotError = false;
        }

        // check if letter barcodes input doesn't contain commas chars ','
        String[] letterBarCodes = inputLetterCodes.trim().split(",");
        Pattern patternSpecialChars = Pattern.compile("[$&+:;=?@#/|]");
        boolean excludeInput = false;
        List<String> letterCodesNotParsed = new ArrayList<>();
        for (String barcode : letterBarCodes) {
            logger.log(Level.INFO, "Testing barcode value: ".concat(barcode));
            if (patternSpecialChars.matcher(barcode.trim()).find()) {
                excludeInput = true;
                logger.log(Level.INFO, "excludeInput : ".concat(String.valueOf(excludeInput)));
            }

            if (excludeInput) {
                letterCodesNotParsed.add(barcode.trim());
                logger.log(Level.INFO, "inside if letterCodesNotParsed : "
                        .concat(String.valueOf(letterCodesNotParsed.size())));
            }

            letterBarCodes = barcode.concat(",").split(",");
        }
        logger.log(Level.INFO, "after for loop letterCodesNotParsed : "
                .concat(String.valueOf(letterCodesNotParsed.size())));
        if (!letterCodesNotParsed.isEmpty()) {
            addErrorMessage(bundle.getString("manageResponse.invalidBarcode"));
            isNotError = false;
        } else {
            logger.log(Level.INFO, "Test letterBarCodes values : "
                    .concat(String.valueOf(letterBarCodes.length)));
            // validate the letter barcode format
            List<String> letterCodesFormat = new ArrayList<>();
            List<String> letterCodesCounter = new ArrayList<>();
            Pattern pattern = Pattern.compile(".*\\D.*");
            boolean isNotLetterBarCode = false;
            boolean isCommaAfterBarcode = false;
            for (String letterCode : letterBarCodes) {
                logger.log(Level.INFO, "letter codes = ".concat(letterCode));
                if (pattern.matcher(letterCode.trim()).matches()) {
                    isNotLetterBarCode = true;
                }
                if (isNotLetterBarCode) {
                    letterCodesFormat.add(letterCode.trim());
                }
                if (pattern.matcher(letterCode.trim()).find()) {
                    isCommaAfterBarcode = true;
                }
                if (!isCommaAfterBarcode) {
                    letterCodesCounter.add(letterCode.trim());
                }
            }
            // display error message if letter input code doesn't contain number
            if (!letterCodesFormat.isEmpty()) {
                addErrorMessage(bundle.getString("manageResponse.barcodeFormat"));
                isNotError = false;
            }
            logger.log(Level.INFO, "letterCodesCounter size = "
                    .concat(String.valueOf(letterCodesCounter.size())));
            // display error message if letter input code doesn't contain commas
            if (letterCodesCounter.isEmpty()) {
                addErrorMessage(bundle.getString("manageResponse.barcodeCommas"));
                isNotError = false;
            }

            // verify if letter barcode exists in database, but only if there are no previous errors.
            if (isNotError) {
                if (letterCodesFormat.isEmpty() && inputLetterCodes.contains(",")) {
                    letterBarCodes = inputLetterCodes.trim().split(",");
                    List<String> letterCodesList = new ArrayList<>();
                    for (String letterBarCode : letterBarCodes) {
                        letterCodesList.add(letterBarCode.trim());
                    }
                    boolean letterExists = letterFacade.verifyLetterByBarcode(letterCodesList);
                    // display error message if letter input barcode is not in database
                    if (!letterExists) {
                        addErrorMessage(bundle.getString("manageResponse.barcodeNotExist"));
                        isNotError = false;
                    }
                } else // display error message if letter input barcode is not in database
                if (letterFacade.findLettersByBarcodes(inputLetterCodes).isEmpty()) {
                    addErrorMessage(bundle.getString("manageResponse.barcodeNotExist"));
                    isNotError = false;
                }
            }
        }

        return isNotError;
    }

    /**
     * Updates the letter statuses for the selected letter codes.
     *
     * @return String
     */
    public String save() {

        if (!validateLetter()) {
            return null;
        }
        // timestamp check pacl before updates
        java.util.Date date = new java.util.Date();
        logger.log(Level.INFO, "timestamp before updates PACL db = "
                .concat(new java.sql.Timestamp(date.getTime()).toString()));

        // Create Audit log
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Letter Status was changed");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Application Username", findUserName()));

        List<Letter> letterCodesList = letterFacade.findLettersByBarcodes(inputLetterCodes);
        for (Letter letterCode : letterCodesList) {
            letterCode.setStatusId(letter.getStatusId());
            letterFacade.edit(letterCode);
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog,
                    "Letter Input Barcode", String.valueOf(letterCode.getBarcode())));
        }

        // check timestamp after updates
        java.util.Date date2 = new java.util.Date();
        logger.log(Level.INFO, "timestamp after updates PACL db = "
                .concat(new java.sql.Timestamp(date2.getTime()).toString()));

        addInfoMessage(bundle.getString("manageResponse.letterStatusUpdated"));

        // set the audit details logs and create new audit/audit details records
        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        return clear();
    }

    /**
     * form validation method when create a new letterRun.
     *
     * @return boolean
     */
    public final boolean validateLetterMsp() {

        boolean isNotError = true;
        // verify other fields
        // check if letter status was selected before save
        if (letterMsp.getStatusId().getId().equals(new Long("-1"))
                || letterMsp.getStatusId() == null) {
            addErrorMessage(bundle.getString("manageResponse.letterStatusSelected"));
            isNotError = false;
        }

        // check if letter barcodes input has values before save
        if (!Util.notEmpty(inputLetterCodesMsp)) {
            addErrorMessage(bundle.getString("manageResponse.letterBarcodeSelected"));
            isNotError = false;
        }

        // check if letter barcodes input doesn't contain commas chars ','
        String[] letterBarCodes = inputLetterCodesMsp.trim().split(",");
        Pattern patternSpecialChars = Pattern.compile("[$&+:;=?@#/|]");
        boolean excludeInput = false;
        List<String> letterCodesNotParsed = new ArrayList<>();
        for (String barcode : letterBarCodes) {
            logger.log(Level.INFO, "Testing barcode value: ".concat(barcode));
            if (patternSpecialChars.matcher(barcode.trim()).find()) {
                excludeInput = true;
                logger.log(Level.INFO, "excludeInput : ".concat(String.valueOf(excludeInput)));
            }

            if (excludeInput) {
                letterCodesNotParsed.add(barcode.trim());
                logger.log(Level.INFO, "inside if letterCodesNotParsed : "
                        .concat(String.valueOf(letterCodesNotParsed.size())));
            }

            letterBarCodes = barcode.concat(",").split(",");
        }
        logger.log(Level.INFO, "after for loop letterCodesNotParsed : "
                .concat(String.valueOf(letterCodesNotParsed.size())));
        if (!letterCodesNotParsed.isEmpty()) {
            addErrorMessage(bundle.getString("manageResponse.invalidBarcode"));
            isNotError = false;
        } else {
            logger.log(Level.INFO, "Test letterBarCodes values : ".concat(String.valueOf(letterBarCodes.length)));
            // validate the letter barcode format
            List<String> letterCodesFormat = new ArrayList<>();
            List<String> letterCodesCounter = new ArrayList<>();
            Pattern pattern = Pattern.compile(".*\\D.*");
            boolean isNotLetterBarCode = false;
            boolean isCommaAfterBarcode = false;
            for (String letterCode : letterBarCodes) {
                logger.log(Level.INFO, "letter codes = ".concat(letterCode));
                if (pattern.matcher(letterCode.trim()).matches()) {
                    isNotLetterBarCode = true;
                }
                if (isNotLetterBarCode) {
                    letterCodesFormat.add(letterCode.trim());
                }
                if (pattern.matcher(letterCode.trim()).find()) {
                    isCommaAfterBarcode = true;
                }
                if (!isCommaAfterBarcode) {
                    letterCodesCounter.add(letterCode.trim());
                }
            }
            // display error message if letter input code doesn't contain number
            if (!letterCodesFormat.isEmpty()) {
                addErrorMessage(bundle.getString("manageResponse.barcodeFormat"));
                isNotError = false;
            }
            logger.log(Level.INFO, "letterCodesCounter size = "
                    .concat(String.valueOf(letterCodesCounter.size())));
            // display error message if letter input code doesn't contain commas
            if (letterCodesCounter.isEmpty()) {
                addErrorMessage(bundle.getString("manageResponse.barcodeCommas"));
                isNotError = false;
            }

            // verify if letter barcode exists in database, but only if there are no previous errors.
            if (isNotError) {
                if (letterCodesFormat.isEmpty() && inputLetterCodesMsp.contains(",")) {
                    letterBarCodes = inputLetterCodesMsp.trim().split(",");
                    List<String> letterCodesList = new ArrayList<>();
                    for (String letterBarCode : letterBarCodes) {
                        letterCodesList.add(letterBarCode.trim());
                    }

                    boolean letterExists = letterMspFacade.verifyLetterByBarcode(letterCodesList);
                    // display error message if letter input barcode is not in database
                    if (!letterExists) {
                        addErrorMessage(bundle.getString("manageResponse.barcodeNotExist"));
                        isNotError = false;
                    }
                } else // display error message if letter input barcode is not in database
                if (letterMspFacade.findLettersByBarcodes(inputLetterCodesMsp).isEmpty()) {
                    addErrorMessage(bundle.getString("manageResponse.barcodeNotExist"));
                    isNotError = false;
                }
            }
        }

        return isNotError;
    }

    /**
     * Updates the letter statuses for the selected letter codes.
     *
     * @return String
     */
    public String saveMsp() {

        if (!validateLetterMsp()) {
            return null;
        }
        // timestamp check pacl before updates
        java.util.Date date = new java.util.Date();
        logger.log(Level.INFO, "timestamp before updates PACL db = "
                .concat(new java.sql.Timestamp(date.getTime()).toString()));

        // Create Audit log
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Letter Status was changed");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Application Username", findUserName()));
        
        List<LetterMspDetail> letterCodesList = letterMspFacade.findLettersByBarcodes(inputLetterCodesMsp);
        for (LetterMspDetail letterCode : letterCodesList) {
            letterCode.setStatusId(letterMsp.getStatusId());
            letterMspFacade.edit(letterCode);
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog,
                    "Letter Input Barcode", String.valueOf(letterCode.getBarcode())));
        }

        // check timestamp after updates
        java.util.Date date2 = new java.util.Date();
        logger.log(Level.INFO, "timestamp after updates PACL db = "
                .concat(new java.sql.Timestamp(date2.getTime()).toString()));

        addInfoMessage(bundle.getString("manageResponse.letterStatusUpdated"));

        // set the audit details logs and create new audit/audit details records 
        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        return clear();
    }

    /**
     * Clears the form.
     *
     * @return String
     */
    public String clear() {
        letter = new Letter();
        letterMsp = new LetterMspDetail();
        inputLetterCodes = "";
        inputLetterCodesMsp = "";
        addPlaceholders();
        resetComponent("manageResponseForm");
        return null;
    }

    /**
     * Defaults parent objects which don't have valid PKs set.
     */
    private void addPlaceholders() {
        if (letter.getStatusId() == null) {
            letter.setStatusId(new CodesLetterStatus());
        }

        if (letterMsp.getStatusId() == null) {
            letterMsp.setStatusId(new CodesLetterStatus());
        }
    }

    /* Getters and Setters */
    public Letter getLetter() {
        return letter;
    }

    public void setLetter(Letter letter) {
        this.letter = letter;
    }

    public String getInputLetterCodes() {
        return inputLetterCodes;
    }

    public void setInputLetterCodes(String inputLetterCodes) {
        this.inputLetterCodes = inputLetterCodes;
    }

    public List<String> getLetterCodes() {
        return letterCodes;
    }

    public void setLetterCodes(List<String> letterCodes) {
        this.letterCodes = letterCodes;
    }

    public LetterMspDetail getLetterMsp() {
        return letterMsp;
    }

    public void setLetterMsp(LetterMspDetail letterMsp) {
        this.letterMsp = letterMsp;
    }

    public String getInputLetterCodesMsp() {
        return inputLetterCodesMsp;
    }

    public void setInputLetterCodesMsp(String inputLetterCodesMsp) {
        this.inputLetterCodesMsp = inputLetterCodesMsp;
    }
}
