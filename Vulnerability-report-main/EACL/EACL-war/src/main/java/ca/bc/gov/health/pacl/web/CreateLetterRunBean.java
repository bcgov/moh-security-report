/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.pacl.web;

import ca.bc.gov.health.exceptions.createLetterException;
import ca.bc.gov.health.jsf.BaseBean;
import static ca.bc.gov.health.jsf.BaseBean.addErrorMessage;
import static ca.bc.gov.health.jsf.BaseBean.addInfoMessage;
import ca.bc.gov.health.pacl.ejb.entity.AdminOptionsMsp;
import ca.bc.gov.health.pacl.ejb.entity.ApplicationAuditDtlLog;
import ca.bc.gov.health.pacl.ejb.entity.ApplicationAuditLog;
import ca.bc.gov.health.pacl.ejb.entity.CodesLetterStatus;
import ca.bc.gov.health.pacl.ejb.entity.CodesProjectType;
import ca.bc.gov.health.pacl.ejb.entity.LetterMspDetail;
import ca.bc.gov.health.pacl.ejb.entity.LetterTemplate;
import ca.bc.gov.health.pacl.ejb.entity.Notifications;
import ca.bc.gov.health.pacl.ejb.entity.PracSvaProject;
import ca.bc.gov.health.pacl.ejb.entity.Project;
import ca.bc.gov.health.pacl.ejb.entity.ServiceMsp;
import ca.bc.gov.health.pacl.ejb.session.AdminOptionsMspFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.ApplicationAuditLogFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.CodesLetterStatusFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.CodesLetterTemplateTypeFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.CodesProjectStatusFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.CodesProjectTypeFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.HIMspServDetailClaimsFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.LetterTemplateFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.NotificationFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.PracSvaProjectFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.ProjectFacadeLocal;
import ca.bc.gov.health.pacl.model.LetterRunMspModel;
import ca.bc.gov.health.pacl.util.CurrentContext;
import ca.bc.gov.health.pacl.util.PaclConstants;
import ca.bc.gov.health.pacl.util.Util;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.ejb.EJBException;
import jakarta.faces.FactoryFinder;
import jakarta.faces.context.FacesContext;
import jakarta.faces.context.FacesContextFactory;
import jakarta.faces.event.ValueChangeEvent;
import jakarta.faces.lifecycle.Lifecycle;
import jakarta.faces.lifecycle.LifecycleFactory;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.sql.DataSource;

/**
 * Backing bean for creating a new letter run type.
 *
 * @author dan.stepanov
 */
@Named("createLetterRun")
@ViewScoped
public class CreateLetterRunBean extends BaseBean {

    private static Logger logger = Logger.getLogger(CreateLetterRunBean.class.getName());

    private static ResourceBundle bundle = ResourceBundle.getBundle("MessageResources", FacesContext.getCurrentInstance().getViewRoot().getLocale());
    /**
     * new value for the letter run date.
     */
    private Date letterRunDate;
    /**
     * new value for the input practitioner code.
     */
    private String inputPracCodes;
    /**
     * Lists practitioner codes verified in HI.
     */
    private List<String> pracCodesHI = new ArrayList<>();
    /**
     * new value for the fee item codes.
     */
    private String feeItemCodes;
    /**
     * new value for the service codes.
     */
    private String serviceCodes;

    private DataSource ds;
    /*
     * Facade for persistence
     */
    @EJB
    private transient HIMspServDetailClaimsFacadeLocal hiMspServDetailClaimsFacade;

    @EJB
    private transient CodesProjectTypeFacadeLocal codesProjectTypeFacade;

    @EJB
    private transient ProjectFacadeLocal projectFacade;

    @EJB
    private transient CodesProjectStatusFacadeLocal codesProjectStatusFacade;

    @EJB
    private transient CodesLetterTemplateTypeFacadeLocal codesLetterTemplTypeFacade;

    @EJB
    private transient CodesLetterStatusFacadeLocal codesLetterStatusFacade;

    @EJB
    private transient ApplicationAuditLogFacadeLocal applicationAuditLogFacade;

    @EJB
    private transient AdminOptionsMspFacadeLocal adminOptionsMspFacade;

    @EJB
    private transient PracSvaProjectFacadeLocal pracSvaProjectFacade;

    @EJB
    private transient LetterTemplateFacadeLocal letterTemplateFacade;

    @EJB
    private transient NotificationFacadeLocal notificationFacade;

    /*
     * The instance we're currently editing
     */
    private Project project;
    /**
     * letter template type for random audit.
     */
    private long templateTypeRandom;
    /**
     * letter template type for Select service audit.
     */
    private long templateTypeSelectService;
    /**
     * letter template type for Select service w/questions audit.
     */
    private long templateTypeSelectServiceQuest;
    /**
     * max patients value for each letter run type.
     */
    private Long maxPatients;
    /**
     * latest SVA project code counter for random types.
     */
    private Integer svaProjCounterRandom;
    /**
     * latest SVA project code last two digits year for random types.
     */
    private String svaPrjRandomYear;
    /**
     * latest SVA project code counter for select service types.
     */
    private Integer svaProjCounterSelectService;
    /**
     * latest SVA project code last two digits year for select service types.
     */
    private String svaPrjSelectServiceYear;
    /*
     * The instance letter we're retrieving and caching
     */
    private CodesLetterStatus letterStatusNoResponse;
    /**
     * The HILogin object is used to connect to the HI context. Direct usage of @Inject causes a
     * ContextNotActiveException (WELD-001303). To prevent this issue, the init() method employs findBean() to obtain
     * the object.
     */
    private HealthIdeasLogin hiLogin;
    
    private boolean isErrorGlobal;

    /**
     * Default constructor.
     */
    public CreateLetterRunBean() {
        super();
    }

    /**
     * Initializes this bean after injection.
     */
    @PostConstruct
    public void init() {
        try {
            Context initialContext = new InitialContext();
            ds = (javax.sql.DataSource) initialContext.lookup("java:app/jdbc/eacl");
            clear();
        } catch (Exception e) {
            logger.log(Level.SEVERE, e.getMessage());
        }
        hiLogin = new HealthIdeasLogin();
        hiLogin = (HealthIdeasLogin) hiLogin.findBean("HealthIdeasLogin");
    }

    /**
     * form validation method when create a new project.
     *
     * @return boolean
     */
    public final boolean validateProject() {

        boolean isNotError = true;
        // verify other fields
        // check if projectType was selected before create
        if (project.getProjectTypeId().getId().equals(new Long("-1"))
                || project.getProjectTypeId() == null) {
            addErrorMessage(bundle.getString("letterRun.Creation.TypeSelected"));
            isNotError = false;
        }
        // check if the search fields contain invalid chars
        String invalidChars = "[!#$%&()*+,/:;<=>?@\\[\\]^\\_\\`\\{|\\}~‚ƒ„…†‡ˆ‰Š‹Œ‘“”•–—˜™š›œŸ¡¢£¤¥¦§¨©ª«¬¬®¯°±²³´µ¶•¸¹º»¼½¾¿ÃÅÆÐÑÕ×ØÞßãåæðñõ÷øþÿ]";
        if (Util.notEmpty(project.getName())) {
            String firstCharPrj = project.getName().substring(0, 1);
            if (firstCharPrj.matches(invalidChars)) {
                addErrorMessage(bundle.getString("letterRun.Creation.SpecialChar"));
                isNotError = false;
            }
        }

        // verify if MSP claim start date is after the claim end date.
        if (project.getProjectFromDate().after(project.getProjectToDate())) {
            addErrorMessage(bundle.getString("letterRun.Creation.claimStart"));
            isNotError = false;
        }

        // verify if letter run name and letter run month/year are unique
        // in database project table.
        if (projectFacade.projectExist(project)) {
            addErrorMessage(bundle.getString("letterRun.Creation.Exists"));
            isNotError = false;
        }

        // verify if max. patients value is a positive number and > 0.
        if (project.getMaxPatients() <= 0) {
            addErrorMessage(bundle.getString("letterRun.Creation.Positive"));
            isNotError = false;
        }
        // verify if the max number of patients per practitioner
        // exceeds the default Patient Limit from Admin Options MSP table
        AdminOptionsMsp adminOptionsMsp = adminOptionsMspFacade.findDefaultPatientLimit().get(0);
        if (project.getMaxPatients() > adminOptionsMsp.getDefaultPatientMaxLimit()) {
            addErrorMessage(bundle.getString("letterRun.Creation.MaxPatient"));
            isNotError = false;
        }

        // verify if the max number of patients per practitioner
        // is under the default Patient minimum from Admin Options MSP table
        if (project.getMaxPatients() < adminOptionsMsp.getDefaultPatientMinLimit()) {
            addErrorMessage(bundle.getString("letterRun.Creation.MinPatient"));
            isNotError = false;
        }

        // validate the practitioner code format from HI
        // “######” where # means always a digit (e.g. 001234 and 021278)
        String[] pracCodes = inputPracCodes.toUpperCase().trim().split(",");
        List<String> pracCodesFormat = new ArrayList<>();
        //BCMOHAM-15859
        String regExpDigits = "[a-zA-Z0-9]+";
        // String regExpDigits = "\\d+";
        Pattern pat = Pattern.compile(regExpDigits);

        for (String practitionerCode : pracCodes) {
            if (practitionerCode.trim().length() < 5
                    || practitionerCode.trim().length() > 6
                    || !pat.matcher(practitionerCode.trim()).matches()) {
                pracCodesFormat.add(practitionerCode.trim());
            }
        }
        // display error message if practitioner input code
        // doesn't have the latest format
        if (!pracCodesFormat.isEmpty()) {
            // build the practitioner codes
            String delimiter = ", ";
            String apos = "'";

            Iterator<? extends String> iter = pracCodesFormat.iterator();
            StringBuilder pracCodeBadFormatString = new StringBuilder();
            pracCodeBadFormatString.append(apos).append(iter.next()).append(apos);
            while (iter.hasNext()) {
                pracCodeBadFormatString.append(delimiter).append(apos).append(iter.next()).append(apos);
            }
            addErrorMessage(bundle.getString("letterRun.Creation.InputCodes") + pracCodeBadFormatString + " " + bundle.getString("letterRun.Creation.DontMatch"));
            isNotError = false;
        }

        // search HealthIdeas for the practitioner codes;
        List<String> pracCodesList = new ArrayList<>();
        for (String pracCode : pracCodes) {
            pracCodesList.add(pracCode.trim());
        }

        // display error message if more than 240 practitioners in list
        if (pracCodesList.size() > PaclConstants.MAX_RANDOM_PRAC_INPUT_LIST) {
            addErrorMessage(bundle.getString("letterRun.Creation.PracList")
                    + PaclConstants.MAX_RANDOM_PRAC_INPUT_LIST
                    + bundle.getString("letterRun.Creation.CurrentSize") + pracCodesList.size() + ")");
            isNotError = false;
        }

        //Verifies if the input prac codes are valid in HI database
        pracCodesHI = hiMspServDetailClaimsFacade.verifyPractitionerCodesHI(
                hiLogin.getEntityManager(), pracCodesList);
        // display info message if practitioner input code is not in HI
        if (pracCodesHI != null && pracCodesHI.isEmpty()) {
            addErrorMessage(bundle.getString("letterRun.Creation.PracCodeNotExist"));
            isNotError = false;
        }

        return isNotError;
    }

    /**
     * Creates a new letter run type record.
     *
     * @return String
     */
    public String addLetterRun() throws Exception {
        // validate screen input valus and the business rules
        if (!validateProject()) {
            isErrorGlobal = true;
            return null;
        }

        // create a list of optional fee item codes from the screen
        List<String> feeCodesScreen = new ArrayList<>();
        if (Util.notEmpty(feeItemCodes)) {
            String[] feeItCodes = feeItemCodes.trim().split(",");
            for (String feeCode : feeItCodes) {
                feeCodesScreen.add(feeCode.trim());
            }
        }

        // create a list of optional service codes from the screen
        List<String> serviceCodesScreen = new ArrayList<>();
        if (Util.notEmpty(serviceCodes)) {
            String[] servCodes = serviceCodes.trim().split(",");
            for (String serviceCode : servCodes) {
                serviceCodesScreen.add(serviceCode.trim());
            }
        }

        // retrieve Letters details from HI and then depending on the selected
        // letter run type are set in project letter
        // get logged IDIR user name from the session
        final String applicationUserName = findUserName();
        // create deep copy for Project instance
        final Project cloneProject = project;
        // create a copy of practitioner numbers from the screen
        final List<String> clonePracCodesHI = new ArrayList<>();
        clonePracCodesHI.addAll(pracCodesHI);
        // create a copy of fee item codes from the screen
        final List<String> cloneFeeCodesScreen = new ArrayList<>();
        cloneFeeCodesScreen.addAll(feeCodesScreen);
        // create a copy of service codes from the screen
        final List<String> cloneServiceCodesScreen = new ArrayList<>();
        cloneServiceCodesScreen.addAll(serviceCodesScreen);

        final Notifications notification = new Notifications();
        notification.setUserChannel(HealthIdeasLogin.getUserChannel());
        notification.setLetterRunName(project.getName());
        notification.setCreateOrPrint("Create");
        notification.setMessage("Create letter run started");
        notification.setProcessStart(new Date());

        notificationFacade.create(notification);
        notificationFacade.flushClear();

        if (PaclConstants.RANDOM_MONTHLY_TYPE.equals(project.getProjectTypeId().getName())) {

            // create new thread for random monthly claims process
            Thread tRand = new Thread() {
                @Override
                public void run() {
                    String calculateClaimsResponse = "";
                    try {
                        CurrentContext.getCurrentUserName().set(applicationUserName);
                        calculateClaimsResponse = calculateLetterRunRandomClaims(applicationUserName,
                                clonePracCodesHI, cloneProject);
                    } catch (createLetterException e) {

                        notification.setProcessFinish(new Date());
                        notification.setMessage(e.getMessage());
                        notificationFacade.edit(notification);
                        notificationFacade.flushClear();
                        logger.log(Level.SEVERE, e.getMessage());

                    } catch (Exception e) {
                        notification.setProcessFinish(new Date());
                        notification.setMessage("Cannot create letter run, "
                                + "as it violates a constraint failure " + e.getClass().getSimpleName()
                                + " with message: " + e.getMessage());
                        notificationFacade.edit(notification);
                        notificationFacade.flushClear();

                        logger.log(Level.SEVERE, "Cannot create letter run, "
                                + "as it violates a constraint failure {0} with message: {1}",
                                new Object[]{e.getClass().getSimpleName(), e.getMessage()});

                    } finally {
                        if (notification.getProcessFinish() == null) {

                            logger.log(Level.INFO, "Create letter run successful");
                            notification.setProcessFinish(new Date());
                            notification.setMessage("Create letter run successful " + calculateClaimsResponse);
                            notificationFacade.edit(notification);
                            notificationFacade.flushClear();
                        }

                    }
                }
            };
            tRand.start();

        } else if (PaclConstants.SELECT_SRV_TYPE.equals(project.getProjectTypeId().getName())
                || PaclConstants.SELECT_SRV_QUEST_TYPE.equals(project.getProjectTypeId().getName())) {

            // create new thread for select service claims process
            Thread tSelect = new Thread() {
                @Override
                public void run() {
                    String calculateClaimsResponse = "";
                    try {
                        CurrentContext.getCurrentUserName().set(applicationUserName);
                        calculateClaimsResponse = calculateLetterRunSelectServiceClaims(applicationUserName,
                                cloneFeeCodesScreen, cloneServiceCodesScreen,
                                clonePracCodesHI, cloneProject);
                    } catch (createLetterException e) {
                        notification.setProcessFinish(new Date());
                        notification.setMessage(e.getMessage());
                        notificationFacade.edit(notification);
                        notificationFacade.flushClear();
                        logger.log(Level.SEVERE, e.getMessage());
                    } catch (Exception e) {
                        notification.setProcessFinish(new Date());
                        notification.setMessage("Cannot create letter run, "
                                + "as it violates a constraint failure " + e.getClass().getSimpleName()
                                + " with message: " + e.getMessage());
                        notificationFacade.edit(notification);
                        notificationFacade.flushClear();
                        logger.log(Level.SEVERE, "Cannot create letter run, "
                                + "as it violates a constraint failure {0} with message: {1}",
                                new Object[]{e.getClass().getSimpleName(), e.getMessage()});
                    } finally {
                        if (notification.getProcessFinish() == null) {
                            notification.setProcessFinish(new Date());
                            notification.setMessage("Create letter run successful " + calculateClaimsResponse);
                            notificationFacade.edit(notification);
                            notificationFacade.flushClear();
                        }
                    }
                }
            };
            tSelect.start();
        }

        clear();
        // add logic for reset
        FacesContext context = FacesContext.getCurrentInstance();
        addInfoMessage(bundle.getString("letterRun.Creation.InProgress"));
        context.getExternalContext().getFlash().setKeepMessages(true);

        return "/createLetterRun.xhtml?faces-redirect=true";
    }

    /**
     * Get FacesContext from the session request via FacesContextFactory.
     *
     * @param request HttpServletRequest - session HTTP request
     * @param response HttpServletResponse - session HTTP response
     *
     * @return FacesContext
     */
    public FacesContext getFacesContext(HttpServletRequest request,
            HttpServletResponse response) {
        FacesContext facesContext = FacesContext.getCurrentInstance();
        if (facesContext == null) {

            FacesContextFactory contextFactory
                    = (FacesContextFactory) FactoryFinder.getFactory(FactoryFinder.FACES_CONTEXT_FACTORY);
            LifecycleFactory lifecycleFactory
                    = (LifecycleFactory) FactoryFinder.getFactory(FactoryFinder.LIFECYCLE_FACTORY);
            Lifecycle lifecycle
                    = lifecycleFactory.getLifecycle(LifecycleFactory.DEFAULT_LIFECYCLE);

            facesContext
                    = contextFactory.getFacesContext(request.getSession().getServletContext(),
                            request, response, lifecycle);

        }
        return facesContext;
    }

    /**
     * Retrieves Random monthly patient claims from HI per each practitioner. If claims exists insert a new letter run
     * type and then populates the practitioner(SVA project)/letterMSP/serviceMSP entities.
     *
     * @param applicationUserName String - application logged IDIR user name
     * @param pracCodesScreen List<String> - practitioner codes selected from the screen
     * @param project Project - project(letter run) with input values from session/screen
     */
    private String calculateLetterRunRandomClaims(String applicationUserName,
            List<String> pracCodesScreen, Project project) throws Exception {

        String notificationMessage = "";

        List<PracSvaProject> distinctPracSvaProjects;
        AdminOptionsMsp adminOptionsMsp = adminOptionsMspFacade.findDefaultPatientLimit().get(0);

        // create a new instance of letter run MSP type
        LetterRunMspModel letterRunMspModel = new LetterRunMspModel();
        letterRunMspModel.setHiServiceMspLetters(
                hiMspServDetailClaimsFacade.getHIClaimsForRandomLetterRun(hiLogin.getEntityManager(),
                        pracCodesScreen, project));
        distinctPracSvaProjects = letterRunMspModel.getServiceClaimsForLetterRunRandom();

        boolean found = false;
        List<String> missingDataPracList = new ArrayList<>();

        //This verifies if there are enough data to generate the right amount of letters
        //If list is empty, return generic message and stop process
        //If only some pracs dont have enough results, continue the process and return the list of those who do not have enough
        if (distinctPracSvaProjects.isEmpty()) {

            throw new createLetterException("Insufficient data to create letter run");

        } else if (pracCodesScreen.size() != distinctPracSvaProjects.size()) {
            for (String pracCode : pracCodesScreen) {
                for (PracSvaProject myProject : distinctPracSvaProjects) {
                    if (myProject.getPracBllgNum().equals(pracCode)) {
                        found = true;
                        break;
                    }
                }
                if (found == false) {
                    missingDataPracList.add(pracCode);
                }
                found = false;
            }
            //<br> line break so it's easier to read in the notification table
            notificationMessage = "<br> Insufficient patients numbers to generate letters for practitioners: "
                    + missingDataPracList.toString();

        }

        // verify the results for practitioners/patients/claims
        // set project info with values from the screen
        setProjectInfo(applicationUserName, project, pracCodesScreen);

        /* Check the following before generating new SVA random project code:
         1. get the latest record from database and verify with current year
         2. increase SVA random project code per year if year is a match
         3. reset SVA random project code to '0' for new year
         */
        // verify the current year and set SVA counter
        StringBuilder svaCountBuilder = new StringBuilder();
        java.util.Date currentDate = new java.util.Date();
        Calendar instance = Calendar.getInstance();
        instance.setTime(currentDate);
        String currentYear = String.valueOf(instance.get(Calendar.YEAR));
        String lastTwoDigitsYear = currentYear.substring(PaclConstants.PREFIX_YEAR_INDEX_SVA_CODE);

        // initialize the SVA counter for random from database
        // and then increase with 1
        String svaLetterRunTypePrefix = PaclConstants.SVA_PROJECT_SEQ_RANDOM;
        svaCountBuilder.append(svaLetterRunTypePrefix);
        svaCountBuilder.append(lastTwoDigitsYear);
        String getNextSeq = "select PRAC_SVA_CODE_RANDOM_SEQ.nextval from dual";
        Connection conn;
        conn = ds.getConnection();
        // insert new Prac/SvaProjects
        for (PracSvaProject pracSvaProject : distinctPracSvaProjects) {
            pracSvaProject.setProjectId(project);
            // set initial SVA projects status to 'Open'
            pracSvaProject.setSvaProjectStatusId(
                    codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_OPEN));

            PreparedStatement pstNext = conn.prepareStatement(getNextSeq);

            ResultSet nextSet = pstNext.executeQuery();
            nextSet.next();

            Integer initSvaProjCounterRandom = nextSet.getInt(1);

            // update SVA project sequence code
            String updatedSvaProjCode = generateSvaProjectCode(svaCountBuilder.toString(), initSvaProjCounterRandom);
            pracSvaProject.setSvaProjectCode(updatedSvaProjCode);
            // increase sva Counter for Random letter types

            pracSvaProject.setId(null);
            // create patients for the Prac/SvaProjects
            for (LetterMspDetail letterMspDetail : pracSvaProject.getLetterMspDetailList()) {
                letterMspDetail.setPracSvaProjectId(pracSvaProject);
                letterMspDetail.setProjectId(project);
                letterMspDetail.setLetterTemplateId(new LetterTemplate(getTemplateTypeRandom()));
                letterMspDetail.setStatusId(getLetterStatusNoResponse());
                // barcode insertable set to false in LetterMspDetail entity
                letterMspDetail.setLetterPrintedFlag('N');
                // insert new MSP letters for patients per practitioner
                letterMspDetail.setId(null);

                // create services MSP for each letterMspDetail Patient
                for (ServiceMsp serviceMsp : letterMspDetail.getServiceMspList()) {
                    serviceMsp.setPracSvaProjectId(pracSvaProject);
                    serviceMsp.setLetterMspId(letterMspDetail);

                    // insert new services MSP for each letterMspDetail
                    serviceMsp.setId(null);
                }
            }
            // create new practitioners for the selected letter/service Msp
            try {
                pracSvaProjectFacade.create(pracSvaProject);
            } catch (EJBException e) {
                for (Throwable t = e.getCause(); t != null; t = t.getCause()) {
                    if (t.getClass().getName().equals("java.sql.SQLException")) {
                        addErrorMessage(bundle.getString("letterRun.Creation.Constraint"));
                        conn.close();
                    }
                }
            }

        }
        // check timestamp after inserts
        java.util.Date date2 = new java.util.Date();
        logger.log(Level.INFO, "timestamp after inserts EACL db = "
                .concat(new java.sql.Timestamp(date2.getTime()).toString()));

        project.setPracSvaProjectList(distinctPracSvaProjects);
        conn.close();

        return notificationMessage;

    }

    /**
     * Set the all project types with input values from the session/screen.
     *
     * @param project Project - project with input values from session/screen
     * @param pracCodesScreen List<String> - list of practitioner codes from screen
     *
     */
    private void setProjectInfo(String applicationUserName, Project project,
            List<String> pracCodesScreen) {

        // set project with values from the screen
        // set this value with logged user id
        project.setProjectOwner(applicationUserName);
        // set initial project status to 'Open'
        project.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_OPEN));

        // timestamp check pacl inserts
        java.util.Date date = new java.util.Date();
        logger.log(Level.INFO, "timestamp before inserts EACL db = "
                .concat(new java.sql.Timestamp(date.getTime()).toString()));

        // create a new letter run type
        try {
            projectFacade.create(project);

            // Create Audit log
            ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Create Letter Run");
            List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Owner", applicationUserName));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Name", project.getName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Month", project.getProjectMonth()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Year", project.getProjectYear()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Id", (project.getId().toString())));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Practitioner Input Codes", (pracCodesScreen.toString())));

            applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
            applicationAuditLogFacade.create(applicationAuditLog);

        } catch (EJBException e) {
            for (Throwable t = e.getCause(); t != null; t = t.getCause()) {
                if (t.getClass().getName().equals("java.sql.SQLException")) {
                    addErrorMessage(bundle.getString("letterRun.Creation.Constraint"));
                }
            }
        }
    }

    /**
     * Retrieves Select Services patient claims from HI per each practitioner. If claims exists insert a new letter run
     * type and then populates the practitioner(SVA project)/letterMSP/serviceMSP entities.
     *
     * @param applicationUserName String - application logged IDIR user name
     * @param feeCodesScreen List<String> - fee item codes selected from the screen
     * @param serviceCodesScreen List<String> - service codes selected from the screen
     * @param pracCodesScreen List<String> - practitioner codes selected from the screen
     * @param project Project - project(letter run) with input values from session/screen
     * @throws Exception
     * @throws createLetterException
     */
    private String calculateLetterRunSelectServiceClaims(String applicationUserName,
            List<String> feeCodesScreen, List<String> serviceCodesScreen,
            List<String> pracCodesScreen, Project project) throws Exception {

        String notificationMessage = "";
        List<PracSvaProject> distinctPracSvaProjects;
        AdminOptionsMsp adminOptionsMsp = adminOptionsMspFacade.findDefaultPatientLimit().get(0);

        // create a new instance of letter run MSP type
        LetterRunMspModel letterRunMspModel = new LetterRunMspModel();
        letterRunMspModel.setHiServiceMspLetters(
                hiMspServDetailClaimsFacade.getHIClaimsForSelectServiceLetterRun(hiLogin.getEntityManager(),
                        feeCodesScreen, serviceCodesScreen, pracCodesScreen, project));

        distinctPracSvaProjects = letterRunMspModel.getServiceClaimsForLetterRunRandom();

        boolean found = false;
        List<String> missingDataPracList = new ArrayList<>();
        //This verifies if there are enough data to generate the right amount of letters
        //If list is empty, return generic message and stop process
        //If only a certain ammount of pracs have enough results, display the list of those who do not have enough and continue process
        if (distinctPracSvaProjects.isEmpty()) {
            throw new createLetterException("Insufficient data to create letter run");
        } else if (pracCodesScreen.size() != distinctPracSvaProjects.size()) {
            for (String pracCode : pracCodesScreen) {
                for (PracSvaProject myProject : distinctPracSvaProjects) {
                    if (myProject.getPracBllgNum().equals(pracCode)) {
                        found = true;
                        break;
                    }
                }
                if (found == false) {
                    missingDataPracList.add(pracCode);
                }
                found = false;
            }
            //<br> line break so it's easier to read in the notification table
            notificationMessage = "<br> Insufficient patients numbers to generate letters for practitioners: "
                    + missingDataPracList.toString();

        }

        // verify the results for practitioners/patients/claims
        // set project info with values from the screen
        setProjectInfo(applicationUserName, project, pracCodesScreen);

        /* Check the following before generating new SVA project code for select services:
         1. get the latest record from database and verify with current year
         2. increase SVA select services project code per year if year is a match
         3. reset SVA select services project code to '0' for new year
         */
        // verify the current year and set SVA counter
        StringBuilder svaCountBuilder = new StringBuilder();
        java.util.Date currentDate = new java.util.Date();
        Calendar instance = Calendar.getInstance();
        instance.setTime(currentDate);
        String currentYear = String.valueOf(instance.get(Calendar.YEAR));
        String lastTwoDigitsYear = currentYear.substring(PaclConstants.PREFIX_YEAR_INDEX_SVA_CODE);

        String svaLetterRunTypePrefix = PaclConstants.SVA_PROJECT_SEQ_SELECT_SERVICE;
        svaCountBuilder.append(svaLetterRunTypePrefix);
        svaCountBuilder.append(lastTwoDigitsYear);
        String getNextSeq = "select PRAC_SVA_CODE_SELECT_SEQ.nextval from dual";
        Connection conn;
        conn = ds.getConnection();
        // insert new Prac/SvaProjects
        for (PracSvaProject pracSvaProject : distinctPracSvaProjects) {
            pracSvaProject.setProjectId(project);
            // set initial SVA projects status to 'Open'
            pracSvaProject.setSvaProjectStatusId(
                    codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_OPEN));

            PreparedStatement pstNext = conn.prepareStatement(getNextSeq);
            ResultSet nextSet = pstNext.executeQuery();
            nextSet.next();

            Integer initSvaProjCounterSelectServ = nextSet.getInt(1);

            // update SVA project sequence code for select service types
            String updatedSvaProjCode = generateSvaProjectCode(svaCountBuilder.toString(), initSvaProjCounterSelectServ);
            pracSvaProject.setSvaProjectCode(updatedSvaProjCode);
            // increase sva Counter for select service letter types

            pracSvaProject.setId(null);

            // create patients for the Prac/SvaProjects
            for (LetterMspDetail letterMspDetail : pracSvaProject.getLetterMspDetailList()) {
                letterMspDetail.setPracSvaProjectId(pracSvaProject);
                letterMspDetail.setProjectId(project);
                letterMspDetail.setLetterTemplateId(new LetterTemplate((project.getProjectTypeId().getName().equals(PaclConstants.SELECT_SRV_QUEST_TYPE)) ? getTemplateTypeSelectServiceQuest() : getTemplateTypeSelectService()));
                letterMspDetail.setStatusId(getLetterStatusNoResponse());
                // barcode insertable set to false in LetterMspDetail entity
                letterMspDetail.setLetterPrintedFlag('N');
                // insert new MSP letters for patients per practitioner
                letterMspDetail.setId(null);

                // create services MSP for each letterMspDetail Patient
                for (ServiceMsp serviceMsp : letterMspDetail.getServiceMspList()) {
                    serviceMsp.setPracSvaProjectId(pracSvaProject);
                    serviceMsp.setLetterMspId(letterMspDetail);

                    // insert new services MSP for each letterMspDetail
                    serviceMsp.setId(null);
                }
            }
            // create new practitioners for the selected letter/service Msp
            try {
                pracSvaProjectFacade.create(pracSvaProject);
            } catch (EJBException e) {
                for (Throwable t = e.getCause(); t != null; t = t.getCause()) {
                    if (t.getClass().getName().equals("java.sql.SQLException")) {
                        addErrorMessage(bundle.getString("letterRun.Creation.Constraint"));
                    }
                }
                conn.close();
            }

        }
        // check timestamp after inserts
        java.util.Date date2 = new java.util.Date();
        logger.log(Level.INFO, "timestamp after inserts EACL db = "
                .concat(new java.sql.Timestamp(date2.getTime()).toString()));
        project.setPracSvaProjectList(distinctPracSvaProjects);
        conn.close();
        return notificationMessage;
    }

    /**
     * Clears the form.
     *
     * @return String
     */
    public String clear() throws Exception {
        project = new Project();
        project.setProjectTypeId(new CodesProjectType());
        isErrorGlobal = false;
        letterRunDate = null;
        inputPracCodes = null;
        serviceCodes = null;
        feeItemCodes = null;
        maxPatients = null;
        resetComponent("createLetterRunForm");
        return null;
    }

    /**
     * Set SVA project code for each practitioner retrieved from HI.
     *
     * @param stringToPad String - string value to be padded with '0's
     * @param padToLength String - string length for padding
     *
     * @return String
     */
    public static String setSVACounter(String stringToPad, int padToLength) {
        if (stringToPad.length() < padToLength) {
            return String.format("%0" + String.valueOf(
                    padToLength - stringToPad.length()) + "d%s", 0, stringToPad);
        }
        return stringToPad;
    }

    /**
     * Generate SVA project codes for each letter run types.
     *
     * @param svaLetterRunTypePrefix String - letter run type corresponding to SVA projects
     * @param svaProjCounter Integer - SVA counter for the project sequence
     *
     * @return String
     */
    private String generateSvaProjectCode(String svaLetterRunTypeYear, Integer svaProjCounter) {
        StringBuilder svaBuilder = new StringBuilder();
        svaBuilder.append(svaLetterRunTypeYear);
        // set SVA counter with padded 0s
        String increasedSvaCounter = setSVACounter(String.valueOf(svaProjCounter), PaclConstants.PREFIX_INDEX_SVA_CODE_PADDED);
        svaBuilder.append(increasedSvaCounter);
        String svaProjectCode = svaBuilder.toString();

        return svaProjectCode;
    }

    /* Getters and Setters */
    public Date getLetterRunDate() {
        return letterRunDate;
    }

    public void setLetterRunDate(Date letterRunDate) {
        this.letterRunDate = letterRunDate;
        Calendar instance = Calendar.getInstance();
        instance.setTime(letterRunDate);
        String month = String.valueOf(instance.get(Calendar.MONTH) + 1);
        project.setProjectMonth(month.length() == 1 ? "0" + month : month);
        project.setProjectYear(String.valueOf(instance.get(Calendar.YEAR)));

    }

    public void changeProjectType(ValueChangeEvent e) throws ClassCastException {
        if (((Long) e.getNewValue()) != -1) {
            project.setProjectTypeId(codesProjectTypeFacade.find(e.getNewValue()));
            if (PaclConstants.SELECT_SRV_QUEST_TYPE.equals(project.getProjectTypeId().getName())) {
                addWarnMessage(bundle.getString("letterRun.Creation.Questions"));
            }
        } else {
            project.setProjectTypeId(new CodesProjectType());
        }
    }

    public Project getProject() {
        return project;
    }

    public void setProject(Project project) {
        this.project = project;
    }

    public String getInputPracCodes() {
        return inputPracCodes;
    }

    public void setInputPracCodes(String inputPracCodes) {
        this.inputPracCodes = inputPracCodes;
    }

    public List<String> getPracCodesHI() {
        return pracCodesHI;
    }

    public void setPracCodesHI(List<String> pracCodesHI) {
        this.pracCodesHI = pracCodesHI;
    }

    /**
     * Retrieve the minimum number of patients allowed per practitioner.
     *
     * @return long minPatientsPerPrac - retrieves the minimum patients per practitioner.
     */
    public long getHIPatientMinForPractitioner() {
        // find the most recent record by date CREATED_ON_DTM
        AdminOptionsMsp adminOptionsMsp = adminOptionsMspFacade.findDefaultPatientLimit().get(0);
        long minPatientsPerPrac = adminOptionsMsp.getDefaultPatientMinLimit();
        return minPatientsPerPrac;
    }

    /**
     * Retrieve the minimum number of Claims allowed per patient.
     *
     * @return long minClaimPerPatient - retrieves the minimum claims per patient.
     */
    public long getHIClaimMinForPatient() {
        // find the most recent record by date CREATED_ON_DTM
        AdminOptionsMsp adminOptionsMsp = adminOptionsMspFacade.findDefaultPatientLimit().get(0);
        long minClaimPerPatient = adminOptionsMsp.getDefaultClaimMinLimit();
        return minClaimPerPatient;
    }

    public long getTemplateTypeRandom() {
        LetterTemplate letterTemplate
                = letterTemplateFacade.findByLetterTemplateTypeId(codesLetterTemplTypeFacade.findByName(PaclConstants.RANDOM_LTR_TEMPLATE_TYPE));
        templateTypeRandom = letterTemplate.getId();

        return templateTypeRandom;
    }

    public long getTemplateTypeSelectService() {
        LetterTemplate letterTemplate
                = letterTemplateFacade.findByLetterTemplateTypeId(codesLetterTemplTypeFacade.findByName(PaclConstants.SELECT_SRV_TEMPLATE_TYPE));
        templateTypeSelectService = letterTemplate.getId();

        return templateTypeSelectService;
    }

    public long getTemplateTypeSelectServiceQuest() {
        LetterTemplate letterTemplate
                = letterTemplateFacade.findByLetterTemplateTypeId(codesLetterTemplTypeFacade.findByName(PaclConstants.SELECT_SRV_QUEST_TEMPLATE_TYPE));
        templateTypeSelectServiceQuest = letterTemplate.getId();

        return templateTypeSelectServiceQuest;
    }

    public CodesLetterStatus getLetterStatusNoResponse() {
        letterStatusNoResponse = codesLetterStatusFacade.findByName(PaclConstants.LETTER_STATUS_NO_RESPONSE);
        return letterStatusNoResponse;
    }

    public String getFeeItemCodes() {
        return feeItemCodes;
    }

    public void setFeeItemCodes(String feeItemCodes) {
        this.feeItemCodes = feeItemCodes;
    }

    public String getServiceCodes() {
        return serviceCodes;
    }

    public void setServiceCodes(String serviceCodes) {
        this.serviceCodes = serviceCodes;
    }

    public Long getMaxPatients() {
        if (!isErrorGlobal) {
            maxPatients = null;
            if (PaclConstants.RANDOM_MONTHLY_TYPE.equals(project.getProjectTypeId().getName())) {
                maxPatients = PaclConstants.DEFAULT_SVA_RANDOM_MAX_PATIENTS;
            } else if (PaclConstants.SELECT_SRV_TYPE.equals(project.getProjectTypeId().getName())
                    || PaclConstants.SELECT_SRV_QUEST_TYPE.equals(project.getProjectTypeId().getName())) {
                maxPatients = PaclConstants.DEFAULT_SVA_SELECT_SERV_MAX_PATIENTS;
            }
        }
        isErrorGlobal = false;
        return maxPatients;
    }

    public void setMaxPatients(Long maxPatients) {
        this.maxPatients = maxPatients;
        project.setMaxPatients(maxPatients);
    }

    public Integer getSvaProjCounterRandom() throws Exception, NumberFormatException {

        String svaProjectCode = searchSvaProjectCd(PaclConstants.RANDOM_MONTHLY_TYPE);
        if (Util.notEmpty(svaProjectCode)) {
            svaProjCounterRandom = Integer.parseInt(
                    svaProjectCode.substring(PaclConstants.PREFIX_INDEX_SVA_CODE));
        }
        return svaProjCounterRandom;
    }

    public void setSvaProjCounterRandom(Integer svaProjCounterRandom) {
        this.svaProjCounterRandom = svaProjCounterRandom;
    }

    public String getSvaPrjRandomYear() throws Exception {

        String svaProjectCode = searchSvaProjectCd(PaclConstants.RANDOM_MONTHLY_TYPE);
        if (Util.notEmpty(svaProjectCode)) {
            svaPrjRandomYear = svaProjectCode.substring(
                    PaclConstants.PREFIX_YEAR_TWO_DIGITS_INDEX_SVA_CODE,
                    PaclConstants.PREFIX_INDEX_SVA_CODE);
        }
        return svaPrjRandomYear;
    }

    public void setSvaPrjRandomYear(String svaPrjRandomYear) {
        this.svaPrjRandomYear = svaPrjRandomYear;
    }

    public Integer getSvaProjCounterSelectService() throws Exception, NumberFormatException {

        String svaProjectCode = searchSvaProjectCd(PaclConstants.SELECT_SRV_TYPE);
        if (Util.notEmpty(svaProjectCode)) {
            svaProjCounterSelectService = Integer.parseInt(
                    svaProjectCode.substring(PaclConstants.PREFIX_INDEX_SVA_CODE));
        }
        return svaProjCounterSelectService;
    }

    public void setSvaProjCounterSelectService(Integer svaProjCounterSelectService) {
        this.svaProjCounterSelectService = svaProjCounterSelectService;
    }

    public String getSvaPrjSelectServiceYear() throws Exception {

        String svaProjectCode = searchSvaProjectCd(PaclConstants.SELECT_SRV_TYPE);
        if (Util.notEmpty(svaProjectCode)) {
            svaPrjSelectServiceYear = svaProjectCode.substring(
                    PaclConstants.PREFIX_YEAR_TWO_DIGITS_INDEX_SVA_CODE,
                    PaclConstants.PREFIX_INDEX_SVA_CODE);
        }
        return svaPrjSelectServiceYear;
    }

    public void setSvaPrjSelectServiceYear(String svaPrjSelectServiceYear) {
        this.svaPrjSelectServiceYear = svaPrjSelectServiceYear;
    }

    /**
     * Search for SVA project codes for each letter run type.
     *
     * @param letterRunType String - letter run type corresponding to SVA projects
     *
     * @return String
     */
    public String searchSvaProjectCd(String letterRunType) throws Exception {

        PracSvaProject svaProject = new PracSvaProject();
        try {
            List<PracSvaProject> svaProjectList = pracSvaProjectFacade.retrieveRecentSvaCode(letterRunType);
            if (PaclConstants.RANDOM_MONTHLY_TYPE.equals(letterRunType)) {
                if (svaProjectList.isEmpty()) {
                    svaProject.setSvaProjectCode(PaclConstants.SVA_PRJ_CODE_RANDOM_FIRST);
                    svaProjectList.add(svaProject);
                } else if (svaProjectList.size() >= 1) {
                    svaProject = svaProjectList.get(0);
                }
            } else if (PaclConstants.SELECT_SRV_TYPE.equals(letterRunType)) {
                if (svaProjectList.isEmpty()) {
                    svaProject.setSvaProjectCode(PaclConstants.SVA_PRJ_CODE_SELECT_SERVICE_FIRST);
                    svaProjectList.add(svaProject);
                } else if (svaProjectList.size() >= 1) {
                    svaProject = svaProjectList.get(0);
                }
            }

        } catch (EJBException e) {
            for (Throwable t = e.getCause(); t != null; t = t.getCause()) {
                if (t.getClass().getName().equals("java.sql.SQLException")) {
                    addErrorMessage("Cannot lookup record.");
                }
            }
        }
        // retrieve the SVA project code for each letter run type
        String svaProjectCode = svaProject.getSvaProjectCode();
        return svaProjectCode;
    }

}
