/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.pacl.web;

import ca.bc.gov.health.jsf.BaseBean;
import static ca.bc.gov.health.jsf.BaseBean.addErrorMessage;
import static ca.bc.gov.health.jsf.BaseBean.addInfoMessage;
import ca.bc.gov.health.pacl.ejb.entity.AdminOptions;
import ca.bc.gov.health.pacl.ejb.entity.ApplicationAuditDtlLog;
import ca.bc.gov.health.pacl.ejb.entity.ApplicationAuditLog;
import ca.bc.gov.health.pacl.ejb.entity.CodesProjectStatus;
import ca.bc.gov.health.pacl.ejb.entity.Letter;
import ca.bc.gov.health.pacl.ejb.entity.PharmacyProvider;
import ca.bc.gov.health.pacl.ejb.entity.Project;
import ca.bc.gov.health.pacl.ejb.session.AdminOptionsFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.ApplicationAuditLogFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.CodesProjectStatusFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.CodesProjectTypeFacadeLocal;
import ca.bc.gov.health.pacl.ejb.session.ProjectFacadeLocal;
import ca.bc.gov.health.pacl.service.EmailService;
import ca.bc.gov.health.pacl.util.PaclConstants;
import ca.bc.gov.health.pacl.util.Util;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.context.FacesContext;
import jakarta.faces.event.ValueChangeEvent;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;
import jakarta.servlet.http.HttpServletResponse;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;

/**
 * Backing bean for finding project and displaying project summary. Added close/archive projects and show statistical
 * reports functionality.
 *
 * @author dan.stepanov
 */
@Named("findProject")
@ViewScoped
public class FindProjectBean extends BaseBean {

    private static Logger logger = Logger.getLogger(FindProjectBean.class.getName());
    /**
     * new value for the pharmacy code.
     */
    private String code;
    /**
     * new value for the pharmacy name.
     */
    private String name;
    /**
     * new value for the project date.
     */
    private Date projectDate;
    /**
     * new value for the project year.
     */
    private String projectYear;
    /**
     * new value for the project status.
     */
    private Long projectStatus;
    /**
     * new value for the project type.
     */
    private Long projectType;

    private StringBuilder ReportCSV;
    /*
     * Email service instance for editing.
     */
    private EmailService emailService = new EmailService(PaclConstants.SERVER_EMAIL_HOST, PaclConstants.PACL_SYSTEM_NAME);

    /**
     * Facade for persistence.
     */
    @EJB
    private transient ProjectFacadeLocal projectFacade;

    @EJB
    private transient CodesProjectTypeFacadeLocal codesProjectTypeFacade;

    @EJB
    private transient ApplicationAuditLogFacadeLocal applicationAuditLogFacade;

    @EJB
    private transient CodesProjectStatusFacadeLocal codesProjectStatusFacade;

    @EJB
    private AdminOptionsFacadeLocal adminOptionsFacade;
    /**
     * The instance we're currently editing.
     */
    private Project project;

    /**
     * This index is set from the screen when the user selects a search result item the index is used to retrieve the
     * project details from the projects list.
     */
    private Integer selectedIndex;
    /**
     * List of search results to display.
     */
    private List<Project> projectResults = new ArrayList<>();

    /**
     * List of selected project
     */
    private List<Project> recentProjectsSelected = new ArrayList<>();
    /**
     * new value for project selection checkbox.
     */
    private boolean projectSelected = false;
    /**
     * List of pharmacy/PO providers for statistical report.
     */
    private List<PharmacyProvider> pharmProviders = new ArrayList<>();

    private Boolean displayStats = false;

    /**
     * Default constructor.
     */
    public FindProjectBean() {
        super();
    }

    /**
     * Initializes this bean after injection is complete.
     */
    @PostConstruct
    public void init() {
        clear();
    }

    /**
     * Clears the state of this bean.
     */
    public String clear() {
        project = new Project();
        project.setProjectTypeId(codesProjectTypeFacade.findByName("Pharmacy Project"));
        projectType = project.getProjectTypeId().getId();
        project.setStatusId(new CodesProjectStatus());
        projectResults = projectFacade.findRecent();
        recentProjectsSelected = new ArrayList<>();

        return null;
    }

    /**
     * Retrieves the project records based on the user selection criteria.
     *
     * @return String
     */
    public String findProjects() {
        // validate the form fields
        if (!validateFindProjects()) {
            return null;
        }
        String projectDateString = projectDate != null ? projectDate.toString() : "";
        logger.log(Level.INFO, "search param before query = "
                .concat("name = ").concat(name)
                .concat(" code = ").concat(code)
                .concat(" projectYear = ").concat(projectYear)
                .concat(" projectStatus = ").concat(String.valueOf(projectStatus))
                .concat("project date = ").concat(projectDateString));
        projectResults = projectFacade.findBySearchCriteria(name,
                code, projectDate, projectYear, projectStatus, projectType.toString());

        // add info message if there are no project records to display
        if (projectResults.isEmpty()) {
            addWarnMessage("No projects found for selected criteria. "
                    + "Please try again.");
        }
        return null;
    }

    /**
     * Validates user input search criteria and pharmacy code format from HI.
     *
     * @return boolean
     */
    public boolean validateFindProjects() {

        // verify that search criteria has at least one input field value
        if (Util.notEmpty(name)
                || Util.notEmpty(code)
                || Util.notEmpty(projectYear)
                || projectStatus != null
                || projectDate != null) {

            // validate the pharmacy/PO provider code format from HI
            // “BC00000axx” where ‘a’ means letter and x means letter or digit
            // (e.g. BC00000A12 and BC00000ABC)
            if (Util.notEmpty(code)) {
                Pattern p = Pattern.compile("^(BC00000)[A-Z][A-Z0-9]{2}$");
                if (!p.matcher(code).lookingAt()) {
                    // display error message if Pharmacy/P&O Provider input code doesn't have the latest format
                    addErrorMessage("Pharmacy/Provider input code doesn't match the latest formats.");
                    return false;
                }
            }
            // Search criteria is valid
            return true;
        }
        // Not enough search criteria
        addErrorMessage("Please enter at least one input value in the search criteria.");
        return false;
    }

    /**
     * Navigates to the project details page if a valid project instance is provided.
     *
     * @projectToView Project to view its details
     *
     * @return String
     */
    public final String showDetailsForProjectAction(Project projectToView) {

        if (projectToView != null) {
            FacesContext.getCurrentInstance().getExternalContext().getFlash().put("projectToView", (Project) projectToView);

            // Create Audit log
            ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("View Project Details");
            List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Application Username", findUserName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Details: Name", projectToView.getName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Details: Month", projectToView.getProjectMonth()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Details: Year", projectToView.getProjectYear()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Details: Id", (projectToView.getId().toString())));

            applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
            applicationAuditLogFacade.create(applicationAuditLog);

            return "projectDetail.xhtml?faces-redirect=true";
        }

        return "manageProjects.xhtml";

    }

    /**
     * Close the selected projects.
     *
     * @return String
     */
    public String close() {
        nullify();

        // verify if the project was already archived when select close function
        if (verifyProjectArchived()) {
            return null;
        }

        // Create Audit log
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Project(s) Closed Details");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Application Username", findUserName()));

        Date closedDate = new Date();
        for (Project projectForUpdate : recentProjectsSelected) {

            projectForUpdate.setClosedDate(closedDate);
            projectForUpdate.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_CLOSE));
            projectFacade.editWithReturn(projectForUpdate);

            // auditing log project close details
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Close Details: Name", projectForUpdate.getName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Close Details: Month", projectForUpdate.getProjectMonth()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Close Details: Year", projectForUpdate.getProjectYear()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Close Details: Id", (projectForUpdate.getId().toString())));

            //Check if the project has exceed daysBeforeArchive or is due to expired in less than SECOND_REMINDER_EMAIL
            Date projectCreateDate = project.getCreatedOnDtm();
            AdminOptions adminOptions = adminOptionsFacade.findDefaultPatientLimit().get(0);
            // get system admin email
            String serverAdminEmail = adminOptions.getServerAdminEmail();

            Calendar cal = Calendar.getInstance();
            cal.setTime(projectCreateDate);
            // get total days until the project is archived
            cal.add(Calendar.HOUR, 24 * (int) (adminOptions.getDaysBeforeArchive()));
            Date projectTimeoutDate = cal.getTime();
            Date todayDate = new Date();

            //Get number of day before the project will be archived
            int dayBeforeArchive = (int) ((projectTimeoutDate.getTime() - todayDate.getTime()) / (1000 * 60 * 60 * 24));

            //if project should already been archived, set the value to 0
            if (dayBeforeArchive < 0) {
                dayBeforeArchive = 0;
            }
            //Check if the project will be archive in less than the number of day that the second Email reminder is send
            if (dayBeforeArchive < adminOptions.getSecondReminderEmail()) {
                emailService.sendEmailNotifications(
                        project,
                        dayBeforeArchive, serverAdminEmail);
            }
        }

        // set auditing detail logs and saved audit records in database for closed projects
        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        // display info message for closing the selected projects
        addInfoMessage("The selected projects were successfully closed.");
        init();
        return null;
    }

    /**
     * Archive the selected projects.
     *
     * @return String
     */
    public String archive() {
        nullify();

        // verify if the project was closed before archive
        if (!verifyProjectClose()) {
            return null;
        }

        // Create Audit log
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Project(s) Archive Details");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Application Username", findUserName()));

        Date archiveDate = new Date();
        for (Project projectForUpdate : recentProjectsSelected) {

            projectForUpdate.setArchivedDate(archiveDate);
            projectForUpdate.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_ARCHIVE));
            projectFacade.editWithReturn(projectForUpdate);

            // auditing log project close details
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archive Details: Name", projectForUpdate.getName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archive Details: Month", projectForUpdate.getProjectMonth()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archive Details: Year", projectForUpdate.getProjectYear()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archive Details: Id", (projectForUpdate.getId().toString())));

        }

        // set auditing detail logs and saved audit records in database for archived projects
        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        addInfoMessage("The selected projects were successfully archived.");
        init();
        return null;
    }

    /**
     * Show statistical report for the selected projects.
     *
     * @return String
     */
    public String showStatisticalReport() {
        nullify();
        if (recentProjectsSelected.isEmpty()) {
            setDisplayStats(false);
            addWarnMessage("No projects were selected.");
            return null;
        }

        // verify if the project was already archived when selecting
        // statistical report function
        if (verifyIfArchived()) {
            return null;
        }

        // Create Audit log for Statistical Report
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Statistical Report Project(s)");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Statistical Report Username", findUserName()));

        // test statistical report
        // calculate statistical data for the selected projects
        calculateStatisticalInfo(recentProjectsSelected, logDetailList, applicationAuditLog);

        // set auditing detail logs and create audit records in database for
        // Statistical Report projects selected
        logger.log(Level.INFO, "logDetailList size = ".concat(String.valueOf(logDetailList.size())));
        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        // display info message for statistical reports selected projects
        addInfoMessage("Statistical report displayed for the selected projects.");
        generateReportCSV();
        setDisplayStats(true);
        return null;
    }

    /**
     * Sub-method to calculate statistical data and audit logs for the selected projects.
     *
     * @param projectsForStatistics List<Project> - list of selected projects to calculate statistics
     * @param logDetailList List<ApplicationAuditDtlLog> - list of auditing detail logs for the selected project
     * @param applicationAuditLog ApplicationAuditLog - application audit log object when create new record for
     * statistics
     *
     */
    public void calculateStatisticalInfo(
            List<Project> projectsForStatistics,
            List<ApplicationAuditDtlLog> logDetailList,
            ApplicationAuditLog applicationAuditLog) {

        int letterAnomalyPercentageTotalTemp = 0;
        int letterReturnsPercentageTotalTemp = 0;

        for (Project projectForUpdate : recentProjectsSelected) {

            project = projectForUpdate;
            List<PharmacyProvider> phamarcyProviderPerProject = projectForUpdate.getPharmacyProviderList();
            if (!phamarcyProviderPerProject.isEmpty()) {
                project.setPharmacyProviderList(phamarcyProviderPerProject);
            }
            logger.log(Level.INFO, "Pharmacy provider List size = ".concat(String.valueOf(project.getPharmacyProviderList().size())));
            int totalMailed = 0;
            int totalNotDelivered = 0;
            int totalAnomalies = 0;
            int totalDelivered = 0;
            int totalReturnsPerProject = 0;
            for (PharmacyProvider pharmacyPOprovider : project.getPharmacyProviderList()) {

                List<Letter> lettersPharmProvider = pharmacyPOprovider.getLetterList();
                List<Letter> lettersMailed = new ArrayList<>();
                List<Letter> lettersNonDelivered = new ArrayList<>();
                List<Letter> lettersConfirmed = new ArrayList<>();
                List<Letter> lettersAnomaly = new ArrayList<>();
                logger.log(Level.INFO, "letter list size = ".concat(String.valueOf(lettersPharmProvider.size())));
                if (!lettersPharmProvider.isEmpty()) {
                    for (Letter statLetter : lettersPharmProvider) {

                        // add Letter to lettersMailed list
                        if (statLetter.getLetterPrintedFlag() == PaclConstants.LETTER_PRINTED_FLAG
                                && statLetter.getLetterDate() != null) {
                            lettersMailed.add(statLetter);
                        }

                        // add Letter to lettersNonDelivered list
                        if (PaclConstants.LETTER_NON_DELIVERED.equals(statLetter.getStatusId().getName())) {
                            lettersNonDelivered.add(statLetter);
                        }

                        // add Letter to lettersConfirmed list
                        if (PaclConstants.LETTER_CONFIRMED.equals(statLetter.getStatusId().getName())) {
                            lettersConfirmed.add(statLetter);
                        }

                        // add Letter to lettersAnomaly list
                        if (PaclConstants.LETTER_ANOMALY.equals(statLetter.getStatusId().getName())) {
                            lettersAnomaly.add(statLetter);
                        }

                        logger.log(Level.INFO, "lettersMailed list size = ".concat(String.valueOf(lettersMailed.size())));
                        logger.log(Level.INFO, "lettersNonDelivered list size = ".concat(String.valueOf(lettersNonDelivered.size())));
                    }
                    if (!lettersMailed.isEmpty()) {
                        pharmacyPOprovider.setLetterMailed(lettersMailed.size());
                    }
                    if (!lettersNonDelivered.isEmpty()) {
                        pharmacyPOprovider.setLetterNonDelivered(lettersNonDelivered.size());
                    }
                    // add condition for negative numbers
                    int letterDeliver;
                    if (lettersNonDelivered.size() < lettersMailed.size()) {
                        letterDeliver = lettersMailed.size() - lettersNonDelivered.size();
                    } else {
                        letterDeliver = 0; // temp for percentage calculations
                    }
                    pharmacyPOprovider.setLetterDelivered(letterDeliver);

                    // setup total letters returned with status Confirmed and Anomaly
                    int letterTotalReturn = 0;
                    if (!lettersConfirmed.isEmpty() || !lettersAnomaly.isEmpty()) {
                        letterTotalReturn = lettersConfirmed.size() + lettersAnomaly.size();
                    } else if (!lettersConfirmed.isEmpty() && !lettersAnomaly.isEmpty()) {
                        letterTotalReturn = 0;
                    }
                    pharmacyPOprovider.setLetterTotalReturns(letterTotalReturn);

                    // setup total letters returned with Anomaly
                    int letterReturnAnomaly;
                    if (!lettersAnomaly.isEmpty()) {
                        letterReturnAnomaly = lettersAnomaly.size();
                    } else {
                        letterReturnAnomaly = 0; // temp for percentage calculations
                    }
                    pharmacyPOprovider.setLetterTotalAnomaly(letterReturnAnomaly);

                    // setup total percentage of letters returned and for
                    // total letters percentage with anomaly
                    int letterTotalPercentReturn;
                    int letterTotalPercentAnomaly;
                    if (letterDeliver > 0) {
                        letterTotalPercentReturn = (int) Math.round((100.0 * letterTotalReturn) / letterDeliver);
                        logger.log(Level.INFO, "letterTotalPercentReturn = ".concat(String.valueOf(letterTotalPercentReturn)));
                        letterTotalPercentAnomaly = (int) Math.round((100.0 * letterReturnAnomaly) / letterDeliver);
                        logger.log(Level.INFO, "letterTotalPercentAnomaly = ".concat(String.valueOf(letterTotalPercentAnomaly)));
                    } else {
                        letterTotalPercentReturn = 0;
                        letterTotalPercentAnomaly = 0;
                    }
                    pharmacyPOprovider.setLetterTotalPercentReturns(letterTotalPercentReturn);
                    pharmacyPOprovider.setLetterTotalPercentAnomaly(letterTotalPercentAnomaly);
                }
                //Calculate all Total per Project
                totalMailed += pharmacyPOprovider.getLetterMailed();
                totalNotDelivered += pharmacyPOprovider.getLetterNonDelivered();
                totalDelivered += pharmacyPOprovider.getLetterDelivered();
                totalAnomalies += pharmacyPOprovider.getLetterTotalAnomaly();
                logger.log(Level.INFO, "totalMailed size = ".concat(String.valueOf(totalMailed)));
                logger.log(Level.INFO, "totalNotDelivered size = ".concat(String.valueOf(totalNotDelivered)));
                logger.log(Level.INFO, "totalDelivered size = ".concat(String.valueOf(totalDelivered)));
                logger.log(Level.INFO, "totalDelivered size = ".concat(String.valueOf(totalAnomalies)));
                totalReturnsPerProject += pharmacyPOprovider.getLetterTotalReturns();
                letterReturnsPercentageTotalTemp += pharmacyPOprovider.getLetterTotalPercentReturns();

                letterAnomalyPercentageTotalTemp += pharmacyPOprovider.getLetterTotalPercentAnomaly();

            }
            project.setLetterMailedTotal(totalMailed);
            project.setLetterNotDeliverTotal(totalNotDelivered);
            project.setLetterDeliverTotal(totalDelivered);
            project.setLetterReturnsPerProjectTotal(totalReturnsPerProject);
            project.setLetterAnomalyTotal(totalAnomalies);

            if (project.getPharmacyProviderList().size() > 0) {
                letterReturnsPercentageTotalTemp = (int) Math.round(letterReturnsPercentageTotalTemp / project.getPharmacyProviderList().size());
                letterAnomalyPercentageTotalTemp = (int) Math.round(letterAnomalyPercentageTotalTemp / project.getPharmacyProviderList().size());
            } else {
                letterAnomalyPercentageTotalTemp = 0;
            }
            project.setLetterAnomalyPercentageTotal(letterAnomalyPercentageTotalTemp);
            project.setLetterReturnsPercentageTotal(letterReturnsPercentageTotalTemp);

            // auditing log for Statistical Report on selected projects
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Statistical Report Project: Id", project.getId().toString()));
        }
    }

    /**
     * Method to round the percentages to 1 decimal
     *
     * @param value
     * @param precision
     * @return
     */
    private static double round(double value, int precision) {
        int scale = (int) Math.pow(10, precision);
        return (double) Math.round(value * scale) / scale;
    }

    /**
     *
     * Pre-generate the CSV Report
     */
    public void generateReportCSV() {
        ReportCSV = new StringBuilder();
        ReportCSV.append("\"Project Name\",\"Practiotioner Code - Letter Run Name\","
                + "\"Letters Mailed\",\"Letters Not Delivered\","
                + "\"Letters Delivered\",\"Total Returns\",\"% Total Returns\","
                + "\"Total Anomalies\",\"% Total Anomalies\"\n");

        for (Project projectForUpdate : recentProjectsSelected) {

            project = projectForUpdate;
            for (PharmacyProvider pharmacyPOprovider : project.getPharmacyProviderList()) {

                // exporting report for each Sva Project per selected project
                ReportCSV.append("\"").append(project.getName()).append("\",");
                ReportCSV.append("\"").append(pharmacyPOprovider.getCode()).append("-").append(pharmacyPOprovider.getName()).append("\",");
                ReportCSV.append("\"").append(pharmacyPOprovider.getLetterMailed()).append("\",");
                ReportCSV.append("\"").append(pharmacyPOprovider.getLetterNonDelivered()).append("\",");
                ReportCSV.append("\"").append(pharmacyPOprovider.getLetterDelivered()).append("\",");
                ReportCSV.append("\"").append(pharmacyPOprovider.getLetterTotalReturns()).append("\",");
                ReportCSV.append("\"").append(pharmacyPOprovider.getLetterTotalPercentReturns()).append("%\",");
                ReportCSV.append("\"").append(pharmacyPOprovider.getLetterTotalAnomaly()).append("\",");
                ReportCSV.append("\"").append(pharmacyPOprovider.getLetterTotalPercentAnomaly()).append("%\"\n");
            }
            // exporting report totals summary values for each project
            ReportCSV.append("\"Project Summary Totals" + "\",");
            ReportCSV.append("\"" + "\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterMailedTotal()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterNotDeliverTotal()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterDeliverTotal()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterReturnsPerProjectTotal()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterReturnsPercentageTotal()).append("%\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterAnomalyTotal()).append("\",");
            ReportCSV.append("\"").append(projectForUpdate.getLetterAnomalyPercentageTotal()).append("%\"\n");
        }

    }

    /**
     * Export statistical report for selected projects as CSV.
     *
     * @return String
     */
    public String exportReportCSV() {

        HttpServletResponse response = (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();
        response.setContentType("text/csv");
        response.setHeader("content-disposition", "attachment;filename=StatisticalReportExport.csv");
        try (PrintWriter out = response.getWriter()) {
            out.print(ReportCSV.toString());
            addInfoMessage("Statistical Report has been exported succesfully");
        } catch (Exception e) {
            addErrorMessage("Unable to export statistical report: " + e.getMessage());
        }
        return null;
    }

    /**
     * Verify if project is closed before archive it.
     *
     * @return boolean
     */
    public final boolean verifyProjectClose() {

        boolean isNotError = true;
        // check if selected project status is 'Closed'
        List<Project> projectsToArchive = new ArrayList<>();
        List<Project> projectSelections = new ArrayList<>();
        for (Project projectForUpdate : recentProjectsSelected) {

            projectSelections.add(projectForUpdate);
            if (projectForUpdate.getClosedDate() == null
                    && !PaclConstants.PROJECT_STATUS_CLOSE.equals(projectForUpdate.getStatusId().getName())) {
                projectsToArchive.add(projectForUpdate);
            }

        }
        // check if projects were not selected and display warn message
        if (projectSelections.isEmpty()) {
            addWarnMessage("No projects were selected.");
            isNotError = false;
        }
        // display an error message if selected project status is not 'Closed'
        if (!projectsToArchive.isEmpty()) {
            addErrorMessage("The Project Status must be 'Closed' "
                    + "before being 'Archived' for the selected projects.");
            isNotError = false;
        }

        return isNotError;
    }

    /**
     * Verify if project is archived when user re-select to close it.
     *
     * @return boolean
     */
    public final boolean verifyProjectArchived() {

        boolean isError = false;
        // create new lists for project selections/archived/closed
        List<Project> projectsArchived = new ArrayList<>();
        List<Project> projectSelections = new ArrayList<>();
        List<Project> projectsClosed = new ArrayList<>();
        for (Project projectForUpdate : recentProjectsSelected) {

            projectSelections.add(projectForUpdate);
            if (projectForUpdate.getArchivedDate() == null
                    && PaclConstants.PROJECT_STATUS_ARCHIVE.equals(projectForUpdate.getStatusId().getName())) {
                projectsArchived.add(projectForUpdate);
            }
            if (projectForUpdate.getClosedDate() != null
                    && PaclConstants.PROJECT_STATUS_CLOSE.equals(projectForUpdate.getStatusId().getName())) {
                projectsClosed.add(projectForUpdate);
            }

        }
        // check if projects were not selected and display warn message
        if (projectSelections.isEmpty()) {
            addWarnMessage("No projects were selected.");
            isError = true;
        }
        // display an error message if selected project status is 'Archived'
        // and user selects Close function
        if (!projectsArchived.isEmpty()) {
            addErrorMessage("The Project Status is 'Archived' "
                    + "for the selected projects.");
            isError = true;
        }
        // display an error message if selected projects were already closed
        if (!projectsClosed.isEmpty()) {
            addErrorMessage("The selected projects were already closed.");
            isError = true;
        }

        return isError;
    }

    /**
     * Verify if project archived when user selects statistical report function.
     *
     * @return boolean
     */
    public final boolean verifyIfArchived() {

        boolean isError = false;
        // create new lists for project selections/archived
        List<Project> projectsArchived = new ArrayList<>();
        List<Project> projectSelections = new ArrayList<>();
        for (Project projectForUpdate : recentProjectsSelected) {

            projectSelections.add(projectForUpdate);
            if (projectForUpdate.getArchivedDate() == null
                    && PaclConstants.PROJECT_STATUS_ARCHIVE.equals(projectForUpdate.getStatusId().getName())) {
                projectsArchived.add(projectForUpdate);
            }

        }
        // check if projects were not selected and display warn message
        if (projectSelections.isEmpty()) {
            addWarnMessage("No projects were selected.");
            isError = true;
        }
        // display an error message if selected project status is 'Archived'
        // and user selects Close function
        if (!projectsArchived.isEmpty()) {
            addErrorMessage("The Project Status is 'Archived' "
                    + "for the selected projects.");
            isError = true;
        }

        return isError;
    }

    /**
     * Nullifies any child objects which don't have valid PKs set.
     */
    private void nullify() {
        if (project.getProjectTypeId() != null && project.getProjectTypeId().getId() == null) {
            project.setProjectTypeId(null);
        }
        if (project.getStatusId() != null && project.getStatusId().getId() == null) {
            project.setStatusId(null);
        }
    }

    /* Getters and Setters */
    public Date getProjectDate() throws Exception {
        return projectDate;
    }

    public void setProjectDate(Date projectDate) {
        this.projectDate = projectDate;
    }

    public void changeProjectType(ValueChangeEvent e) {
        project.setProjectTypeId(codesProjectTypeFacade.find(e.getNewValue()));
        projectType = codesProjectTypeFacade.find(e.getNewValue()).getId();
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getProjectYear() {
        return projectYear;
    }

    public void setProjectYear(String projectYear) {
        this.projectYear = projectYear;
    }

    public Long getProjectStatus() {
        return projectStatus;
    }

    public void setProjectStatus(Long projectStatus) {
        this.projectStatus = projectStatus;
    }

    public Project getProject() {
        return project;
    }

    public void setProject(Project project) {
        this.project = project;
    }

    public Integer getSelectedIndex() {
        return selectedIndex;
    }

    public void setSelectedIndex(Integer selectedIndex) {
        this.selectedIndex = selectedIndex;
    }

    public List<Project> getProjectResults() {
        return projectResults;
    }

    public void setProjectResults(List<Project> projectResults) {
        this.projectResults = projectResults;
    }

    public boolean isProjectSelected() {
        return projectSelected;
    }

    public void setProjectSelected(boolean projectSelected) {
        this.projectSelected = projectSelected;
    }

    public List<PharmacyProvider> getPharmProviders() {
        return pharmProviders;
    }

    public void setPharmProviders(List<PharmacyProvider> pharmProviders) {
        this.pharmProviders = pharmProviders;
    }

    public Boolean getDisplayStats() {
        return displayStats;
    }

    public void setDisplayStats(Boolean displayStats) {
        this.displayStats = displayStats;
    }

    public List<Project> getRecentProjectsSelected() {
        return recentProjectsSelected;
    }

    public void setRecentProjectsSelected(List<Project> recentProjectsSelected) {
        this.recentProjectsSelected = recentProjectsSelected;
    }

}
