package ca.bc.gov.health.pacl.web;

import ca.bc.gov.health.jsf.BaseBean;
import ca.bc.gov.health.pacl.ejb.entity.*;
import ca.bc.gov.health.pacl.ejb.session.*;
import ca.bc.gov.health.pacl.jasper.JasperLetterMsp;
import ca.bc.gov.health.pacl.service.EmailService;
import ca.bc.gov.health.pacl.util.PaclConstants;
import jakarta.annotation.Resource;
import jakarta.ejb.EJB;
import jakarta.enterprise.context.SessionScoped;
import jakarta.faces.context.FacesContext;
import jakarta.inject.Named;
import jakarta.jms.ConnectionFactory;
import jakarta.jms.JMSException;
import jakarta.jms.MessageProducer;
import jakarta.jms.Queue;
import jakarta.jms.Session;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.ResourceBundle;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.primefaces.component.datatable.DataTable;
import org.primefaces.event.CellEditEvent;

/**
 * Backing bean for manage project details.
 *
 * @author Michael.Tremblay
 */
@Named("letterRunDetail")
@SessionScoped
public class LetterRunDetailBean extends BaseBean {

    @Resource(mappedName = "jms/Queue")
    private Queue queue;

    @Resource(mappedName = "jms/QueueFactory")
    private ConnectionFactory queueFactory;

    private static ResourceBundle bundle = ResourceBundle.getBundle("MessageResources", FacesContext.getCurrentInstance().getViewRoot().getLocale());

    private static final String className = LetterRunDetailBean.class.getName();

    private static final Logger logger = Logger.getLogger(className);

    private static enum Result {

        SUCCESS("SUCCESS"), ERROR("ERROR"), WARNING("WARNING");
        private final String literal;

        Result(String value) {
            this.literal = value;
        }

        @Override
        public String toString() {
            return literal;
        }
    };

    /**
     * EJB to handle persistence.
     */
    @EJB
    private transient ProjectFacadeLocal projectFacade;
    /* EJB to handle PracSva instances */
    @EJB
    private transient PracSvaProjectFacadeLocal pracSvaFacade;

    @EJB
    private transient ApplicationAuditLogFacadeLocal applicationAuditLogFacade;
    @EJB
    private transient CodesProjectStatusFacadeLocal codesProjectStatusFacade;

    @EJB
    private HealthideasFacadeLocal healthideasFacade;

    @EJB
    private AdminOptionsMspFacadeLocal adminOptionsMspFacade;
    
    @EJB
    private NotificationFacadeLocal notificationFacade;

    /**
     * Instances we're currently editing.
     */
    private Project project;

    private PracSvaProject svaProject;

    /**
     * Flag managing Print buttons availability.
     */
    private boolean disablePrintButtons = true;

    /**
     * Select/Un-select all letters for the pharmacy.
     */
    private boolean selectAll = false;
    /**
     * Local instance of the printing date.
     */
    private Date printingDate;

    /**
     * List of selected patients based on the pharmacy/provider selection.
     */
    private List<JasperLetterMsp> selectedPatientsList = new ArrayList<>();
    /**
     * Message to be displayed when the letter status is changed.
     */
    private Long projectId;

    private List<PracSvaProject> svaResults = new ArrayList<>();

    private List<PracSvaProject> svaResultsSelected = new ArrayList<>();

    private boolean disablePrint;

    /*
     * Email service instance for editing.
     */
    private EmailService emailService = new EmailService(PaclConstants.SERVER_EMAIL_HOST, PaclConstants.EACL_SYSTEM_NAME);

    /**
     * Default Constructor.
     */
    public LetterRunDetailBean() {
    }

    public void init() {

        long projectId = (long) FacesContext.getCurrentInstance().getExternalContext().getFlash().get("projectToView");
        Project project_ = projectFacade.findProjectById(projectId);

        svaProject = new PracSvaProject();
        svaResults = new ArrayList<>();
        svaResultsSelected = new ArrayList<>();

        if (project_ != null) {
            try {
                // set the previously selected project
                project = project_;

                selectedPatientsList = new ArrayList<>();

                svaResults = pracSvaFacade.findSvaByProjectId(project);
            } catch (Exception e) {
                addErrorMessage(e.getMessage());
            }
        }
    }

    /**
     *
     * Use to reset data from letter run detail when it is not an ajax request
     */
    public void resetData() {
        if (!FacesContext.getCurrentInstance().getPartialViewContext().isAjaxRequest()) {
            printingDate = null;
            init();
        }
    }

    /**
     * Allows the edited data from the table to be persisted
     *
     * @param event
     */
    public void onCellEdit(CellEditEvent event) {

        PracSvaProject projectEdit = (PracSvaProject) ((DataTable) event.getComponent()).getRowData();
        pracSvaFacade.edit(projectEdit);
        svaResults = new ArrayList<>();
        svaResults = pracSvaFacade.findSvaByProjectId(project);
        addInfoMessage(bundle.getString("letterRun.Detail.SvaModifs"));
    }

    /**
     * Verifies if the letter run still had opened SVA projects
     *
     * @param p
     * @return
     */
    public boolean validateOpenSvaProject(Project p) {

        boolean isOpen = false;

        for (PracSvaProject sva : pracSvaFacade.findSvaByProjectId(p)) {
            if (sva.getSvaProjectStatusId().getName().equals(PaclConstants.PROJECT_STATUS_OPEN)) {
                isOpen = true;

                return isOpen;
            }
        }
        return isOpen;
    }

    /**
     * Code to format the date to the specific format
     *
     * @param dateToFormat
     * @return String
     */
    public String dateFormatter(Date dateToFormat) {

        if (dateToFormat != null) {
            return new SimpleDateFormat("yyyy-MM-dd").format(dateToFormat);
        } else {
            return "";
        }
    }

    /**
     * Method that redirects the user to the Letter Run details page
     *
     * @param project
     * @return String
     */
    public final String showDetailsPatientAction(Project project) {

        if (project != null) {

            FacesContext.getCurrentInstance().getExternalContext().getFlash().put("projectToView", (Project) project);

            // Create Audit log
            ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("View Patient Details : ");
            List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Application Username", findUserName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Details: Name", project.getName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Details: Month", project.getProjectMonth()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Details: Year", project.getProjectYear()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Run Details: Id", (project.getId().toString())));

            applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
            applicationAuditLogFacade.create(applicationAuditLog);

            return "PatientDetail.xhtml?faces-redirect=true";
        }

        return "LetterRunDetails.xhtml";
    }

    /**
     * Close the selected project.
     *
     * @return String
     */
    public String close() {
        nullify();
        // verify if the project status was already closed
        if (!verifyProjectStatus()) {
            return null;
        }
        if (!validateOpenSvaProject(project)) {
            Date closedDate = new Date();
            project.setClosedDate(closedDate);
            project.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_CLOSE));
            projectFacade.editWithReturn(project);

            //Check if the project has exceed daysBeforeArchive or is due to expired in less than SECOND_REMINDER_EMAIL
            Date projectCreateDate = project.getCreatedOnDtm();
            AdminOptionsMsp adminOptions = adminOptionsMspFacade.findDefaultPatientLimit().get(0);
            // get system admin email
            String serverAdminEmail = adminOptions.getServerAdminEmail();

            Calendar cal = Calendar.getInstance();
            cal.setTime(projectCreateDate);
            // get total days until the project is archived
            cal.add(Calendar.HOUR, 24 * (int) (adminOptions.getDaysBeforeArchive()));
            Date projectTimeoutDate = cal.getTime();
            Date todayDate = new Date();

            //Get number of day before the project will be archived
            int dayBeforeArchive = (int) ((projectTimeoutDate.getTime() - todayDate.getTime()) / (1000 * 60 * 60 * 24));

            //if project should already been archived, set the value to 0
            if (dayBeforeArchive < 0) {
                dayBeforeArchive = 0;
            }
            //Check if the project will be archive in less than the number of day that the second Email reminder is send
            if (dayBeforeArchive < adminOptions.getSecondReminderEmail()) {
                emailService.sendEmailNotifications(
                        project,
                        dayBeforeArchive, serverAdminEmail);
            }

            // Create Audit log for closed project
            ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Project Closed Details");
            List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed by Username", findUserName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Name", project.getName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Month", project.getProjectMonth()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Year", project.getProjectYear()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Id", (project.getId().toString())));

            applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
            applicationAuditLogFacade.create(applicationAuditLog);

            // display info message on screen when selected project was closed
            addInfoMessage(bundle.getString("project.projectDetails.closeLetterRun"));
            setProjectId(project.getId());
            logger.log(Level.INFO, "inside close before refresh projectId = ".concat(String.valueOf(projectId.longValue())));
            return null;
        } else {
            addErrorMessage(bundle.getString("letterRun.Search.CloseError"));
            return null;
        }
    }

    /**
     * Used to close SVA project
     *
     * @return
     */
    public String closeProject() {

        Date closedDate = new Date();

        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("SVA Project Closed Details");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        if (svaResultsSelected.isEmpty()) {
            addWarnMessage(bundle.getString("project.projectDetails.noProjectSelected"));
        }

        for (PracSvaProject projectForUpdate : svaResultsSelected) {
            projectForUpdate.setSvaProjectCloseDate(closedDate);
            projectForUpdate.setSvaProjectStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_CLOSE));
            pracSvaFacade.edit(projectForUpdate);
        }

        addInfoMessage(bundle.getString("project.projectDetails.changeStatus"));
        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);
        svaResults = new ArrayList<>();
        svaResultsSelected = new ArrayList<>();
        svaResults = pracSvaFacade.findSvaByProjectId(project);

        return null;
    }

    /**
     * Used to reopen a SVA project
     *
     * @return
     */
    public String openProject() {

        Date closedDate = null;

        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("SVA Project Opened Details");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();

        if (svaResultsSelected.isEmpty()) {
            addWarnMessage(bundle.getString("project.projectDetails.noProjectSelected"));
            return null;
        }

        for (PracSvaProject projectForUpdate : svaResultsSelected) {

            projectForUpdate.setSvaProjectCloseDate(closedDate);
            projectForUpdate.setSvaProjectStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_OPEN));
            pracSvaFacade.edit(projectForUpdate);
        }
        addInfoMessage(bundle.getString("project.projectDetails.changeStatus"));
        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        svaResultsSelected = new ArrayList<>();
        svaResults = new ArrayList<>();
        svaResults = pracSvaFacade.findSvaByProjectId(project);

        return null;
    }

    /**
     * Archive the selected project.
     *
     * @return String
     */
    public String archive() {
        nullify();

        // verify if the project was closed before archive
        if (!verifyProjectClose()) {
            return null;
        }
        Date archiveDate = new Date();
        project.setArchivedDate(archiveDate);
        project.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_ARCHIVE));
        projectFacade.editWithReturn(project);

        // Create Audit log for closed project
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Project Archived Details");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived by Username", findUserName()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Name", project.getName()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Month", project.getProjectMonth()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Year", project.getProjectYear()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Id", (project.getId().toString())));

        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        // display info message on screen when selected project was archived
        addInfoMessage(bundle.getString("project.projectDetails.archiveProject"));
        setProjectId(project.getId());
        return null;
    }

    /**
     * Verify if project is closed before archiving it.
     *
     * @return boolean
     */
    public final boolean verifyProjectClose() {
        // check if project status is 'Closed' and if not display error message
        if (project.getClosedDate() == null && !PaclConstants.PROJECT_STATUS_CLOSE.equals(project.getStatusId().getName())) {
            addErrorMessage(bundle.getString("project.projectDetails.checkProjectClosed"));
            return false;
        }
        return true;
    }

    public final boolean verifyProjectStatus() {
        // check if project status was already 'Closed' and display error message
        if (project.getClosedDate() != null && PaclConstants.PROJECT_STATUS_CLOSE.equals(project.getStatusId().getName())) {
            addErrorMessage(bundle.getString("project.projectDetails.checkProjectStatus"));
            return false;
        }
        return true;
    }

    //Function used to send a message to the JMS Queue. 
    public String sendJMSMessageToQueue() throws JMSException {
        //Verifies if there is already a running letter run process
        if (notificationFacade.isActivePrintRun()) {

            logger.log(Level.INFO, "There is already a job running. Print process will be available when it is completed.");
            addErrorMessage("There is already a letter run being printed. You will be able to print one as soon as the process is completed.");

        } else {
            addToQueue();
        }
        return null;
    }

    private void addToQueue() throws JMSException {

        jakarta.jms.Connection connection = null;
        Session session = null;
        try {
            connection = queueFactory.createConnection();
            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
            
            String channel = HealthIdeasLogin.getUserChannel();

            //Sets all the cache information
            ConcurrentHashMap<String, Object> mapper = new ConcurrentHashMap();
            mapper.put("projectObject", project);
            mapper.put("svaResultsSelected", svaResultsSelected);
            mapper.put("printingDate", printingDate);
            mapper.put("channel", channel);
            mapper.put("timestamp", new org.joda.time.DateTime());
            mapper.put("userLoggedIn", true);
            mapper.put("pendingPush", false);
            mapper.put("runningProcess", true);

            Notifications notification = new Notifications();
            notification.setUserChannel(channel);
            notification.setLetterRunName(project.getName());
            notification.setCreateOrPrint("Print");
            notification.setMessage("Print run started");
            notification.setProcessStart(new Date());
                 
            notificationFacade.create(notification);
            notificationFacade.flushClear();

            addInfoMessage("Letter Printing process has been started");

            //Send message to start the printing process
            try (MessageProducer messageProducer = session.createProducer(queue)) {
                messageProducer.send(session.createObjectMessage(mapper));
            }

        } finally {
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    Logger.getLogger(this.getClass().getName()).log(Level.WARNING, "Cannot close session", e);
                }
            }
            if (connection != null) {
                connection.close();
            }

        }

    }

    /**
     * Nullifies any child objects which don't have valid PKs set.
     */
    private void nullify() {
        if (project.getProjectTypeId() != null && project.getProjectTypeId().getId() == null) {
            project.setProjectTypeId(null);
        }
        if (project.getStatusId() != null && project.getStatusId().getId() == null) {
            project.setStatusId(null);
        }
    }

    public boolean isEmpty() {
        return svaResultsSelected.isEmpty();

    }

    /* Getters and Setters */
    public Project getProject() {
        return project;
    }

    public void setProject(Project project) {
        this.project = project;
    }

    public PracSvaProject getSvaProject() {
        return svaProject;
    }

    public void setSvaProject(PracSvaProject svaProject) {
        this.svaProject = svaProject;
    }

    public List<JasperLetterMsp> getSelectedPatientsList() {
        return selectedPatientsList;
    }

    public void setSelectedPatientsList(List<JasperLetterMsp> selectedPatientsList) {
        this.selectedPatientsList = selectedPatientsList;
    }

    public Date getPrintingDate() {
        return printingDate;
    }

    public void setPrintingDate(Date printingDate) {
        this.printingDate = printingDate;
    }

    public boolean isSelectAll() {
        return selectAll;
    }

    public boolean isDisablePrintButtons() {
        return disablePrintButtons;
    }

    public void setDisablePrintButtons(boolean value) {
        this.disablePrintButtons = value;
    }

    public Long getProjectId() {
        return projectId;
    }

    public void setProjectId(Long projectId) {
        this.projectId = projectId;
    }

    public List<PracSvaProject> getSvaResults() {
        return svaResults;
    }

    public void setSvaResults(List<PracSvaProject> svaResults) {
        this.svaResults = svaResults;
    }

    public List<PracSvaProject> getSvaResultsSelected() {
        return svaResultsSelected;
    }

    public void setSvaResultsSelected(List<PracSvaProject> svaResultsSelected) {
        this.svaResultsSelected = svaResultsSelected;
    }

    public boolean isDisablePrint() {
        return disablePrint;
    }

    public void setDisablePrint(boolean disablePrint) {
        this.disablePrint = disablePrint;
    }
}
