/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.Messages;

import ca.bc.gov.health.pacl.ejb.entity.Notifications;
import ca.bc.gov.health.pacl.ejb.entity.PracSvaProject;
import ca.bc.gov.health.pacl.ejb.entity.Project;
import ca.bc.gov.health.pacl.ejb.session.NotificationFacadeLocal;
import ca.bc.gov.health.process.ProcessLettersInterface;
import jakarta.ejb.ActivationConfigProperty;
import jakarta.ejb.EJB;
import jakarta.ejb.MessageDriven;
import jakarta.jms.JMSException;
import jakarta.jms.Message;
import jakarta.jms.MessageListener;
import jakarta.jms.ObjectMessage;
import java.io.IOException;
import java.util.Date;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Michael.Tremblay
 */
@MessageDriven(mappedName = "jms/Queue", activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "jakarta.jms.Queue")
})
public class PrintMessage implements MessageListener {

    @EJB
    private ProcessLettersInterface processInterface;
    
    @EJB
    private NotificationFacadeLocal notificationFacade;

    private static final String className = PrintMessage.class.getName();
    private static final Logger logger = Logger.getLogger(className);

    public PrintMessage() {
    }

    @Override
    public void onMessage(Message message) {

        ObjectMessage msg = (ObjectMessage) message;
        //Getting the cache hashmap from the message
        ConcurrentHashMap<String, Object> mapper = new ConcurrentHashMap();
        try {
            mapper = (ConcurrentHashMap<String, Object>) msg.getObject();
        } catch (JMSException ex) {
            logger.log(Level.SEVERE, null, ex);
        }

        Project project;
        List<PracSvaProject> svaResultsSelected;
        Date printingDate;
        String channel;
        List<Notifications> notifications;

        //Getting information from hashmap (cache)
        channel = (String) mapper.get("channel");
        project = (Project) mapper.get("projectObject");
        svaResultsSelected = (List<PracSvaProject>) mapper.get("svaResultsSelected");
        printingDate = (Date) mapper.get("printingDate");
        String messageToPrint;
        try {
            //Start letter printing process
            messageToPrint = processInterface.generateLetters(project.getId(), svaResultsSelected, printingDate);

            notifications = notificationFacade.findActivePrintRun(channel);

            if ((notifications != null) && (!notifications.isEmpty())) {
                
                //On the off chance a previous print notification didnt get set to finished we want to set them all
                for (Notifications notification : notifications) {              
                    notification.setProcessFinish(new Date());
                    notification.setMessage(messageToPrint);
                    notificationFacade.edit(notification);                
                }       
                logger.log(Level.INFO, channel.concat("'s print run complete, updated record"));
            } else {
                logger.log(Level.SEVERE, "User : ".concat(channel).concat(" has no active print run recorded"));
            }
            notificationFacade.flushClear();
        } catch (IOException ex) {
            Logger.getLogger(PrintMessage.class.getName()).log(Level.SEVERE, null, ex);
        }

    }
}
