package ca.bc.gov.health.pacl.web;

import ca.bc.gov.health.jsf.BaseBean;
import static ca.bc.gov.health.jsf.BaseBean.addErrorMessage;
import static ca.bc.gov.health.jsf.BaseBean.addInfoMessage;
import ca.bc.gov.health.pacl.ejb.entity.*;
import ca.bc.gov.health.pacl.ejb.session.*;
import ca.bc.gov.health.pacl.model.LetterMspDetailSelector;
import ca.bc.gov.health.pacl.util.PaclConstants;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.component.UIData;
import jakarta.faces.context.FacesContext;
import jakarta.faces.event.ValueChangeEvent;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.primefaces.component.datatable.DataTable;
import org.primefaces.event.CellEditEvent;

/**
 * Backing bean for manage project details.
 *
 * @author JSF Code Generator
 */
@Named("patientDetail")
@ViewScoped
public class PatientDetailBean extends BaseBean {

    private static ResourceBundle bundle = ResourceBundle.getBundle("MessageResources", FacesContext.getCurrentInstance().getViewRoot().getLocale());
    private static final String className = ProjectDetailBean.class.getName();

    private static final Logger logger = Logger.getLogger(className);

    /**
     * EJB to handle persistence.
     */
    @EJB
    private transient ProjectFacadeLocal projectFacade;
    /* EJB to handle PharmacyProvider instances */
    @EJB
    private transient PracSvaProjectFacadeLocal pracSvaFacade;
    /* EJB to handle Letter instances */
    @EJB
    private transient LetterMspDetailFacadeLocal letterMspFacade;
    @EJB
    private transient ApplicationAuditLogFacadeLocal applicationAuditLogFacade;
    @EJB
    private transient CodesProjectStatusFacadeLocal codesProjectStatusFacade;
    @EJB
    private transient CodesLetterStatusFacadeLocal codesLetterStatusFacade;

    /**
     * Instances we're currently editing.
     */
    private Project project;
    private PracSvaProject svaProject;
    private LetterMspDetail letter;

    private Project projectClicked;

    /**
     * Flag managing Print buttons availability.
     */
    private boolean disablePrintButtons = true;

    /**
     * Select/Un-select all letters for the pharmacy.
     */
    private boolean selectAll = false;
    /**
     * Local instance of the printing date.
     */
    private Date printingDate;
    /**
     * List of patient letters for the selected pharmacy/provider.
     */
    private List<LetterMspDetail> lettersAll = new ArrayList<>();
    /**
     * List of selected patients based on the pharmacy/provider selection.
     */
    private List<LetterMspDetail> selectedLettersList = new ArrayList<>();
    /**
     * Message to be displayed when the letter status is changed.
     */
    private Long projectId;

    private List<PracSvaProject> svaResults = new ArrayList<>();

    private List<LetterMspDetail> letterResults = new ArrayList<>();

    private List<LetterMspDetailSelector> letterResultsSel = new ArrayList<>();

    private List<String> filterList = new ArrayList<>();

    private LetterMspDetailSelector letterSelector;

    private String filterOption;
    private int patientCount;
    /**
     * Message to be displayed when the letter status is changed.
     */
    private String CHANGE_MESSAGE = "";

    /**
     * Default Constructor.
     */
    public PatientDetailBean() {
    }

    /**
     * Initializes this bean.
     */
    @PostConstruct
    public void init() {
        CHANGE_MESSAGE = bundle.getString("project.projectDetails.letter.changeStatus");

        Project project_ = (Project) FacesContext.getCurrentInstance().getExternalContext().getFlash().get("projectToView");
        letter = new LetterMspDetail();
        letterResults = new ArrayList<>();
        letterResultsSel = new ArrayList<>();
        filterList = new ArrayList<>();
        patientCount = 0;

        if (project_ != null) {
            try {
                // set the previously selected project
                project = project_;

                letterResults = letterMspFacade.findByProjectId(project);

                for (LetterMspDetail letterSel : letterResults) {
                    patientCount++;
                    LetterMspDetailSelector letterSelectorInstance = new LetterMspDetailSelector();
                    letterSelectorInstance.setLetterMspDetail(letterSel);
                    letterSelectorInstance.setLetterSelected(false);
                    letterResultsSel.add(letterSelectorInstance);
                }

                populateFilterOptions();

            } catch (Exception e) {
                addErrorMessage(e.getMessage());
            }
        }
    }

    /**
     * Method used to populate the filter to filter the letter run
     */
    public void populateFilterOptions() {

        boolean exists;

        for (LetterMspDetail letterSel : letterResults) {
            exists = false;
            String svaProjectCode = letterSel.getPracSvaProjectId().getPracBllgNum() + "-" + letterSel.getPracSvaProjectId().getSvaProjectCode();

            for (String item : filterList) {
                if (item.equals(svaProjectCode)) {
                    exists = true;
                }
            }

            if (!exists) {
                filterList.add(svaProjectCode);
            }
        }
        Collections.sort(filterList);
        filterList.add(0,"All");
    }

    /**
     * Method used to refresh the datatable results
     */
    public void changeLetterList() {

        if (!filterOption.equals("All") && filterOption.contains("-")) {
            // Letters for the selected PracCode/SVA Project
            String[] parts = filterOption.split("-");
            String pracCode = parts[0];
            String svaCode = parts[1];
            List<LetterMspDetail> list = letterMspFacade.findBySvaCodePracCode(pracCode, svaCode, project.getId().intValue());
            letterResultsSel = new ArrayList<>();
            patientCount = 0;
            for (LetterMspDetail item : list) {
                patientCount++;
                LetterMspDetailSelector letterSelectorInstance = new LetterMspDetailSelector();
                letterSelectorInstance.setLetterMspDetail(item);
                letterSelectorInstance.setLetterSelected(false);
                letterResultsSel.add(letterSelectorInstance);
            }

        } else { // Selecting all letters for LetterRun

            letterResultsSel = new ArrayList<>();
            patientCount = 0;
            letterResults = letterMspFacade.findByProjectId(project);

            for (LetterMspDetail letterSel : letterResults) {
                patientCount++;
                LetterMspDetailSelector letterSelectorInstance = new LetterMspDetailSelector();
                letterSelectorInstance.setLetterMspDetail(letterSel);
                letterSelectorInstance.setLetterSelected(false);
                letterResultsSel.add(letterSelectorInstance);
            }
        }
    }

    /**
     * Allows the edited data from the table to be persisted
     *
     * @param event
     */
    public void onCellEdit(CellEditEvent event) {

        LetterMspDetailSelector letterEdit = (LetterMspDetailSelector) ((DataTable) event.getComponent()).getRowData();

        CodesLetterStatus status = codesLetterStatusFacade.findById(letterEdit.getLetterMspDetail().getStatusId().getId().intValue());

        letterEdit.getLetterMspDetail().setStatusId(status);

        letterMspFacade.edit(letterEdit.getLetterMspDetail());

        addInfoMessage(bundle.getString("patientDetail.modifsLetters"));
    }

    /**
     * Change the patient letter status depending on the user selection.
     */
    public void changeLetterStatus(ValueChangeEvent e) {
        if ((Long) e.getNewValue() != -1) {
            UIData table = (UIData) e.getComponent().findComponent("resultsTable");
            int index = table.getRowIndex();
            LetterMspDetailSelector row = letterResultsSel.get(index);
            LetterMspDetail instance = (LetterMspDetail) row.getLetterMspDetail();
            instance.setStatusId(new CodesLetterStatus((Long) e.getNewValue()));
            row.setLetterMspDetail(letterMspFacade.editWithReturn(instance));
            addInfoMessage(bundle.getString("project.projectDetails.letter.changeStatus"));
        }
    }

    /**
     * Display patients age
     *
     * @param birthDate
     * @return
     */
    public int displayAge(Date birthDate) {

        Date now = new Date();
        long timeBetween = now.getTime() - birthDate.getTime();
        double yearsBetween = timeBetween / 3.156e+10;
        int age = (int) Math.floor(yearsBetween);

        return age;
    }

    /**
     * Verify if the letterPrinted value is set to Y
     *
     * @param letter
     * @return
     */
    public boolean verifyLetterPrinted(LetterMspDetail letter) {

        return letter.getLetterPrintedFlag() == 'Y';
    }

    /**
     * Verifies if the letter run still has opened SVA projects
     *
     * @param p
     * @return
     */
    public boolean validateOpenSvaProject(Project p) {

        boolean isOpen = false;
        List<PracSvaProject> listSva = pracSvaFacade.findSvaByProjectId(p);

        for (PracSvaProject sva : listSva) {
            if (sva.getSvaProjectStatusId().getName().equals(PaclConstants.PROJECT_STATUS_OPEN)) {
                isOpen = true;

                return isOpen;
            }
        }
        return isOpen;
    }

    /**
     * Code to format the date to the specific format
     *
     * @param dateToFormat
     * @return String
     */
    public String dateFormatter(Date dateToFormat) {

        if (dateToFormat != null) {
            return new SimpleDateFormat("yyyy-MM-dd").format(dateToFormat);
        } else {
            return "";
        }
    }

    /**
     * Close the selected project.
     *
     * @return String
     */
    public String close() {
        nullify();
        // verify if the project status is not already closed
        if (!verifyProjectStatus()) {
            return null;
        }
        if (!validateOpenSvaProject(project)) {
            Date closedDate = new Date();
            project.setClosedDate(closedDate);
            project.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_CLOSE));
            projectFacade.editWithReturn(project);

            // Create Audit log for closed project
            ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Project Closed Details");
            List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed by Username", findUserName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Name", project.getName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Month", project.getProjectMonth()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Year", project.getProjectYear()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Id", (project.getId().toString())));

            applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
            applicationAuditLogFacade.create(applicationAuditLog);

            // display info message on screen when selected project was closed
            addInfoMessage(bundle.getString("project.projectDetails.closeProject"));
            setProjectId(project.getId());
            logger.log(Level.INFO, "inside close before refresh projectId = ".concat(String.valueOf(projectId.longValue())));
            return null;
        } else {
            addErrorMessage(bundle.getString("letterRun.Search.CloseError"));
            return null;
        }
    }

    /**
     * Archive the selected project.
     *
     * @return String
     */
    public String archive() {
        nullify();

        // verify if the project was closed before archive
        if (!verifyProjectClose()) {
            return null;
        }
        Date archiveDate = new Date();
        project.setArchivedDate(archiveDate);
        project.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_ARCHIVE));
        projectFacade.editWithReturn(project);

        // Create Audit log for closed project
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Project Archived Details");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived by Username", findUserName()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Name", project.getName()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Month", project.getProjectMonth()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Year", project.getProjectYear()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Id", (project.getId().toString())));

        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        // display info message on screen when selected project was archived
        addInfoMessage(bundle.getString("project.projectDetails.archiveProject"));
        setProjectId(project.getId());
        return null;
    }

    /**
     * Validated if there are at least 1 project selected
     *
     * @return
     */
    public int selectedValidator() {
        int countSelected = 0;
        for (LetterMspDetailSelector letterForUpdate : letterResultsSel) {
            if (letterForUpdate.isLetterSelected()) {
                countSelected++;
            }
        }
        return countSelected;
    }

    /**
     * Verify if project is closed before archive it.
     *
     * @return boolean
     */
    public final boolean verifyProjectClose() {
        // check if project status is 'Closed' and if not display error message
        if (project.getClosedDate() == null && !PaclConstants.PROJECT_STATUS_CLOSE.equals(project.getStatusId().getName())) {
            addErrorMessage(bundle.getString("project.projectDetails.checkProjectClosed"));
            return false;
        }
        return true;
    }

    /**
     * Verify that the project status is set to close
     *
     * @return
     */
    public final boolean verifyProjectStatus() {
        // check if project status was already 'Closed' and display error message
        if (project.getClosedDate() != null && PaclConstants.PROJECT_STATUS_CLOSE.equals(project.getStatusId().getName())) {
            addErrorMessage(bundle.getString("project.projectDetails.checkProjectStatus"));
            return false;
        }
        return true;
    }

    /**
     * Nullifies any child objects which don't have valid PKs set.
     */
    private void nullify() {
        if (project.getProjectTypeId() != null && project.getProjectTypeId().getId() == null) {
            project.setProjectTypeId(null);
        }
        if (project.getStatusId() != null && project.getStatusId().getId() == null) {
            project.setStatusId(null);
        }
    }
    
    public void saveAdminNotes(String id, String notes) {
        LetterMspDetail l = letterMspFacade.find(Long.parseLong(id));
        l.setAdminNotes(notes);
        letterMspFacade.editWithReturn(l);
    }

    /* Getters and Setters */
    public Project getProject() {
        return project;
    }

    public void setProject(Project project) {
        this.project = project;
    }

    public PracSvaProject getSvaProject() {
        return svaProject;
    }

    public void setSvaProject(PracSvaProject svaProject) {
        this.svaProject = svaProject;
    }

    public Date getPrintingDate() {
        return printingDate;
    }

    public void setPrintingDate(Date printingDate) {
        this.printingDate = printingDate;
    }

    public boolean isSelectAll() {
        return selectAll;
    }

    public boolean isDisablePrintButtons() {
        return disablePrintButtons;
    }

    public void setDisablePrintButtons(boolean value) {
        this.disablePrintButtons = value;
    }

    public Long getProjectId() {
        return projectId;
    }

    public void setProjectId(Long projectId) {
        this.projectId = projectId;
    }

    public Project getProjectClicked() {
        return projectClicked;
    }

    public void setProjectClicked(Project projectClicked) {
        this.projectClicked = projectClicked;
    }

    public List<PracSvaProject> getSvaResults() {
        return svaResults;
    }

    public void setSvaResults(List<PracSvaProject> svaResults) {
        this.svaResults = svaResults;
    }

    public LetterMspDetail getLetter() {
        return letter;
    }

    public void setLetter(LetterMspDetail letter) {
        this.letter = letter;
    }

    public List<LetterMspDetail> getLettersAll() {
        return lettersAll;
    }

    public void setLettersAll(List<LetterMspDetail> lettersAll) {
        this.lettersAll = lettersAll;
    }

    public List<LetterMspDetail> getSelectedLettersList() {
        return selectedLettersList;
    }

    public void setSelectedLettersList(List<LetterMspDetail> selectedLettersList) {
        this.selectedLettersList = selectedLettersList;
    }

    public List<LetterMspDetail> getLetterResults() {
        return letterResults;
    }

    public void setLetterResults(List<LetterMspDetail> letterResults) {
        this.letterResults = letterResults;
    }

    public List<LetterMspDetailSelector> getLetterResultsSel() {
        return letterResultsSel;
    }

    public void setLetterResultsSel(List<LetterMspDetailSelector> letterResultsSel) {
        this.letterResultsSel = letterResultsSel;
    }

    public LetterMspDetailSelector getLetterSelector() {
        return letterSelector;
    }

    public void setLetterSelector(LetterMspDetailSelector letterSelector) {
        this.letterSelector = letterSelector;
    }

    public List<String> getFilterList() {
        return filterList;
    }

    public void setFilterList(List<String> filterList) {
        this.filterList = filterList;
    }

    public String getFilterOption() {
        return filterOption;
    }

    public void setFilterOption(String filterOption) {
        this.filterOption = filterOption;
    }

    public int getPatientCount() {
        return patientCount;
    }

    public void setPatientCount(int patientCount) {
        this.patientCount = patientCount;
    }

}
