package ca.bc.gov.health.pacl.web;

import ca.bc.gov.health.jsf.BaseBean;
import static ca.bc.gov.health.jsf.BaseBean.addErrorMessage;
import static ca.bc.gov.health.jsf.BaseBean.addInfoMessage;
import ca.bc.gov.health.jsf.SelectItemHelper;
import ca.bc.gov.health.pacl.ejb.entity.AdminOptions;
import ca.bc.gov.health.pacl.ejb.entity.ApplicationAuditDtlLog;
import ca.bc.gov.health.pacl.ejb.entity.ApplicationAuditLog;
import ca.bc.gov.health.pacl.ejb.entity.CodesLetterStatus;
import ca.bc.gov.health.pacl.ejb.entity.CodesProjectStatus;
import ca.bc.gov.health.pacl.ejb.entity.CodesProjectType;
import ca.bc.gov.health.pacl.ejb.entity.Letter;
import ca.bc.gov.health.pacl.ejb.entity.PharmacyProvider;
import ca.bc.gov.health.pacl.ejb.entity.Project;
import ca.bc.gov.health.pacl.ejb.session.*;
import ca.bc.gov.health.pacl.jasper.JasperLetter;
import ca.bc.gov.health.pacl.jasper.JasperLetterCollection;
import ca.bc.gov.health.pacl.service.EmailService;
import ca.bc.gov.health.pacl.util.PaclConstants;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.component.UIData;
import jakarta.faces.context.FacesContext;
import jakarta.faces.event.ValueChangeEvent;
import jakarta.faces.model.SelectItem;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;
import jakarta.servlet.ServletOutputStream;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import net.sf.jasperreports.engine.JRException;
import net.sf.jasperreports.engine.JasperFillManager;
import net.sf.jasperreports.engine.JasperPrint;
import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;
import net.sf.jasperreports.engine.export.JRPdfExporter;
import net.sf.jasperreports.engine.util.FileBufferedOutputStream;
import net.sf.jasperreports.export.SimpleExporterInput;
import net.sf.jasperreports.export.SimpleOutputStreamExporterOutput;
import net.sf.jasperreports.export.SimplePdfExporterConfiguration;
import net.sf.jasperreports.j2ee.servlets.BaseHttpServlet;

/**
 * Backing bean for manage project details.
 *
 * @author JSF Code Generator
 */
@Named("projectDetail")
@ViewScoped
public class ProjectDetailBean extends BaseBean {

    private static ResourceBundle bundle
            = ResourceBundle.getBundle("MessageResources");
    private static final String className = ProjectDetailBean.class.getName(),
            SESSION_JPRINT = "reportJasperPrint",
            SESSION_FILENAME = "reportFileName",
            SESSION_SHOW_DIALOGUE = "showPrintDialogue";

    /*
     * Email service instance for editing.
     */
    private EmailService emailService = new EmailService(PaclConstants.SERVER_EMAIL_HOST, PaclConstants.PACL_SYSTEM_NAME);

    private static final Logger logger = Logger.getLogger(className);

    private static enum Result {

        SUCCESS("SUCCESS"), ERROR("ERROR"), WARNING("WARNING");
        private final String literal;

        Result(String value) {
            this.literal = value;
        }

        @Override
        public String toString() {
            return literal;
        }
    };

    /**
     * EJB to handle persistence.
     */
    @EJB
    private transient ProjectFacadeLocal projectFacade;
    /* EJB to handle PharmacyProvider instances */
    @EJB
    private transient PharmacyProviderFacadeLocal pharmacyProviderFacade;
    /* EJB to handle Letter instances */
    @EJB
    private transient LetterFacadeLocal letterFacade;
    @EJB
    private transient LetterTemplateFacadeLocal letterTemplateFacade;
    @EJB
    private transient ApplicationAuditLogFacadeLocal applicationAuditLogFacade;
    @EJB
    private transient CodesProjectStatusFacadeLocal codesProjectStatusFacade;
    @EJB
    private AdminOptionsFacadeLocal adminOptionsFacade;

    /**
     * Instances we're currently editing.
     */
    private Project project;
    private PharmacyProvider pharmacyProvider;

    /**
     * Flag managing Print buttons availability.
     */
    private boolean disablePrintButtons = true;
    /**
     * Indicates whether a provider has been picked up from the list.
     */
    private boolean providerSelected = false;
    /**
     * Select/Un-select all letters for the pharmacy.
     */
    private boolean selectAll = false;
    /**
     * Local instance of the printing date.
     */
    private Date printingDate;
    /**
     * List of pharmacy/providers for the selected project.
     */
    private List<PharmacyProvider> pharmacyList = new ArrayList<>();
    /**
     * List of patient letters for the selected pharmacy/provider.
     */
    private List<JasperLetter> patientLettersAll = new ArrayList<>();
    /**
     * List of selected patients based on the pharmacy/provider selection.
     */
    private List<JasperLetter> selectedPatientsList = new ArrayList<>();
    /**
     * Lists of select items pharmacy providers to display on the screen.
     */
    private List<SelectItem> selectedPharmsProviders = new ArrayList<>();
    /**
     * Message to be displayed when the letter status is changed.
     */
    private String CHANGE_MESSAGE = "";
    /**
     * Message to be displayed when the letter status is changed.
     */
    private Long projectId;

    /**
     * Default Constructor.
     */
    public ProjectDetailBean() {
    }

    /**
     * Initializes this bean.
     */
    @PostConstruct
    public void init() {

        CHANGE_MESSAGE = bundle.getString("project.projectDetails.letter.changeStatus");

        Project project_ = (Project) FacesContext.getCurrentInstance().getExternalContext().getFlash().get("projectToView");
        pharmacyProvider = new PharmacyProvider();
        if (project_ != null) {
            try {
                // set the previously selected project
                project = project_;
                List<Letter> list
                        = letterFacade.orderByProvideNamePatientLastName(project.getId());
                patientLettersAll = new ArrayList<>();
                list.forEach((Letter item) -> {
                    patientLettersAll.add(new JasperLetter(item));
                });
                selectedPatientsList = new ArrayList<>();
                if (patientLettersAll != null) {
                    selectedPatientsList.addAll(patientLettersAll);
                }

                getPharmacyProviderForProject();

            } catch (Exception e) {
                addErrorMessage(e.getMessage());
            }
        }
    }

    /**
     * Change the patient letter status depending on the user selection.
     */
    public void changeLetterStatus(ValueChangeEvent e) {
        if ((Long) e.getNewValue() != -1) {
            UIData table = (UIData) e.getComponent().findComponent("letterTable");
            int index = table.getRowIndex();
            JasperLetter row = patientLettersAll.get(index);
            Letter instance = (Letter) row.getLetter();
            instance.setStatusId(new CodesLetterStatus((Long) e.getNewValue()));
            row.setLetter(letterFacade.editWithReturn(instance));
            addInfoMessage(bundle.getString("project.projectDetails.letter.changeStatus"));
        }
    }

    /**
     * Change the patient letters displayed depending on the pharmacy provider
     * code selected.
     */
    public void changePharmacyProviderCode() {
        if (pharmacyProvider.getId() != -1) {
            // clear project print date when change pharmacy/provider code
            printingDate = null;
            // Letters for the selected pharmacy
            List<Letter> list = letterFacade.findLettersByProviderId(pharmacyProvider.getId());
            patientLettersAll = new ArrayList<>();
            list.forEach((Letter item) -> {
                patientLettersAll.add(new JasperLetter(item));
            });
            providerSelected = true;
            disablePrintButtons = false;

            selectAll = true;
            selectedPatientsList = new ArrayList<>();
            for (JasperLetter letterSelection : patientLettersAll) {
                if (letterSelection.isSelected()) {
                    selectedPatientsList.add(letterSelection);
                }
            }
        } else { // Selecting all letters for the project
            List<Letter> list = project.getLetterList();
            patientLettersAll = new ArrayList<>();
            list.forEach((Letter item) -> {
                patientLettersAll.add(new JasperLetter(item));
            });
            providerSelected = false;
            disablePrintButtons = true;

            selectAll = false;
            selectedPatientsList = new ArrayList<>();
            if (patientLettersAll != null) {
                selectedPatientsList.addAll(patientLettersAll);
            }
        }
    }

    /**
     * Close the selected project.
     *
     * @return String
     */
    public String close() {
        nullify();
        // verify if the project status is not already closed
        if (!verifyProjectStatus()) {
            return null;
        }
        Date closedDate = new Date();
        project.setClosedDate(closedDate);
        project.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_CLOSE));
        projectFacade.editWithReturn(project);

        //Check if the project has exceed daysBeforeArchive or is due to expired in less than SECOND_REMINDER_EMAIL
        Date projectCreateDate = project.getCreatedOnDtm();
        AdminOptions adminOptions = adminOptionsFacade.findDefaultPatientLimit().get(0);
        // get system admin email
        String serverAdminEmail = adminOptions.getServerAdminEmail();

        Calendar cal = Calendar.getInstance();
        cal.setTime(projectCreateDate);
        // get total days until the project is archived
        cal.add(Calendar.HOUR, 24 * (int) (adminOptions.getDaysBeforeArchive()));
        Date projectTimeoutDate = cal.getTime();
        Date todayDate = new Date();

        //Get number of day before the project will be archived
        int dayBeforeArchive = (int) ((projectTimeoutDate.getTime() - todayDate.getTime()) / (1000 * 60 * 60 * 24));

        //if project should already been archived, set the value to 0
        if (dayBeforeArchive < 0) {
            dayBeforeArchive = 0;
        }
        //Check if the project will be archive in less than the number of day that the second Email reminder is send
        if (dayBeforeArchive < adminOptions.getSecondReminderEmail()) {
            emailService.sendEmailNotifications(
                    project,
                    dayBeforeArchive, serverAdminEmail);
        }

        // Create Audit log for closed project
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Project Closed Details");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed by Username", findUserName()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Name", project.getName()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Month", project.getProjectMonth()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Year", project.getProjectYear()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Closed Id", (project.getId().toString())));

        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        // display info message on screen when selected project was closed
        addInfoMessage(bundle.getString("project.projectDetails.closeProject"));
        setProjectId(project.getId());
        logger.log(Level.INFO, "inside close before refresh projectId = ".concat(String.valueOf(projectId.longValue())));
        return refresh();
    }

    /**
     * Archive the selected project.
     *
     * @return String
     */
    public String archive() {
        nullify();

        // verify if the project was closed before archive
        if (!verifyProjectClose()) {
            return null;
        }
        Date archiveDate = new Date();
        project.setArchivedDate(archiveDate);
        project.setStatusId(codesProjectStatusFacade.findByName(PaclConstants.PROJECT_STATUS_ARCHIVE));
        projectFacade.editWithReturn(project);

        // Create Audit log for closed project
        ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Project Archived Details");
        List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived by Username", findUserName()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Name", project.getName()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Month", project.getProjectMonth()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Year", project.getProjectYear()));
        logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Archived Id", (project.getId().toString())));

        applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
        applicationAuditLogFacade.create(applicationAuditLog);

        // display info message on screen when selected project was archived
        addInfoMessage(bundle.getString("project.projectDetails.archiveProject"));
        setProjectId(project.getId());
        return refresh();
    }

    /**
     * Setup the selected project and re-query from database by project id.
     *
     * @return Project
     */
    private Project setupSelectedProject() {

        Project tempProject = projectFacade.findProjectById(projectId);
        pharmacyProvider = new PharmacyProvider();
        if (tempProject != null) {
            try {
                // set the previously selected project
                project = tempProject;
                List<Letter> list
                        = letterFacade.orderByProvideNamePatientLastName(project.getId());
                patientLettersAll = new ArrayList<>();
                list.forEach((Letter item) -> {
                    patientLettersAll.add(new JasperLetter(item));
                });
                selectedPatientsList = new ArrayList<>();
                if (patientLettersAll != null) {
                    selectedPatientsList.addAll(patientLettersAll);
                }
                logger.log(Level.INFO, "setupSelectedProject details for "
                        .concat("project info = ").concat(String.valueOf(project.getId().longValue())));
                getPharmacyProviderForProject();

            } catch (Exception e) {
                addErrorMessage(e.getMessage());
            }
        }
        return tempProject;
    }

    /**
     * Called at the end of close/archive serves a similar purpose to clear(),
     * but doesn't reprocess the displayed lists.
     *
     * @return String
     */
    public String refresh() {
        project = new Project();
        setupSelectedProject();
        return null;
    }

    /**
     * Verify if project is closed before archive it.
     *
     * @return boolean
     */
    public final boolean verifyProjectClose() {
        // check if project status is 'Closed' and if not display error message
        if (project.getClosedDate() == null
                && !PaclConstants.PROJECT_STATUS_CLOSE.equals(project.getStatusId().getName())) {
            addErrorMessage(bundle.getString("project.projectDetails.checkProjectClosed"));
            return false;
        }
        return true;
    }

    /**
     * Verify if project is closed before archive it.
     *
     * @return boolean
     */
    public final boolean verifyProjectStatus() {
        // check if project status was already 'Closed' and display error message
        if (project.getClosedDate() != null
                && PaclConstants.PROJECT_STATUS_CLOSE.equals(project.getStatusId().getName())) {
            addErrorMessage(bundle.getString("project.projectDetails.checkProjectStatus"));
            return false;
        }
        return true;
    }

    /**
     * Prints the letters for the selected pharmacy/project and sets the print
     * flag to Y in case of success.
     *
     * @return One of three following values:
     * <ul>
     * <li> SUCCESS
     * <li> WARNING
     * <li> ERROR
     * </ul>
     */
    public String printLetters() {
        String value;
        if (printingDate == null) {
            value = bundle.getString("project.projectDetails.printingDate.validationError");
            addErrorMessage(value);
            return null;
        }

        Result result = generateLetters(true);
        if (result == Result.SUCCESS) {
            for (JasperLetter letter_ : selectedPatientsList) {
                if (letter_.getLetterPrintedFlag() == 'N') {
                    letter_.setLetterPrintedFlag('Y');
                    letter_.setLetter(letterFacade.editWithReturn(letter_.getLetter()));
                }
            }
            // Saving the FIRST PRINTING DATE for the project
            if (project.getFirstPrintingDate() == null) {
                project.setFirstPrintingDate(new Date());
                project = projectFacade.editWithReturn(project);
            }
        }

        if (result.equals(Result.SUCCESS)) {
            value = bundle.getString("project.projectDetails.printLetters.success");
            addInfoMessage(value);
            printLettersFromSession();

        } else {
            value = bundle.getString("project.projectDetails.printLetters.error");
            addErrorMessage(value);
        }

        return result.toString();
    }

    /**
     * Prints a report from the user session into the response output
     */
    public void printLettersFromSession() {

        try {
            if (FacesContext.getCurrentInstance().getExternalContext().getSessionMap().get(SESSION_JPRINT) != null) {
                logger.log(Level.INFO, "Printing letters from JasperPrint stored in the user session");

                JasperPrint jprint = (JasperPrint) FacesContext.getCurrentInstance().getExternalContext().getSessionMap().get(SESSION_JPRINT);
                String fileName = (String) FacesContext.getCurrentInstance().getExternalContext().getSessionMap().get(SESSION_FILENAME);
                Boolean showDialog = (Boolean) FacesContext.getCurrentInstance().getExternalContext().getSessionMap().get(SESSION_SHOW_DIALOGUE);

                printToResponse(jprint, fileName, showDialog);

                FacesContext.getCurrentInstance().getExternalContext().getSessionMap().remove(SESSION_JPRINT);
                FacesContext.getCurrentInstance().getExternalContext().getSessionMap().remove(SESSION_FILENAME);
                FacesContext.getCurrentInstance().getExternalContext().getSessionMap().remove(SESSION_SHOW_DIALOGUE);
                logger.log(Level.INFO, "Letters successfully printed");
            }

        } catch (JRException e) {
            logger.log(Level.SEVERE, bundle.getString("project.projectDetails.printLetters.jasperError"), e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, bundle.getString("project.projectDetails.printLetters.genericError"), e);
        }
    }

    /**
     * Preview the letters for the selected pharmacy/project.
     *
     * @return One of three following values:
     * <ul>
     * <li> SUCCESS
     * <li> WARNING
     * <li> ERROR
     * </ul>
     */
    public String previewLetters() {
        String value;
        if (printingDate == null) {

            value = bundle.getString("project.projectDetails.printingDate.validationError");
            addErrorMessage(value);

            return null;
        }

        Result result = generateLetters(false);
        if (result.equals(Result.SUCCESS)) {

            value = bundle.getString("project.projectDetails.previewLetters.success");
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_INFO, value, value));
            printLettersFromSession();
        } else {
            value = bundle.getString("project.projectDetails.printLetters.error");
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_INFO, value, value));
        }

        return result.toString();
    }

    /**
     * Performs report generation for the selected list of letters and saves the
     * JasperPrint object in session for further printing
     *
     * @return One of three following values:
     * <ul>
     * <li> SUCCESS
     * <li> WARNING
     * <li> ERROR
     * </ul>
     */
    private Result generateLetters(boolean showDialog) {
        if (!selectedPatientsList.isEmpty()) {
            List<JasperLetter> lettersToPrint = new ArrayList<>();
            // Create Audit log for preview/print letters
            ApplicationAuditLog applicationAuditLog = new ApplicationAuditLog("Print Letters Details");
            List<ApplicationAuditDtlLog> logDetailList = new ArrayList<>();
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Application Username", findUserName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Details: Name", this.project.getName()));
            logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Project Details: Id", (this.project.getId().toString())));

            for (JasperLetter letter_ : selectedPatientsList) {

                if (getPrintingDate() != null) {
                    letter_.setLetterDate(getPrintingDate());
                }
                lettersToPrint.add(new JasperLetter(letter_.getLetter()));
                logDetailList.add(new ApplicationAuditDtlLog(applicationAuditLog, "Letter Ids Selected", (letter_.getLetter().getId().toString())));

            }

            // set auditing detail logs and saved audit records in database
            // for selected letters
            applicationAuditLog.setApplicationAuditDtlLogList(logDetailList);
            applicationAuditLogFacade.create(applicationAuditLog);

            if (lettersToPrint.size() > 0) {
                /*
                 * This is stupid, but this is the world we have. Since nobody
                 * wants to change the database model to reflect the requirement
                 * saying that a given project MUST have only one type of letters,
                 * here the following algorithm is used to detect the template:
                 * Pick up the first letter from the list, check its template
                 * and assign it to the whole collection.
                 */
                JasperLetterCollection letters = new JasperLetterCollection(letterTemplateFacade.find(lettersToPrint.get(0).getLetterTemplateId().getId()));
                letters.setLetters(lettersToPrint);
                letters.setProjectName(this.project.getName());
                letters.setProjectMonth(this.project.getProjectMonth());
                letters.setProjectYear(this.project.getProjectYear());
                // Print
                JRBeanCollectionDataSource ds = new JRBeanCollectionDataSource(letters.getLetters());
                String reportName;
                String templateName = letters.getLetterTemplate().getLetterTemplateTypeId().getName();
                String fileName = project.getName().replace(' ', '_').replaceAll("[^A-Za-z0-9()_]", "");
                switch (templateName.trim()) {
                    case "PRESCRIPTIONS":
                        reportName = "PrescriptionLetter.jasper";
                        fileName += "_PrescriptionLetters";
                        break;
                    case "PROSTHETICS AND ORTHOTICS":
                        reportName = "ProstheticAndOrthoticLetter.jasper";
                        fileName += "_ProstheticAndOrthoticLetters";
                        break;
                    default:
                        reportName = "PlanMLetter.jasper";
                        fileName += "_PlanMLetters";
                }
                fileName += "_" + new java.text.SimpleDateFormat("ddMMyyyy-HHmmss").format(new Date());
                fileName += ".pdf";
                logger.log(Level.INFO, "Report file for the report: ".concat(this.project.getName())
                        .concat(" is ").concat(reportName));
                logger.log(Level.INFO, "PDF File name: ".concat(fileName));

                try {
                    logger.log(Level.INFO, "Generating the report");
                    JasperPrint jprint = JasperFillManager.fillReport(
                            Thread.currentThread().getContextClassLoader().getResourceAsStream(reportName), letters.getParameters(), ds);

                    // Export to the session
                    logger.log(Level.INFO, "Exporting the report to the user session");

                    FacesContext.getCurrentInstance().getExternalContext().getSessionMap().put(SESSION_JPRINT, jprint);
                    FacesContext.getCurrentInstance().getExternalContext().getSessionMap().put(SESSION_FILENAME, fileName);
                    FacesContext.getCurrentInstance().getExternalContext().getSessionMap().put(SESSION_SHOW_DIALOGUE, showDialog);

                    logger.log(Level.INFO, "PDF export to the session completed; "
                            .concat(String.valueOf(letters.getLetters().size()))
                            .concat(" letter").concat(letters.getLetters().size() == 1 ? "" : "s")
                            .concat(" printed"));

                    return Result.SUCCESS;
                } catch (JRException e) {
                    logger.log(Level.SEVERE, bundle.getString("project.projectDetails.printLetters.jasperError"), e);
                }
            }
            logger.log(Level.INFO, "No letters found for the project ".concat(this.project.getName()));

            return Result.WARNING;

        }
        return Result.SUCCESS;
    }

    /**
     *
     * @param jprint JasperPrint instance with the report
     * @param fileName File name for the report
     * @param showDialog If true then show the print dialog when PDF is opened
     * @throws JRException
     * @throws IOException
     */
    private void printToResponse(JasperPrint jprint, String fileName, boolean showDialog) throws JRException, IOException {
        JRPdfExporter exporter = new JRPdfExporter();
        exporter.setExporterInput(new SimpleExporterInput(jprint));
        // If printing, then:
        // "The system opens the print dialog to allow the user to select the printing options"
        if (showDialog) {
            SimplePdfExporterConfiguration pdfExportConfig = new SimplePdfExporterConfiguration();
            pdfExportConfig.setPdfJavaScript("this.print();");
            exporter.setConfiguration(pdfExportConfig);
        }

        // Export to the response output stream 
        HttpServletResponse response = (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();
        response.setContentType("application/pdf");
        response.setHeader("content-disposition", "attachment; filename=" + fileName);

        Boolean isBuffered
                = Boolean.valueOf(
                        ((HttpServletRequest) FacesContext.getCurrentInstance().getExternalContext().getRequest()).
                        getParameter(BaseHttpServlet.BUFFERED_OUTPUT_REQUEST_PARAMETER));
        if (isBuffered) {
            // Not sure if this piece is needed, but http://massapi.com/class/jr/JRPdfExporter.html says it should.
            FileBufferedOutputStream fbos = new FileBufferedOutputStream();
            exporter.setExporterOutput(new SimpleOutputStreamExporterOutput(fbos));
            exporter.exportReport();
            fbos.close();
            if (fbos.size() > 0) {
                response.setContentType("application/pdf");
                response.setContentLength(fbos.size());
                ServletOutputStream ouputStream = response.getOutputStream();

                try {
                    fbos.writeData(ouputStream);
                    fbos.dispose();
                    ouputStream.flush();
                } finally {
                    if (ouputStream != null) {
                        try {
                            ouputStream.close();
                        } catch (IOException ex) {
                            logger.log(Level.SEVERE, "An IOException occurred".concat(ex.toString()));
                        }
                    }
                }
            }
        } else {
            exporter.setExporterOutput(new SimpleOutputStreamExporterOutput(response.getOutputStream()));
            exporter.exportReport();
        }

        // Finalizing response
        FacesContext.getCurrentInstance().responseComplete();
    }

    /**
     * Clears the form.
     */
    public String clear() {
        addPlaceholders();
        return "projectDetail.xhtml";
    }

    /**
     * Nullifies any child objects which don't have valid PKs set.
     */
    private void nullify() {
        if (project.getProjectTypeId() != null && project.getProjectTypeId().getId() == null) {
            project.setProjectTypeId(null);
        }
        if (project.getStatusId() != null && project.getStatusId().getId() == null) {
            project.setStatusId(null);
        }
    }

    /**
     * Defaults parent objects which don't have valid PKs set.
     */
    private void addPlaceholders() {
        if (project.getId() == null) {
            project = new Project();
        }
        if (project.getProjectTypeId() == null) {
            project.setProjectTypeId(new CodesProjectType());
        }
        if (project.getStatusId() == null) {
            project.setStatusId(new CodesProjectStatus());
        }
    }

    /**
     * Defines components to be re-rendered when the Print button is clicked.
     *
     *
     * @return ID(s) of components re-rendered
     */
    public String getRenderedComponentsForPrintLettersButton() {
        if (printingDate == null) {
            return "buttonsId";
        }
        return "projectSummary buttonsId previewContentPanel";
    }
    
    public void saveLetterAdminNotes(int index, String notes) {
        JasperLetter row = patientLettersAll.get(index);
        Letter letter = (Letter) row.getLetter();
        
        letter.setAdminNotes(notes);
        letter = letterFacade.editWithReturn(letter);
        row.setLetter(letter);
    }

    /* Getters and Setters */
    public Project getProject() {
        return project;
    }

    public void setProject(Project project) {
        this.project = project;
    }

    public PharmacyProvider getPharmacyProvider() {
        return pharmacyProvider;
    }

    public void setPharmacyProvider(PharmacyProvider pharmacyProvider) {
        this.pharmacyProvider = pharmacyProvider;
    }

    public List<PharmacyProvider> getPharmacyList() {
        return pharmacyList;
    }

    public void setPharmacyList(List<PharmacyProvider> pharmacyList) {
        this.pharmacyList = pharmacyList;
    }

    public List<SelectItem> getPharmacyProviderForProject() {
        List<PharmacyProvider> pharmProviders = pharmacyProviderFacade.findProvidersByProjectId(project.getId());
        selectedPharmsProviders
                = SelectItemHelper.buildSelectItemListMultipleLabels(pharmProviders, "code", "name", "id");
        return selectedPharmsProviders;
    }

    public List<JasperLetter> getPatientLettersAll() {
        return patientLettersAll;
    }

    public void setPatientLettersAll(List<JasperLetter> patientLettersAll) {
        this.patientLettersAll = patientLettersAll;
    }

    public List<JasperLetter> getSelectedPatientsList() {
        return selectedPatientsList;
    }

    public void setSelectedPatientsList(List<JasperLetter> selectedPatientsList) {
        this.selectedPatientsList = selectedPatientsList;
    }

    public boolean isProviderSelected() {
        return providerSelected;
    }

    public void setProviderSelected(boolean providerSelected) {
        this.providerSelected = providerSelected;
    }

    public Date getPrintingDate() {
        return printingDate;
    }

    public void setPrintingDate(Date printingDate) {
        this.printingDate = printingDate;
    }

    public boolean isSelectAll() {
        return selectAll;
    }

    public void setSelectAll(boolean value) {

        this.selectAll = value;
    }

    public boolean isDisablePrintButtons() {
        return disablePrintButtons;
    }

    public void setDisablePrintButtons(boolean value) {
        this.disablePrintButtons = value;
    }

    public Long getProjectId() {
        return projectId;
    }

    public void setProjectId(Long projectId) {
        this.projectId = projectId;
    }

}
