/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.pacl.ejb.session;

import ca.bc.gov.health.pacl.ejb.entity.Project;
import ca.bc.gov.health.pacl.util.PaclConstants;
import jakarta.ejb.Stateless;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Dan.Stepanov
 */
@Stateless
public class ProjectFacade extends AbstractFacade<Project> implements ProjectFacadeLocal {

    static Logger logger = Logger.getLogger(ProjectFacade.class.getName());

    /**
     * New instance for EntityManager class.
     */
    @PersistenceContext(unitName = "PACLPU")
    private EntityManager em;

    /**
     * Gets the local instance of the {@link EntityManager} class.
     * @return entity Manager
     */
    @Override
    protected EntityManager getEntityManager() {
        return em;
    }

    /**
     * Default constructor.
     */
    public ProjectFacade() {
        super(Project.class);
    }

    /**
     * Retrieve a list of Projects ordered by name.
     * @return List<Project> - list of projects ordered by name
     */
    @Override
    public List<Project> findAll() {
        Query query = em.createNativeQuery("select * from PROJECT c"
                + " order by UPPER(c.name)", Project.class);

        return query.getResultList();
    }

    /**
     * Retrieve the default list with the most recent 5 projects.
     * @return List<Project> - list of the 5 most recent projects
     */
    @Override
    public List<Project> findRecent() {
        // The max result should be configurable. Needs to be moved out to JNDI property or so
        
         Query q = em.createNamedQuery("Project.findRecent");
        q.setParameter("id1", PaclConstants.PHARMACY_PROJECT_ID);
        q.setParameter("id2", PaclConstants.PO_PROVIDER_PROJECT_ID);
        q.setParameter("id3", PaclConstants.PLAN_M_PROJECT_ID);
        System.out.println(q.toString());
         return q.setMaxResults(PaclConstants.DISPLAY_DEFAULT_PROJECTS_FIND).getResultList();
   
    }

    /**
     * Retrieve the projects based on user selected search criteria.
     *
     * @param name String - input search criteria from screen
     * @param code String - input search criteria from screen
     * @param projectDate Date - input search criteria from screen
     * @param projectYear String  - input search criteria from screen
     * @param projectStatus Long - input search criteria from screen
     * 
     * 
     * @return List<Project> - list of projects from the search criteria
     */
    @Override
    public List<Project> findBySearchCriteria(String name, String code, 
            Date projectDate, String projectYear, Long projectStatus) {

        StringBuilder builder = new StringBuilder("SELECT p FROM Project p");

        boolean isWhereAdded = false;
        int paramsCount = 0;
        String joinStmt =  " JOIN p.pharmacyProviderList pList";

        // Conditionally build the where clause for the query
        if (name != null && !name.trim().isEmpty()) {
            if (isWhereAdded) {
                builder.append(" AND pList.name LIKE ?").append(++paramsCount);
            } else {
                builder.append(joinStmt);
                builder.append(" WHERE pList.name LIKE ?").append(++paramsCount);
                isWhereAdded = true;
            }
        }

        if (code != null && !code.trim().isEmpty()) {
            if (isWhereAdded) {
                builder.append(" AND pList.code LIKE ?").append(++paramsCount);
            } else {
                builder.append(joinStmt);
                builder.append(" WHERE pList.code LIKE ?").append(++paramsCount);
                isWhereAdded = true;
            }
        }

        if (projectYear != null && !projectYear.trim().isEmpty()) {
            if (isWhereAdded) {
                builder.append(" AND p.projectYear = ?").append(++paramsCount);
            } else {
                builder.append(" WHERE p.projectYear = ?").append(++paramsCount);
                isWhereAdded = true;
            }
        }

        if (projectDate != null) {
            if (isWhereAdded) {
                builder.append(" AND p.projectMonth = ?").append(++paramsCount);
                builder.append(" AND p.projectYear = ?").append(++paramsCount);
            } else {
                builder.append(" WHERE p.projectMonth = ?").append(++paramsCount);
                builder.append(" AND p.projectYear = ?").append(++paramsCount);
                isWhereAdded = true;
            }
        }

        if (projectStatus != null) {

            if (isWhereAdded) {
                builder.append(" AND p.statusId.id = ?").append(++paramsCount);
            } else {
                builder.append(" WHERE p.statusId.id = ?").append(++paramsCount);
                isWhereAdded = true;
            }

        }
        // apppend order by clause at the end of query
        builder.append(" ORDER BY p.createdOnDtm DESC"); 

        logger.log(Level.INFO, "project search query = " + builder.toString());         
          //Set positional parameters
        Query q = em.createQuery(builder.toString(), Project.class);
        paramsCount = 0;

        if (name != null && !name.trim().isEmpty()) {
            q.setParameter(++paramsCount, "%" + name.toUpperCase() + "%");
        }

        if (code != null && !code.trim().isEmpty()) {
            q.setParameter(++paramsCount, "%" + code.toUpperCase() + "%");
        }

        if (projectYear != null && !projectYear.trim().isEmpty()) {
            q.setParameter(++paramsCount, projectYear);
        }

        if (projectDate != null) {
        Calendar instance = Calendar.getInstance();
        instance.setTime(projectDate);
        String month = String.valueOf(instance.get(Calendar.MONTH) + 1);
        String projectAuditMonth = month.length() == 1 ? "0" + month : month;
        String projectAuditYear = String.valueOf(instance.get(Calendar.YEAR));
            q.setParameter(++paramsCount, projectAuditMonth);
            q.setParameter(++paramsCount, projectAuditYear);
        }

        if (projectStatus != null) {
            q.setParameter(++paramsCount, projectStatus);
        }

        return q.getResultList();

    }
     /**
     * Retrieve the projects based on user selected search criteria.
     *
     * @param name String - input search criteria from screen
     * @param code String - input search criteria from screen
     * @param projectDate Date - input search criteria from screen
     * @param projectYear String  - input search criteria from screen
     * @param projectStatus Long - input search criteria from screen
     * @param projectTypeId Int - input serach criteria from screen
     * 
     * @return List<Project> - list of projects from the search criteria
     */
    @Override
    public List<Project> findBySearchCriteria(String name, String code, 
            Date projectDate, String projectYear, Long projectStatus, String projectTypeId) {

        StringBuilder builder = new StringBuilder("SELECT p FROM Project p");

        boolean isWhereAdded = false;
        int paramsCount = 0;
        String joinStmt =  " JOIN p.pharmacyProviderList pList";

        // Conditionally build the where clause for the query
        if (name != null && !name.trim().isEmpty()) {
            if (isWhereAdded) {
                builder.append(" AND pList.name LIKE ?").append(++paramsCount);
            } else {
                builder.append(joinStmt);
                builder.append(" WHERE pList.name LIKE ?").append(++paramsCount);
                isWhereAdded = true;
            }
        }

        if (code != null && !code.trim().isEmpty()) {
            if (isWhereAdded) {
                builder.append(" AND pList.code LIKE ?").append(++paramsCount);
            } else {
                builder.append(joinStmt);
                builder.append(" WHERE pList.code LIKE ?").append(++paramsCount);
                isWhereAdded = true;
            }
        }

        if (projectYear != null && !projectYear.trim().isEmpty()) {
            if (isWhereAdded) {
                builder.append(" AND p.projectYear = ?").append(++paramsCount);
            } else {
                builder.append(" WHERE p.projectYear = ?").append(++paramsCount);
                isWhereAdded = true;
            }
        }

        if (projectDate != null) {
            if (isWhereAdded) {
                builder.append(" AND p.projectMonth = ?").append(++paramsCount);
                builder.append(" AND p.projectYear = ?").append(++paramsCount);
            } else {
                builder.append(" WHERE p.projectMonth = ?").append(++paramsCount);
                builder.append(" AND p.projectYear = ?").append(++paramsCount);
                isWhereAdded = true;
            }
        }

        if (projectStatus != null) {

            if (isWhereAdded) {
                builder.append(" AND p.statusId.id = ?").append(++paramsCount);
            } else {
                builder.append(" WHERE p.statusId.id = ?").append(++paramsCount);
                isWhereAdded = true;
            }

        }
        if (projectTypeId != null) {

            if (isWhereAdded) {
                builder.append(" AND p.projectTypeId.id = ?").append(++paramsCount);
            } else {
                builder.append(" WHERE p.projectTypeId.ids = ?").append(++paramsCount);
                isWhereAdded = true;
            }

        }
        // apppend order by clause at the end of query
        builder.append(" ORDER BY p.createdOnDtm DESC"); 

        logger.log(Level.INFO, "project search query = " + builder.toString());         
          //Set positional parameters
        Query q = em.createQuery(builder.toString(), Project.class);
        paramsCount = 0;

        if (name != null && !name.trim().isEmpty()) {
            q.setParameter(++paramsCount, "%" + name.toUpperCase() + "%");
        }

        if (code != null && !code.trim().isEmpty()) {
            q.setParameter(++paramsCount, "%" + code.toUpperCase() + "%");
        }

        if (projectYear != null && !projectYear.trim().isEmpty()) {
            q.setParameter(++paramsCount, projectYear);
        }

        if (projectDate != null) {
        Calendar instance = Calendar.getInstance();
        instance.setTime(projectDate);
        String month = String.valueOf(instance.get(Calendar.MONTH) + 1);
        String projectAuditMonth = month.length() == 1 ? "0" + month : month;
        String projectAuditYear = String.valueOf(instance.get(Calendar.YEAR));
            q.setParameter(++paramsCount, projectAuditMonth);
            q.setParameter(++paramsCount, projectAuditYear);
        }

        if (projectStatus != null) {
            q.setParameter(++paramsCount, projectStatus);
        }
        if (projectTypeId != null) {
            q.setParameter(++paramsCount,   Long.parseLong(projectTypeId));
        }
        return q.getResultList();

    }

    /**
     * Verify the unique project constraint on project name
     * and project month/year.
     * @param project Project - project details form the screen
     *
     * @return Project project
     */
    @Override
    public Project verifyProjectExist(Project project) {
        Query query = em.createNativeQuery("select * from PROJECT p"
                + " where p.NAME = ?1 and p.PROJECT_YEAR =?2"
                + " and p.PROJECT_MONTH = ?3", Project.class);
        query.setParameter(1, project.getName());
        query.setParameter(2, project.getProjectYear());
        query.setParameter(3, project.getProjectMonth());
        return (Project) query.getSingleResult();
    }

    /**
     * Verify if project name and project month/year are unique in database.
     * @param project Project - project details form the screen
     *
     * @return boolean
     */
    @Override
    public boolean projectExist(Project project) {
        boolean isCreated = false;
        Project testProject = new Project();
        try {
            testProject = verifyProjectExist(project);
        } catch (Exception e) {
            for (Throwable t = e.getCause(); t != null; t = t.getCause()) {
                if (t.getClass().getName().equals("java.sql.SQLException")) {
                    logger.log(Level.INFO, "Cannot add record, as it violates a constraint.", e);
                    throw e;
                }
            }
        }
        if (testProject.getId() != null) {
            isCreated = true;
        }
        return isCreated;
    }

    /**
     * The same as edit, but returns the modified object.
     * 
     * @param project Project - selected project for update
     *
     * @return Project project
     */
    @Override
    public Project editWithReturn(Project project) {
        return getEntityManager().merge(project);
    }
    
    /**
     * The same as edit, but returns the modified object.
     * 
     * @param project Project - selected project for update
     *
     * @return Project project
     */
    @Override
    public void editRefresh(Project project) {
        getEntityManager().merge(project);
        getEntityManager().refresh(project);  
                }

    /**
     * Finds project instance by project id.
     * @param prjId Long - project Id
     *
     * @return Project
     */
    @Override
    public Project findProjectById(Long prjId) {
        Query query = em.createNativeQuery("select * from PROJECT pr"
                + " where pr.ID = ?1", Project.class);
        query.setParameter(1, prjId);
        return (Project) query.getSingleResult();
    }

    /**
     * TODO! Retrieve the letter run based on user selected search criteria.
     *
     * @param pracLastName String - input search criteria from screen
     * @param pracFirstName String - input search criteria from screen
     * @param pracCode String - input search criteria from screen
     * @param svaProjectCode String - input search criteria from screen
     * @param letterRunDate Date - input search criteria from screen
     * @param letterRunYear String  - input search criteria from screen
     * @param letterRunStatus Long - input search criteria from screen
     *            String pracFirstName, String pracCode, String svaProjectCode,
            Date letterRunDate, String letterRunYear, Long letterRunStatus) {

        StringBuilder builder = new StringBuilder("SELECT p FROM Project p");
        boolean isWhereAdded = false;
        int paramsCount = 0;
        
        //Set positional parameters
        Query q = em.createQuery(builder.toString(), Project.class);
        paramsCount = 0;

        return q.getResultList();
     * @return List<Project> - list of projects from the search criteria
     */
    @Override
    public List<Project> findLetterRunBySearchCriteria(String pracLastName,
            String pracFirstName, String pracCode, String svaProjectCode,
            Date letterRunDate, String letterRunYear, Long letterRunStatus) {

        StringBuilder builder = new StringBuilder("SELECT p FROM Project p");
        boolean isWhereAdded = false;
        int paramsCount = 0;
        
        //Set positional parameters
        Query q = em.createQuery(builder.toString(), Project.class);
        paramsCount = 0;

        return q.getResultList();
    }
    /**
     * Function to get all project that is close and that is due for an email reminder or for being archive
     * @param DueDate
     * @return 
     */
    @Override
    public List<Project> findAllpharmArchivedBatch(Date DueDate)
    {
       Query q = em.createNamedQuery("Project.findAllpharmArchivedBatch");
        q.setParameter("ArchiveDate", DueDate);
         return q.getResultList();
    
    }

}