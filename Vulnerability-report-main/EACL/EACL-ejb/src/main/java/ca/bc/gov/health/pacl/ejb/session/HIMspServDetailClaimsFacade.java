/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.pacl.ejb.session;

import ca.bc.gov.health.pacl.ejb.entity.AdminOptionsMsp;
import ca.bc.gov.health.pacl.ejb.entity.CodesFeeItemExcl;
import ca.bc.gov.health.pacl.ejb.entity.CodesFeeItemLongExcl;
import ca.bc.gov.health.pacl.ejb.entity.CodesPayeeExcl;
import ca.bc.gov.health.pacl.ejb.entity.CodesSubscriberExcl;
import ca.bc.gov.health.pacl.ejb.entity.Project;
import ca.bc.gov.health.pacl.model.HIServiceMspLetter;
import ca.bc.gov.health.pacl.util.AddressHelper;
import ca.bc.gov.health.pacl.util.PaclConstants;
import ca.bc.gov.health.pacl.util.FuzzyMatch;
import ca.bc.gov.health.pacl.util.Util;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.ejb.EJBException;
import jakarta.ejb.Stateless;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;


import ca.bc.gov.health.pacl.model.EmailMessage;
import ca.bc.gov.health.pacl.service.EmailService;


/**
 *
 * @author Dan.Stepanov
 */
@Stateless
public class HIMspServDetailClaimsFacade implements HIMspServDetailClaimsFacadeLocal {

    private static Logger logger = Logger.getLogger(HIMspServDetailClaimsFacade.class.getName());

    /*
     * Facade for persistence for exclusions and AdminOptionsMsp
     */
    @EJB
    private AdminOptionsMspFacadeLocal adminOptionsMspFacade;
    @EJB
    private HealthideasFacadeLocal hiFacade;
    @EJB
    private CodesSubscriberExclFacadeLocal codesSubscriberExclFacade;
    @EJB
    private CodesFeeItemExclFacadeLocal codesFeeItemExclFacade;
    @EJB
    private CodesFeeItemLongExclFacadeLocal codesFeeItemLongExclFacade;
    @EJB
    private CodesPayeeExclFacadeLocal codesPayeeExclFacade;
    /**
     * Which AHIP schema will we be connecting to?.
     */
    private String schemaPrefix;

    public HIMspServDetailClaimsFacade() {
    }

    /**
     * Lookup the AHIP schema prefix for this environment.
     */
    @PostConstruct
    public void init() {
        schemaPrefix = hiFacade.lookupSchemaPrefixFromJNDI();
    }

    /**
     * Verify if practitioner codes from screen exists in HI.
     *
     * @param EntityManager em - Entity Manager instance to use
     * @param pracCodes List<String> - practitioner input codes
     *
     * @return List<String>
     */
    @Override
    public List<String> verifyPractitionerCodesHI(EntityManager em, List<String> pracCodes) {
        List<String> pracCodesHI = new ArrayList<>();
        // search HealthIdeas for the practitioner codes;
        // then create a list of practitioner instances
        pracCodes.forEach((String practitionerCode) -> {
            List<String> pracCodesScreen = new ArrayList<>();
            Query query = em.createNativeQuery("select PRAC.PRAC_BLLG_NUM AS PRAC_BLLG_NUM"
                    + " FROM " + schemaPrefix + ".CB_DTL_DM_PRAC_VW PRAC"
                            + " WHERE PRAC.PRAC_BLLG_NUM = ?1");
            query.setParameter(1, practitionerCode.trim().toUpperCase());
            try {
                pracCodesScreen = query.getResultList();
            } catch (EJBException e) {
                for (Throwable t = e.getCause(); t != null; t = t.getCause()) {
                    if (t.getClass().getName().equals("java.sql.SQLException")) {
                        logger.log(Level.INFO, "Cannot find the record in the system.", e);
                        throw e;
                    }
                }
            }
            if (!pracCodesScreen.isEmpty()) {
                pracCodesHI.add(practitionerCode.trim());
            }
        });
        return pracCodesHI;
    }

    /**
     * Retrieve the max number of patients allowed per practitioner.
     *
     * @return long maxPatients - retrieves the max. patients per practitioner.
     */
    public long getHIClaimsForPractitioner() {
        // find the most recent record by date CREATED_ON_DTM
        AdminOptionsMsp adminOptionsMsp = adminOptionsMspFacade.findDefaultPatientLimit().get(0);
        long maxPatients = adminOptionsMsp.getDefaultPatientMaxLimit();
        return maxPatients;
    }

    /**
     * Retrieve the min number of patients allowed per practitioner.
     *
     * @return long minPatients - retrieves the min. patients per practitioner.
     */
    public long getHIClaimsMinForPractitioner() {
        // find the most recent record by date CREATED_ON_DTM
        AdminOptionsMsp adminOptionsMsp = adminOptionsMspFacade.findDefaultPatientLimit().get(0);
        long minPatients = adminOptionsMsp.getDefaultPatientMinLimit();
        return minPatients;
    }

    /**
     * Retrieve the max number of claims allowed per patient.
     *
     * @return long maxClaimsPerPatient - retrieves the max. claims per patient.
     */
    public long getHIClaimsMaxForPatient() {
        // find the most recent record by date CREATED_ON_DTM
        AdminOptionsMsp adminOptionsMsp = adminOptionsMspFacade.findDefaultPatientLimit().get(0);
        long maxClaimsPerPatient = adminOptionsMsp.getDefaultClaimMaxLimit();
        return maxClaimsPerPatient;
    }

    /**
     * Retrieve the minimum number of claims allowed per patient.
     *
     * @return long minClaimsPerPatient - retrieves the minimum claims per
     * patient.
     */
    public long getHIClaimsMinForPatient() {
        // find the most recent record by date CREATED_ON_DTM
        AdminOptionsMsp adminOptionsMsp = adminOptionsMspFacade.findDefaultPatientLimit().get(0);
        long minClaimsPerPatient = adminOptionsMsp.getDefaultClaimMinLimit();
        return minClaimsPerPatient;
    }

    /**
     * Retrieve the minimum number of patients allowed per practitioner.
     *
     * @return long minPatientsPerPrac - retrieves the minimum patients per
     * practitioner.
     */
    public long getHIPatientMinForPractitioner() {
        // find the most recent record by date CREATED_ON_DTM
        AdminOptionsMsp adminOptionsMsp = adminOptionsMspFacade.findDefaultPatientLimit().get(0);
        long minPatientsPerPrac = adminOptionsMsp.getDefaultPatientMinLimit();
        return minPatientsPerPrac;
    }

    /**
     * Retrieve the MSP claims records for the selected practitioners from HI
     * with mandatory/optional fields.
     *
     * @param em EntityManager - Entity Manager instance to use
     * @param pracCodesScreen List<String> - practitioner codes selected from
     * the screen
     * @param project Project - project with input values from session/screen
     *
     * @throws Exception
     *
     * @return List<HIServiceMspLetter> hiServiceMspLetter - a list of records
     * with services/letters/practitioners from HI
     */
    @Override
    public List<HIServiceMspLetter> getHIClaimsForRandomLetterRun(
            EntityManager em, List<String> pracCodesScreen, Project project)
            throws Exception {

        // build the practitioner codes
        String delimiter = ", ";
        String apos = "'";

        Iterator<? extends String> iter = pracCodesScreen.iterator();
        StringBuilder pracCodeString = new StringBuilder();
        pracCodeString.append(apos).append(iter.next()).append(apos);
        while (iter.hasNext()) {
            pracCodeString.append(delimiter).append(apos).append(iter.next()).append(apos);
        }

        // retrieve relevant table exclusions TODO!
        // retrieve PHN exclusions
        List<String> phnExclusions = new ArrayList<>();
        for (CodesSubscriberExcl subscriberExcl : codesSubscriberExclFacade.findExcludedPhnByAuditDate(project)) {
            String phnExcl = subscriberExcl.getPhn();
            phnExclusions.add(phnExcl);
        }

        // build the PHN exclusions list
        StringBuilder phnExclString = new StringBuilder();
        if (!phnExclusions.isEmpty()) {
            Iterator<? extends String> iterPhns = phnExclusions.iterator();
            phnExclString.append(apos).append(iterPhns.next()).append(apos);
            while (iterPhns.hasNext()) {
                phnExclString.append(delimiter).append(apos).append(iterPhns.next()).append(apos);
            }
        }

        // retrieve payee exclusions
        List<String> payeeExclusions = new ArrayList<>();
        for (CodesPayeeExcl payeeExcl : codesPayeeExclFacade.findExcludedPayeeByAuditDate(project)) {
            String payeeCodeExcl = payeeExcl.getPayeeIdnt();
            payeeExclusions.add(payeeCodeExcl);
        }

        // build the payee exclusions list
        StringBuilder payeeExclString = new StringBuilder();
        if (!payeeExclusions.isEmpty()) {
            Iterator<? extends String> iterPayees = payeeExclusions.iterator();
            payeeExclString.append(apos).append(iterPayees.next()).append(apos);
            while (iterPayees.hasNext()) {
                payeeExclString.append(delimiter).append(apos).append(iterPayees.next()).append(apos);
            }
        }

        // retrieve fee items exclusions
        List<String> fitmExclusions = new ArrayList<>();
        String exclusionFlag = PaclConstants.FEE_ITEM_EXCLUSION_FLAG;
        for (CodesFeeItemExcl feeItemExcl : codesFeeItemExclFacade.findExcludedFeeItemCodes(exclusionFlag)) {
            String feeExcl = String.valueOf(feeItemExcl.getFitmCd());
            fitmExclusions.add(feeExcl);
        }
        // build the fee item exclusions list
        Iterator<? extends String> iterFees = fitmExclusions.iterator();
        StringBuilder feeExclString = new StringBuilder();
        String openParenthesis = "(1,";
        String closeParenthesis = ")";
        feeExclString.append(openParenthesis).append(apos).append(iterFees.next()).append(apos).append(closeParenthesis);
        while (iterFees.hasNext()) {
            feeExclString.append(delimiter).append(openParenthesis).append(apos).append(iterFees.next()).append(apos).append(closeParenthesis);
        }

        // timestamp check HI
        java.util.Date date = new java.util.Date();
        logger.log(Level.INFO, "timestamp before MSP query HI = : " + new java.sql.Timestamp(date.getTime()));

        StringBuilder mspQueryBuilderHI = new StringBuilder();
        // Subquery to identify all matching PHN records
        // and parsing of the address/city/province/postal code/country

        /* NEW QUERY*/
        mspQueryBuilderHI.append("WITH msp_claims AS ( "
                + "SELECT /*+ no_parallel no_index(mspclm) no_index(prac) no_index(payee) */" /*no_index(clnt) */
                + "       mspclm.ROWID       AS rid "
                + ",      clnt.clnt_idnt     AS phnnum "
                + ",      prac.prac_bllg_num AS prac_bllg_num "
                + "FROM   " + schemaPrefix + ".cb_dtl_ft_mspclm_vwp mspclm "
                + ",      " + schemaPrefix + ".cb_dtl_dm_prac_vw prac "
                + ",      " + schemaPrefix + ".cb_dtl_dm_payee_vw payee "
                + ",      " + schemaPrefix + ".cb_dtl_dm_clnt_vw clnt "
                + "WHERE mspclm.prac_label = prac.label "
                + " AND mspclm.payee_label = payee.label "
                + " AND mspclm.clnt_label = clnt.label "
                + " AND mspclm.pd_amt > 0 "
                + "AND mspclm.msp_clm_pmt_cat_label = 'P' "
                + "AND mspclm.msp_pmt_resp_label = 'M' "
                + "AND clnt.mrg_clnt_dth_date IS NULL "
                + "AND clnt.clnt_idnt_cdg = 'PHN' "
                + "AND (   MONTHS_BETWEEN (mspclm.srv_date, clnt.mrg_clnt_brth_date) / 12 >= 20 "
                + "OR MONTHS_BETWEEN (mspclm.srv_date, clnt.mrg_clnt_brth_date) / 12 <= 9) "
                //start and end date entered by the user 
                + " AND mspclm.srv_date BETWEEN ?1 "
                + "                        AND ?2 ");

        // exclude PHNs based on auditing date range
        if (!phnExclusions.isEmpty()) {
            mspQueryBuilderHI.append(" AND TO_NUMBER(CLNT.CLNT_IDNT) NOT IN (" + phnExclString.toString() + ") ");
        }
        //Prac Billing number enter by the user
        mspQueryBuilderHI.append(" AND PRAC.PRAC_BLLG_NUM IN (" + pracCodeString.toString() + ") ");

        // build the exclusion rules for fee items/PHNs/payees
        // exclude fee items that have exclusion flag set 'Y' from HI
        // removed to_number and instr conditions after new load from DB2
        if (!fitmExclusions.isEmpty()) {
            mspQueryBuilderHI.append(" AND (1, mspclm.pd_srv_label) IN ( "
                    + feeExclString.toString() + ")");
        }

        // exclude payees based on auditing date range
        if (!payeeExclusions.isEmpty()) {
            mspQueryBuilderHI.append(" AND PAYEE.PAYEE_IDNT NOT IN (" + payeeExclString.toString() + ") ");
        }

        mspQueryBuilderHI.append("   ), "
                + "sampled_msp_claims AS ( "
                + "  SELECT prac_bllg_num, "
                + "         phnnum, "
                + "         rid, "
                + "         count_clm_per_phn,"
                + "         rnk_clm_per_phn"
                + "    FROM (SELECT"
                + "                 row_number () OVER (PARTITION BY t1.phnnum ORDER BY dbms_random.value)"
                + "                    rnk_clm_per_phn,"
                + "                     count (*) OVER (PARTITION BY t1.phnnum ORDER BY t1.phnnum)"
                + "                    count_clm_per_phn,"
                + "                 t1.prac_bllg_num,"
                + "                 t1.phnnum,"
                + "                 t.rid"
                + "            FROM (SELECT phnnum,"
                + "                         prac_bllg_num "
                + "                    FROM (SELECT DISTINCT phnnum, prac_bllg_num FROM msp_claims t)) t1,"
                + "                 msp_claims t "
                + "WHERE   t.phnnum = t1.phnnum "
                + "    AND t.prac_bllg_num = t1.prac_bllg_num) "
                + " WHERE count_clm_per_phn >=" + getHIClaimsMinForPatient()
                //number of claims per prac and phn is difference between high and low + 1 (6-1+1=6).
                + "     AND rnk_clm_per_phn <=" + getHIClaimsMaxForPatient() + " order by dbms_random.value), ");

        mspQueryBuilderHI.append("sampled_claim_details AS ( "
                + "   SELECT /*+ materialize */" 
                + "          mspclm.clm_num AS clm_num, "
                + "          payee.payee_idnt AS payee_idnt, "
                + "          payee.payee_org_nm AS payee_org_nm, "
                + "          clnt.clnt_idnt AS phnnum, "
                + "          clnt.clnt_anon_idnt_id AS clnt_anon_idnt_id, "
                + "          mspclm.srv_date AS dtofserv, "
                + "          pd_srv.pd_fitm_cd AS pd_fitm_cd, "
                + "          pd_srv.pd_fitm AS pd_fitm, "
                + "          pd_srv.pd_fitm_dscr AS pd_fitm_dscr, "
                + "          pd_srv.pd_srv_cd AS pd_srv_cd, "
                + "          pd_srv.pd_srv_cd_dscr AS pd_srv_cd_dscr, "
                + "          pd_srv.tydf_code AS tydf_code, "
                + "          clnt.mrg_clnt_brth_date AS brdt, "
                + "          " + schemaPrefix + ".api_clntcmpl_app.getAttributeClient ( "
                + "             clnt.mrg_clnt_anon_id, "
                + "             'MAILING_ADDRESS') "
                + "             AS clnt_addr, "
                + "          " + schemaPrefix + ".api_clntcmpl_app.getAttributeClient ( "
                + "             clnt.mrg_clnt_anon_id, "
                + "             'MAIL_ADDRESS_LINE') "
                + "             AS clnt_addr_comparision_field, "
                + "          " + schemaPrefix + ".api_clntcmpl_app.getAttribute (clnt_anon_idnt_id, "
                + "                                                  'LEGAL_SURNAME') "
                + "             AS legal_surname, "
                + "          " + schemaPrefix + ".api_clntcmpl_app.getAttribute (clnt_anon_idnt_id, "
                + "                                                  'LEGAL_FIRST_GIVEN_NAME') "
                + "             AS legal_first_given_name, "
                + "          prac.prac_bllg_num as prac_bllg_num, "
                + "          prac.prac_idnt as prac_idnt, "
                + "          prac.prac_surnm as prac_surname, "
                + "          prac.prac_1st_gvn_nm as prac_1st_gvn_nm, "
                + "          prac.prac_2nd_gvn_nm as prac_2nd_gvn_nm, "
                + "          prac.prac_3rd_gvn_nm as prac_3rd_gvn_nm, "
                + "          xsp.prac_spty_cd as prac_spty_cd, "
                + "          xsp.prac_spty as prac_spty, "
                + "          smpl.count_clm_per_phn,"
                + "          smpl.rnk_clm_per_phn"
                + "   FROM " + schemaPrefix + ".cb_dtl_ft_mspclm_vwp mspclm, "
                + "        sampled_msp_claims smpl, "
                + "        " + schemaPrefix + ".cb_dtl_dm_srv_date_vw srv_dt, "
                + "        " + schemaPrefix + ".cb_dtl_dm_pd_srv_vw pd_srv, "
                + "        " + schemaPrefix + ".cb_dtl_dm_payee_vw payee, "
                + "        " + schemaPrefix + ".cb_dtl_dm_prac_vw prac, "
                + "        " + schemaPrefix + ".cb_dtl_dm_clnt_vw clnt, "
                // Get unique combination of prac anon ID and its current specialty effective on SYSDATE. Using billing number.
                + "        (SELECT * FROM (SELECT  DISTINCT pr.label, spty.rcnt_bllg_spty_cd_1 as prac_spty_cd, spty.rcnt_bllg_spty_1 as prac_spty, pracsp.eff_date as eff_date, ROW_NUMBER() OVER (PARTITION BY pr.label ORDER BY spty.rcnt_bllg_spty_cd_1 ASC) AS rn"
                + "         FROM " + schemaPrefix + ".cb_dtl_dm_prac_vw pr,"
                + "        " + schemaPrefix + ".cb_dtl_dm_prac_vw prac_rst,"
                + "        " + schemaPrefix + ".cb_dtl_ft_ctgpracrst_vwp pracsp,"
                + "        " + schemaPrefix + ".cb_dtl_dm_rcnt_bllg_spty_1_vw spty"
                + "         WHERE pr.prac_bllg_num = prac_rst.prac_bllg_num "
                + "         AND prac_rst.label = pracsp.prac_label"
                + "         AND SYSDATE BETWEEN pracsp.eff_date AND pracsp.end_date"
                + "         AND pracsp.rcnt_bllg_spty_1_label = spty.label "
                + "         AND pracsp.rcnt_bllg_spty_1_level_name = spty.level_name) WHERE rn=1) xsp"
                + "   WHERE mspclm.rowid = smpl.rid "
                + "     AND mspclm.clnt_label = clnt.label "
                + "     AND mspclm.prac_label = prac.label "
                + "     AND mspclm.payee_label = payee.label "
                + "     AND mspclm.srv_date_label = srv_dt.label "
                + "     AND mspclm.pd_srv_label = pd_srv.label "
                + "     AND mspclm.pd_srv_tydf_code = pd_srv.tydf_code "
                + "     AND prac.label = xsp.label), "
                + "addressed_claims AS ( "
                + "   SELECT prac_bllg_num, "
                + "          prac_surname, "
                + "          prac_1st_gvn_nm, "
                + "          prac_2nd_gvn_nm, "
                + "          prac_3rd_gvn_nm, "
                + "          phnnum, "
                + "          dtofserv, "
                + "          brdt, "
                + "          tydf_code, "
                + "          clnt_addr, "
                + "          SUBSTR(clnt_addr, 1, INSTR(clnt_addr, '|', 1) - 1) AS address_line_1, "
                + "          SUBSTR(clnt_addr, INSTR(clnt_addr, '|', 1, 1) + 1, INSTR(clnt_addr, '|', 1, 2) - INSTR(clnt_addr, '|', 1)- 1) AS address_line_2, "
                + "          SUBSTR(clnt_addr, INSTR(clnt_addr, '|', 1, 2) + 1, INSTR(clnt_addr, '|', 1, 3) - INSTR(clnt_addr, '|', 1, 2) - 1) AS address_line_3, "
                + "          SUBSTR(clnt_addr, INSTR(clnt_addr, '|', 1, 3) + 1, INSTR(clnt_addr, '|', 1, 4) - INSTR(clnt_addr, '|', 1, 3) - 1) AS address_line_4, "
                + "          SUBSTR(clnt_addr, INSTR(clnt_addr, '|', 1, 4) + 1) AS postal_code, "
                + "          pd_fitm_cd, "
                + "          pd_fitm, "
                + "          pd_fitm_dscr, "
                + "          pd_srv_cd, "
                + "          pd_srv_cd_dscr, "
                + "          payee_idnt, "
                + "          payee_org_nm, "
                + "          prac_idnt, "
                + "          prac_spty_cd, "
                + "          prac_spty, "
                + "          legal_surname, "
                + "          legal_first_given_name,"
                + "          clnt_addr_comparision_field,"
                + "          count_clm_per_phn,"
                + "          rnk_clm_per_phn"
                + "   FROM sampled_claim_details), "
                + " condition_query as("
                + "   SELECT * "
                + "FROM addressed_claims "
                + "WHERE address_line_1 IS NOT NULL "
                // Validating the province with postal code. V is for BC
                + "  AND postal_code IS NOT NULL AND postal_code LIKE 'V%'"
                + "  AND legal_first_given_name IS NOT NULL "
                + "  AND legal_surname IS NOT NULL "
                + "ORDER BY prac_bllg_num, phnnum, dtofserv, pd_fitm_cd"
                + "   ),"
                + " condition_query_Unique as( "
                + "      SELECT DISTINCT prac_bllg_num,phnnum,"
                + "      count (DISTINCT(PHNNUM)) OVER (PARTITION BY prac_bllg_num  )   count_phn_per_prac "
                + "      FROM condition_query"
                + "  ),"
                + " condition_query_unique_rnk as("
                + "      SELECT prac_bllg_num,phnnum,count_phn_per_prac,"
                + "      row_number () OVER (PARTITION BY prac_bllg_num ORDER BY DBMS_RANDOM.VALUE) rnk_phn_per_prac"
                + "      from condition_query_Unique"
                + "  )"
                + " SELECT DISTINCT cq.*, cqur.count_phn_per_prac, cqur.rnk_phn_per_prac "
                + " FROM  condition_query cq, condition_query_unique_rnk cqur"
                + " where cq.prac_bllg_num = cqur.prac_bllg_num "
                + " AND cq.phnnum = cqur.phnnum"
                + " AND cqur.count_phn_per_prac >= " + getHIPatientMinForPractitioner()
                + " AND cqur.rnk_phn_per_prac<= " + project.getMaxPatients()
                + " order by  cq.prac_bllg_num,cq.phnnum asc");
        
        logger.log(Level.INFO, "query HI = " + mspQueryBuilderHI.toString());
        Query mspQueryHI = em.createNativeQuery(mspQueryBuilderHI.toString());
        mspQueryHI.setParameter(1, project.getProjectFromDate());
        mspQueryHI.setParameter(2, project.getProjectToDate());
        
        List result = new ArrayList();
        try {
            result = mspQueryHI.getResultList();
        } catch (Exception e){
            logger.log(Level.SEVERE, "Exception after query HI for Random: " + e.getMessage());
            throw e;
        }

        logger.log(Level.INFO, "Number of rows returned for the random letter run : " + result.size());
        java.util.Date date2 = new java.util.Date();
        logger.log(Level.INFO, "timestamp after MSP query HI = : " + new java.sql.Timestamp(date2.getTime()));

        List<HIServiceMspLetter> hIServiceMspLetters = new ArrayList<>(result.size());

        hIServiceMspLetters = populateHIMspLetterClaims(result, hIServiceMspLetters);

        return hIServiceMspLetters;
    }

    /**
     * Retrieve the MSP claims records for the selected practitioners from HI
     * with mandatory/optional fields.
     *
     * @param em EntityManager - Entity Manager instance to use
     * @param pracCodesScreen List<String> - practitioner codes selected from
     * the screen
     * @param project Project - project with input values from session/screen
     * @param optFeeItemCodesScreen List<String> - optional fee item codes
     * selected from the screen
     * @param optServiceCodesScreen List<String> - optional service codes
     * selected from the screen
     *
     * @throws Exception
     *
     * @return List<HIServiceMspLetter> hiServiceMspLetter - a list of records
     * with services/letters/practitioners from HI
     */
    @Override
    public List<HIServiceMspLetter> getHIClaimsForSelectServiceLetterRun(
            EntityManager em, List<String> optFeeItemCodesScreen,
            List<String> optServiceCodesScreen, List<String> pracCodesScreen,
            Project project) throws Exception {

        // build the practitioner codes
        String delimiter = ", ";
        String apos = "'";

        Iterator<? extends String> iter = pracCodesScreen.iterator();
        StringBuilder pracCodeString = new StringBuilder();
        pracCodeString.append(apos).append(iter.next()).append(apos);
        while (iter.hasNext()) {
            pracCodeString.append(delimiter).append(apos).append(iter.next()).append(apos);
        }

        // retrieve relevant table exclusions TODO!
        // retrieve PHN exclusions
        List<String> phnExclusions = new ArrayList<>();
        for (CodesSubscriberExcl subscriberExcl : codesSubscriberExclFacade.findExcludedPhnByAuditDate(project)) {
            String phnExcl = subscriberExcl.getPhn();
            phnExclusions.add(phnExcl);
        }

        // build the PHN exclusions list
        StringBuilder phnExclString = new StringBuilder();
        if (!phnExclusions.isEmpty()) {
            Iterator<? extends String> iterPhns = phnExclusions.iterator();
            phnExclString.append(apos).append(iterPhns.next()).append(apos);
            while (iterPhns.hasNext()) {
                phnExclString.append(delimiter).append(apos).append(iterPhns.next()).append(apos);
            }
        }

        // retrieve payee exclusions
        List<String> payeeExclusions = new ArrayList<>();
        for (CodesPayeeExcl payeeExcl : codesPayeeExclFacade.findExcludedPayeeByAuditDate(project)) {
            String payeeCodeExcl = payeeExcl.getPayeeIdnt();
            payeeExclusions.add(payeeCodeExcl);
        }

        // build the payee exclusions list
        StringBuilder payeeExclString = new StringBuilder();
        if (!payeeExclusions.isEmpty()) {
            Iterator<? extends String> iterPayees = payeeExclusions.iterator();
            payeeExclString.append(apos).append(iterPayees.next()).append(apos);
            while (iterPayees.hasNext()) {
                payeeExclString.append(delimiter).append(apos).append(iterPayees.next()).append(apos);
            }
        }

        // retrieve fee items exclusions
        List<String> fitmExclusions = new ArrayList<>();
        String exclusionFlag = PaclConstants.FEE_ITEM_EXCLUSION_FLAG;
        for (CodesFeeItemExcl feeItemExcl : codesFeeItemExclFacade.findExcludedFeeItemCodes(exclusionFlag)) {
            String feeExcl = String.valueOf(feeItemExcl.getFitmCd());
            fitmExclusions.add(feeExcl);
        }
        // build the fee item exclusions list
        Iterator<? extends String> iterFees = fitmExclusions.iterator();
        StringBuilder feeExclString = new StringBuilder();
        String openParenthesis = "(1,";
        String closeParenthesis = ")";
        feeExclString.append(openParenthesis).append(apos).append(iterFees.next()).append(apos).append(closeParenthesis);
        while (iterFees.hasNext()) {
            feeExclString.append(delimiter).append(openParenthesis).append(apos).append(iterFees.next()).append(apos).append(closeParenthesis);
        }

        // timestamp check HI
        java.util.Date date = new java.util.Date();
        logger.log(Level.INFO, "timestamp before MSP query HI = : " + new java.sql.Timestamp(date.getTime()));
        StringBuilder mspQueryBuilderHI = new StringBuilder();
        // Subquery to identify all matching PHN records
        // and parsing of the address/city/province/postal code/country

        /* NEW QUERY*/
        mspQueryBuilderHI.append("WITH msp_claims AS ( "
                + "SELECT /*+ no_parallel no_index(mspclm) no_index(prac) no_index(payee)*/ " /* no_index(clnt) */
                + "       mspclm.ROWID       AS rid "
                + ",      clnt.clnt_idnt     AS phnnum "
                + ",      prac.prac_bllg_num AS prac_bllg_num "
                + "FROM   " + schemaPrefix + ".cb_dtl_ft_mspclm_vwp mspclm "
                + ",      " + schemaPrefix + ".cb_dtl_dm_prac_vw prac "
                + ",      " + schemaPrefix + ".cb_dtl_dm_payee_vw payee "
                + ",      " + schemaPrefix + ".cb_dtl_dm_clnt_vw clnt "
                + "WHERE mspclm.prac_label = prac.label "
                + " AND mspclm.payee_label = payee.label "
                + " AND mspclm.clnt_label = clnt.label "
                + " AND mspclm.pd_amt > 0 "
                + "AND mspclm.msp_clm_pmt_cat_label = 'P' "
                + "AND mspclm.msp_pmt_resp_label = 'M' "
                + "AND clnt.mrg_clnt_dth_date IS NULL "
                + "AND clnt.clnt_idnt_cdg = 'PHN' "
                + "AND (   MONTHS_BETWEEN (mspclm.srv_date, clnt.mrg_clnt_brth_date) / 12 >= 20 "
                + "OR MONTHS_BETWEEN (mspclm.srv_date, clnt.mrg_clnt_brth_date) / 12 <= 9) "
                //start and end date entered by the user 
                + " AND mspclm.srv_date BETWEEN ?1 "
                + "                        AND ?2 ");

        // exclude PHNs based on auditing date range
        if (!phnExclusions.isEmpty()) {
            mspQueryBuilderHI.append(" AND TO_NUMBER(CLNT.CLNT_IDNT) NOT IN (" + phnExclString.toString() + ") ");
        }
        //Prac Billing number enter by the user
        mspQueryBuilderHI.append(" AND PRAC.PRAC_BLLG_NUM IN (" + pracCodeString.toString() + ") ");

        // build the exclusion rules for fee items/PHNs/payees
        // exclude fee items that have exclusion flag set 'Y' from HI
        // removed to_number and instr conditions after new load from DB2
        if (!fitmExclusions.isEmpty()) {
            mspQueryBuilderHI.append(" AND (1, mspclm.pd_srv_label) IN ( "
                    + feeExclString.toString() + ")");
        }

        // exclude payees based on auditing date range
        if (!payeeExclusions.isEmpty()) {
            mspQueryBuilderHI.append(" AND PAYEE.PAYEE_IDNT NOT IN (" + payeeExclString.toString() + ") ");
        }

        // HI query with optional search parameters
        // check optional fee item and service codes from the screen
        if ((!optFeeItemCodesScreen.isEmpty()
                && !optFeeItemCodesScreen.contains((String) ""))
                || (!optServiceCodesScreen.isEmpty()
                && !optServiceCodesScreen.contains((String) ""))) {
            // begin optional filter specific for fee/service codes
            mspQueryBuilderHI.append(" AND ( ");
            // add optional service codes from the screen
            if (!optServiceCodesScreen.isEmpty()
                    && !optServiceCodesScreen.contains((String) "")) {
                Iterator<? extends String> iterOptServiceCodes = optServiceCodesScreen.iterator();
                StringBuilder optionalServiceCodeStr = new StringBuilder();
                optionalServiceCodeStr.append(apos).append(iterOptServiceCodes.next()).append(apos);
                while (iterOptServiceCodes.hasNext()) {
                    optionalServiceCodeStr.append(delimiter).append(apos).append(iterOptServiceCodes.next()).append(apos);
                }
                // add condition for service codes from the screen
                if ((!optionalServiceCodeStr.toString().isEmpty()
                        && !"''".equals(optionalServiceCodeStr.toString()))
                        && optionalServiceCodeStr.toString() != null) {
                    mspQueryBuilderHI.append("MSPCLM.SRC_PD_SRV_CD IN ("
                            + optionalServiceCodeStr.toString() + ")");
                }
            }
            // add optional fee item codes from the screen
            if (!optFeeItemCodesScreen.isEmpty()
                    && !optFeeItemCodesScreen.contains((String) "")) {
                Iterator<? extends String> iterOptFeeCodes = optFeeItemCodesScreen.iterator();
                StringBuilder optionalFeeCodeStr = new StringBuilder();
                optionalFeeCodeStr.append(apos).append(iterOptFeeCodes.next()).append(apos);
                while (iterOptFeeCodes.hasNext()) {
                    optionalFeeCodeStr.append(delimiter).append(apos).append(iterOptFeeCodes.next()).append(apos);
                }
                // add condition for fee item codes from the screen
                if (((!optionalFeeCodeStr.toString().isEmpty()
                        && !"''".equals(optionalFeeCodeStr.toString()))
                        && optionalFeeCodeStr.toString() != null)
                        && (!optServiceCodesScreen.isEmpty()
                        && !optServiceCodesScreen.contains((String) ""))) {
                    mspQueryBuilderHI.append(" OR MSPCLM.SRC_PD_FITM_CD IN ("
                            + optionalFeeCodeStr.toString() + ")");
                } else if (((!optionalFeeCodeStr.toString().isEmpty()
                        && !"''".equals(optionalFeeCodeStr.toString()))
                        && optionalFeeCodeStr.toString() != null)
                        || (optServiceCodesScreen.isEmpty()
                        && optServiceCodesScreen.contains((String) ""))) {
                    mspQueryBuilderHI.append(" MSPCLM.SRC_PD_FITM_CD IN ("
                            + optionalFeeCodeStr.toString() + ")");
                }
            }

            // end optional filter
            mspQueryBuilderHI.append(" ) ");
        }

        mspQueryBuilderHI.append("   ), "
                + "sampled_msp_claims AS ( "
                + "  SELECT prac_bllg_num, "
                + "         phnnum, "
                + "         rid, "
                + "         count_clm_per_phn,"
                + "         rnk_clm_per_phn"
                + "    FROM (SELECT"
                + "                 row_number () OVER (PARTITION BY t1.phnnum ORDER BY dbms_random.value)"
                + "                    rnk_clm_per_phn,"
                + "                     count (*) OVER (PARTITION BY t1.phnnum ORDER BY t1.phnnum)"
                + "                    count_clm_per_phn,"
                + "                 t1.prac_bllg_num,"
                + "                 t1.phnnum,"
                + "                 t.rid"
                + "            FROM (SELECT phnnum,"
                + "                         prac_bllg_num "
                + "                    FROM (SELECT DISTINCT phnnum, prac_bllg_num FROM msp_claims t)) t1,"
                + "                 msp_claims t "
                + "WHERE   t.phnnum = t1.phnnum "
                + "    AND t.prac_bllg_num = t1.prac_bllg_num) "
                + " WHERE count_clm_per_phn >=" + getHIClaimsMinForPatient()
                //number of claims per prac and phn is difference between high and low + 1 (6-1+1=6).
                + "     AND rnk_clm_per_phn <=" + getHIClaimsMaxForPatient() + " order by dbms_random.value), ");

        mspQueryBuilderHI.append("sampled_claim_details AS ( "
                + "   SELECT /*+ materialize */  "
                + "          mspclm.clm_num AS clm_num, "
                + "          payee.payee_idnt AS payee_idnt, "
                + "          payee.payee_org_nm AS payee_org_nm, "
                + "          clnt.clnt_idnt AS phnnum, "
                + "          clnt.clnt_anon_idnt_id AS clnt_anon_idnt_id, "
                + "          mspclm.srv_date AS dtofserv, "
                + "          pd_srv.pd_fitm_cd AS pd_fitm_cd, "
                + "          pd_srv.pd_fitm AS pd_fitm, "
                + "          pd_srv.pd_fitm_dscr AS pd_fitm_dscr, "
                + "          pd_srv.pd_srv_cd AS pd_srv_cd, "
                + "          pd_srv.pd_srv_cd_dscr AS pd_srv_cd_dscr, "
                + "          pd_srv.tydf_code AS tydf_code, "
                + "          clnt.mrg_clnt_brth_date AS brdt, "
                + "          " + schemaPrefix + ".api_clntcmpl_app.getAttributeClient ( "
                + "             clnt.mrg_clnt_anon_id, "
                + "             'MAILING_ADDRESS') "
                + "             AS clnt_addr, "
                                + "          " + schemaPrefix + ".api_clntcmpl_app.getAttributeClient ( "
                + "             clnt.mrg_clnt_anon_id, "
                + "             'MAIL_ADDRESS_LINE') "
                + "             AS clnt_addr_comparision_field, "
                + "          " + schemaPrefix + ".api_clntcmpl_app.getAttribute (clnt_anon_idnt_id, "
                + "                                                  'LEGAL_SURNAME') "
                + "             AS legal_surname, "
                + "          " + schemaPrefix + ".api_clntcmpl_app.getAttribute (clnt_anon_idnt_id, "
                + "                                                  'LEGAL_FIRST_GIVEN_NAME') "
                + "             AS legal_first_given_name, "
                + "          prac.prac_bllg_num as prac_bllg_num, "
                + "          prac.prac_idnt as prac_idnt, "
                + "          prac.prac_surnm as prac_surname, "
                + "          prac.prac_1st_gvn_nm as prac_1st_gvn_nm, "
                + "          prac.prac_2nd_gvn_nm as prac_2nd_gvn_nm, "
                + "          prac.prac_3rd_gvn_nm as prac_3rd_gvn_nm, "
                + "          xsp.prac_spty_cd as prac_spty_cd, "
                + "          xsp.prac_spty as prac_spty, "
                + "          smpl.count_clm_per_phn,"
                + "          smpl.rnk_clm_per_phn"
                + "   FROM " + schemaPrefix + ".cb_dtl_ft_mspclm_vwp mspclm, "
                + "        sampled_msp_claims smpl, "
                + "        " + schemaPrefix + ".cb_dtl_dm_srv_date_vw srv_dt, "
                + "        " + schemaPrefix + ".cb_dtl_dm_pd_srv_vw pd_srv, "
                + "        " + schemaPrefix + ".cb_dtl_dm_payee_vw payee, "
                + "        " + schemaPrefix + ".cb_dtl_dm_prac_vw prac, "
                + "        " + schemaPrefix + ".cb_dtl_dm_clnt_vw clnt, "
                // Get unique combination of prac anon ID and its current specialty effective on SYSDATE. Using billing number.
                + "        (SELECT * FROM (SELECT  DISTINCT pr.label, spty.rcnt_bllg_spty_cd_1 as prac_spty_cd, spty.rcnt_bllg_spty_1 as prac_spty, pracsp.eff_date as eff_date, ROW_NUMBER() OVER (PARTITION BY pr.label ORDER BY spty.rcnt_bllg_spty_cd_1 ASC) AS rn"
                + "         FROM " + schemaPrefix + ".cb_dtl_dm_prac_vw pr,"
                + "        " + schemaPrefix + ".cb_dtl_dm_prac_vw prac_rst,"
                + "        " + schemaPrefix + ".cb_dtl_ft_ctgpracrst_vwp pracsp,"
                + "        " + schemaPrefix + ".cb_dtl_dm_rcnt_bllg_spty_1_vw spty"
                + "         WHERE pr.prac_bllg_num = prac_rst.prac_bllg_num "
                + "         AND prac_rst.label = pracsp.prac_label"
                + "         AND SYSDATE BETWEEN pracsp.eff_date AND pracsp.end_date"
                + "         AND pracsp.rcnt_bllg_spty_1_label = spty.label "
                + "         AND pracsp.rcnt_bllg_spty_1_level_name = spty.level_name) WHERE rn=1) xsp"
                + "   WHERE mspclm.rowid = smpl.rid "
                + "     AND mspclm.clnt_label = clnt.label "
                + "     AND mspclm.prac_label = prac.label "
                + "     AND mspclm.payee_label = payee.label "
                + "     AND mspclm.srv_date_label = srv_dt.label "
                + "     AND mspclm.pd_srv_label = pd_srv.label "
                + "     AND mspclm.pd_srv_tydf_code = pd_srv.tydf_code "
                + "     AND prac.label = xsp.label), "
                + "addressed_claims AS ( "
                + "   SELECT prac_bllg_num, "
                + "          prac_surname, "
                + "          prac_1st_gvn_nm, "
                + "          prac_2nd_gvn_nm, "
                + "          prac_3rd_gvn_nm, "
                + "          phnnum, "
                + "          dtofserv, "
                + "          brdt, "
                + "          tydf_code, "
                + "          clnt_addr, "
                + "          SUBSTR(clnt_addr, 1, INSTR(clnt_addr, '|', 1) - 1) AS address_line_1, "
                + "          SUBSTR(clnt_addr, INSTR(clnt_addr, '|', 1, 1) + 1, INSTR(clnt_addr, '|', 1, 2) - INSTR(clnt_addr, '|', 1)- 1) AS address_line_2, "
                + "          SUBSTR(clnt_addr, INSTR(clnt_addr, '|', 1, 2) + 1, INSTR(clnt_addr, '|', 1, 3) - INSTR(clnt_addr, '|', 1, 2) - 1) AS address_line_3, "
                + "          SUBSTR(clnt_addr, INSTR(clnt_addr, '|', 1, 3) + 1, INSTR(clnt_addr, '|', 1, 4) - INSTR(clnt_addr, '|', 1, 3) - 1) AS address_line_4, "
                + "          SUBSTR(clnt_addr, INSTR(clnt_addr, '|', 1, 4) + 1) AS postal_code, "
                + "          pd_fitm_cd, "
                + "          pd_fitm, "
                + "          pd_fitm_dscr, "
                + "          pd_srv_cd, "
                + "          pd_srv_cd_dscr, "
                + "          payee_idnt, "
                + "          payee_org_nm, "
                + "          prac_idnt, "
                + "          prac_spty_cd, "
                + "          prac_spty, "
                + "          legal_surname, "
                + "          legal_first_given_name,"
                + "          clnt_addr_comparision_field,"
                + "          count_clm_per_phn,"
                + "          rnk_clm_per_phn"
                + "   FROM sampled_claim_details), "
                + " condition_query as("
                + "   SELECT * "
                + "FROM addressed_claims "
                + "WHERE address_line_1 IS NOT NULL "
                // Validating the province with postal code. V is for BC
                + "  AND postal_code IS NOT NULL AND postal_code LIKE 'V%'"
                + "  AND legal_first_given_name IS NOT NULL "
                + "  AND legal_surname IS NOT NULL "
                + "ORDER BY prac_bllg_num, phnnum, dtofserv, pd_fitm_cd"
                + "   ),"
                + " condition_query_Unique as( "
                + "      SELECT DISTINCT prac_bllg_num,phnnum,"
                + "      count (DISTINCT(PHNNUM)) OVER (PARTITION BY prac_bllg_num  )   count_phn_per_prac "
                + "      FROM condition_query"
                + "  ),"
                + " condition_query_unique_rnk as("
                + "      SELECT prac_bllg_num,phnnum,count_phn_per_prac,"
                + "      row_number () OVER (PARTITION BY prac_bllg_num ORDER BY DBMS_RANDOM.VALUE) rnk_phn_per_prac"
                + "      from condition_query_Unique"
                + "  )"
                + " SELECT DISTINCT cq.*, cqur.count_phn_per_prac, cqur.rnk_phn_per_prac "
                + " FROM  condition_query cq, condition_query_unique_rnk cqur"
                + " where cq.prac_bllg_num = cqur.prac_bllg_num "
                + " AND cq.phnnum = cqur.phnnum"
                + " AND cqur.count_phn_per_prac >= " + getHIPatientMinForPractitioner()
                + " AND cqur.rnk_phn_per_prac<= " + project.getMaxPatients()
                + " order by  cq.prac_bllg_num,cq.phnnum asc");
        
        logger.log(Level.INFO, "query HI = " + mspQueryBuilderHI.toString());
        Query mspQueryHI = em.createNativeQuery(mspQueryBuilderHI.toString());
        mspQueryHI.setParameter(1, project.getProjectFromDate());
        mspQueryHI.setParameter(2, project.getProjectToDate());

        List result = new ArrayList();
        try {
            result = mspQueryHI.getResultList();
        } catch (Exception e){
            logger.log(Level.SEVERE, "Exception after query HI for Select: " + e.getMessage());
            throw e;
        }
        
        logger.log(Level.INFO, "Number of rows returned for the select services letter run : " + result.size());
        java.util.Date date2 = new java.util.Date();
        logger.log(Level.INFO, "timestamp after MSP query HI = : " + new java.sql.Timestamp(date2.getTime()));

        List<HIServiceMspLetter> hIServiceMspLetters = new ArrayList<>(result.size());

        hIServiceMspLetters = populateHIMspLetterClaims(result, hIServiceMspLetters);

        return hIServiceMspLetters;
    }

    /**
     * Retrieve the fee item short description by fee item code.
     *
     * @param feeItemCd integer - fee item code from HI
     *
     * @return String feeItemShortDesc - fee item short description.
     */
    public String retrieveFeeItemByCode(String feeItemCd) throws Exception {
        String feeItemShortDesc = null;
        // find fee item short desc by fee item code from application database
        CodesFeeItemExcl feeItemExcl = codesFeeItemExclFacade.findFeeItemByCode(feeItemCd);
        if (feeItemExcl != null && Util.notEmpty(feeItemExcl.getFitmCd())) {
            feeItemShortDesc = feeItemExcl.getFitmShortDscr();
        } else {
            feeItemShortDesc = "";
        }

        return feeItemShortDesc;
    }

    /**
     * Retrieve the fee item long description by fee item code.
     *
     * @param feeItemCd integer - fee item code from HI
     *
     * @return String feeItemShortDesc - fee item short description.
     */
    public String retrieveFeeItemLongDescByCode(String feeItemCd) throws Exception {
        String feeItemLongDesc = null;
        // find fee item short desc by fee item code from application database
        CodesFeeItemLongExcl feeItemLongExcl = codesFeeItemLongExclFacade.findFeeItemLongDescByCode(feeItemCd);
        if (feeItemLongExcl != null && Util.notEmpty(feeItemLongExcl.getFitmLongDscr())) {
            feeItemLongDesc = feeItemLongExcl.getFitmLongDscr();
        } else if (Util.notEmpty(feeItemLongExcl.getFitmLongDscr())) {
            feeItemLongExcl.setFitmDscrCd("00");
            feeItemLongDesc = feeItemLongExcl.getFitmLongDscr();
        }

        return feeItemLongDesc;
    }

    /**
     * Populates list of MSP letters with claim records from HI queries.
     *
     * @param result List - list with claims records from HI query
     * @param hIServiceMspLetters List<HIServiceMspLetter> - list with MSP
     * letters
     *
     */
    private List<HIServiceMspLetter> populateHIMspLetterClaims(List result,
            List<HIServiceMspLetter> hIServiceMspLetters) throws Exception {
        List<String> ErrorList = new ArrayList<>();
        Object[] record;
        HIServiceMspLetter hiServiceMsp;
        for (int i = 0; i < result.size(); i++) {
            record = (Object[]) result.get(i);
            
            
            //BCMOHAM-18966
            
            
            
            String Address1 = ((String)record[10]).toLowerCase().replaceAll("\\s+","");
            String AddressComparison = ((String)record[27]).toLowerCase().replaceAll("\\s+","");;
            logger.log(Level.INFO, "Checking street address for quality: {0}", Address1);
            
            int matchScore = FuzzyMatch.fuzzyMatch(Address1, AddressComparison);
            if (matchScore < 85 && result.size() > 1)
            {
                logger.log(Level.INFO, "MSP Letter Batch Error: Address rejected due to low confidence match: {0}", Address1);
                ErrorList.add(Address1 + "|" + AddressComparison );
            
            }
            else
            {
            

            hiServiceMsp = new HIServiceMspLetter();
            hiServiceMsp.setPractitionerCode((String) record[0]);
            hiServiceMsp.setPracSurname((String) record[1]);
            hiServiceMsp.setPracFirstGivenName((String) record[2]);
            hiServiceMsp.setPracSecondGivenName((String) record[3]);
            hiServiceMsp.setPracThirdGivenName((String) record[4]);
            hiServiceMsp.setPhn(Long.parseLong((String) record[5]));
            hiServiceMsp.setServiceMspDate((Date) record[6]);
            hiServiceMsp.setPatientBirthday((Date) record[7]);
            hiServiceMsp.setTypeDefCode((String) record[8]);
            hiServiceMsp.setPatientAddress((String) record[9]);
            hiServiceMsp.setPatientStreetAddress(AddressHelper.concatAddress((String) record[10], (String) record[11], (String) record[12], (String) record[13]));
            hiServiceMsp.setPatientPostalCode((String) record[14]);
            hiServiceMsp.setPatientCity(" ");
            hiServiceMsp.setPatientProvince(" ");
            hiServiceMsp.setFeeItemCode((String) record[15]);
            hiServiceMsp.setFeeItem((String) record[16]);

            // retrieve fee item code from HI and set fee item short/long descr.
            String feeItemCodeHI = hiServiceMsp.getFeeItemCode();
            // add condition if fee item cd HI doesn't exist in CODES_FEE_ITEM_EXCL table
            if (Util.notEmpty(retrieveFeeItemByCode(feeItemCodeHI))) {
                hiServiceMsp.setFeeItem(retrieveFeeItemByCode(feeItemCodeHI));
            }
            // add condition if fee item long desc doesn't exist in CODES_FEE_ITEM_LONG_EXCL table
            if (Util.notEmpty(retrieveFeeItemLongDescByCode(feeItemCodeHI))) {
                hiServiceMsp.setFeeItemDescr(retrieveFeeItemLongDescByCode(feeItemCodeHI));
            }
            hiServiceMsp.setServiceCode((String) record[18]);
            hiServiceMsp.setServiceCdDescr((String) record[19]);
            hiServiceMsp.setPayeeId((String) record[20]);
            hiServiceMsp.setPayeeOrgName((String) record[21]);
            hiServiceMsp.setPractitionerIdentif((String) record[22]);
            hiServiceMsp.setPracSptyCd((String) record[23]);
            hiServiceMsp.setPracSptyDesc((String) record[24]);
            hiServiceMsp.setPatientLastNm((String) record[25]);
            hiServiceMsp.setPatientFirstNm((String) record[26]);
            hIServiceMspLetters.add(hiServiceMsp);
            }

        }
        
        if(!ErrorList.isEmpty())
        {
            //try
            //{
            //    sendWarningEmail(ErrorList);
            //}
            //catch (EJBException e) {
            //             logger.log(Level.INFO, "The email for the list of rejected addresses for this letter run cannot be sent to the Admin Email, probably because the admin email address has not been set in the database {0}" , e);
            //}
        }
        
        return hIServiceMspLetters;
    }
    
        public void sendWarningEmail(List<String> ErrorList)
    {
        EmailService emailService = new EmailService(PaclConstants.SERVER_EMAIL_HOST, PaclConstants.PACL_SYSTEM_NAME);
        AdminOptionsMsp myAdminOptions = new AdminOptionsMsp();
        String serverAdminEmail = myAdminOptions.getServerAdminEmail();
        EmailMessage myEmailMessage = new EmailMessage();
        myEmailMessage.setEmailAddress(serverAdminEmail);
        String EmailSubject = "Inconsitient addresses were detected in the current letter run and were automatically excluded because of a confidence less than 85%";
        myEmailMessage.setSubject(EmailSubject);
        String ErrorListBody = "";
        
        for (int i = 0; i < ErrorList.size(); i++) {
            String element = ErrorList.get(i);
            ErrorListBody = ErrorListBody + element + "\r\n";
    }
    
        myEmailMessage.setBody(ErrorListBody);
        emailService.sendEmail(myEmailMessage);
    }
}
