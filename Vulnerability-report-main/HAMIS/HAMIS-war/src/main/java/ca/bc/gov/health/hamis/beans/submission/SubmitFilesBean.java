package ca.bc.gov.health.hamis.beans.submission;

import ca.bc.gov.health.hamis.beans.session.DroplistBean;
import ca.bc.gov.health.hamis.beans.session.UserBean;
import ca.bc.gov.health.hamis.dto.CustomAccountGroupingDto;
import ca.bc.gov.health.hamis.dto.HealthOrganizationDto;
import ca.bc.gov.health.hamis.dto.ProviderDefinitionDto;
import ca.bc.gov.health.hamis.dto.SEFFile;
import ca.bc.gov.health.hamis.dto.SefErrorMessageDto;
import ca.bc.gov.health.hamis.dto.StandardExtractFileDto;
import ca.bc.gov.health.hamis.dto.StandardExtractSourceDto;
import ca.bc.gov.health.hamis.dto.SubmissionDto;
import ca.bc.gov.health.hamis.reports.jasper.submission.IReconciliationReport;
import ca.bc.gov.health.hamis.reports.jasper.submission.IValidationReport;
import ca.bc.gov.health.hamis.service.ICustomAccountGroupingFacade;
import ca.bc.gov.health.hamis.service.IHealthOrganizationFacade;
import ca.bc.gov.health.hamis.service.IProviderDefinitionFacade;
import ca.bc.gov.health.hamis.service.IStandardExtractFileErrorMessageFacade;
import ca.bc.gov.health.hamis.service.IStandardExtractFileFacade;
import ca.bc.gov.health.hamis.service.IStandardExtractSourceFacade;
import ca.bc.gov.health.hamis.service.ISubmissionFacade;
import ca.bc.gov.health.hamis.service.ISubmissionMessageFacade;
import ca.bc.gov.health.jsf.SelectItemComparator;
import jakarta.ejb.EJB;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.context.FacesContext;
import jakarta.faces.model.SelectItem;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.primefaces.event.FileUploadEvent;
import org.primefaces.model.StreamedContent;

/**
 * JSF Backing bean to handle the file upload, validation, and submission processes
 *
 * @author greg.perkins
 */
@Named("SubmitFilesBean")
@ViewScoped
@Getter
@Setter
public class SubmitFilesBean implements Serializable {

  private static final long serialVersionUID = 8439439895023932621L;

  // Logger instance
  private static final Logger log = LogManager.getLogger(SubmitFilesBean.class);

  // Constants
  private static final String CONTENT_TYPE = "application/pdf";
  private static final String CONTENT_DISPOSITION = "Content-Disposition";

  // Inject the facade classes that we need
  @EJB private ICustomAccountGroupingFacade customAccountGroupingFacade;
  @EJB private IStandardExtractSourceFacade strandarExtractSourceFacade;
  @EJB private IStandardExtractFileFacade sefFacade;
  @EJB private IStandardExtractFileErrorMessageFacade sefErrorFacade;
  @EJB private IHealthOrganizationFacade hoFacade;
  @EJB private IProviderDefinitionFacade providerFacade;
  @EJB private ISubmissionFacade submissionFacade;
  @EJB private ISubmissionMessageFacade submissionMessageFacade;

  // Reference to the session beans we need
  @Inject private UserBean userBean;
  @Inject private transient DroplistBean droplistBean;

  // Inject Facade for the reports
  @Inject private transient IReconciliationReport reconciliationFacade;
  @Inject private transient IValidationReport validationReportFacade;

  /** ********* Variables for Upload Section ********** */
  // Local variables for page state
  private Map<String, Boolean> requiresPolling = new HashMap<>();

  private String period;
  private String year;
  private int sefSource;
  private int customMap;
  private int sefId;
  private List<String> errors;
  private List<SelectItem> periods;
  private List<SelectItem> custAccounts;
  private List<SelectItem> seSources;

  // SEF files uploaded
  private transient List<SEFFile> files;

  /** ********* Variables for Reconciliation Reports Section ********** */
  // Reports files generated by Jasper
  private transient StreamedContent balanceReport;

  private transient StreamedContent revenueExpReport;
  private transient StreamedContent revenueExpSummaryReport;

  // Report params
  private int revExpSummarySefSource; // remove
  private String revExpSummaryFinStat;
  private String revExpSummaryActualBudget;
  private String revExpDetailFinStat;
  private String revExpDetailActualBudget;

  private Set<String> revExpDetailLei;
  private Set<String> revExpDetailHsp;

  private List<SelectItem> leis;
  private List<SelectItem> hsps;

  /** ********* Variables for Validation Section ********** */
  private List<SubmissionDto> sefValidations;

  private List<SubmissionDto> sectorValidations;

  private int subId;
  private Integer actualsProgress;
  private Integer budgetsProgress;

  private List<String> validationReports =
      Arrays.asList("Sector Validation", "SEF Validation", "SEF File Status");

  /** ********* Variables for Submission Section ********** */
  /** List of exports */
  private List<SubmissionDto> exports;

  /** Value from budget/actual droplist */
  private String actualOrBudget;

  @Setter(AccessLevel.NONE)
  @Getter(AccessLevel.NONE)
  private int cachedHealthAuthority = -1;

  @Setter(AccessLevel.NONE)
  @Getter(AccessLevel.NONE)
  private String cachedLocalPeriod = null;

  @Setter(AccessLevel.NONE)
  @Getter(AccessLevel.NONE)
  private String cachedFiscalYear = null;

  private void invalidateCachedParameters() {
    cachedHealthAuthority = -1;
    cachedLocalPeriod = null;
    cachedFiscalYear = null;
  }

  /**
   * Get a list of SEFFiles based on the current HA, and the selected fiscal year and period. Will
   * have the status, and percent completed populated for display
   *
   * @param healthAuthority int - User's health authority
   * @param localPeriod String - Reporting Period from the UI
   * @param fiscalYear String - Fiscal Year from the UI
   * @return List<SEFFile>
   */
  public List<SEFFile> getFiles(int healthAuthority, String localPeriod, String fiscalYear) {
    // Check to see if the values are populated, if not return no results.
    if (StringUtils.isNotEmpty(localPeriod) && StringUtils.isNotEmpty(fiscalYear)) {
      if ((!fiscalYear.equals(cachedFiscalYear))
          || (!localPeriod.equals(cachedLocalPeriod))
          || (healthAuthority != cachedHealthAuthority)
          || (this.files == null)
          || requiresPolling.get(healthAuthority + "|" + localPeriod + "|" + fiscalYear)) {

        // BCMOHAD-2432: Stop doing the same query over and over again for the same set of
        // parameters.
        cachedFiscalYear = fiscalYear;
        cachedLocalPeriod = localPeriod;
        cachedHealthAuthority = healthAuthority;

        List<StandardExtractFileDto> localFiles =
            sefFacade.getSefSummaryForReportingPeriod(fiscalYear, localPeriod, healthAuthority);
        List<SEFFile> out = new ArrayList<>();
        boolean pollForUpdates = false;
        for (StandardExtractFileDto file : localFiles) {
          String cd = file.getSefStatusTypeCd();
          double pct = 100;
          boolean inProgress = true;
          if ("PRC01".equals(cd)) {
            pct = 100.0 / 6;
          } else if ("PRC02".equals(cd)) {
            pct = 200.0 / 6;
          } else if ("PRC03".equals(cd)) {
            pct = 300.0 / 6;
          } else if ("PRC04".equals(cd)) {
            pct = 400.0 / 6;
          } else if ("PRC05".equals(cd)) {
            pct = 500.0 / 6;
          } else {
            inProgress = false;
          }
          pollForUpdates |= inProgress;
          List<String> localErrors = new ArrayList<>();
          SEFFile sefFile =
              new SEFFile(
                  (int) file.getSefId(),
                  healthAuthority,
                  file.getFileName(),
                  0l,
                  file.getUploadedBy(),
                  file.getUploadDate(),
                  new byte[0],
                  file.getSefStatusTypeDesc(),
                  (int) pct,
                  localErrors);
          out.add(sefFile);
        }
        requiresPolling.put(healthAuthority + "|" + localPeriod + "|" + fiscalYear, pollForUpdates);
        this.files = out;
        return out;
      } else {
        return this.files;
      }
    } else {
      files = new ArrayList<>();
      return files;
    }
  }

  /**
   * Returns true if there are records still in progress, and the UI should poll for updates
   *
   * @param healthAuthority
   * @param period
   * @param fiscalYear
   * @return
   */
  public boolean shouldPollForStatusUpdates(int healthAuthority, String period, String fiscalYear) {
    Boolean poll = requiresPolling.get(healthAuthority + "|" + period + "|" + fiscalYear);
    return poll != null && poll;
  }

  /**
   * Returns the list of Error messages for a SEF file
   *
   * @param sefId int
   * @return List<String>
   */
  public void getErrorsForFile(int sefId) {
    List<SefErrorMessageDto> sefErrors = sefErrorFacade.getErrorsForFile(sefId);
    errors = new ArrayList<>();
    for (SefErrorMessageDto sefError : sefErrors) {
      errors.add("Line " + sefError.getLineNo() + ": " + sefError.getMessage());
    }
  }

  /** Clears error messages */
  public void clearErrors() {
    errors.clear();
  }

  /**
   * Get all FiscalYears.
   *
   * @return List<SelectItem>
   */
  public List<SelectItem> getAllFiscalYears() {
    return droplistBean.getFiscalYears();
  }

  /**
   * Get all Periods by Year
   *
   * @param year String
   * @return List<SelectItem>
   */
  public List<SelectItem> getAllPeriodsByFiscalYear(String year) {
    return droplistBean.getPeriodsByFiscalYear(year);
  }

  /**
   * Get All Custom Account Grouping by Year and hoID
   *
   * @param fiscalyear
   * @param hoID
   * @return
   */
  public List<SelectItem> getAllCustomAccountGrouping(String fiscalyear, long hoID) {
    return customAccountGroupingFacade.getAllCustomAccountGroupingsSummary(fiscalyear, hoID)
        .stream()
        .map(CustomAccountGroupingDto::toSelectItem)
        .collect(Collectors.toList());
  }

  /**
   * Get All Standard Extract Source by Year and hoID
   *
   * @param fiscalyear String
   * @param hoID long
   * @return List<SelectItem>
   */
  public List<SelectItem> getAllStandardExtractSource(String fiscalyear, long hoID) {
    List<SelectItem> items =
        strandarExtractSourceFacade.findStandardExtractSource(fiscalyear, hoID).stream()
            .map(StandardExtractSourceDto::toSelectItem)
            .collect(Collectors.toList());
    Collections.sort(items, new SelectItemComparator());
    return items;
  }

  /** Process to Update Period, Custom Account, SEFSource dropdown when the year change. */
  public void onYearChange() {
    log.debug("+++++ On Year Change started");
    if (year != null && !"".equals(year)) {
      periods = getAllPeriodsByFiscalYear(year);
      custAccounts = getAllCustomAccountGrouping(year, userBean.getHealthAuthority());
      seSources = getAllStandardExtractSource(year, userBean.getHealthAuthority());
      refreshValidationStatus();
      refreshSubmissionStatus();
    } else {
      periods = new ArrayList<>();
      refreshSubmissionStatus();
    }
    log.debug("+++++ On Year Change completed");
  }

  /** Event handler for the period droplist changing */
  public void onPeriodChange() {
    log.debug("===== On Period Change started");
    refreshValidationStatus();
    refreshSubmissionStatus();
    log.debug("===== On Period Change completed");
  }

  /**
   * File Upload.
   *
   * @param event
   */
  public void upload(FileUploadEvent event) {
    log.debug("Uploading file...");
    invalidateCachedParameters();
    SEFFile file = new SEFFile();
    file.setFileName(event.getFile().getFileName());
    file.setContents(event.getFile().getContent());
    long startTime = System.currentTimeMillis();

    // Parse the file and exit if any errors found
    List<String> localErrors = new ArrayList<>();
    List<String[]> rows = null;
    try {
      rows = sefFacade.parseFile(file.getContents(), localErrors);
    } catch (IOException e) {
      localErrors.add(e.getMessage());
    }

    if (!localErrors.isEmpty()) {
      FacesContext.getCurrentInstance()
          .addMessage(
              "uploadForm:uploadControl",
              new FacesMessage(
                  FacesMessage.SEVERITY_ERROR,
                  "Some lines in the file do not have the required length",
                  "Some lines in the file do not have the required length"));
      return;
    }
    sefFacade.asyncProcessImportFile(
        file, rows, sefSource, customMap, period, year, userBean.getUserName(), startTime);
    sefFacade.deleteValidation(userBean.getHealthAuthority(), year, period);
    try {
      Thread.sleep(4000);
    } catch (InterruptedException e) {
      // ignore
    }
    // Force refresh of files
    requiresPolling.put(userBean.getHealthAuthority() + "|" + period + "|" + year, true);
    files = null;
    refreshValidationStatus();
  }

  /** Deletes a standard extract file */
  public void deleteFile() {
    log.info("delete SEF file");
    invalidateCachedParameters();
    sefFacade.deleteStandardExtractFile(sefId);
    sefFacade.deleteValidation(userBean.getHealthAuthority(), year, period);
    refreshValidationStatus();
  }

  /**
   * Determines if the required parameters are set to allow uploads
   *
   * @return boolean
   */
  public boolean uploadEnabled() {
    return (period != null && !"".equals(period))
        && (year != null && !"".equals(year))
        && sefSource > 0;
  }

  /** Populate LEI and HSP droplistBean when the dialog is opened */
  public void openRevenueReportDialog() {
    leis = new ArrayList<>();
    hsps = new ArrayList<>();
    for (HealthOrganizationDto dto : hoFacade.getHspList(userBean.getHealthAuthority(), year)) {
      hsps.add(new SelectItem(dto.getHoId(), dto.getCurrentName()));
    }
    for (ProviderDefinitionDto dto :
        providerFacade.getLeiList(userBean.getHealthAuthority(), year)) {
      leis.add(new SelectItem(dto.getLei(), dto.getName()));
    }
  }

  /** Clear the selected LEIs when an HSP is selected */
  public void clearLei() {
    this.revExpDetailLei = new HashSet<>();
  }

  /** Clear the selected HSPs when an LEI is selected */
  public void clearHsp() {
    this.revExpDetailHsp = new HashSet<>();
  }

  /** Clear all selections - called when dialogue is closed */
  public void clearAll() {
    clearHsp();
    clearLei();
  }

  public boolean getReportButtonDisabled() {
    if ((revExpDetailHsp != null) && (revExpDetailLei != null))
      return (revExpDetailHsp.isEmpty()) && (revExpDetailLei.isEmpty());
    else {
      if (revExpDetailHsp != null) return revExpDetailHsp.isEmpty();
      else if (revExpDetailLei != null) return revExpDetailLei.isEmpty();
      else return true;
    }
  }

  /**
   * Determines if prerequisites for validation are met
   *
   * @return boolean
   */
  public boolean isValidationEnabled() {
    boolean isOk = true;
    if (files == null || files.isEmpty()) {
      return false;
    }
    for (SEFFile file : files) {
      if (!file.isAccepted()) {
        isOk = false;
      }
    }
    return isOk;
  }

  /** Returns true if the sector validation reports should be enabled */
  public boolean isSectorValidationReportEnabled() {
    return isValidationEnabled() && sectorValidations != null && !sectorValidations.isEmpty();
  }

  /** Returns true if the SEF validation reports should be enabled */
  public boolean isSefValidationReportEnabled() {
    boolean validationDone = false;
    if (isValidationEnabled() && sefValidations != null) {
      for (SubmissionDto validation : sefValidations) {
        if (!validation.isInProgress()) {
          validationDone = true;
        }
      }
    }
    return validationDone;
  }

  /** ********* Reconciliation Reports Section ********** */
  /** Call the balance sheet report */
  public void getBalanceSheetReport() {

    log.debug("Viewing Balance Sheet Report ");

    HttpServletResponse response =
        (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();
    response.setContentType(CONTENT_TYPE);
    response.setHeader(CONTENT_DISPOSITION, "attachment; filename=BalanceSheet-report.pdf");
    try {
      reconciliationFacade.getBalanceSheetReport(
          userBean.getHealthAuthority(),
          userBean.getHealthAuthorityName(),
          year,
          period,
          response.getOutputStream());
      FacesContext.getCurrentInstance().responseComplete();
    } catch (Exception e) {
      log.error(e);
    }
  }

  /** Call the Revenue/Expense Summary report */
  public void getRevenueExpenseReport() {

    log.debug("Viewing Revenue Expense Report ");

    HttpServletResponse response =
        (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();
    response.setContentType(CONTENT_TYPE);
    response.setHeader(
        CONTENT_DISPOSITION, "attachment; filename=RevenueExpenseSummary-report.pdf");
    try {
      reconciliationFacade.getRevenueExpenseSummaryReport(
          userBean.getHealthAuthority(),
          userBean.getHealthAuthorityName(),
          year,
          period,
          revExpSummaryActualBudget,
          revExpSummaryFinStat,
          response.getOutputStream());
      FacesContext.getCurrentInstance().responseComplete();
    } catch (Exception e) {
      log.error("Exception caught in Revenue Expense Summary report", e.fillInStackTrace());
    }
  }

  /** Call the Revenue/Expense Details report */
  public void getRevenueExpenseDetailReport() {
    log.debug("Viewing Revenue Expense Detail Report ");

    HttpServletResponse response =
        (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();
    response.setContentType(CONTENT_TYPE);
    response.setHeader(
        CONTENT_DISPOSITION, "attachment; filename=RevenueExpenseDetails-report.pdf");

    try {
      reconciliationFacade.getRevenueExpenseDetailsReport(
          year,
          period,
          userBean.getHealthAuthority(),
          userBean.getHealthAuthorityName(),
          revExpDetailActualBudget,
          revExpDetailFinStat,
          revExpDetailLei,
          revExpDetailHsp,
          response.getOutputStream());
      FacesContext.getCurrentInstance().responseComplete();
    } catch (Exception e) {
      log.error(e);
    }
  }

  /** ********* Validation Section ********** */

  /** Combine SEF & Sector validations into a single list for display in a table */
  public List<SubmissionDto> getAllValidations() {
    List<SubmissionDto> allRecords = new ArrayList<>();
    allRecords.addAll(sectorValidations);
    allRecords.addAll(sefValidations);
    return allRecords;
  }

  /**
   * Returns true if there are records still in progress, and the UI should poll for updates
   *
   * @return
   */
  public boolean shouldPollForValidationUpdates() {
    boolean poll = false;
    if (!sefValidations.isEmpty()) {
      for (SubmissionDto sub : sefValidations) {
        if (!sub.isAccepted() && !sub.isError()) {
          poll = true;
        }
      }
    }
    return poll;
  }

  /** Starts the validation process */
  public void validate() {
    sefFacade.validateStandardExtractFiles(userBean.getHealthAuthority(), year, period);
    refreshValidationStatus();
    while (sefValidations.size() == 0) {
      try {
        // Wait for a second to allow the async DB process to commit so the poll on the front-end
        // will
        // refresh
        Thread.sleep(500);
        refreshValidationStatus();
      } catch (Exception e) {
        // ignore
      }
    }
  }

  /** Refresh the validation progress bars */
  public void refreshValidationStatus() {
    int hoId = userBean.getHealthAuthority();
    if (hoId > 0 && year != null && !"".equals(year) && period != null && !"".equals(period)) {
      log.debug(
          "Refreshing validation status for org ID {}, year {} and period {}", hoId, year, period);
      sefValidations = submissionFacade.getSefValidations(hoId, year, period);
      sectorValidations = submissionFacade.getSectorValidations(hoId, year, period);
    } else {
      sefValidations = new ArrayList<>();
      sectorValidations = new ArrayList<>();
    }
  }

  /** Call the Sector Validation report */
  public void getSectorValidationReport() {
    log.debug("Viewing SEF file Sector Validation Report");

    HttpServletResponse response =
        (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();
    response.setContentType(CONTENT_TYPE);
    response.setHeader(CONTENT_DISPOSITION, "attachment; filename=SectorValidation-report.pdf");
    try {
      validationReportFacade.getSectorValidationReport(
          userBean.getHealthAuthority(), year, period, response.getOutputStream());
      FacesContext.getCurrentInstance().responseComplete();
    } catch (Exception e) {
      log.error(e);
    }
  }

  /** Call the SEF Validation report */
  public void getSEFValidationReport() {
    log.debug("Viewing SEF file Validation Report");

    HttpServletResponse response =
        (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();
    response.setContentType(CONTENT_TYPE);
    response.setHeader(CONTENT_DISPOSITION, "attachment; filename=SefValidation-report.pdf");
    try {
      validationReportFacade.getSEFValidationReport(
          userBean.getHealthAuthority(), year, period, response.getOutputStream());
      FacesContext.getCurrentInstance().responseComplete();
    } catch (Exception e) {
      log.error(e);
    }
  }

  /** Call the SEF file Status report */
  public void getSEFFileStatusReport() {
    log.debug("Viewing SEF file Status Report");

    HttpServletResponse response =
        (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();
    response.setContentType(CONTENT_TYPE);
    response.setHeader(CONTENT_DISPOSITION, "attachment; filename=SefFileStatus-report.pdf");
    try {
      validationReportFacade.getSEFFileStatusReport(
          userBean.getHealthAuthority(), year, period, response.getOutputStream());
      FacesContext.getCurrentInstance().responseComplete();
    } catch (Exception e) {
      log.error(e);
    }
  }

  /** ********* Submission Section ********** */
  /** Submits the data in the database */
  public void sendData() {
    log.debug("Sending data to MoH...");
    sefFacade.exportStandardExtractFiles(
        userBean.getHealthAuthority(), year, period, actualOrBudget);
    refreshSubmissionStatus();
  }

  /** Re-query the data from the database */
  public void refreshSubmissionStatus() {
    int hoId = userBean.getHealthAuthority();
    exports = submissionFacade.getExports(hoId, year, period);
  }

  /**
   * Returns true if we have rows still in progress
   *
   * @return boolean
   */
  public boolean shouldPollForSubmissionUpdates() {
    boolean poll = false;
    if (exports != null && !exports.isEmpty()) {
      for (SubmissionDto sub : exports) {
        if (sub.isInProgress()) {
          poll = true;
        }
      }
    }
    return poll;
  }

  /**
   * Determines if the submission section is enabled
   *
   * @return boolean
   */
  public boolean isSubmissionEnabled() {
    if (sefValidations == null || sefValidations.isEmpty()) {
      return false;
    }
    boolean ok = true;
    for (SubmissionDto dto : sefValidations) {
      if (dto.isError()) {
        ok = false;
      }
    }
    return isValidationEnabled() && ok;
  }

  public void findErrorsForSubmission(Long subId) {
    errors = submissionMessageFacade.getErrorsForSubmission(subId);
  }
}
