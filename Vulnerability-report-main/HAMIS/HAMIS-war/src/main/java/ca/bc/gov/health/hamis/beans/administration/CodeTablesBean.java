package ca.bc.gov.health.hamis.beans.administration;

import ca.bc.gov.health.hamis.beans.common.Messages;
import ca.bc.gov.health.hamis.beans.session.DroplistBean;
import ca.bc.gov.health.hamis.beans.session.UserBean;
import ca.bc.gov.health.hamis.dto.AccountTypeDto;
import ca.bc.gov.health.hamis.dto.FiscalYearDto;
import ca.bc.gov.health.hamis.dto.FundTypeDto;
import ca.bc.gov.health.hamis.dto.HealthAuthorityTypeDto;
import ca.bc.gov.health.hamis.dto.PeerGroupDto;
import ca.bc.gov.health.hamis.dto.ProviderTypeDto;
import ca.bc.gov.health.hamis.dto.RegionalTeamDto;
import ca.bc.gov.health.hamis.dto.RelationshipTypeDto;
import ca.bc.gov.health.hamis.dto.SectorTypeDto;
import ca.bc.gov.health.hamis.dto.ServiceTypeDto;
import ca.bc.gov.health.hamis.service.IAccountTypeFacade;
import ca.bc.gov.health.hamis.service.IFiscalYearFacade;
import ca.bc.gov.health.hamis.service.IFundTypeFacade;
import ca.bc.gov.health.hamis.service.IHealthAuthorityTypeFacade;
import ca.bc.gov.health.hamis.service.IPeerGroupFacade;
import ca.bc.gov.health.hamis.service.IProviderTypeFacade;
import ca.bc.gov.health.hamis.service.IRegionalTeamFacade;
import ca.bc.gov.health.hamis.service.IRelationshipTypeFacade;
import ca.bc.gov.health.hamis.service.ISectorTypeFacade;
import ca.bc.gov.health.hamis.service.IServiceTypeFacade;
import ca.bc.gov.health.hamis.util.HamisConstants;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.context.FacesContext;
import jakarta.faces.model.SelectItem;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.io.Serializable;
import java.text.MessageFormat;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.primefaces.event.SelectEvent;

/**
 * Backing bean for the Edit Code Tables page
 *
 * @author vladimir.dovgalyuk
 */
@Named("CodeTablesBean")
@ViewScoped
@Getter
@Setter
public class CodeTablesBean implements Serializable {

  private static final long serialVersionUID = -9185026081920904897L;

  private static final Logger LOG = LogManager.getLogger(CodeTablesBean.class);

  private static final String UPDATE_DIALOG_TITLE = "codeTables.updateDialogTitle";
  private static final String CREATE_DIALOG_TITLE = "codeTables.createDialogTitle";
  private static final String TASK = "task";
  private static final String EDIT_FORM = "codeEditForm";

  @EJB private IAccountTypeFacade accountTypeFacade;
  @EJB private IFundTypeFacade fundTypeFacade;
  @EJB private IRelationshipTypeFacade relationshipTypeFacade;
  @EJB private IRegionalTeamFacade healthServiceDeliveryAreaFacade;
  @EJB private IPeerGroupFacade localHealthAreaFacade;
  @EJB private IHealthAuthorityTypeFacade healthAuthorityTypeFacade;
  @EJB private IFiscalYearFacade fiscalYearFacade;
  @EJB private ISectorTypeFacade sectorTypeFacade;
  @EJB private IServiceTypeFacade serviceTypeFacade;
  @EJB private IProviderTypeFacade providerTypeFacade;

  private List<SelectItem> sectorTypesList;
  private List<SelectItem> serviceTypesList;

  /**
   * Controls rendering of Sector Type drop-down control
   *
   * @return true if Sector Type drop-down control is visible
   */
  public boolean isDisplaySectorTypesList() {
    return (currentTask == Tasks.CREATE_PROVIDER_TYPE)
        || (currentTask == Tasks.UPDATE_PROVIDER_TYPE);
  }

  /**
   * Controls rendering of Sub-Sector Type drop-down control
   *
   * @return true if Sub-Sector Type drop-down control is visible
   */
  public boolean isDisplayServiceTypesList() {
    return (currentTask == Tasks.CREATE_PROVIDER_TYPE)
        || (currentTask == Tasks.UPDATE_PROVIDER_TYPE);
  }

  private List<AccountTypeDto> accountTypes;
  private List<FundTypeDto> fundTypes;
  private List<RelationshipTypeDto> relationshipTypes;
  private List<RegionalTeamDto> healthServiceDeliveryAreas;
  private List<PeerGroupDto> localHealthAreas;
  private List<HealthAuthorityTypeDto> healthAuthorityTypes;
  private List<SectorTypeDto> sectorTypes;
  private List<ServiceTypeDto> serviceTypes;
  private List<ProviderTypeDto> providerTypes;

  private AccountTypeDto accountType;
  private FundTypeDto fundType;
  private RelationshipTypeDto relationshipType;
  private RegionalTeamDto healthServiceDeliveryArea;
  private PeerGroupDto localHealthArea;
  private HealthAuthorityTypeDto healthAuthorityType;
  private SectorTypeDto sectorType;
  private ServiceTypeDto serviceType;
  private ProviderTypeDto providerType;

  private String fiscalYear;
  private String fiscalYearType;

  @Setter(AccessLevel.NONE)
  @Getter(AccessLevel.NONE)
  @Inject
  private transient DroplistBean droplists;

  @Setter(AccessLevel.NONE)
  @Getter(AccessLevel.NONE)
  @Inject
  private UserBean userBean;

  @Setter(AccessLevel.NONE)
  @Getter(AccessLevel.NONE)
  private Tasks currentTask;

  public enum Tasks {
    UPDATE_LHA_TYPE("Local Health Area"),
    CREATE_LHA_TYPE("Local Health Area"),
    UPDATE_HSDA_TYPE("Health Service Delivery Area"),
    CREATE_HSDA_TYPE("Health Service Delivery Area"),
    UPDATE_RELATIONSHIP_TYPE("Relationship Type"),
    CREATE_RELATIONSHIP_TYPE("Relationship Type"),
    UPDATE_SECTOR_TYPE("Sector Type"),
    CREATE_SECTOR_TYPE("Sector Type"),
    UPDATE_SUBSECTOR_TYPE("Sub-Sector Type"),
    CREATE_SUBSECTOR_TYPE("Sub-Sector Type"),
    UPDATE_PROVIDER_TYPE("Provider Type"),
    CREATE_PROVIDER_TYPE("Provider Type"),
    UPDATE_ACCOUNT_TYPE("Account Type"),
    CREATE_ACCOUNT_TYPE("Account Type"),
    UPDATE_FUND_TYPE("Fund Type"),
    CREATE_FUND_TYPE("Fund Type"),
    UPDATE_HA_TYPE("Health Authority Type"),
    CREATE_HA_TYPE("Health Authority Type");

    private String type;

    Tasks(String type) {
      this.type = type;
    }

    public String getType() {
      return type;
    }
  }

  @Setter(AccessLevel.NONE)
  private String dialogueHeader = "";

  private String description;
  /**
   * Controls Description input in the dialog
   *
   * @return true if Description input is rendered
   */
  public boolean isDisplayDescriptionInput() {
    return (currentTask == Tasks.UPDATE_LHA_TYPE)
        || (currentTask == Tasks.CREATE_LHA_TYPE)
        || (currentTask == Tasks.UPDATE_HSDA_TYPE)
        || (currentTask == Tasks.CREATE_HSDA_TYPE)
        || (currentTask == Tasks.UPDATE_RELATIONSHIP_TYPE)
        || (currentTask == Tasks.CREATE_RELATIONSHIP_TYPE)
        || (currentTask == Tasks.UPDATE_SUBSECTOR_TYPE)
        || (currentTask == Tasks.CREATE_SUBSECTOR_TYPE)
        || (currentTask == Tasks.UPDATE_SECTOR_TYPE)
        || (currentTask == Tasks.CREATE_SECTOR_TYPE)
        || (currentTask == Tasks.UPDATE_HA_TYPE)
        || (currentTask == Tasks.CREATE_HA_TYPE)
        || (currentTask == Tasks.UPDATE_ACCOUNT_TYPE)
        || (currentTask == Tasks.CREATE_ACCOUNT_TYPE)
        || (currentTask == Tasks.UPDATE_FUND_TYPE)
        || (currentTask == Tasks.CREATE_FUND_TYPE);
  }

  /*
   * Local variable for all codes except for provider one
   */
  private String code;
  /**
   * Controls Code input in the dialog
   *
   * @return true if Code input is rendered
   */
  public boolean isDisplayCodeInput() {
    return (currentTask == Tasks.UPDATE_LHA_TYPE)
        || (currentTask == Tasks.CREATE_LHA_TYPE)
        || (currentTask == Tasks.UPDATE_HSDA_TYPE)
        || (currentTask == Tasks.CREATE_HSDA_TYPE)
        || (currentTask == Tasks.UPDATE_RELATIONSHIP_TYPE)
        || (currentTask == Tasks.CREATE_RELATIONSHIP_TYPE)
        || (currentTask == Tasks.UPDATE_SUBSECTOR_TYPE)
        || (currentTask == Tasks.CREATE_SUBSECTOR_TYPE)
        || (currentTask == Tasks.UPDATE_SECTOR_TYPE)
        || (currentTask == Tasks.CREATE_SECTOR_TYPE)
        || (currentTask == Tasks.UPDATE_HA_TYPE)
        || (currentTask == Tasks.CREATE_HA_TYPE)
        || (currentTask == Tasks.UPDATE_ACCOUNT_TYPE)
        || (currentTask == Tasks.CREATE_ACCOUNT_TYPE)
        || (currentTask == Tasks.UPDATE_FUND_TYPE)
        || (currentTask == Tasks.CREATE_FUND_TYPE);
  }

  /*
   * Local variable for provider code
   */
  private String providerCode;
  /**
   * Controls rendering of Provider Code input
   *
   * @return true if Provider Code is rendered
   */
  public boolean isDisplayProviderCodeInput() {
    return (currentTask == Tasks.UPDATE_PROVIDER_TYPE)
        || (currentTask == Tasks.CREATE_PROVIDER_TYPE);
  }

  /*
   * Local variable for Provider's National Code
   */
  private String harpProviderCode;

  /*
   * Local variable for Relationship Types possible double count
   */
  private boolean possibleDoubleCount;

  /*
   * Local variables for Provider's sector and sub-sector types
   */
  private String sectorTypeCode;
  private String serviceTypeCode;

  /*
   * Local variable to control visibility of Create Dialogue for Provider Type.
   * Dialogue is not displayed if the maximal value of HARP Provider Code has been
   * reached for the given fiscal year.
   */
  private boolean showProviderCreateDialogue = true;

  public boolean isShowProviderCreateDialogue() {
    return showProviderCreateDialogue;
  }

  /*
   * Variable for storing maximal value of Harp Provider Code
   */
  private Long maxHarpCode = -1L;

  /*
   * Retrieves maximal value of Harp Provider Code from the database
   */
  private void updateMaxHarpCode() {
    maxHarpCode = providerTypeFacade.getMaxHarpCodeForFiscalYear(fiscalYear);
    if (maxHarpCode >= 99)
      // Maximal value has been reached
      showProviderCreateDialogue = false;
    else showProviderCreateDialogue = true;
  }

  public boolean isDisplayPossibleDoubleCount() {
    return (currentTask == Tasks.CREATE_RELATIONSHIP_TYPE)
        || (currentTask == Tasks.UPDATE_RELATIONSHIP_TYPE);
  }

  /**
   * Controls visibility of Create button in the dialog
   *
   * @return true if visible
   */
  public boolean isCreateCodeType() {
    return (currentTask == Tasks.CREATE_SUBSECTOR_TYPE)
        || (currentTask == Tasks.CREATE_SECTOR_TYPE)
        || (currentTask == Tasks.CREATE_PROVIDER_TYPE)
        || (currentTask == Tasks.CREATE_LHA_TYPE)
        || (currentTask == Tasks.CREATE_HSDA_TYPE)
        || (currentTask == Tasks.CREATE_RELATIONSHIP_TYPE)
        || (currentTask == Tasks.CREATE_HA_TYPE)
        || (currentTask == Tasks.CREATE_ACCOUNT_TYPE)
        || (currentTask == Tasks.CREATE_FUND_TYPE);
  }

  /**
   * Controls visibility of Update button in the dialog
   *
   * @return true if visible
   */
  public boolean isUpdateCodeType() {
    return (currentTask == Tasks.UPDATE_RELATIONSHIP_TYPE)
        || (currentTask == Tasks.UPDATE_SUBSECTOR_TYPE)
        || (currentTask == Tasks.UPDATE_PROVIDER_TYPE)
        || (currentTask == Tasks.UPDATE_LHA_TYPE)
        || (currentTask == Tasks.UPDATE_HSDA_TYPE)
        || (currentTask == Tasks.UPDATE_SECTOR_TYPE)
        || (currentTask == Tasks.UPDATE_HA_TYPE)
        || (currentTask == Tasks.UPDATE_ACCOUNT_TYPE)
        || (currentTask == Tasks.UPDATE_FUND_TYPE);
  }

  /**
   * Controls size and maximal length of code input
   *
   * @return length of Code input
   */
  public String getCodeLength() {
    String length;
    switch (currentTask) {
      case CREATE_RELATIONSHIP_TYPE:
      case UPDATE_RELATIONSHIP_TYPE:
      case UPDATE_SUBSECTOR_TYPE:
      case CREATE_SUBSECTOR_TYPE:
      case CREATE_SECTOR_TYPE:
      case UPDATE_SECTOR_TYPE:
      case CREATE_PROVIDER_TYPE:
      case UPDATE_PROVIDER_TYPE:
        length = "2";
        break;
      case CREATE_HA_TYPE:
      case UPDATE_HA_TYPE:
        length = "5";
        break;
      case CREATE_LHA_TYPE:
      case UPDATE_LHA_TYPE:
      case CREATE_HSDA_TYPE:
      case UPDATE_HSDA_TYPE:
        length = "6";
        break;
      default:
        length = "1";
    }
    return length;
  }

  @PostConstruct
  public void init() {
    accountTypes = accountTypeFacade.getAccountTypes();
    fundTypes = fundTypeFacade.getFundTypes();
    relationshipTypes = relationshipTypeFacade.getAll();
    healthServiceDeliveryAreas = healthServiceDeliveryAreaFacade.getAll();
    localHealthAreas = localHealthAreaFacade.getAll();
    healthAuthorityTypes = healthAuthorityTypeFacade.getAll();

    fiscalYear =
        droplists.getFiscalYears().stream()
            .filter(fy -> "C".equalsIgnoreCase(fy.getDescription()))
            .findFirst()
            .orElse(droplists.getFiscalYears().get(0))
            .getLabel();

    onYearChange();
    enablePageMessaging();
    updateMaxHarpCode();
  }

  public boolean isEditableFiscalYear() {
    return HamisConstants.YearType.CURRENT.getShortName().equals(fiscalYearType);
  }

  /** Event handler for fiscal year change */
  public void onYearChange() {
    fiscalYearType = fiscalYearFacade.getYearTypeForFiscal(fiscalYear);
    providerTypes = providerTypeFacade.getProviderTypesByFiscalYear(fiscalYear);
    refreshServiceTypes();
    refreshSectorTypes();
  }

  private void refreshServiceTypes() {
    LOG.debug("Refreshing list of sub-sector types for fiscal year {}", fiscalYear);
    serviceTypes = serviceTypeFacade.getByFiscalYear(fiscalYear);
    serviceTypesList =
        serviceTypes.stream().map(ServiceTypeDto::toSelectItem).collect(Collectors.toList());
  }

  private void refreshSectorTypes() {
    LOG.debug("Refreshing list of sector types for fiscal year {}", fiscalYear);
    sectorTypes = sectorTypeFacade.getSectorTypesByFiscalYear(fiscalYear);
    sectorTypesList =
        sectorTypes.stream().map(SectorTypeDto::toSelectItem).collect(Collectors.toList());
  }

  /** Resets local variables */
  public void clearAll() {
    dialogueHeader = "";
    code = "";
    description = "";
    harpProviderCode = "";
    providerCode = "";
    sectorTypeCode = "";
    serviceTypeCode = "";
    enablePageMessaging();
  }

  /** Creates new Account type */
  private void createAccountType() {
    LOG.debug("Creating new account type with code {}", code);
    // Checking if the code already exists
    boolean duplicateDetected = false;
    for (AccountTypeDto account : accountTypes) {
      if (code.trim().equalsIgnoreCase(account.getAcctypCode())) {
        reportDuplicateCode(code);
        duplicateDetected = true;
      }
    }
    if (!duplicateDetected) {
      // Create new account
      accountType = new AccountTypeDto();
      accountType.setAcctypCode(code);
      accountType.setDescription(description);
      accountType.setUserCreated(userBean.getUserName());
      accountType.setUserModified(userBean.getUserName());
      Date d = new Date();
      accountType.setDateCreated(d);
      accountType.setDateModified(d);
      try {
        accountTypeFacade.createAccountType(accountType);
        reportCreateSuccess();
        accountTypes = accountTypeFacade.getAccountTypes();
      } catch (Exception e) {
        reportCreateException(e);
      }
    }
  }

  /** Create new Fund Type */
  private void createFundType() {
    LOG.debug("Creating new fund type with code {}", code);
    // Checking if the code already exists
    boolean duplicateDetected = false;
    for (FundTypeDto val : fundTypes) {
      if (code.trim().equalsIgnoreCase(val.getFndtypCode())) {
        reportDuplicateCode(code);
        duplicateDetected = true;
      }
    }
    if (!duplicateDetected) {
      fundType = new FundTypeDto();
      fundType.setFndtypCode(code);
      fundType.setDescription(description);
      fundType.setUserCreated(userBean.getUserName());
      fundType.setUserModified(userBean.getUserName());
      Date d = new Date();
      fundType.setDateCreated(d);
      fundType.setDateModified(d);
      try {
        fundTypeFacade.createFundType(fundType);
        reportCreateSuccess();
        fundTypes = fundTypeFacade.getFundTypes();
      } catch (Exception e) {
        reportCreateException(e);
      }
    }
  }

  /** Create new Relationship Type */
  private void createRelationshipType() {
    LOG.debug("Creating new organization relationship type with code {}", code);
    // Checking if the code already exists
    boolean duplicateDetected = false;
    for (RelationshipTypeDto val : relationshipTypes) {
      if (code.trim().equalsIgnoreCase(val.getReltypCode())) {
        reportDuplicateCode(code);
        duplicateDetected = true;
      }
    }
    if (!duplicateDetected) {
      // Create new account
      relationshipType = new RelationshipTypeDto();
      relationshipType.setReltypCode(code);
      relationshipType.setDescription(description);
      relationshipType.setDefaultPossibleDblCnt(possibleDoubleCount ? "Y" : "N");
      relationshipType.setUserCreated(userBean.getUserName());
      relationshipType.setUserModified(userBean.getUserName());
      Date d = new Date();
      relationshipType.setDateCreated(d);
      relationshipType.setDateModified(d);
      try {
        relationshipTypeFacade.createRelationshipType(relationshipType);
        reportCreateSuccess();
        relationshipTypes = relationshipTypeFacade.getAll();
        DroplistBean.clearRelationships();
      } catch (Exception e) {
        reportCreateException(e);
      }
    }
  }

  /** Create Health Service Delivery area */
  private void createHealthServiceDeliveryArea() {
    LOG.debug("Creating new Health Service Delivery area with code {}", code);
    // Checking if the code already exists
    boolean duplicateDetected = false;
    for (RegionalTeamDto val : healthServiceDeliveryAreas) {
      if (code.trim().equalsIgnoreCase(val.getRtCode())) {
        reportDuplicateCode(code);
        duplicateDetected = true;
      }
    }
    if (!duplicateDetected) {
      healthServiceDeliveryArea = new RegionalTeamDto();
      healthServiceDeliveryArea.setRtCode(code);
      healthServiceDeliveryArea.setDescription(description);
      healthServiceDeliveryArea.setUserCreated(userBean.getUserName());
      healthServiceDeliveryArea.setUserModified(userBean.getUserName());
      Date d = new Date();
      healthServiceDeliveryArea.setDateCreated(d);
      healthServiceDeliveryArea.setDateModified(d);
      try {
        healthServiceDeliveryAreaFacade.createRegionalTeam(healthServiceDeliveryArea);
        reportCreateSuccess();
        DroplistBean.clearHealthServiceDeliveryAreas();
        healthServiceDeliveryAreas = healthServiceDeliveryAreaFacade.getAll();
      } catch (Exception e) {
        reportCreateException(e);
      }
    }
  }

  /** Create Local Health area */
  private void createLocalHealthArea() {
    LOG.debug("Creating new Local Health area with code {}", code);
    // Checking if the code already exists
    boolean duplicateDetected = false;
    for (PeerGroupDto val : localHealthAreas) {
      if (code.trim().equalsIgnoreCase(val.getPgCode())) {
        reportDuplicateCode(code);
        duplicateDetected = true;
      }
    }
    if (!duplicateDetected) {
      localHealthArea = new PeerGroupDto();
      localHealthArea.setPgCode(code);
      localHealthArea.setDescription(description);
      localHealthArea.setUserCreated(userBean.getUserName());
      localHealthArea.setUserModified(userBean.getUserName());
      Date d = new Date();
      localHealthArea.setDateCreated(d);
      localHealthArea.setDateModified(d);
      try {
        localHealthAreaFacade.createPeerGroup(localHealthArea);
        reportCreateSuccess();
        localHealthAreas = localHealthAreaFacade.getAll();
        DroplistBean.clearLocalHealthAreas();
      } catch (Exception e) {
        reportCreateException(e);
      }
    }
  }

  /** Create Health Authority type */
  private void createHealthAuthorityType() {
    LOG.debug("Creating new Health Authority type with code {}", code);
    // Checking if the code already exists
    boolean duplicateDetected = false;
    for (HealthAuthorityTypeDto val : healthAuthorityTypes) {
      if (code.trim().equalsIgnoreCase(val.getHatypCode())) {
        reportDuplicateCode(code);
        duplicateDetected = true;
      }
    }
    if (!duplicateDetected) {
      // Create new HA
      healthAuthorityType = new HealthAuthorityTypeDto();
      healthAuthorityType.setHatypCode(code);
      healthAuthorityType.setDescription(description);
      healthAuthorityType.setUserCreated(userBean.getUserName());
      healthAuthorityType.setUserModified(userBean.getUserName());
      Date d = new Date();
      healthAuthorityType.setDateCreated(d);
      healthAuthorityType.setDateModified(d);
      try {
        healthAuthorityTypeFacade.createHealthAuthorityType(healthAuthorityType);
        reportCreateSuccess();
        healthAuthorityTypes = healthAuthorityTypeFacade.getAll();
      } catch (Exception e) {
        reportCreateException(e);
      }
    }
  }

  /** Create Sector Type */
  private void createSectorType() {
    LOG.debug("Creating new Sector type with code {} for fiscal year {}", code, fiscalYear);
    boolean duplicateDetected = false;
    for (SectorTypeDto val : sectorTypes) {
      if (code.trim().equalsIgnoreCase(val.getSctrtypCode())) {
        reportDuplicateCodeFY(code);
        duplicateDetected = true;
      }
    }
    if (!duplicateDetected) {
      sectorType = new SectorTypeDto();
      sectorType.setSctrtypCode(code);
      sectorType.setDescription(description);
      FiscalYearDto fiscalYearDto = fiscalYearFacade.getFiscalYear(fiscalYear);
      sectorType.setFiscalYear(fiscalYearDto);
      sectorType.setUserCreated(userBean.getUserName());
      sectorType.setUserModified(userBean.getUserName());
      Date d = new Date();
      sectorType.setDateCreated(d);
      sectorType.setDateModified(d);
      try {
        sectorTypeFacade.createSectorType(sectorType);
        reportCreateSuccess();

        refreshSectorTypes();
      } catch (Exception e) {
        reportCreateException(e);
      }
    }
  }

  /** Create Service Type */
  private void createServiceType() {
    LOG.debug(
        "Creating new Sub-Sector (Service) type with code {} for fiscal year {}", code, fiscalYear);
    boolean duplicateDetected = false;
    for (ServiceTypeDto val : serviceTypes) {
      if (code.trim().equalsIgnoreCase(val.getSrvctypCode())) {
        reportDuplicateCodeFY(code);
        duplicateDetected = true;
      }
    }
    if (!duplicateDetected) {
      serviceType = new ServiceTypeDto();
      serviceType.setSrvctypCode(code);
      serviceType.setDescription(description);
      FiscalYearDto fiscalYearDto = fiscalYearFacade.getFiscalYear(fiscalYear);
      serviceType.setFiscalYear(fiscalYearDto);
      serviceType.setUserCreated(userBean.getUserName());
      serviceType.setUserModified(userBean.getUserName());
      Date d = new Date();
      serviceType.setDateCreated(d);
      serviceType.setDateModified(d);
      try {
        serviceTypeFacade.createServiceType(serviceType);
        reportCreateSuccess();
        refreshServiceTypes();
      } catch (Exception e) {
        reportCreateException(e);
      }
    }
  }

  /** Create Provider Type */
  private void createProviderType() {
    LOG.debug(
        "Creating new Provider type with code {} for fiscal year {}", providerCode, fiscalYear);
    boolean duplicateDetected = false;
    for (ProviderTypeDto val : providerTypes) {
      if (code.trim().equalsIgnoreCase(val.getHarpPrvdrCode())
          && sectorTypeCode.equals(val.getSctrId().getSctrtypCode())
          && serviceTypeCode.equals(val.getSrvcId().getSrvctypCode())) {
        String message = Messages.getMessageForKey("codeTables.error.providerTypeAlreadyExists");
        message = MessageFormat.format(message, code, sectorTypeCode, serviceTypeCode);
        Messages.addErrorMessage(EDIT_FORM, message);
        LOG.error(message);
        duplicateDetected = true;
      }
    }
    if (!duplicateDetected) {
      boolean sectorTypeFound = false;
      boolean serviceTypeFound = false;
      // Search for sector type in the local list
      for (SectorTypeDto typ : sectorTypes) {
        if (typ.getSctrtypCode().equals(sectorTypeCode)) {
          sectorType = typ;
          sectorTypeFound = true;
        }
      }
      // Search for service type in the local list
      for (ServiceTypeDto typ : serviceTypes) {
        if (typ.getSrvctypCode().equals(serviceTypeCode)) {
          serviceType = typ;
          serviceTypeFound = true;
        }
      }
      if (sectorTypeFound && serviceTypeFound) {
        providerType = new ProviderTypeDto();
        providerType.setSctrId(sectorType);
        providerType.setSrvcId(serviceType);
        FiscalYearDto fiscalYearDto = fiscalYearFacade.getFiscalYear(fiscalYear);
        providerType.setFiscalYear(fiscalYearDto);
        providerType.setHarpPrvdrCode(providerCode);
        providerType.setHarpAbbreviation(harpProviderCode);
        // Audit fields
        providerType.setUserCreated(userBean.getUserName());
        providerType.setUserModified(userBean.getUserName());
        Date d = new Date();
        providerType.setDateCreated(d);
        providerType.setDateModified(d);

        try {
          providerTypeFacade.createProviderType(providerType);
          String message = Messages.getMessageForKey("codeTables.createProviderType.success");
          message = MessageFormat.format(message, providerCode);
          Messages.addInfoMessage(EDIT_FORM, message);
          LOG.debug(message);
          providerTypes = providerTypeFacade.getProviderTypesByFiscalYear(fiscalYear);
          // Retrieve the new HARP Code maximum
          updateMaxHarpCode();
          clearAll();
        } catch (Exception e) {
          reportCreateException(e);
        }
      } else { // Either Service type or Sector type cannot be retrieved
        if (!sectorTypeFound) {
          String message = Messages.getMessageForKey("codeTables.error.sectorTypeNotFound");
          message = MessageFormat.format(message, sectorTypeCode);
          Messages.addErrorMessage(EDIT_FORM, message);
          LOG.error(message);
        }
        if (!serviceTypeFound) {
          String message = Messages.getMessageForKey("codeTables.error.serviceTypeNotFound");
          message = MessageFormat.format(message, serviceTypeCode);
          Messages.addErrorMessage(EDIT_FORM, message);
          LOG.error(message);
        }
      }
    }
  }

  /** Updates Account type */
  private void updateAccountType() {
    LOG.debug("Updating existing account type with code {}", code);
    accountType = new AccountTypeDto();
    accountType.setAcctypCode(code);
    accountType.setDescription(description);
    accountType.setUserModified(userBean.getUserName());
    try {
      accountTypeFacade.updateAccountType(accountType);
      reportUpdateSuccess();
      accountTypes = accountTypeFacade.getAccountTypes();
    } catch (Exception e) {
      reportUpdateException(e);
    }
  }

  /** Update Fund Type */
  private void updateFundType() {
    LOG.debug("Updating existing fund type with code {}", code);
    fundType = new FundTypeDto();
    fundType.setFndtypCode(code);
    fundType.setDescription(description);
    fundType.setUserModified(userBean.getUserName());
    try {
      fundTypeFacade.updateFundType(fundType);
      reportUpdateSuccess();
      fundTypes = fundTypeFacade.getFundTypes();
    } catch (Exception e) {
      reportUpdateException(e);
    }
  }

  /** Update Relationship Type */
  private void updateRelationshipType() {
    LOG.debug("Updating existing organization relationship type with code {}", code);
    relationshipType = new RelationshipTypeDto();
    relationshipType.setReltypCode(code);
    relationshipType.setDescription(description);
    relationshipType.setDefaultPossibleDblCnt(possibleDoubleCount ? "Y" : "N");
    relationshipType.setUserModified(userBean.getUserName());
    try {
      relationshipTypeFacade.updateRelationshipType(relationshipType);
      reportUpdateSuccess();
      relationshipTypes = relationshipTypeFacade.getAll();
      DroplistBean.clearRelationships();
    } catch (Exception e) {
      reportUpdateException(e);
    }
  }

  /** Update HealthService Delivery Area */
  private void updateHealthServiceDeliveryArea() {
    LOG.debug("Updating existing Health Service Delivery area with code {}", code);
    healthServiceDeliveryArea = new RegionalTeamDto();
    healthServiceDeliveryArea.setRtCode(code);
    healthServiceDeliveryArea.setDescription(description);
    healthServiceDeliveryArea.setUserModified(userBean.getUserName());
    try {
      healthServiceDeliveryAreaFacade.updateRegionalTeam(healthServiceDeliveryArea);
      reportUpdateSuccess();
      healthServiceDeliveryAreas = healthServiceDeliveryAreaFacade.getAll();
      DroplistBean.clearHealthServiceDeliveryAreas();
    } catch (Exception e) {
      reportUpdateException(e);
    }
  }

  /** Update Local Health Area */
  private void updateLocalHealthArea() {
    LOG.debug("Updating existing Local Health area with code {}", code);
    localHealthArea = new PeerGroupDto();
    localHealthArea.setPgCode(code);
    localHealthArea.setDescription(description);
    localHealthArea.setUserModified(userBean.getUserName());
    try {
      localHealthAreaFacade.updatePeerGroup(localHealthArea);
      reportUpdateSuccess();
      localHealthAreas = localHealthAreaFacade.getAll();
      DroplistBean.clearLocalHealthAreas();
    } catch (Exception e) {
      reportUpdateException(e);
    }
  }

  /** Update Health Authority type */
  private void updateHealthAuthorityType() {
    LOG.debug("Updating existing Health Authority type with code {}", code);
    healthAuthorityType = new HealthAuthorityTypeDto();
    healthAuthorityType.setHatypCode(code);
    healthAuthorityType.setDescription(description);
    healthAuthorityType.setUserModified(userBean.getUserName());
    try {
      healthAuthorityTypeFacade.updateHealthAuthorityType(healthAuthorityType);
      reportUpdateSuccess();
      healthAuthorityTypes = healthAuthorityTypeFacade.getAll();
    } catch (Exception e) {
      reportUpdateException(e);
    }
  }

  /** Update Sector Type */
  private void updateSectorType() {
    LOG.debug("Updating existing Sector type with code {} for fiscal year {}", code, fiscalYear);
    // Check for possible duplicates

    sectorType = new SectorTypeDto();
    sectorType.setSctrtypCode(code);
    sectorType.setDescription(description);
    FiscalYearDto fiscalYearDto = fiscalYearFacade.getFiscalYear(fiscalYear);
    sectorType.setFiscalYear(fiscalYearDto);
    sectorType.setUserModified(userBean.getUserName());
    try {
      sectorTypeFacade.updateSectorType(sectorType);
      reportUpdateSuccess();
      refreshSectorTypes();
    } catch (Exception e) {
      reportUpdateException(e);
    }
  }

  /** Update Service Type */
  private void updateServiceType() {
    LOG.debug(
        "Updating existing Sub-Sector (Service) type with code {} for fiscal year {}",
        code,
        fiscalYear);
    serviceType = new ServiceTypeDto();
    serviceType.setSrvctypCode(code);
    serviceType.setDescription(description);
    FiscalYearDto fiscalYearDto = fiscalYearFacade.getFiscalYear(fiscalYear);
    serviceType.setFiscalYear(fiscalYearDto);
    serviceType.setUserModified(userBean.getUserName());
    try {
      serviceTypeFacade.updateServiceType(serviceType);
      reportUpdateSuccess();
      refreshServiceTypes();
    } catch (Exception e) {
      reportUpdateException(e);
    }
  }

  /** Update Provider Type */
  private void updateProviderType() {
    LOG.debug(
        "Updating existing Provider type with provider code {}, fiscal year {}, sector type code {} and service type code {}",
        providerCode,
        fiscalYear,
        sectorTypeCode,
        serviceTypeCode);

    // Check for duplicates
    boolean exists = false;
    for (ProviderTypeDto pt : providerTypes) {
      if ((providerCode.trim().equals(pt.getHarpPrvdrCode()))
          && (sectorTypeCode.equals(pt.getSctrId().getSctrtypCode()))
          && (serviceTypeCode.equals(pt.getSrvcId().getSrvctypCode()))
          && (providerType.getPtId().longValue() != pt.getPtId().longValue())) {
        exists = true;
        break;
      }
    }
    if (exists) {
      String message = Messages.getMessageForKey("codeTables.error.providerTypeAlreadyExists");
      message = MessageFormat.format(message, providerCode, sectorTypeCode, serviceTypeCode);
      Messages.addErrorMessage(EDIT_FORM, message);
      LOG.info(message);
    } else {
      providerType.setHarpAbbreviation(harpProviderCode);

      FiscalYearDto fiscalYearDto = fiscalYearFacade.getFiscalYear(fiscalYear);
      providerType.setFiscalYear(fiscalYearDto);
      providerType.setUserModified(userBean.getUserName());
      try {
        providerTypeFacade.updateProviderType(providerType, sectorTypeCode, serviceTypeCode);
        String message = Messages.getMessageForKey("codeTables.updateProviderType.success");
        message = MessageFormat.format(message, providerCode, fiscalYear);
        Messages.addInfoMessage(EDIT_FORM, message);
        LOG.debug(message);
        clearAll();
        providerTypes = providerTypeFacade.getProviderTypesByFiscalYear(fiscalYear);
      } catch (Exception e) {
        reportUpdateException(e);
      }
    }
  }

  /** Deletes account type */
  private void deleteAccountType() {
    try {
      boolean result = accountTypeFacade.deleteAccountType(code);
      if (result) {
        reportDeleteSuccess(code);
        accountTypes = accountTypeFacade.getAccountTypes();
      } else reportDeleteError();
    } catch (Exception e) {
      reportDeleteException(e);
    }
  }

  /** Deletes Fund type */
  private void deleteFundType() {
    try {
      boolean result = fundTypeFacade.deleteFundType(code);
      if (result) {
        reportDeleteSuccess(code);
        fundTypes = fundTypeFacade.getFundTypes();
      } else reportDeleteError();
    } catch (Exception e) {
      reportDeleteException(e);
    }
  }

  /** Deletes Relationship type */
  private void deleteRelationshipType() {
    try {
      boolean result = relationshipTypeFacade.deleteRelationshipType(code);
      if (result) {
        reportDeleteSuccess(code);
        relationshipTypes = relationshipTypeFacade.getAll();
        DroplistBean.clearRelationships();
      } else reportDeleteError();
    } catch (Exception e) {
      reportDeleteException(e);
    }
  }

  /** Deletes Health Service Delivery Area */
  private void deleteHealthServiceDeliveryArea() {
    try {
      boolean result = healthServiceDeliveryAreaFacade.deleteRegionalTeam(code);
      if (result) {
        reportDeleteSuccess(code);
        healthServiceDeliveryAreas = healthServiceDeliveryAreaFacade.getAll();
        DroplistBean.clearHealthServiceDeliveryAreas();
      } else reportDeleteError();
    } catch (Exception e) {
      reportDeleteException(e);
    }
  }

  /** Deletes Local Health Area */
  private void deleteLocalHealthArea() {
    try {
      boolean result = localHealthAreaFacade.deletePeerGroup(code);
      if (result) {
        reportDeleteSuccess(code);
        localHealthAreas = localHealthAreaFacade.getAll();
        DroplistBean.clearLocalHealthAreas();
      } else reportDeleteError();
    } catch (Exception e) {
      reportDeleteException(e);
    }
  }

  /** Deletes Health Authority Type */
  private void deleteHealthAuthorityType() {
    try {
      boolean result = healthAuthorityTypeFacade.deleteHealthAuthorityType(code);
      if (result) {
        reportDeleteSuccess(code);
        healthAuthorityTypes = healthAuthorityTypeFacade.getAll();
      } else reportDeleteError();
    } catch (Exception e) {
      reportDeleteException(e);
    }
  }

  /** Deletes Sector type */
  private void deleteSectorType() {
    try {
      boolean result = sectorTypeFacade.deleteSectorType(code, fiscalYear);
      if (result) {
        reportDeleteSuccess(code);
        refreshSectorTypes();
      } else reportDeleteError();
    } catch (Exception e) {
      reportDeleteException(e);
    }
  }

  /** Deletes Service type */
  private void deleteServiceType() {
    try {
      boolean result = serviceTypeFacade.deleteServiceType(code, fiscalYear);
      if (result) {
        reportDeleteSuccess(code);
        refreshServiceTypes();
      } else reportDeleteError();
    } catch (Exception e) {
      reportDeleteException(e);
    }
  }

  /** Deletes Provider Type */
  private void deleteProviderType() {
    try {
      boolean result =
          providerTypeFacade.deleteProviderType(
              providerCode, fiscalYear, sectorTypeCode, serviceTypeCode);
      if (result) {
        reportDeleteSuccess(providerCode);
        providerTypes = providerTypeFacade.getProviderTypesByFiscalYear(fiscalYear);
        updateMaxHarpCode();
      } else reportProviderDeleteError();
    } catch (Exception e) {
      reportDeleteException(e);
    }
  }

  /**
   * Listener to row select event for code tables
   *
   * @param event Select event
   */
  public void updateExistingType(SelectEvent event) {
    clearAll();
    currentTask = (Tasks) event.getComponent().getAttributes().get(TASK);
    dialogueHeader =
        MessageFormat.format(Messages.getMessageForKey(UPDATE_DIALOG_TITLE), currentTask.getType());
    switch (currentTask) {
      case UPDATE_SECTOR_TYPE:
        description = sectorType.getDescription();
        code = sectorType.getSctrtypCode();
        break;
      case UPDATE_SUBSECTOR_TYPE:
        description = serviceType.getDescription();
        code = serviceType.getSrvctypCode();
        break;
      case UPDATE_PROVIDER_TYPE:
        providerCode = providerType.getHarpPrvdrCode();
        harpProviderCode = providerType.getHarpAbbreviation();
        sectorTypeCode = providerType.getSctrId().getSctrtypCode();
        serviceTypeCode = providerType.getSrvcId().getSrvctypCode();
        break;
      case UPDATE_ACCOUNT_TYPE:
        description = accountType.getDescription();
        code = accountType.getAcctypCode();
        break;
      case UPDATE_FUND_TYPE:
        description = fundType.getDescription();
        code = fundType.getFndtypCode();
        break;
      case UPDATE_RELATIONSHIP_TYPE:
        description = relationshipType.getDescription();
        code = relationshipType.getReltypCode();
        possibleDoubleCount = "Y".equalsIgnoreCase(relationshipType.getDefaultPossibleDblCnt());
        break;
      case UPDATE_HSDA_TYPE:
        description = healthServiceDeliveryArea.getDescription();
        code = healthServiceDeliveryArea.getRtCode();
        break;
      case UPDATE_LHA_TYPE:
        description = localHealthArea.getDescription();
        code = localHealthArea.getPgCode();
        break;
      case UPDATE_HA_TYPE:
        description = healthAuthorityType.getDescription();
        code = healthAuthorityType.getHatypCode();
        break;
      default:
    }
  }

  /** Sets current task based on the passed parameter */
  public void createNewType() {
    clearAll();
    FacesContext context = FacesContext.getCurrentInstance();
    String task = context.getExternalContext().getRequestParameterMap().get(TASK);
    currentTask = Tasks.valueOf(task);
    if (currentTask == Tasks.CREATE_PROVIDER_TYPE) {
      Long harpCode = providerTypeFacade.getMaxHarpCodeForFiscalYear(fiscalYear);
      if (harpCode < 99) {
        harpCode++;
        String harpCodeStr = harpCode.toString();
        providerCode = (harpCodeStr.length() < 2 ? "0" + harpCodeStr : harpCodeStr);
      } else {
        // Maximal value has been reached
        showProviderCreateDialogue = false;
        String message =
            MessageFormat.format(
                Messages.getMessageForKey("codeTables.createProviderType.error"), harpCode);
        Messages.addErrorMessage(EDIT_FORM, message);
        LOG.info(message);
        return;
      }
    }
    showProviderCreateDialogue = true;
    dialogueHeader =
        MessageFormat.format(Messages.getMessageForKey(CREATE_DIALOG_TITLE), currentTask.getType());
  }

  /** Generic Create/Save method called from the dialogue */
  public void saveCodeType() {
    disablePageMessaging();
    if (isUpdateCodeType()) {
      LOG.debug("Updating existing {}", currentTask.getType());
      switch (currentTask) {
        case UPDATE_SECTOR_TYPE:
          updateSectorType();
          break;
        case UPDATE_SUBSECTOR_TYPE:
          updateServiceType();
          break;
        case UPDATE_PROVIDER_TYPE:
          updateProviderType();
          break;
        case UPDATE_ACCOUNT_TYPE:
          updateAccountType();
          break;
        case UPDATE_FUND_TYPE:
          updateFundType();
          break;
        case UPDATE_RELATIONSHIP_TYPE:
          updateRelationshipType();
          break;
        case UPDATE_HSDA_TYPE:
          updateHealthServiceDeliveryArea();
          break;
        case UPDATE_LHA_TYPE:
          updateLocalHealthArea();
          break;
        case UPDATE_HA_TYPE:
          updateHealthAuthorityType();
          break;
        default:
      }
    } else {
      LOG.debug("Creating new {}", currentTask.getType());
      switch (currentTask) {
        case CREATE_SECTOR_TYPE:
          createSectorType();
          break;
        case CREATE_SUBSECTOR_TYPE:
          createServiceType();
          break;
        case CREATE_PROVIDER_TYPE:
          createProviderType();
          break;
        case CREATE_ACCOUNT_TYPE:
          createAccountType();
          break;
        case CREATE_FUND_TYPE:
          createFundType();
          break;
        case CREATE_RELATIONSHIP_TYPE:
          createRelationshipType();
          break;
        case CREATE_HSDA_TYPE:
          createHealthServiceDeliveryArea();
          break;
        case CREATE_LHA_TYPE:
          createLocalHealthArea();
          break;
        case CREATE_HA_TYPE:
          createHealthAuthorityType();
          break;
        default:
      }
    }
  }

  /** Generic delete for all types */
  public void deleteCodeType() {
    LOG.debug("Deleting {} with the code {}", currentTask.getType(), code);
    // Check for dependent records
    disablePageMessaging();
    switch (currentTask) {
      case UPDATE_SECTOR_TYPE:
        deleteSectorType();
        break;
      case UPDATE_SUBSECTOR_TYPE:
        deleteServiceType();
        break;
      case UPDATE_PROVIDER_TYPE:
        deleteProviderType();
        break;
      case UPDATE_ACCOUNT_TYPE:
        deleteAccountType();
        break;
      case UPDATE_FUND_TYPE:
        deleteFundType();
        break;
      case UPDATE_RELATIONSHIP_TYPE:
        deleteRelationshipType();
        break;
      case UPDATE_HSDA_TYPE:
        deleteHealthServiceDeliveryArea();
        break;
      case UPDATE_LHA_TYPE:
        deleteLocalHealthArea();
        break;
      case UPDATE_HA_TYPE:
        deleteHealthAuthorityType();
        break;
      default:
    }
  }

  private boolean enablePageMessages = true;

  /**
   * Manages rendering of the PF Messages Component defined for the whole page
   *
   * @return true if page-wide messages component shall be rendered, false otherwise
   */
  public boolean isEnablePageMessages() {
    return enablePageMessages;
  }

  /** Turns rendering of the page-wide PF Messages Component off */
  public void disablePageMessaging() {
    enablePageMessages = false;
  }

  /** Turns rendering of the page-wide PF Messages Component n */
  public void enablePageMessaging() {
    enablePageMessages = true;
  }

  /*
   * Convenience methods to report various outcomes of create/update/delete methods
   */

  private void reportDuplicateCode(String val) {
    String message = Messages.getMessageForKey("codeTables.error.codeAlreadyExists");
    message = MessageFormat.format(message, currentTask.type, val);
    Messages.addErrorMessage(EDIT_FORM, message);
    LOG.info(message);
  }

  private void reportDuplicateCodeFY(String val) {
    String message = Messages.getMessageForKey("codeTables.error.codeAlreadyExistsFY");
    message = MessageFormat.format(message, currentTask.type, val);
    Messages.addErrorMessage(EDIT_FORM, message);
    LOG.info(message);
  }

  private void reportCreateSuccess() {
    String message = Messages.getMessageForKey("codeTables.create.success");
    message = MessageFormat.format(message, currentTask.getType(), description, code);
    Messages.addInfoMessage(EDIT_FORM, message);
    LOG.debug(message);
    clearAll();
  }

  private void reportUpdateSuccess() {
    String message = Messages.getMessageForKey("codeTables.update.success");
    message = MessageFormat.format(message, currentTask.getType(), code);
    Messages.addInfoMessage(EDIT_FORM, message);
    LOG.debug(message);
    clearAll();
  }

  private void reportDeleteSuccess(String val) {
    String message = Messages.getMessageForKey("codeTables.delete.success");
    message = MessageFormat.format(message, currentTask.getType(), val);
    Messages.addInfoMessage(EDIT_FORM, message);
    LOG.debug(message);
    clearAll();
  }

  private void reportDeleteError() {
    String message = Messages.getMessageForKey("codeTables.delete.dependenciesFound");
    message = MessageFormat.format(message, currentTask.getType(), code);
    Messages.addErrorMessage(EDIT_FORM, message);
    message = Messages.getMessageForKey("codeTables.delete.dependenciesFound");
    message = MessageFormat.format(message, currentTask.getType(), code);
    LOG.debug(message);
  }

  private void reportProviderDeleteError() {
    String message = Messages.getMessageForKey("codeTables.delete.dependenciesFound");
    message = MessageFormat.format(message, currentTask.getType(), providerCode);
    Messages.addErrorMessage(EDIT_FORM, message);
    message = Messages.getMessageForKey("codeTables.delete.dependenciesFound");
    message = MessageFormat.format(message, currentTask.getType(), providerCode);
    LOG.debug(message);
  }

  private void reportCreateException(Exception e) {
    String message = Messages.getMessageForKey("codeTables.create.error");
    message = MessageFormat.format(message, currentTask.getType());
    Messages.addErrorMessage(EDIT_FORM, message);
    LOG.error(message, e.fillInStackTrace());
  }

  private void reportUpdateException(Exception e) {
    String message = Messages.getMessageForKey("codeTables.update.error");
    message = MessageFormat.format(message, currentTask.getType());
    Messages.addErrorMessage(EDIT_FORM, message);
    LOG.error(message, e.fillInStackTrace());
  }

  private void reportDeleteException(Exception e) {
    String message = Messages.getMessageForKey("codeTables.delete.error");
    message = MessageFormat.format(message, currentTask.getType());
    Messages.addErrorMessage(EDIT_FORM, message);
    LOG.error(message, e.fillInStackTrace());
  }
}
