package ca.bc.gov.health.hamis.beans.administration;

import ca.bc.gov.health.hamis.beans.common.Messages;
import ca.bc.gov.health.hamis.beans.session.DroplistBean;
import ca.bc.gov.health.hamis.beans.session.UserBean;
import ca.bc.gov.health.hamis.dto.FiscalYearDto;
import ca.bc.gov.health.hamis.dto.ReportingPeriodDto;
import ca.bc.gov.health.hamis.service.IFiscalYearFacade;
import ca.bc.gov.health.hamis.service.IReportingPeriodFacade;
import ca.bc.gov.health.hamis.util.HamisConstants;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import lombok.Getter;
import lombok.Setter;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.primefaces.event.SelectEvent;

/**
 * Backing bean for the Reporting Periods page
 *
 * @author camille.estival
 */
@Named("ReportingPeriodsBean")
@ViewScoped
@Getter
@Setter
public class ReportingPeriodsBean implements Serializable {

  private static final long serialVersionUID = 1L;
  private static final Logger LOG = LogManager.getLogger(ReportingPeriodsBean.class);

  private List<FiscalYearDto> fiscalYearsList;
  private FiscalYearDto selectedFiscalYear; // Fiscal Year being edited/created
  private List<ReportingPeriodDto> reportingPeriodsList; // Reporting periods being edited

  private boolean enablePageMessages = true;

  @EJB private IFiscalYearFacade fiscalYearFacade;
  @EJB private IReportingPeriodFacade reportingPeriodFacade;

  @Inject private UserBean userBean;
  /** DropListBean instance to update the default Fiscal Year List */
  @Inject private transient DroplistBean droplists;

  // ID of the forms in the JSF
  private static final String CREATE_FORM_ID = "createForm";

  public static final String YEAR_TYPE_CURRENT = "C";
  public static final String YEAR_TYPE_FUTURE = "F";
  public static final String YEAR_TYPE_PREVIOUS = "P";

  /** Initialize the page */
  @PostConstruct
  public void init() {
    LOG.debug("init method for ReportingPeriodsBean");
    fiscalYearsList = fiscalYearFacade.findAllFiscalYears();
    selectedFiscalYear = new FiscalYearDto();
  }

  /**
   * Retrieve the reporting Periods for a current year
   *
   * @param event
   */
  public void loadReportingPeriodsList(SelectEvent event) {
    LOG.debug("Method loadReportingPeriodsList ");
    if (selectedFiscalYear.getFiscalYear() != null) {
      LOG.debug(
          "Retrieve Reporting Periods for Fiscal Year: {}", selectedFiscalYear.getFiscalYear());
      reportingPeriodsList =
          reportingPeriodFacade.getReportingPeriodsForFiscalYear(
              selectedFiscalYear.getFiscalYear());
    }
    LOG.debug("End of loadReportingPeriodsList.");
  }

  /** Update the reporting Periods for a fiscal year */
  public void saveReportingPeriods() {
    LOG.debug("method saveReportingPeriods");
    // only update periods that got modified
    List<ReportingPeriodDto> originalRepPeriods =
        reportingPeriodFacade.getReportingPeriodsForFiscalYear(selectedFiscalYear.getFiscalYear());

    List<ReportingPeriodDto> modifiedPeriods = new ArrayList<>();
    for (ReportingPeriodDto originalPeriod : originalRepPeriods) {
      reportingPeriodsList.stream()
          .filter(
              period ->
                  (originalPeriod.getPeriod().equalsIgnoreCase(period.getPeriod())
                      && isPeriodModified(originalPeriod, period)))
          .map(
              period -> {
                period.setDateModified(new Date());
                period.setUserModified(userBean.getUserName());
                return period;
              })
          .forEachOrdered(
              period -> {
                modifiedPeriods.add(period);
              });
    }
    reportingPeriodFacade.updateReportingPeriods(modifiedPeriods);

    LOG.debug(
        "Reporting Periods for Fiscal Year {} succesfully updated",
        selectedFiscalYear.getFiscalYear());
    Messages.addInfoMessage(
        CREATE_FORM_ID,
        Messages.getMessageForKey("reportingPeriod.message.updatePeriods.info"),
        selectedFiscalYear.getFiscalYear());

    enablePageMessaging();
    LOG.debug("End of saveReportingPeriods.");
  }

  private boolean isPeriodModified(ReportingPeriodDto original, ReportingPeriodDto period) {
    return original.getStartDate().compareTo(period.getStartDate()) != 0
        || original.getEndDate().compareTo(period.getEndDate()) != 0
        || original.getDueDate().compareTo(period.getDueDate()) != 0;
  }

  /** Create a new Fiscal Year */
  public void insertFiscalYear() {
    LOG.debug("method insertFiscalYear");

    buildFutureFiscalYear();
    fiscalYearFacade.createFiscalYear(selectedFiscalYear);

    // load reporting periods list to display in modal
    loadReportingPeriodsList(null);

    // Refresh Fiscal Year main table
    fiscalYearsList = fiscalYearFacade.findAllFiscalYears();

    // Refresh Fiscal Year in the applicationScoped DropListBean
    DroplistBean.resetFiscalYear();

    LOG.debug("New Fiscal Year {} succesfully created", selectedFiscalYear.getFiscalYear());
    Messages.addInfoMessage(
        CREATE_FORM_ID,
        Messages.getMessageForKey("reportingPeriod.message.createFuture.info"),
        selectedFiscalYear.getFiscalYear());

    disablePageMessaging();
    LOG.debug("End of insertFiscalYear.");
  }

  private void buildFutureFiscalYear() {
    selectedFiscalYear = new FiscalYearDto();
    selectedFiscalYear.setYearType(HamisConstants.YearType.FUTURE.getShortName());

    // Get current year and add a year to end and start date
    FiscalYearDto currentYear = fiscalYearFacade.getCurrentFiscalYear();

    Calendar startDateCal =
        GregorianCalendar.from(
            ZonedDateTime.ofInstant(
                currentYear.getStartDate().toInstant(), ZoneId.systemDefault()));
    startDateCal.add(Calendar.YEAR, 1);
    selectedFiscalYear.setStartDate(startDateCal.getTime());

    Calendar endDateCal =
        GregorianCalendar.from(
            ZonedDateTime.ofInstant(currentYear.getEndDate().toInstant(), ZoneId.systemDefault()));
    endDateCal.add(Calendar.YEAR, 1);
    selectedFiscalYear.setEndDate(endDateCal.getTime());

    // FiscalYear ID also based on current Year
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy");
    String beginningFiscalYear = sdf.format(startDateCal.getTime());
    String endFiscalYear = sdf.format(endDateCal.getTime());
    selectedFiscalYear.setFiscalYear(beginningFiscalYear + "/" + endFiscalYear);

    // Audit fields
    selectedFiscalYear.setDateCreated(new Date());
    selectedFiscalYear.setUserCreated(userBean.getUserName());
  }

  /**
   * Cancel Creation of new Fiscal Year This method is called when the Cancel button is hit from the
   * Create Fiscal Year modal This will delete the by-default reporting periods This is NOT called
   * from the Update Fiscal Year modal
   */
  public void cancelCreateFiscalYear() {
    LOG.debug("method cancelCreateFiscalYear");
    if (isCreateFiscalYear() && isFutureYear()) {
      reportingPeriodFacade.deleteReportingPeriodsForFiscalYear(selectedFiscalYear.getFiscalYear());
      fiscalYearFacade.deleteFiscalYear(selectedFiscalYear);

      // Refresh Fiscal Year main table
      fiscalYearsList = fiscalYearFacade.findAllFiscalYears();
      // Refresh Fiscal Year in the applicationScoped DropListBean
      DroplistBean.resetFiscalYear();

      LOG.debug(
          "New Fiscal Year {} has been cancelled and deleted", selectedFiscalYear.getFiscalYear());
      Messages.addInfoMessage(
          CREATE_FORM_ID,
          Messages.getMessageForKey("reportingPeriod.message.deleteFuture.info"),
          selectedFiscalYear.getFiscalYear());
    }

    enablePageMessaging();
    LOG.debug("End of cancelCreateFiscalYear.");
  }

  /** Start the rollover process for the new year */
  public void rollover() {
    LOG.debug("method rollover");

    // Get Future year
    String futureYear = "NA";
    try {
      // Get Future year
      FiscalYearDto futureYearDto = fiscalYearFacade.getFutureFiscalYear();
      if (futureYearDto != null) {
        futureYear = futureYearDto.getFiscalYear();

        // First call Rollover
        fiscalYearFacade.rollover(futureYearDto);

        // Then make Future year Current
        makeCurrent(futureYearDto);

        // Refresh Fiscal Year main table
        fiscalYearsList = fiscalYearFacade.findAllFiscalYears();
        // Refresh Fiscal Year in the applicationScoped DropListBean
        DroplistBean.resetFiscalYear();

        LOG.debug("Rollover for Fiscal Year {} has been successful", futureYear);
        Messages.addInfoMessage(
            CREATE_FORM_ID,
            Messages.getMessageForKey("reportingPeriod.message.rollover.info"),
            futureYear);
      }

    } catch (Exception e) {
      LOG.error("Rollover for Fiscal year {} has failed", futureYear, e.fillInStackTrace());
      Messages.addInfoMessage(
          CREATE_FORM_ID,
          Messages.getMessageForKey("reportingPeriod.message.rollover.error"),
          futureYear);
    }

    enablePageMessaging();
    LOG.debug("End of rollover.");
  }

  /**
   * Make Future year Current and retire Current year to Previous
   *
   * @param futureYearDto
   */
  private void makeCurrent(FiscalYearDto futureYearDto) {
    // First set Current Year to Previous
    FiscalYearDto currentYear = fiscalYearFacade.getCurrentFiscalYear();
    currentYear.setYearType(HamisConstants.YearType.PREVIOUS.getShortName());
    currentYear.setUserModified(userBean.getUserName());
    fiscalYearFacade.updateFiscalYear(currentYear);

    // Then set Future Year to Current
    futureYearDto.setYearType(HamisConstants.YearType.CURRENT.getShortName());
    futureYearDto.setUserModified(userBean.getUserName());
    fiscalYearFacade.updateFiscalYear(futureYearDto);
  }

  /**
   * Sets Create/Update dialogue header
   *
   * @return String Dialogue header
   */
  public String getDialogueHeader() {
    String header = Messages.getMessageForKey("reportingPeriod.title.reportingPeriods");
    if (selectedFiscalYear.getFiscalYear() != null) {
      header = header.concat(" " + selectedFiscalYear.getFiscalYear());
    }
    return header;
  }

  /**
   * convert shortYearType to full Year Type
   *
   * @param shortYearType short year type: F, C or P
   * @return true if new Fiscal Year has been created
   */
  public String getFullYearType(String shortYearType) {
    switch (shortYearType) {
      case YEAR_TYPE_FUTURE:
        return HamisConstants.YearType.FUTURE.getFullName();
      case YEAR_TYPE_CURRENT:
        return HamisConstants.YearType.CURRENT.getFullName();
      case YEAR_TYPE_PREVIOUS:
        return HamisConstants.YearType.PREVIOUS.getFullName();
      default:
        return shortYearType;
    }
  }

  /**
   * Fiscal Year creation indicator
   *
   * @return true if new Fiscal Year has been just created Used to determine if the Cancel button
   *     need to delete the newly created Future Year
   */
  public boolean isCreateFiscalYear() {
    // DateModified is enough as:
    // 1. this method is only used to check if the year has just being created
    // 2. The modifiedDate is only set by the procedure called by the trigger on Create Fiscal Year,
    // so the modified year in this case is still null
    return (selectedFiscalYear.getDateModified() == null);
  }

  /**
   * Future year indicator
   *
   * @return true if there is Future year
   */
  public boolean isFutureYearExist() {
    return fiscalYearsList.stream()
        .anyMatch(fiscalYear -> ("F".equalsIgnoreCase(fiscalYear.getYearType())));
  }

  /**
   * Future year indicator
   *
   * @return true if the selected year is a Future year
   */
  public boolean isFutureYear() {
    return YEAR_TYPE_FUTURE.equalsIgnoreCase(selectedFiscalYear.getYearType());
  }

  /**
   * Past year indicator
   *
   * @return true if the selected year is a Past year
   */
  public boolean isPastYear() {
    return YEAR_TYPE_PREVIOUS.equalsIgnoreCase(selectedFiscalYear.getYearType());
  }

  /**
   * Manages rendering of the PF Messages Component defined for the whole page
   *
   * @return true if page-wide messages component shall be rendered, false otherwise
   */
  public boolean isEnablePageMessages() {
    return enablePageMessages;
  }

  /** Turns rendering of the page-wide PF Messages Component off */
  public void disablePageMessaging() {
    enablePageMessages = false;
  }

  /** Turns rendering of the page-wide PF Messages Component n */
  public void enablePageMessaging() {
    enablePageMessages = true;
  }
}
