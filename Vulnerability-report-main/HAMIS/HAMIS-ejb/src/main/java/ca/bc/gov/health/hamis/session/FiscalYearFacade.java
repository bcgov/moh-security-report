package ca.bc.gov.health.hamis.session;

import ca.bc.gov.health.hamis.dto.FiscalYearDto;
import ca.bc.gov.health.hamis.entity.FiscalYear;
import ca.bc.gov.health.hamis.mapper.HamisMapper;
import ca.bc.gov.health.hamis.service.IFiscalYearFacade;
import ca.bc.gov.health.hamis.util.HamisConstants;
import jakarta.annotation.Resource;
import jakarta.ejb.Stateless;
import jakarta.persistence.Query;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.List;
import javax.sql.DataSource;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

@Stateless
public class FiscalYearFacade extends AbstractFacade<FiscalYear> implements IFiscalYearFacade {

  private final HamisMapper mapper = HamisMapper.INSTANCE;

  private static final Logger LOGGER = LogManager.getLogger(FiscalYearFacade.class);

  /** Inject data source for raw JDBC access */
  @Resource(name = "java:app/jdbc/hamis")
  DataSource dataSource;

  public FiscalYearFacade() {
    super(FiscalYear.class);
  }

  /**
   * get all fiscal Years
   *
   * @return list of all Fiscal Years
   */
  @Override
  public List<FiscalYearDto> findAllFiscalYears() {
    LOGGER.debug("findAllFiscalYears ");
    final List<FiscalYearDto> fiscalYearList = new ArrayList<>();

    final Query fiscalperiodQuery = getEntityManager().createNamedQuery("FiscalYear.findAll");

    final List<FiscalYear> results = fiscalperiodQuery.getResultList();
    results.forEach(
        result -> {
          fiscalYearList.add(mapper.toDto(result));
        });

    return fiscalYearList;
  }

  /**
   * Retrieve a Fiscal Year
   *
   * @param fiscalYear
   * @return FiscalYearDto
   */
  @Override
  public FiscalYearDto getFiscalYear(final String fiscalYear) {
    LOGGER.debug("Getting Fiscal Year type");
    FiscalYear searchCriteria = new FiscalYear();
    searchCriteria.setFiscalYear(fiscalYear);
    List<FiscalYear> list = search(searchCriteria);
    if (!list.isEmpty()) {
      return mapper.toDto(list.get(0));
    }
    return null;
  }

  /**
   * Creates a fiscal Year
   *
   * @param dto FiscalYearDto
   */
  @Override
  public void createFiscalYear(final FiscalYearDto dto) {
    LOGGER.debug("Creating new Fiscal Year");
    FiscalYear year = mapper.toModel(dto);
    create(year);
  }

  /**
   * update a fiscal Year
   *
   * @param dto FiscalYearDto
   */
  @Override
  public void updateFiscalYear(final FiscalYearDto dto) {
    LOGGER.debug("Updating  Fiscal Year");
    FiscalYear year = mapper.toModel(dto);
    super.edit(year);
  }

  /**
   * get the current fiscal Year
   *
   * @return the current Fiscal Year
   */
  @Override
  public FiscalYearDto getCurrentFiscalYear() {
    LOGGER.debug("Get Current Fiscal Year");
    FiscalYear searchCriteria = new FiscalYear();
    searchCriteria.setYearType(HamisConstants.YearType.CURRENT.getShortName());
    List<FiscalYear> list = search(searchCriteria);
    FiscalYearDto dto;
    if (list != null && !list.isEmpty()) {
      dto = mapper.toDto(list.get(0));
    } else {
      dto = null;
    }
    return dto;
  }

  /**
   * get the Future fiscal Year
   *
   * @return FiscalYearDto
   */
  @Override
  public FiscalYearDto getFutureFiscalYear() {
    LOGGER.debug("Get Future Fiscal Year");
    FiscalYear searchCriteria = new FiscalYear();
    searchCriteria.setYearType(HamisConstants.YearType.FUTURE.getShortName());
    List<FiscalYear> list = search(searchCriteria);
    FiscalYearDto dto;
    if (list != null && !list.isEmpty()) {
      dto = mapper.toDto(list.get(0));
    } else {
      dto = null;
    }
    return dto;
  }

  /**
   * delete a fiscal Year HARD DELETE, not a cascade delete, call delete ReportingPeriod first Only
   * to use just after creating new Future Fiscal Year
   *
   * @param yearDto the fiscal year to delete
   */
  @Override
  public void deleteFiscalYear(final FiscalYearDto yearDto) {
    LOGGER.debug("deleting new Fiscal Year");
    FiscalYear year = find(yearDto.getFiscalYear());
    remove(year);
  }

  /**
   * call the rollover procedure to make a Future year the current fiscal year
   *
   * @param futureYearDto FiscalYearDto
   * @throws Exception
   */
  @Override
  public void rollover(final FiscalYearDto futureYearDto) throws Exception {
    // call procedure that will perform the rollover
    LOGGER.debug(
        "DEBUG: calling pl/sql Rollover procedure for year {}: fiscal_years_data.rollover_current_fiscal()",
        futureYearDto.getFiscalYear());

    try (Connection conn = dataSource.getConnection();
        CallableStatement cs =
            conn.prepareCall("{call fiscal_years_data.rollover_current_fiscal()}")) {
      cs.executeUpdate();
    }
  }

  /**
   * Gets the type for a fiscal year
   *
   * @param fiscalYear
   * @return String
   */
  @Override
  public String getYearTypeForFiscal(final String fiscalYear) {
    LOGGER.debug("Getting Fiscal Year type");
    FiscalYear searchCriteria = new FiscalYear();
    searchCriteria.setFiscalYear(fiscalYear);
    List<FiscalYear> list = search(searchCriteria);
    if (!list.isEmpty()) {
      return list.get(0).getYearType();
    }
    return null;
  }
}
