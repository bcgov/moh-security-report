/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.hamis.session;

import ca.bc.gov.health.hamis.dto.SEFFile;
import ca.bc.gov.health.hamis.dto.StandardExtractFileDto;
import ca.bc.gov.health.hamis.entity.StandardExtractFile;
import ca.bc.gov.health.hamis.service.IStandardExtractFileFacade;
import jakarta.annotation.Resource;
import jakarta.ejb.Asynchronous;
import jakarta.ejb.Stateless;
import jakarta.persistence.Query;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import javax.sql.DataSource;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Implementation of the StandardExtractFileFacadeLocal interface
 *
 * @author greg.perkins
 */
@Stateless
public class StandardExtractFileFacade extends AbstractFacade<StandardExtractFile>
    implements IStandardExtractFileFacade {

  /** Log instance */
  private static final Logger LOGGER = LogManager.getLogger(StandardExtractFileFacade.class);

  // Constants for transaction and operation types
  public static final String ACTUAL = "A";
  public static final String BUDGET = "B";

  public static final String VALIDATE = "VALID";
  public static final String EXPORT = "EXPRT";

  /** Inject data source for raw JDBC access */
  @Resource(name = "java:app/jdbc/hamis")
  DataSource dataSource;

  /** Standard no-arg constructor */
  public StandardExtractFileFacade() {
    super(StandardExtractFile.class);
  }

  /**
   * Returns only the summary data required by progress bar UI for the StandardExtractFile records
   * found by the provided parameters
   *
   * @param fiscalYear
   * @param period
   * @param healthOrganizationId
   * @return
   */
  @Override
  public List<StandardExtractFileDto> getSefSummaryForReportingPeriod(
      String fiscalYear, String period, int healthOrganizationId) {

    LOGGER.debug(
        "Getting SEF Summary for Reporting Period, FY {}, period {} and Org ID {}",
        fiscalYear,
        period,
        healthOrganizationId);
    String querySql =
        "SELECT SEF.SEF_ID, SEF.FILE_NAME, SEF.SEF_TYPE_CD, SST.DESCRIPTION, SEF.UPLOADED_BY, SEF.UPLOAD_DATE\n"
            + "FROM STANDARD_EXTRACT_FILES SEF, SEF_STATUS_TYPES SST, STANDARD_EXTRACT_SOURCES SES, DATA_SUBMITTERS DS\n"
            + "WHERE\n"
            + "SST.TYPE_CD = SEF.SEF_TYPE_CD\n"
            + "AND SEF.SES_ID = SES.SES_ID\n"
            + "AND DS.DS_ID = SES.DS_ID\n"
            + "AND SEF.FISCAL_YEAR = ?\n"
            + "AND SEF.PERIOD = ?\n"
            + "AND DS.HO_ID = ?\n"
            + "ORDER BY SEF.UPLOAD_DATE DESC";
    Query query = getEntityManager().createNativeQuery(querySql);
    query.setParameter(1, fiscalYear);
    query.setParameter(2, period);
    query.setParameter(3, healthOrganizationId);
    List<StandardExtractFileDto> out = new ArrayList<>();
    long startTime = System.currentTimeMillis();

    @SuppressWarnings("unchecked")
    List<Object[]> results = query.getResultList();

    long duration = System.currentTimeMillis() - startTime;
    LOGGER.debug("Query executed in {} ms", duration);
    for (Object[] row : results) {
      StandardExtractFileDto sef = new StandardExtractFileDto();
      sef.setSefId(((BigDecimal) row[0]).longValue());
      sef.setFileName((String) row[1]);
      sef.setSefStatusTypeCd((String) row[2]);
      sef.setSefStatusTypeDesc((String) row[3]);
      sef.setUploadedBy((String) row[4]);
      sef.setUploadDate((Date) row[5]);
      out.add(sef);
    }
    return out;
  }

  /**
   * Validates the Standard Extract Files for a given reporting period and HA
   *
   * @param hoId
   * @param fiscalYear
   * @param period
   */
  @Asynchronous
  @Override
  public void validateStandardExtractFiles(int hoId, String fiscalYear, String period) {
    deleteValidation(hoId, fiscalYear, period);
    startSubValidation(hoId, fiscalYear, period, ACTUAL, VALIDATE);
    startSubValidation(hoId, fiscalYear, period, BUDGET, VALIDATE);
  }

  /**
   * Validates the Standard Extract Files for a given reporting period and HA
   *
   * @param hoId
   * @param fiscalYear
   * @param period
   * @param actualOrBudget
   */
  @Asynchronous
  @Override
  public void exportStandardExtractFiles(
      int hoId, String fiscalYear, String period, String actualOrBudget) {
    if (ACTUAL.equals(actualOrBudget) || BUDGET.equals(actualOrBudget)) {
      startSubValidation(hoId, fiscalYear, period, actualOrBudget, EXPORT);
    } else {
      startSubValidation(hoId, fiscalYear, period, ACTUAL, EXPORT);
      startSubValidation(hoId, fiscalYear, period, BUDGET, EXPORT);
    }
  }

  /**
   * Deletes the validation records for a period
   *
   * @param hoId
   * @param fiscalYear
   * @param period
   */
  @Override
  public void deleteValidation(int hoId, String fiscalYear, String period) {
    LOGGER.debug("Delete Validations for Org ID {}, FY {} and period {}", hoId, fiscalYear, period);
    Connection conn = null;
    PreparedStatement stmt1 = null;
    PreparedStatement stmt2 = null;
    PreparedStatement stmt3 = null;
    try {
      conn = dataSource.getConnection();
      conn.setAutoCommit(false);
      // Delete child records
      String query1 =
          "DELETE FROM SUBMISSION_MESSAGES WHERE SUB_ID IN ("
              + "    SELECT sub.SUB_ID FROM SUBMISSIONS sub"
              + "    WHERE sub.HO_ID = ? AND sub.FISCAL_YEAR = ? AND sub.PERIOD = ? AND sub.STATUS_CD = 'VALID'"
              + ")";
      stmt1 = conn.prepareStatement(query1);
      stmt1.setInt(1, hoId);
      stmt1.setString(2, fiscalYear);
      stmt1.setString(3, period);
      int rows = stmt1.executeUpdate();
      LOGGER.debug("{} rows deleted from SUBMISSION_MESSAGES", rows);

      String query2 =
          "DELETE FROM BALANCE_SHEET_SUMMARY WHERE SUB_ID IN ("
              + "    SELECT sub.SUB_ID FROM SUBMISSIONS sub"
              + "    WHERE sub.HO_ID = ? AND sub.FISCAL_YEAR = ? AND sub.PERIOD = ? AND sub.STATUS_CD = 'VALID'"
              + ")";
      stmt2 = conn.prepareStatement(query2);
      stmt2.setInt(1, hoId);
      stmt2.setString(2, fiscalYear);
      stmt2.setString(3, period);
      rows = stmt2.executeUpdate();
      LOGGER.debug("{} rows deleted from BALANCE_SHEET_SUMMARY", rows);

      // Delete parent records
      String query3 =
          "DELETE FROM SUBMISSIONS sub"
              + "    WHERE sub.HO_ID = ?"
              + "    AND sub.FISCAL_YEAR = ?"
              + "    AND sub.PERIOD = ?"
              + "    AND sub.STATUS_CD = 'VALID'";
      stmt3 = conn.prepareStatement(query3);
      stmt3.setInt(1, hoId);
      stmt3.setString(2, fiscalYear);
      stmt3.setString(3, period);
      rows = stmt3.executeUpdate();
      LOGGER.debug("{} rows deleted from SUBMISSIONS", rows);

      conn.commit();
    } catch (SQLException e) {
      try {
        LOGGER.error("Error in calling Stored procedure", e.fillInStackTrace());
        if (conn != null) {
          conn.rollback();
        }
      } catch (Exception e2) {
        LOGGER.error("Error in rollback", e2.fillInStackTrace());
      }
    } finally {
      if (stmt1 != null) {
        try {
          stmt1.close();
        } catch (SQLException e) {
          LOGGER.error(e.getMessage(), e);
        }
      }
      if (stmt2 != null) {
        try {
          stmt2.close();
        } catch (SQLException e) {
          LOGGER.error(e.getMessage(), e);
        }
      }
      if (stmt3 != null) {
        try {
          stmt3.close();
        } catch (SQLException e) {
          LOGGER.error(e.getMessage(), e);
        }
      }
      if (conn != null) {
        try {
          conn.close();
        } catch (SQLException e) {
          LOGGER.error(e.getMessage(), e);
        }
      }
    }
  }

  /**
   * Starts the sub validation for a given transaction type. Based on the logic in
   * sub_process.start_sub_validation
   *
   * @param hoId int
   * @param fiscalYear String
   * @param period String
   * @param actualOrBudget String, A or B
   * @param validOrExport String, VALID or EXPRT
   */
  private void startSubValidation(
      int hoId, String fiscalYear, String period, String actualOrBudget, String validOrExport) {
    LOGGER.debug("startSubValidation ..");
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
      conn = dataSource.getConnection();
      // Stub out a new submission record
      String insertQuery =
          "insert into submissions(ho_id, fiscal_year, period, type_cd, status_cd, ab_trxn_type)"
              + "values(?,?,?, 'PRC01', ?, ?)";
      stmt = conn.prepareStatement(insertQuery);
      stmt.setInt(1, hoId);
      stmt.setString(2, fiscalYear);
      stmt.setString(3, period);
      stmt.setString(4, validOrExport);
      stmt.setString(5, actualOrBudget);
      stmt.executeUpdate();
      stmt.close();

      // Get the generated PK
      stmt = conn.prepareStatement("SELECT SUB_SEQ.currval from DUAL");
      rs = stmt.executeQuery();
      rs.next();
      String submissionId = rs.getString(1);
      // Do an early commit so we get updates in UI
      conn.commit();

      // Call the validation sub-process with the new key
      subProcess(submissionId, validOrExport, conn);

      // Done!
      conn.commit();
    } catch (SQLException e) {
      try {
        LOGGER.error("Error in calling Stored procedure", e.fillInStackTrace());
        if (conn != null) {
          conn.rollback();
        }
      } catch (Exception e2) {
        LOGGER.error("Error in rollback", e2.fillInStackTrace());
      }
    } finally {
      if (rs != null) {
        try {
          rs.close();
        } catch (SQLException e) {
          LOGGER.error(e.getMessage(), e);
        }
      }
      if (stmt != null) {
        try {
          stmt.close();
        } catch (SQLException e) {
          LOGGER.error(e.getMessage(), e);
        }
      }
      if (conn != null) {
        try {
          conn.close();
        } catch (SQLException e) {
          LOGGER.error(e.getMessage(), e);
        }
      }
    }
  }

  /**
   * Calls the validation procedure Based on the SubProcess.java command line utility
   *
   * @param submissionId String
   * @param validOrExport String, VALID or EXPRT
   * @param conn Connection
   * @throws SQLException
   */
  private void subProcess(String submissionId, String validOrExport, Connection conn)
      throws SQLException {

    String updateQuery = "update submissions set type_cd = 'PRC02' where sub_id = ?";
    try (PreparedStatement stmt = conn.prepareStatement(updateQuery)) {
      // update the standard_extract_files table to indicate that processing has been initiated
      stmt.setString(1, submissionId);
      stmt.executeUpdate();
      LOGGER.debug("DEBUG: submission type is {}", validOrExport);

      if (VALIDATE.equalsIgnoreCase(validOrExport)) {
        subProcessValidate(submissionId, conn, stmt);
      } else {
        subProcessExport(submissionId, conn, stmt);
      }
    }
  }

  /**
   * Call the export process in PL/SQL
   *
   * @param submissionId String
   * @param conn Connection
   * @param stmt PreparedStatement
   * @return
   * @throws SQLException
   */
  private boolean subProcessExport(String submissionId, Connection conn, PreparedStatement stmt)
      throws SQLException {
    // call procedure to submission export
    LOGGER.debug(
        "DEBUG: calling pl/sql submission validation sub_process.sub_export({})", submissionId);

    try (CallableStatement cs = conn.prepareCall("{call sub_process.sub_export(?)}")) {
      cs.setString(1, submissionId);
      cs.executeUpdate();

    } catch (Exception e) {
      LOGGER.error("ERROR: export for sub_id {} ", submissionId, e.fillInStackTrace());

      String updateQuery = "update submissions set type_cd = 'SYSER' where sub_id = ?";
      stmt = conn.prepareStatement(updateQuery);
      stmt.setString(1, submissionId);
      stmt.executeUpdate();

      String insertQuery =
          "insert into submission_messages (sub_id, type_cd, message, test_severity) values (?, 'SYSER', 'call to submission export procedure from external process failed', 'H')";
      stmt = conn.prepareStatement(insertQuery);
      stmt.setString(1, submissionId);
      stmt.executeUpdate();
      return true;
    }
    return false;
  }

  /**
   * Call the validate process in PL/SQL
   *
   * @param submissionId String
   * @param conn Connection
   * @param stmt PreparedStatement
   * @return
   * @throws SQLException
   */
  private boolean subProcessValidate(String submissionId, Connection conn, PreparedStatement stmt)
      throws SQLException {
    // call procedure to validate submission
    LOGGER.debug(
        "DEBUG: calling pl/sql submission validation sub_process.sub_validation({})", submissionId);

    try (CallableStatement cs = conn.prepareCall("{call sub_process.sub_validation(?)}")) {
      cs.setString(1, submissionId);
      cs.executeUpdate();

    } catch (Exception e) {
      LOGGER.error("ERROR: validation for sub_id {} ", submissionId, e.fillInStackTrace());

      String updateQuery = "update submissions set type_cd = 'SYSER' where sub_id = ?";
      stmt = conn.prepareStatement(updateQuery);
      stmt.setString(1, submissionId);
      stmt.executeUpdate();

      String insertQuery =
          "insert into submission_messages (sub_id, type_cd, message, test_severity) values (?, 'SYSER', 'call to submission validation procedure from external process failed', 'H')";
      stmt = conn.prepareStatement(insertQuery);
      stmt.setString(1, submissionId);
      stmt.executeUpdate();
      return true;
    }
    return false;
  }

  /**
   * Deletes a Standard Extract File
   *
   * @param sefId
   */
  @Override
  public void deleteStandardExtractFile(int sefId) {
    LOGGER.debug("deleteStandardExtractFile");
    /*
    Original procedure was
        EH_VIEW_SEF_STATUS$SEF.ActionDelete
    Which has some irrelevant logic, but ultimately calls
        eh_package.delete_sef()
        CG$STANDARD_EXTRACT_FILES.Del()
    These two procedures delete child and parent records, so we'll do the same thing here natively.
    */
    // Delete child records
    getEntityManager()
        .createNativeQuery("DELETE FROM STANDARD_EXTRACT_FILE_DETLS WHERE sef_id = ?")
        .setParameter(1, sefId)
        .executeUpdate();
    getEntityManager()
        .createNativeQuery("DELETE FROM SEF_ERROR_MESSAGES WHERE seem_sf_id = ?")
        .setParameter(1, sefId)
        .executeUpdate();
    getEntityManager()
        .createNativeQuery("DELETE FROM SUBMISSION_MESSAGES WHERE sef_id = ?")
        .setParameter(1, sefId)
        .executeUpdate();
    // Delete parent
    getEntityManager()
        .createNativeQuery("DELETE FROM STANDARD_EXTRACT_FILES WHERE sef_id = ?")
        .setParameter(1, sefId)
        .executeUpdate();
    getEntityManager().flush();
  }

  /**
   * Import a SEF File into the database
   *
   * @param upload SEFFile
   * @param sesId String
   * @param cagId String
   * @param period String
   * @param fiscalYear String
   * @param userId String
   * @return List<String> errors
   */
  @Override
  public List<String> importStandardExtractFile(
      SEFFile upload, int sesId, int cagId, String period, String fiscalYear, String userId) {
    LOGGER.debug("importStandardExtractFile");
    long startTime = System.currentTimeMillis();

    // Parse the file and exit if any errors found
    List<String> errors = new ArrayList<>();
    List<String[]> rows = null;
    try {
      rows = parseFile(upload.getContents(), errors);
      if (!errors.isEmpty()) {
        return errors;
      }

    } catch (IOException e) {
      LOGGER.error(e.getMessage());
      errors.add(e.getMessage());
      return errors;
    }

    asyncProcessImportFile(upload, rows, sesId, cagId, period, fiscalYear, userId, startTime);
    return errors;
  }

  @Asynchronous
  public void asyncProcessImportFile(
      SEFFile upload,
      List<String[]> rows,
      int sesId,
      int cagId,
      String period,
      String fiscalYear,
      String userId,
      long startTime) {
    // We use raw JDBC here instead of the entity manager as we want to do a batch insert for
    // performance reasons
    SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
    String filename = upload.getFileName() + sdf.format(new Date());

    try (Connection conn = dataSource.getConnection()) {

      conn.setAutoCommit(false);
      batchInsert(conn, rows, filename);
      processUpload(conn, upload, filename, sesId, cagId, period, fiscalYear, userId);

      long duration = System.currentTimeMillis() - startTime;
      LOGGER.debug("File imported in {} ms", duration);

    } catch (SQLException e) {
      LOGGER.error(e.fillInStackTrace());
    }
  }

  /**
   * Insert the rows into the staging table using a JDBC batch
   *
   * @param conn Connection
   * @param rows List<String[]>
   * @param filename String
   * @throws SQLException
   */
  private void batchInsert(Connection conn, List<String[]> rows, String filename)
      throws SQLException {

    try (PreparedStatement stmt =
        conn.prepareStatement(
            "INSERT INTO SEF_STAGING(FILE_NAME, LINE_NO, ACCOUNTS, PERIOD_1,PERIOD_2,PERIOD_3,PERIOD_4,"
                + "PERIOD_5,PERIOD_6,PERIOD_7,PERIOD_8,PERIOD_9,PERIOD_10,PERIOD_11,PERIOD_12,PERIOD_13,PERIOD_14) "
                + "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)")) {

      for (int line = 0; line < rows.size(); line++) {
        String[] row = rows.get(line);
        stmt.setString(1, filename);
        stmt.setInt(2, line + 1);
        for (int i = 0; i < 15; i++) {
          stmt.setString(3 + i, row[i]);
        }
        stmt.addBatch();
      }
      stmt.executeBatch();
      conn.commit();
    }
  }

  /**
   * Call the PL/SQL procedure to start the import process
   *
   * @param conn Connection
   * @param upload SEFFile
   * @param filename String
   * @param sesId int
   * @param cagId int
   * @param period String
   * @param fiscalYear String
   * @param userId String
   * @throws SQLException
   */
  private void processUpload(
      Connection conn,
      SEFFile upload,
      String filename,
      int sesId,
      int cagId,
      String period,
      String fiscalYear,
      String userId)
      throws SQLException {

    try (CallableStatement cStmt =
        conn.prepareCall("call SEF_UPLOAD_PKG.PROCESS_SEF(?,?,?,?,?,?,?)")) {
      cStmt.setString(1, upload.getFileName());
      cStmt.setString(2, filename);
      cStmt.setLong(3, sesId);
      // BCMOHAD-2182: CAG is not mandatory
      if (cagId > 0) cStmt.setLong(4, cagId);
      else cStmt.setNull(4, java.sql.Types.NUMERIC);
      cStmt.setString(5, period);
      cStmt.setString(6, fiscalYear);
      cStmt.setString(7, userId);
      cStmt.execute();
    } catch (SQLException e) {
      LOGGER.error(e.fillInStackTrace());
      throw e;
    }
  }

  /**
   * Parse the upload file, and return any errors if found
   *
   * @param contents byte[] - the file contents to parse
   * @param errors List<String> collection to store errors
   * @return List<String[]> the parsed rows
   * @throws IOException
   */
  public List<String[]> parseFile(byte[] contents, List<String> errors) throws IOException {
    BufferedReader reader =
        new BufferedReader(new InputStreamReader(new ByteArrayInputStream(contents)));
    List<String[]> rows = new ArrayList<>();
    String line = reader.readLine();
    int lineNo = 0;
    while (line != null) {
      lineNo++;
      String row[] = new String[15];
      boolean foundRow = false;
      if (line.length() == 161) {
        foundRow = true;
        row[0] = line.substring(0, 21);
        for (int i = 0; i < 14; i++) {
          int start = 21 + i * 10;
          int end = start + 10;
          row[i + 1] = line.substring(start, end);
        }
      } else if (line.length() == 217) {
        foundRow = true;
        row[0] = line.substring(0, 21);
        for (int i = 0; i < 14; i++) {
          int start = 21 + i * 14;
          int end = start + 14;
          row[i + 1] = line.substring(start, end);
        }
      } else {
        errors.add("Line " + lineNo + ": incorrect line length of " + line.length());
      }
      if (foundRow) {
        rows.add(row);
      }
      line = reader.readLine();
    }
    return rows;
  }
}
