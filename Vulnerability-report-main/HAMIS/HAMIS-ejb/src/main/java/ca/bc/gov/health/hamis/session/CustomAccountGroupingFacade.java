package ca.bc.gov.health.hamis.session;

import ca.bc.gov.health.hamis.dto.CustomAccountGroupingDto;
import ca.bc.gov.health.hamis.dto.FiscalYearDto;
import ca.bc.gov.health.hamis.entity.CustomAccount;
import ca.bc.gov.health.hamis.entity.CustomAccountGrouping;
import ca.bc.gov.health.hamis.entity.DataSubmitter;
import ca.bc.gov.health.hamis.exception.HamisException;
import ca.bc.gov.health.hamis.mapper.HamisMapper;
import ca.bc.gov.health.hamis.service.ICustomAccountGroupingFacade;
import jakarta.ejb.Stateless;
import jakarta.persistence.Query;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;
import lombok.val;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.mapstruct.factory.Mappers;

@Stateless
public class CustomAccountGroupingFacade extends AbstractFacade<CustomAccountGrouping>
    implements ICustomAccountGroupingFacade {

  private HamisMapper mapper = Mappers.getMapper(HamisMapper.class);

  private static final Logger LOG = LogManager.getLogger(CustomAccountGroupingFacade.class);

  public CustomAccountGroupingFacade() {
    super(CustomAccountGrouping.class);
  }

  /**
   * Returns summary data for CustomAccountGroupings by fiscal year and health organization -
   * including invalid rows
   *
   * @param fiscalYear String
   * @param hoId long
   * @return List<CustomAccountGroupingDto>
   */
  @Override
  public List<CustomAccountGroupingDto> getAllCustomAccountGroupingsSummary(
      final String fiscalYear, long hoId) {
    return getCags(fiscalYear, hoId, false);
  }

  /**
   * Returns summary data for CustomAccountGroupings by fiscal year and health organization - only
   * valid rows
   *
   * @param fiscalYear String
   * @param hoId long
   * @return List<CustomAccountGroupingDto>
   */
  @Override
  public List<CustomAccountGroupingDto> getValidCustomAccountGroupingsSummary(
      final String fiscalYear, long hoId) {
    return getCags(fiscalYear, hoId, true);
  }

  /**
   * Gets a list of Custom Account Groupings based on the provided params
   *
   * @param fiscalYear String
   * @param hoId long
   * @param filterToValid boolean
   * @return List<CustomAccountGroupingDto>
   */
  private List<CustomAccountGroupingDto> getCags(
      String fiscalYear, long hoId, boolean filterToValid) {
    String queryStr =
        "SELECT \n"
            + "cag.CAG_ID, cag.NAME, "
            + "(SELECT COUNT(*) FROM CUSTOM_ACCOUNTS ca WHERE ca.REVIEW_FLAG = 'Y' AND ca.CAG_ID = cag.CAG_ID AND ca.END_DT IS NULL ) INVALID_ROWS, "
            + "cag.DATE_MODIFIED, cag.CAG_FISCAL_YEAR \n"
            + "FROM CUSTOM_ACCOUNT_GROUPINGS cag, DATA_SUBMITTERS ds\n"
            + "WHERE cag.DS_ID = DS.DS_ID \n"
            + "AND cag.END_DT IS NULL \n"
            + "AND DS.HO_ID = ? AND cag.CAG_FISCAL_YEAR = ? \n"
            + "ORDER BY cag.NAME";
    Query query = getEntityManager().createNativeQuery(queryStr);
    query.setParameter(1, hoId);
    query.setParameter(2, fiscalYear);
    List<Object[]> results = query.getResultList();
    List<CustomAccountGroupingDto> out = new ArrayList<>();
    for (Object[] row : results) {
      int invalidRows = ((BigDecimal) row[2]).intValue();
      if (!filterToValid || invalidRows == 0) {
        CustomAccountGroupingDto dto = new CustomAccountGroupingDto();
        dto.setCagId(((BigDecimal) row[0]).longValue());
        dto.setName((String) row[1]);
        dto.setValid(invalidRows == 0);
        dto.setDateModified((Date) row[3]);
        dto.setFiscalYear(new FiscalYearDto());
        dto.getFiscalYear().setFiscalYear((String) row[4]);
        out.add(dto);
      }
    }
    return out;
  }

  @Override
  public List<CustomAccountGroupingDto> getCustomAccountGroupingsDetails(
      final String fiscalYear, long hoId) throws HamisException {
    LOG.debug("getCustomAccountGroupingList called with parameters fiscalYear and hoId");
    List<CustomAccountGroupingDto> customAccountGroupings =
        new ArrayList<CustomAccountGroupingDto>();

    Query cagQuery =
        getEntityManager().createNamedQuery("CustomAccountGrouping.findCAGForGivenDate");
    cagQuery.setParameter("fiscalYear", fiscalYear);
    cagQuery.setParameter("hoId", hoId);
    try {
      val results = cagQuery.getResultList();
      val filteredResults = filterByReviewFlag(results);
      for (val result : filteredResults) {

        customAccountGroupings.add(mapper.toDto((CustomAccountGrouping) result));
      }

    } catch (Exception e) {
      LOG.error(e);
      throw new HamisException(e.getMessage(), "");
    }

    return customAccountGroupings;
  }

  protected List<CustomAccountGrouping> filterByReviewFlag(List<CustomAccountGrouping> results) {

    // We want to return the list of GROUPING where there is NO customAccount with a revew_flag set
    // to Y.
    // if there is one customAccount with a review_FLAG to Y, we do NOT want to return it

    // return only getReviewFlag set with 'N' or 'NULL'
    List<CustomAccountGrouping> filteredResult =
        results.stream()
            .filter(
                result ->
                    result.getCustomAccounts().stream()
                        .allMatch(
                            customAccount ->
                                "N".equalsIgnoreCase(customAccount.getReviewFlag())
                                    || customAccount.getReviewFlag() == null))
            .collect(Collectors.toList());

    return filteredResult;
  }

  @Override
  public CustomAccountGroupingDto getCustomAccountGrouping(long cagId) {
    CustomAccountGrouping cag = getEntityManager().find(CustomAccountGrouping.class, cagId);
    List<CustomAccount> cas = new ArrayList<>();
    for (CustomAccount ca : cag.getCustomAccounts()) {
      if (ca.getEndDt() == null) {
        cas.add(ca);
      }
    }
    cag.setCustomAccounts(cas);
    return HamisMapper.INSTANCE.toDto(cag);
  }

  /**
   * Duplicates an existing Custom Account Grouping
   *
   * @param cagId int
   * @param duplicateName String
   * @param userName String
   */
  @Override
  public void duplicateCustomAccountMap(long cagId, String duplicateName, String userName) {
    copyCustomAccountMap(duplicateName, userName, cagId);
    copyCustomAccounts(userName, cagId);
  }

  /**
   * Soft Delete an existing Custom Account Grouping
   *
   * @param customAccount CustomAccountGroupingDto
   */
  @Override
  public void deleteCustomAccountMap(CustomAccountGroupingDto customAccount, String userName) {
    LOG.debug("Soft delete Custom Account Map: " + customAccount.getCagId());
    CustomAccountGrouping cag =
        getEntityManager().find(CustomAccountGrouping.class, customAccount.getCagId());
    java.util.Date d = new java.util.Date();
    cag.setUserModified(userName);
    cag.setEndDt(d);
    cag.setDateModified(d);
    // Going through the list of associated custom accounts
    if (cag.getCustomAccounts() != null)
      for (CustomAccount acc : cag.getCustomAccounts()) {
        acc.setEndDt(d);
        acc.setDateModified(d);
        acc.setUserModified(userName);
      }
    getEntityManager().merge(cag);
  }

  /**
   * Updates an existing Custom Account Grouping
   *
   * @param customAccount CustomAccountGroupingDto
   */
  @Override
  public void updateCustomAccountMap(CustomAccountGroupingDto customAccount) {
    LOG.debug("Updating Custom Account Map: " + customAccount.getCagId());
    CustomAccountGrouping cag =
        getEntityManager().find(CustomAccountGrouping.class, customAccount.getCagId());
    cag.setName(customAccount.getName());
    cag.setDateModified(customAccount.getDateModified());
    cag.setUserModified(customAccount.getUserModified());
    cag.setEndDt(customAccount.getEndDt());
    getEntityManager().merge(cag);
  }

  /**
   * Saves a new Custom Account Grouping
   *
   * @param customAccount CustomAccountGroupingDto
   * @return int - generated ID
   */
  @Override
  public long createCustomAccountMap(CustomAccountGroupingDto customAccount) {
    LOG.debug("Creating new Custom Account Map");
    CustomAccountGrouping cag = HamisMapper.INSTANCE.toModel(customAccount);
    cag.setCagId(null);
    cag.setDataSubmitter(new DataSubmitter());
    cag.getDataSubmitter().setDsId(customAccount.getDsId().getDsId());
    getEntityManager().persist(cag);
    return cag.getCagId();
  }

  /**
   * Copy the parent Custom Account Map to a new record with a new name
   *
   * @param newName String
   * @param userName String
   * @param cagId Long
   */
  private void copyCustomAccountMap(String newName, String userName, Long cagId) {
    LOG.debug("Duplicating Custom Account Map: " + cagId + " -> " + newName);
    String cagDuplicationQuery =
        "INSERT INTO CUSTOM_ACCOUNT_GROUPINGS "
            + "(CAG_ID,NAME,CAG_FISCAL_YEAR,DS_ID,EFF_DT,DATE_CREATED,USER_CREATED,DATE_MODIFIED,USER_MODIFIED) "
            + "SELECT "
            + "CAG_SEQ.nextval, ?, (SELECT FISCAL_YEAR FROM FISCAL_YEARS WHERE YEAR_TYPE = 'C'), cag.ds_id, cag.eff_dt, systimestamp , ?, systimestamp , ? "
            + "FROM CUSTOM_ACCOUNT_GROUPINGS cag "
            + "WHERE cag.cag_id = ?";
    Query insert = getEntityManager().createNativeQuery(cagDuplicationQuery);
    insert.setParameter(1, newName);
    insert.setParameter(2, userName);
    insert.setParameter(3, userName);
    insert.setParameter(4, cagId);
    insert.executeUpdate();
  }

  /**
   * Copy the child provider definitions for a cagId
   *
   * @param userName String
   * @param cagId Long
   */
  private void copyCustomAccounts(String userName, Long cagId) {
    LOG.debug("Duplicating custom accounts for : " + cagId);
    String caDuplicationQuery =
        "INSERT INTO CUSTOM_ACCOUNTS("
            + "CA_ID,"
            + "CAG_ID,"
            + "GL_LENGTH,"
            + "MPA_ID,"
            + "MSA_ID,"
            + "CA_TYPE,"
            + "FS_DATA_TYPE,"
            + "GENERAL_LEDGER_ACCT_NUMBER,"
            + "IGNORE_FLAG,"
            + "INVALID_ACCOUNT,"
            + "REVIEW_FLAG,"
            + "TOGGLE_SIGN_FLAG,"
            + "EFF_DT,"
            + "DATE_CREATED,"
            + "USER_CREATED,"
            + "DATE_MODIFIED,"
            + "USER_MODIFIED) "
            + "SELECT "
            + "CA_SEQ.nextval, "
            + "CAG_SEQ.currval, "
            + "ca.GL_LENGTH,"
            + "ca.MPA_ID,"
            + "ca.MSA_ID,"
            + "ca.CA_TYPE,"
            + "ca.FS_DATA_TYPE,"
            + "ca.GENERAL_LEDGER_ACCT_NUMBER,"
            + "ca.IGNORE_FLAG,"
            + "ca.INVALID_ACCOUNT,"
            + "ca.REVIEW_FLAG,"
            + "ca.TOGGLE_SIGN_FLAG,"
            + "ca.EFF_DT,"
            + "systimestamp , ?, systimestamp , ? "
            + "FROM CUSTOM_ACCOUNTS ca "
            + "WHERE ca.cag_id = ? AND ca.END_DT IS NULL";
    Query insert = getEntityManager().createNativeQuery(caDuplicationQuery);
    insert.setParameter(1, userName);
    insert.setParameter(2, userName);
    insert.setParameter(3, cagId);
    insert.executeUpdate();
  }
}
