/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.moh.addrvalidation.service;

import ca.bc.gov.moh.addrvalidation.audit.AddressValidationFileDropAudit;
import ca.bc.gov.moh.addrvalidation.config.Config;
import ca.bc.gov.moh.addrvalidation.config.ConfigType;
import ca.bc.gov.moh.addrvalidation.converter.AddressDoctorXMLToSoapEntityConverter;
import ca.bc.gov.moh.addrvalidation.converter.SoapEntityToAddressDoctorXMLConverter;
import ca.bc.gov.moh.addrvalidation.converter.StatusCodeValueMapper;
import ca.bc.gov.moh.addrvalidation.entity.wsdl.ArrayOfAddress;
import ca.bc.gov.moh.addrvalidation.entity.wsdl.ArrayOfEnrichment;
import ca.bc.gov.moh.addrvalidation.entity.wsdl.Parameters;
import ca.bc.gov.moh.addrvalidation.entity.wsdl.Response;
import ca.bc.gov.moh.addrvalidation.entity.wsdl.Address;
import ca.bc.gov.moh.addrvalidation.entity.wsdl.ArrayOfResult;
import ca.bc.gov.moh.addrvalidation.entity.wsdl.Result;
import ca.bc.gov.moh.addrvalidation.exception.AddressValidationException;
import java.io.IOException;
import java.util.Properties;
import java.util.logging.Level;
import javax.naming.NamingException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author killian.faussart
 */
public class AddressValidationProcessor {

    private static final Logger logger = LoggerFactory.getLogger(AddressValidationProcessor.class);
    private static final boolean BEFORE = true;
    private static final boolean AFTER = false;
    private static final String FILE_DROP_PATH = "fileDropPath";
    
    private final Parameters parameters;
    private final ArrayOfAddress addresses;
    private final ArrayOfEnrichment enrichments;
    private final AddressDoctorXMLToSoapEntityConverter respConverter;
    private final SoapEntityToAddressDoctorXMLConverter reqConverter;
    private final StatusCodeValueMapper statusCodeMapper;

    private final String transactionId;
    
    /**
     * We initialize the AddressDoctorValidator object.
     *
     * @param parameters this object will contain the ProcessMode
     * @param addresses this object will contain the address(es) to valid
     * @param enrichments this object
     * @param transactionId used for file drops
     */
    public AddressValidationProcessor(Parameters parameters, ArrayOfAddress addresses, ArrayOfEnrichment enrichments, String transactionId) throws IOException {
        this.parameters = parameters;
        this.addresses = addresses;
        this.enrichments = enrichments;
        this.transactionId = transactionId;
        this.respConverter = new AddressDoctorXMLToSoapEntityConverter();
        this.reqConverter = new SoapEntityToAddressDoctorXMLConverter();
        this.statusCodeMapper = new StatusCodeValueMapper();

    }

    public Response validate() throws AddressValidationException {

        AddressDoctorWrapper adWrapper = new AddressDoctorWrapper();
        Response response = new Response();

        try {

        ///////////////////////////////////////////////
            // 1. Set the Parameters
            ///////////////////////////////////////////////
            adWrapper.setParametersXML(reqConverter.convertParameters(parameters));

        ///////////////////////////////////////////////
            // 2. Process the addresses and build the results
            ///////////////////////////////////////////////
            ArrayOfResult results = new ArrayOfResult();
            for (Address addr : addresses.getAddress()) {

                String convertedAddr = reqConverter.convert(addr);
                
                try {
                    // Process the address
                    auditProcess(convertedAddr, BEFORE);
                    String result = adWrapper.processAddress(convertedAddr);
                    auditProcess(result, AFTER);
                    
                    // Add to results
                    results.getResult().add(respConverter.convert(result));
                            
                } catch (AddressValidationException e) {
                    // Throw the exception if the error code is not 1500, 1700, or 1701
                    if (!(e.getErrorCode() == 1500
                            || e.getErrorCode() == 1600
                            || e.getErrorCode() == 1700
                            || e.getErrorCode() == 1701)) {
                        throw e;
                    }
                    // Cannot validate address from given country. Set the ProcessStatus code to N2
                    Result resultN2 = new Result();
                    resultN2.setProcessStatus("N2");
                    resultN2.setCountryISO3(addr.getCountry().getString().get(0));
                    
                    // File drop the N2 ProcessStatus and CountryISO3 values
                    auditProcess(convertN2Result(resultN2), AFTER);
                    
                    // Add to results
                    results.getResult().add(resultN2);
                }

                adWrapper.clearData();

            }

        ///////////////////////////////////////////////
            // 3. Clean up
            ///////////////////////////////////////////////
            adWrapper.releaseAddress();

        ///////////////////////////////////////////////
            // 4. Finalize response
            ///////////////////////////////////////////////
            response.setResults(results);
            String[] finalStatus = statusCodeMapper.mapAddressDoctorStatusCode(adWrapper.getStatusCode());
            response.setStatusCode(Integer.parseInt(finalStatus[0]));
            response.setStatusMessage(finalStatus[1]);

        } catch (AddressValidationException ex) {
            //First we make sure the address is released and then we passed off the exception to the web service method
            try{
                adWrapper.releaseAddress();
            }catch(AddressValidationException e){
                //We don't add to the already exciting exception in that situation we just log the error
                logger.error(e.getMessage(),e);
            }
            
            throw ex;
        }

        return response;
    }
    
    private void auditProcess(String xml, boolean isBefore) {
        
        try {
            Properties appProps = Config.<Properties>getResource(ConfigType.APPLICATION_PROPERTIES);
            String fileDropPath = appProps.getProperty(FILE_DROP_PATH);

            AddressValidationFileDropAudit fileDrop = new AddressValidationFileDropAudit(fileDropPath, transactionId);
            fileDrop.dropAddressProcess(xml, isBefore);
            
        } catch (NamingException ex) {
            java.util.logging.Logger.getLogger(AddressValidationProcessor.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    /**
     * Converts a Result object with an N2 ProcessStatus (cannot validate country)
     * into an XML string for file drop auditing.
     * 
     * @param processStatusN2 Result
     * @return XML-formatted String with N2 ProcessStatus and searched country
     */
    private String convertN2Result (Result resultN2) {
        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                + "<Result>\r\n"
                + "\t<ProcessStatus>N2</ProcessStatus>\r\n"
                + "\t<CountryISO3>" + resultN2.getCountryISO3() + "</CountryISO3>\r\n"
                + "</Result>";
    }
    
}
