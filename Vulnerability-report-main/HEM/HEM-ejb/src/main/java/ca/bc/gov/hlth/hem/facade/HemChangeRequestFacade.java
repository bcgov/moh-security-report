package ca.bc.gov.hlth.hem.facade;

import ca.bc.gov.hlth.hem.entity.*;
import java.sql.Timestamp;
import java.time.Instant;

import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.*;
import javax.persistence.criteria.CriteriaBuilder.In;
import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

@Stateless
public class HemChangeRequestFacade extends AbstractFacade<HemChangeRequest> implements HemChangeRequestFacadeLocal {

    private static final String CLASSNAME = HemChangeRequestFacade.class.getSimpleName();
    private static final Logger LOGGER = Logger.getLogger(CLASSNAME);

    @PersistenceContext(unitName = "HEM-pu")
    private EntityManager em;

    @Override
    protected EntityManager getEntityManager() {
        return em;
    }

    public HemChangeRequestFacade() {
        super(HemChangeRequest.class);
    }

    @Override
    public HemChangeRequest find(Object id) {
        return em.find(HemChangeRequest.class, id);
    }

    @Override
    public List<HemChangeRequest> findAll() {
        Query query = em.createNamedQuery("HemChangeRequest.findAll");
        query.setParameter("archived", false);
        return query.getResultList();
    }

    /**
     * Find a list of change request by their rfc link
     *
     * @param param String rfc link
     * @return return a change request by his rfc link
     */
    @Override
    public HemChangeRequest findByRfcId(Integer param) {
        Query query = em.createNamedQuery("HemChangeRequest.findByChangeReqId");
        query.setParameter("changeRequestId", param);
        return (HemChangeRequest) query.getSingleResult();
    }

    @Override
    public List<HemChangeRequest> findByTimeInterval(Date startDate, Date endDate) {
        Query query = em.createNamedQuery("HemChangeRequest.findByTimeInterval");
        query.setParameter("startDate", startDate);
        query.setParameter("endDate", endDate);
        return query.getResultList();
    }

    /**
     * Find a list of change request by a time interval.
     *
     * @param startDate
     * @param endDate
     * @param approved
     * @param onDemand
     * @return return a list of change request by a time interval.
     */
    @Override
    public List<HemChangeRequest> findByTimeInterval(Date startDate, Date endDate, boolean approved, boolean onDemand) {
        Query query = em.createNamedQuery("HemChangeRequest.findByTimeIntervalApproved");
        query.setParameter("startDate", startDate);
        query.setParameter("endDate", endDate);
        query.setParameter("approved", approved);
        query.setParameter("onDemand", onDemand);
        return query.getResultList();
    }

    /**
     * Find a list of change request by a time interval.
     *
     * @param startDate
     * @param endDate
     * @param environments
     * @param rfcTypes
     * @param approved
     * @param onDemand
     * @return return a list of change request by a time interval.
     */
    @Override
    public List<HemChangeRequest> findByTimeIntervalEnvRFC(Date startDate, Date endDate, List<HemEnvironment> environments, List<HemChangeCategory> rfcTypes, boolean approved, boolean onDemand) {
        Query query = em.createNamedQuery("HemChangeRequest.findByTimeIntervalEnvRFC");
        query.setParameter("startDate", startDate);
        query.setParameter("endDate", endDate);
        query.setParameter("environments", environments);
        query.setParameter("rfcTypes", rfcTypes);
        query.setParameter("approved", approved);
        query.setParameter("onDemand", onDemand);
        return query.getResultList();
    }

    /**
     * Find a list of change request by a time interval.
     *
     * @param startDate
     * @param endDate
     * @param environments
     * @param approved
     * @param onDemand
     *
     * @return return a list of change request by a time interval.
     */
    @Override
    public List<HemChangeRequest> findByTimeIntervalEnv(Date startDate, Date endDate, List<HemEnvironment> environments, boolean approved, boolean onDemand) {
        Query query = em.createNamedQuery("HemChangeRequest.findByTimeIntervalEnv");
        query.setParameter("startDate", startDate);
        query.setParameter("endDate", endDate);
        query.setParameter("environments", environments);
        query.setParameter("approved", approved);
        query.setParameter("onDemand", onDemand);
        return query.getResultList();
    }

    /**
     * Find a list of change request by a time interval.
     *
     * @param startDate
     * @param endDate
     * @param rfcTypes
     * @param approved
     * @param onDemand
     * @return return a list of change request by a time interval.
     */
    @Override
    public List<HemChangeRequest> findByTimeIntervalRFC(Date startDate, Date endDate, List<HemChangeCategory> rfcTypes, boolean approved, boolean onDemand) {
        Query query = em.createNamedQuery("HemChangeRequest.findByTimeIntervalRFC");
        query.setParameter("startDate", startDate);
        query.setParameter("endDate", endDate);
        query.setParameter("rfcTypes", rfcTypes);
        query.setParameter("approved", approved);
        query.setParameter("onDemand", onDemand);
        return query.getResultList();
    }

    @Override
    public List<HemChangeRequest> filtersData(
            Date startDate,
            Date endDate,
            List<HemEnvironment> environments,
            List<HemChangeCategory> categories,
            Boolean approved,
            Boolean onDemand,
            HemUser assignedToMeFilter,
            List<HemTeam> assignedToMyTeamsFilter) {

        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<HemChangeRequest> criteriaQuery = cb.createQuery(HemChangeRequest.class);
        Root<HemChangeRequest> rootChange = criteriaQuery.distinct(true).from(HemChangeRequest.class);
        List<Predicate> criterias = new ArrayList<>();

        // date search
        if (startDate != null) {
            criterias.add(cb.greaterThanOrEqualTo(rootChange.<Date>get("startDate"), startDate));
        }

        if (endDate != null) {
            criterias.add(cb.lessThanOrEqualTo(rootChange.<Date>get("endDate"), endDate));
        }

        // Environment filter
        if (environments != null && !environments.isEmpty() && environments.size() > 0) {
            Expression<HemEnvironment> environmentFilter = rootChange.get("fkHemEnvironment");
            Predicate predicateEnvironment = environmentFilter.in(environments);
            criterias.add(predicateEnvironment);
        }

        // Category filter
        if (categories != null && !categories.isEmpty() && categories.size() > 0) {
            Expression<HemChangeCategory> categoryFilter = rootChange.get("hemCategory");
            Predicate predicateCategory = categoryFilter.in(categories);
            criterias.add(predicateCategory);
        }

        // Approval filter
        if (approved != null && approved) {
            Expression<Boolean> approvalRFC = rootChange.get("approvalFlag");
            Predicate predicateApproval = cb.equal(approvalRFC, true);
            criterias.add(predicateApproval);
        }

        // On demand filter
        if (onDemand != null && onDemand) {
            Expression<Boolean> onDemandFlag = rootChange.get("onDemand");
            Predicate predicateOnDemand = cb.equal(onDemandFlag, true);
            criterias.add(predicateOnDemand);
        }

        // Archived filter
        Expression<Boolean> archivedFlag = rootChange.get("archived");
        Predicate predicateArchived = cb.equal(archivedFlag, false);
        criterias.add(predicateArchived);

        // change implementers
        // Assigned to me filter
        // Assigned do my teams filter
        if (assignedToMeFilter != null || assignedToMyTeamsFilter != null) {
            List<HemUser> changeImplementersFilter = new ArrayList();
            if (assignedToMeFilter != null) {
                changeImplementersFilter.add(assignedToMeFilter);
            }
            if (assignedToMyTeamsFilter != null) {
                assignedToMyTeamsFilter.forEach((team) -> {
                    changeImplementersFilter.addAll(team.getTeamMembers());
                });
            }
            if (changeImplementersFilter.size() > 0) {
                In<Integer> inAssignment = cb.in(rootChange.get("changeImplementers"));
                changeImplementersFilter.forEach((member) -> {
                    inAssignment.value(member.getUserId());
                });
                criterias.add(inAssignment);
            }
        }

        // Applying filter
        criteriaQuery.where(cb.and(criterias.toArray(new Predicate[0])));
        TypedQuery<HemChangeRequest> query = em.createQuery(criteriaQuery);

        // Date filter
        query.setParameter("startDate", startDate);
        query.setParameter("endDate", endDate);

        // Environment filter
        if (environments != null && !environments.isEmpty() && environments.size() > 0) {
            query.setParameter("hemEnvironment", environments);
        }

        // Category filter
        if (categories != null && !categories.isEmpty() && categories.size() > 0) {
            query.setParameter("hemCategory", categories);
        }

        // Approval filter
        if (approved != null && approved) {
            query.setParameter("approvalFlag", approved);
        }

        // Ondemand filter
        if (onDemand != null && onDemand) {
            query.setParameter("onDemand", onDemand);
        }

        // Always remove the archived items from the list
        // We keep the archived items for not bring data corruption.
        query.setParameter("archived", false);

        return query.getResultList();
    }

    @Override
    public void create(HemChangeRequest h, String username) {
        h.setCreatedBy(username);
        h.setCreatedDate(Timestamp.from(Instant.now()));

        h.setLastModifiedBy(username);
        h.setLastModifiedDate(Timestamp.from(Instant.now()));

        try {
            em.persist(h);
        } catch (Exception e) {
            ConstraintViolationException ve = (ConstraintViolationException) e.getCause();
            Set<ConstraintViolation<?>> violations = ve.getConstraintViolations();
            LOGGER.log(Level.SEVERE, violations.toString());
        }
    }

    @Override
    public void edit(HemChangeRequest h, String username) {
        h.setLastModifiedBy(username);
        // No need anymore to update the last modified date.
        // This is handle by the database engine directly.
     //   h.setLastModifiedDate(Timestamp.from(Instant.now()));

        em.merge(h);

    }

    @Override
    public void remove(HemChangeRequest h, String username) {
        h.setArchived(true);
        h.setArchivedBy(username);
        h.setArchivedDate(Timestamp.from(Instant.now()));

        edit(h);
    }
}
