package ca.bc.gov.hlth.hem.utils;

import ca.bc.gov.hlth.hem.entity.HemChangeCategory;
import ca.bc.gov.hlth.hem.entity.HemEnvironment;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author CGI Information Management Consultants Inc.
 */
public final class ReleaseWindowHelper {

    private static final String CLASSNAME = ReleaseWindowHelper.class.getSimpleName();
    private static final Logger LOGGER = Logger.getLogger(CLASSNAME);

    private static final int DEADLINE_HOURS = 16;
    private static final int DEADLINE_MINUTES = 30;

    /*  
        This Enum consist of several hardcoded values to allow clearer mapping between
        stringy-fied day names and bitmask association. 
     */
    public enum Day {
        None("none", 0, 0x0000000),
        Sunday("sunday", Calendar.SUNDAY, 0x0000001),
        Monday("monday", Calendar.MONDAY, 0x0000010),
        Tuesday("tuesday", Calendar.TUESDAY, 0x0000100),
        Wednesday("wednesday", Calendar.WEDNESDAY, 0x0001000),
        Thursday("thursday", Calendar.THURSDAY, 0x0010000),
        Friday("friday", Calendar.FRIDAY, 0x0100000),
        Saturday("saturday", Calendar.SATURDAY, 0x1000000);

        Day(final String dayName, final int day, final int bitmask) {
            this.dayName = dayName;
            this.bitmask = bitmask;
            this.day = day;
        }

        final int bitmask;
        final int day;
        final String dayName;

        public int getBitmask() {
            return this.bitmask;
        }

        public String getDayName() {
            return this.dayName;
        }

        public int intValue() {
            return day;
        }

        public static Day convertToDay(String dayName) {

            if (dayName == null) {
                LOGGER.log(Level.INFO, "Provided day is null, expected values: \n"
                        + "\t- [Sunday], [Monday], [Tuesday], [Wednesday], [Thursday], [Friday] and [Saturday]");
                return Day.None;
            }

            String normalizedDayName = dayName.toLowerCase();

            for (Day day : Day.values()) {
                if (day.getDayName().equals(normalizedDayName)) {
                    return day;
                }
            }
            return Day.None;
        }
    }

    ReleaseWindowHelper() {
    }

    /**
     * Check if given date and environment respect pre-established release day
     * for RFC(Request For Change)
     * <p>
     * If the change category correspond to a category that is overrided, the
     * rule is ignored
     * <p>
     * Release days goes as configured in the environment window
     * <p>
     *
     *
     * @param plannedStartDate Date of the expected start of the RFC
     * @param category Category of RFC
     * @param environment Environment of the RFC
     * @return true if the RFC planned date is valid
     *
     */
    public static boolean IsReleaseDayValid(Date plannedStartDate, HemChangeCategory category, HemEnvironment environment) {

        if (category.isCategoryReleaseOverride()) {
            return true;
        }

        Calendar cal = Calendar.getInstance();
        cal.setTime(plannedStartDate);

        int plannedDay = cal.get(Calendar.DAY_OF_WEEK);

        Day releaseDay = Day.values()[plannedDay];

        return (releaseDay.bitmask & environment.getEnvironmentReleaseInfo()) > 0;
    }

    /**
     * Check if given date and environment respect pre-established release
     * window for RFC(Request For Change)
     * <p>
     * If the change category correspond to : Standard, urgent or emergency the
     * rule is ignored
     * <p>
     * Release windows goes as follow based on <strong>creating date of the
     * RFC</strong>:
     * <p>
     * <strong>Test/Staging deadlines</strong>
     * <br>Tuesday release : the day before 16:30
     * <br>Thursday release : the day before 16:30
     * <p>
     * <strong>Production deadline</strong>
     * <br>Wednesday release : a week earlier, the Friday before 16:30
     *
     * @param creationDate Date of creation of the RFC
     * @param plannedStartDate Date of the expected start of the RFC
     * @param category Category of RFC
     * @param environment Environment of the RFC
     * @return true if the RFC creation date is valid
     *
     */
    public static boolean IsReleaseWindowValid(Date creationDate, Date plannedStartDate, HemChangeCategory category, HemEnvironment environment) {

        if (category.isCategoryReleaseOverride()) {
            return true;
        }

        Calendar cal = Calendar.getInstance();
        cal.setTime(plannedStartDate);

        int releaseTimeInDay = environment.getEnvironmentReleaseWindow();

        int deadlineEndHour = DEADLINE_HOURS;
        int deadlineEndMinute = DEADLINE_MINUTES;

        //Quick check if the deadline found in the database is valid
        setupDeadlineInfo(
                environment.getEnvironmentReleaseDeadline(),
                deadlineEndHour,
                deadlineEndMinute);

        cal.add(Calendar.DAY_OF_MONTH, -releaseTimeInDay);
        cal.set(Calendar.DAY_OF_WEEK, Calendar.FRIDAY);//->Toujours avant la fds

        //We ensure that we are at the 16:30 deadline
        cal.set(Calendar.HOUR_OF_DAY, deadlineEndHour);
        cal.set(Calendar.MINUTE, deadlineEndMinute);

        return creationDate.before(cal.getTime());
    }

    public static void setupDeadlineInfo(String deadlineData, int hours, int minutes) {
        String errorMessage
                = "Error while trying to evaluate deadline hours, please follow expected format: HH:MM";

        String[] tokenized = null;
        if (deadlineData != null) {
            tokenized = deadlineData.split(":");
        }

        if (tokenized == null || tokenized.length < 2) {
            LOGGER.log(Level.SEVERE, errorMessage);
            return;
        }

        try {
            hours = Integer.parseInt(tokenized[0]);
            minutes = Integer.parseInt(tokenized[1]);
        } catch (NumberFormatException e) {
            LOGGER.log(Level.SEVERE, errorMessage);
        }
    }

    public static void setDayReleasable(HemEnvironment hemEnvironment, Day releaseDay, boolean releasable) {

        int storedValue = hemEnvironment.getEnvironmentReleaseInfo();

        if (releasable) {
            storedValue |= releaseDay.getBitmask();
        } else {
            storedValue &= ~releaseDay.getBitmask();
        }

        hemEnvironment.setEnvironmentReleaseInfo(storedValue);
    }

    public static boolean isDayReleasable(HemEnvironment hemEnvironment, Day releaseDay) {
        return (hemEnvironment.getEnvironmentReleaseInfo() & releaseDay.getBitmask()) > 0;
    }

    public static String getPrettyfiedReleaseableDays(HemEnvironment env) {

        StringBuilder sb = new StringBuilder();
        int count = 0;

        //Lazyly iterating over the enum of helper class
        for (int index = Day.Sunday.intValue(); index < Day.Saturday.intValue(); index++) {

            //Only adding releasable days
            if (isDayReleasable(env, Day.values()[index])) {
                sb.append(Day.values()[index].getDayName());
                sb.append(", ");

                count++;
            }
        }

        if (count == 0) {
            return "no release day has been set";
        }

        //Since we dont need trailing caracters
        sb.delete(sb.length() - 2, sb.length());

        return sb.toString();
    }
}
