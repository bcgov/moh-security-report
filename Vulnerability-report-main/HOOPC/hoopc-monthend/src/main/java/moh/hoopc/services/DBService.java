package moh.hoopc.services;

import java.sql.*;
import java.util.*;
import moh.hoopc.services.input.*;
import moh.hoopc.services.output.*;
import moh.hoopc.services.util.*;
import org.apache.log4j.Logger;

/**
 * @author Eric Bregeon
 * @version 1.0
 * @copyright Licensed Materials - Property of IBM - Copyright IBM Canada Ltd. 2003. All Rights
 *     Reserved
 * @security IBM Confidential
 * @date 02 November 2004
 * @revision Last Revision Name Comments
 * @revision ==========================================================================
 * @revision 02 November 2004 Eric Bregeon Created.
 * @see
 */
public abstract class DBService implements IErrorText {

  private Logger logger = Logger.getLogger(DBService.class.getName());

  private Input input;
  private Output output;
  private Properties properties;
  private ErrorBeanList errorBeanList = new ErrorBeanList();

  protected static final int ORACLE_OK = 0;
  // DB Statement to be run in the tx
  private CallableStatement cstmt;

  public DBService(Input input, Output output, Properties properties) {
    this.input = input;
    this.output = output;
    this.properties = properties;
  }

  public Input getInputBean() {
    return input;
  }

  public Output getOutputBean() {
    return output;
  }

  public ErrorBeanList getErrorBeanList() {
    return errorBeanList;
  }

  /**
   * Test validity of base input parameters Throws validation exception if reguirments are not met
   */
  protected void validateInput() throws ValidationException {
    DBInput input = (DBInput) getInputBean();
    if (input.getConnection() == null) {
      addError(HOOPC0002);
    }
  }

  /** Passes cstmt on to subclass services setResponse method */
  protected void setResponse(CallableStatement cstmt) throws SQLException, ServiceFailedException {
    setOutputBean(cstmt);
  }

  /**
   * Implmented in sublclass to package values returned in cstmt into the the services output bean
   *
   * @param CallableStatement cstmt
   */
  protected abstract void setOutputBean(CallableStatement cstmt)
      throws SQLException, ServiceFailedException;

  /**
   * Implmented in sublclass to create oracle stored procedure call in cstmt
   *
   * @param CallableStatement cstmt
   */
  protected abstract CallableStatement createStatement(CallableStatement cstmt) throws SQLException;

  protected void addMessage(String errorId, String errorMessage) {
    ErrorBean errorBean = new ErrorBean(errorId, errorMessage);
    errorBeanList.addError(errorBean);
  }

  public void process() throws ServiceFailedException, ValidationException {
    validateInput();
    if (!errorBeanList.isEmpty()) throw new ValidationException(errorBeanList);

    try {
      cstmt = createStatement(cstmt);
      executeStatement(cstmt);
      setOutputBean(cstmt);
    } catch (SQLException ex) {
      logger.error("SQLException occured: ", ex);
      ex.printStackTrace();
      addError(HOOPC0003);
      // throw new ServiceFailedException(errorBeanList);
      throw new ServiceFailedException(ex.toString());
    } finally {
      try {
        // close the statement
        if (cstmt != null) {
          cstmt.close();
          cstmt = null;
        }
      } catch (SQLException ex) {
        addError(HOOPC0003);
        throw new ServiceFailedException(errorBeanList);
      }
    }
  }

  /**
   * This method executes the service transaction
   *
   * @param CallableStatement cstmt
   */
  private CallableStatement executeStatement(CallableStatement cstmt)
      throws ServiceFailedException, SQLException {
    cstmt.execute();
    return cstmt;
  }

  void addError(String errorCode) {
    try {
      String errorText = getErrorText(errorCode);
      ErrorBean errorBean = new ErrorBean(errorCode, errorText);
      errorBeanList.addError(errorBean);
    } catch (Exception e) {
    }
  }

  void addError(String errorCode, String extraText) {
    try {
      String errorText = getErrorText(errorCode);
      ErrorBean errorBean = new ErrorBean(errorCode, errorText + " " + extraText);
      errorBeanList.addError(errorBean);
    } catch (Exception e) {
    }
  }

  /**
   * Return a text error from the Properties file.
   *
   * @return java.lang.String
   */
  private String getErrorText(String error) {
    // String text = properties.getProperty(error);
    if (error == null) return ("No Text Error");
    else return error;
  }
}
