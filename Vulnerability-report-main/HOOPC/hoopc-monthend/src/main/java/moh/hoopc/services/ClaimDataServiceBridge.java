package moh.hoopc.services;

import ca.bc.gov.health.constants.ClaimType;
import ca.bc.gov.health.constants.GlobalConstants;
import ca.bc.gov.health.constants.ResidencyType;
import ca.bc.gov.health.database.entity.ClaimAdjustments;
import ca.bc.gov.health.database.entity.ClaimTypes;
import ca.bc.gov.health.database.entity.ResidencyTypes;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.service.ClaimService;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.viewmodel.AdmissionsViewModel;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.PatientsViewModel;
import jakarta.enterprise.inject.spi.CDI;
import jakarta.transaction.Transactional;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.sql.Connection;
import java.text.MessageFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import moh.hoopc.app.Claim;
import moh.hoopc.app.Ric;
import moh.hoopc.app.Roc;
import moh.hoopc.services.util.ServiceFailedException;
import moh.hpc.month.end.Runner;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** @author christian.hudon */
public class ClaimDataServiceBridge extends ClaimDataService {
  private static Logger logger = LoggerFactory.getLogger(ClaimDataServiceBridge.class);

  ClaimService claimService;
  HoopcAppService appService;
  Runner runner;

  public ClaimDataServiceBridge(String hostname, String port, String sid, String uid, String pwd,
      int dbConnectTimeOut, int dbQueryTimeOut, String userId, String sessionId)
      throws ServiceFailedException {
    super(hostname, port, sid, uid, pwd, dbConnectTimeOut, dbQueryTimeOut, userId, sessionId);
    claimService = CDI.current().select(ClaimService.class).get();
    appService = CDI.current().select(HoopcAppService.class).get();
    runner = CDI.current().select(Runner.class).get();
    this.con = runner.getEm().unwrap(Connection.class);
    runner.getEm().joinTransaction();
  }

  public ClaimDataServiceBridge(Connection con, String userId, String sessionId) {
    super(con, userId, sessionId);
    claimService = CDI.current().select(ClaimService.class).get();
    appService = CDI.current().select(HoopcAppService.class).get();
  }

  @Override
  public Roc createClaim(Roc claim) throws ServiceFailedException {
    ClaimViewModel newClaimModel = toNewModel(ClaimType.OUTPATIENT, ResidencyType.RES, claim);

    Long claimId = createClaim(newClaimModel);

    // TODO remap to old model? For now just return original.
    return claim;
  }

  @Override
  public Ric createClaim(Ric claim) throws ServiceFailedException {
    ClaimViewModel newClaimModel = toNewModel(ClaimType.INPATIENT, ResidencyType.RES, claim);

    Long claimId = createClaim(newClaimModel);

    // TODO remap to old model? For now just return original.
    return claim;
  }

  @Override
  public Roc createAdj(Roc claim) throws ServiceFailedException {
    return (Roc) createAdjustmentDecision(claim, GlobalConstants.OUTPATIENT_CLAIM_TYPE);
  }

  @Override
  public Ric createAdj(Ric claim) throws ServiceFailedException {
    return (Ric) createAdjustmentDecision(claim, GlobalConstants.INPATIENT_CLAIM_TYPE);
  }

  @Transactional
  protected Claim createAdjustmentDecision(Claim claim, String claimType)
      throws ServiceFailedException {
    logger.info(MessageFormat.format(
        "Create adjustment for service date {0}, admision date {1}, amount {2}",
        claim.getServiceDate(), claim.getAdmissionDate(), claim.getTotalAmountClaimed()));
    try {
      // Find matching claim (throws exception if not found or more that one found)
      ClaimViewModel matching = findMatchingClaim(claim, claimType);

      ClaimAdjustments request = matching.getClaimAdjustmentsRequest();
      ClaimAdjustments decision = matching.getClaimAdjustmentsDecision();

      if (decision == null) {
        // Create if no decision, override if decision exists 
        decision = new ClaimAdjustments(GlobalConstants.CLAIM_ADJ_DEC_TYPE);
        matching.setClaimAdjustmentsDecision(decision);
      }  
      decision.setAmount(BigDecimal.valueOf(claim.getTotalAmountClaimed()));
      decision.setAdjustmentDate(LocalDate.now());
      decision.setAdjustmentStatus(GlobalConstants.CLAIM_ADJ_DEC_APP);
      claimService.saveClaimDecision(matching);

      if (request != null) {
        request.setAdjustmentStatus(GlobalConstants.CLAIM_ADJ_DEC_APP);
        claimService.saveClaimRequest(matching);
      } else {
        // Not an error. Can have decision without request.
      }

    } catch (HoopcException e) {
      throw new ServiceFailedException("Error calling new createAdj", e);
    }
    return claim;
  }

  protected ClaimViewModel findMatchingClaim(Claim claim, String claimType) throws HoopcException {
    Long matchingClaim = null;
    ClaimTypes cType = appService.getClaimType(claimType);
    ResidencyTypes resType = appService.getResidencyType(GlobalConstants.RES_RESIDENCY_TYPE);
    if (!StringUtils.isBlank(claim.getProvincialClaimNumber())) {
      // Find by provincialClaimNumber
      // NOTE: Was in old code but looks like this field is always null.
      logger.info(MessageFormat.format("Find by provincialClaimNumber {0}",
          claim.getProvincialClaimNumber()));
      matchingClaim = claimService.findByProvincialClaimNumber(cType, resType,
          claim.getProvincialClaimNumber());
    } else {
      // Find by insuranceNumber, hospitalNumber, birthDate, serviceDate/admissionDate and
      // totalAmount
      String insuranceNumber = claim.getInsuranceNumber();
      LocalDate birthDate = toLocalDate(claim.getBirthDate());
      String hospitalNumber = claim.getHospitalNumber();
      // NOTE: assumes that serviceDate == admission.admissionDate for inpatient claims. old app
      // used to query admissionDate for inpatient.
      LocalDate serviceDate = null;
      if (GlobalConstants.INPATIENT_CLAIM_TYPE.contentEquals(claimType)) {
        serviceDate = toLocalDate(claim.getAdmissionDate()); 
        }
      else {
        serviceDate = toLocalDate(claim.getServiceDate()); 
      }
      BigDecimal totalAmount = BigDecimal.valueOf(claim.getTotalAmountClaimed());

      logger.info(MessageFormat.format("findMatchingClaim ({0}, {1}, {2}, {3}, {4})",
          insuranceNumber, birthDate, hospitalNumber, serviceDate, totalAmount));
      matchingClaim = claimService.findMatchingClaim(cType, resType, insuranceNumber, birthDate,
          hospitalNumber, serviceDate, totalAmount);
    }

    if (matchingClaim == null) {
      // NOTE: Should not normally get here. Previous ME validation steps have already validated
      // that there is one. If here, there is a bug with the query
      throw new HoopcException("Could not find matching claim");
    }

    return claimService.loadClaim(matchingClaim);
  }


  protected Long createClaim(ClaimViewModel newClaim) throws ServiceFailedException {
    try {
      LocalDateTime begin = LocalDateTime.now();
      Long claimId = claimService.createClaim(newClaim);
      LocalDateTime end = LocalDateTime.now();
      logger.info(MessageFormat.format("Create claim {0} : {1} ms", claimId,
          ChronoUnit.MILLIS.between(begin, end)));
      return claimId;
    } catch (HoopcException e) {
      throw new ServiceFailedException("Error calling new ClaimService", e);
    }
    // TODO process validation errors
  }

  /**
   * Creates a new ClaimViewModel from a old Claim model. Maps only fields used in SADetailRecord
   * and general claim info. Other fields should not be used by MountEnd process.
   *
   * @param claimType
   * @param residencyType
   * @param oldModel
   * @return
   */
  protected ClaimViewModel toNewModel(ClaimType claimType, ResidencyType residencyType,
      Claim oldModel) {

    ClaimViewModel newModel = new ClaimViewModel();

    // Set ResidencyType and ClaimType (Non-Resident Outpatient)
    newModel.setResidencyType(appService.getResidencyType(residencyType.name()));
    newModel.setClaimType(appService.getClaimType(claimType.name()));
    newModel.setClaimSource("IMPORT");
    newModel.setStatusCode("PENDING");
    // TODO ICD10 hardcoded
    newModel.setIcdCodingScheme("ICD10");

    // Claim data
    newModel.setProvincialClaimId(oldModel.getProvincialClaimNumber());
    newModel.setHospitalNumberAndName(oldModel.getHospitalNumber());
    newModel.setTreatingProvince(oldModel.getTreatingProvince());

    newModel.setServiceCodeValue(oldModel.getServiceCode());
    newModel.setServiceDate(toLocalDate(oldModel.getServiceDate()));
    newModel.setAccidentCode(oldModel.getAccidentCode());
    newModel.setAccidentIndicator(oldModel.getAccidentIndicator());
    newModel.setTotalAmountClaimed(toBigDecimal(oldModel.getTotalAmountClaimed()));
    newModel.setHospitalNotes(oldModel.getNotes());

    // Patient data
    newModel.setPatient(new PatientsViewModel());
    newModel.getPatient().setInsuranceCardNumber(oldModel.getInsuranceNumber());
    newModel.getPatient().setCardExpiryDate(toLocalDate(oldModel.getInsuranceCardExpiryDate()));
    newModel.getPatient().setFirstName(oldModel.getFirstName());
    newModel.getPatient().setLastName(oldModel.getLastName());
    newModel.getPatient().setAddress1(oldModel.getAddress1());
    newModel.getPatient().setAddress2(oldModel.getAddress2());
    newModel.getPatient().setCity(oldModel.getCity());
    newModel.getPatient().setProvince(oldModel.getProvince());
    newModel.getPatient().setPostalCode(oldModel.getPostalCode());
    newModel.getPatient().setSexCode(oldModel.getGender());
    newModel.getPatient().setBirthDate(toLocalDate(oldModel.getBirthDate()));
    newModel.getPatient().setDeceasedFlag(oldModel.getDeceasedFlag());

    // Admission data
    newModel.setAdmission(new AdmissionsViewModel());
    newModel.getAdmission().setAdmissionDate(toLocalDate(oldModel.getAdmissionDate()));
    newModel.getAdmission().setDischargeDate(toLocalDate(oldModel.getDischargeDate()));
    newModel.getAdmission().setTotalDaysStay(oldModel.getTotalDaysStay());
    newModel.getAdmission().setLongTermStayInd(oldModel.getLongTermFlag());
    newModel.getAdmission().setTotalDaysStay(oldModel.getTotalDaysStay());
    newModel.getAdmission().setWardRate(toInt(oldModel.getPerDiemRate()));

    // Diagnostic, procedure and highcost codes
    newModel.getDiagnosisCodes()[0] = oldModel.getDiagnosis1();
    newModel.getDiagnosisCodes()[1] = oldModel.getDiagnosis2();
    newModel.getDiagnosisCodes()[2] = oldModel.getDiagnosis3();
    newModel.getProcedureCodes()[0] = oldModel.getProcedure1();
    newModel.getProcedureCodes()[1] = oldModel.getProcedure2();
    newModel.getProcedureCodes()[2] = oldModel.getProcedure3();
    newModel.getHighCostProcedures()[0].setCodeValue(oldModel.getHighCost1Code());
    newModel.getHighCostProcedures()[1].setCodeValue(oldModel.getHighCost2Code());
    newModel.getHighCostProcedures()[2].setCodeValue(oldModel.getHighCost3Code());
    newModel.getHighCostProcedures()[0].setProcedureDate(toLocalDate(oldModel.getHighCost1Date()));
    newModel.getHighCostProcedures()[1].setProcedureDate(toLocalDate(oldModel.getHighCost2Date()));
    newModel.getHighCostProcedures()[2].setProcedureDate(toLocalDate(oldModel.getHighCost3Date()));

    return newModel;
  }

  private BigDecimal toBigDecimal(Double totalAmountClaimed) {
    if (totalAmountClaimed == null)
      return null;
    return BigDecimal.valueOf(totalAmountClaimed).setScale(2, RoundingMode.HALF_EVEN);
  }

  private Integer toInt(Double perDiemRate) {
    if (perDiemRate == null)
      return null;
    return perDiemRate.intValue();
  }

  private LocalDate toLocalDate(Date oldDate) {
    if (oldDate == null)
      return null;
    return oldDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
  }

}
