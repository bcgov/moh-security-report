/**
 * ****************************************************************************** Licensed Materials
 * - Property of IBM * Copyright IBM Canada Ltd 2005 All Rights Reserved * Created on Feb 15, 2005 *
 * ****************************************************************************** Please do not
 * makes any changes to this file without first * updating the revision history below, under
 * description * please include Harvest Change Request or PSO Tools CR that * caused the change. *
 * ****************************************************************************** Revision History:
 * * * Date Name Description * ---------- ----------------
 * --------------------------------------------- * 02-15-2005 David Bartlett Initial Spec *
 * ******************************************************************************
 */
package moh.hpc.month.end.nonresident.processors;

import jakarta.enterprise.context.Dependent;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Hashtable;
import java.util.Properties;
import moh.hpc.month.end.constants.PropertyFileKeys;
import moh.hpc.month.end.exceptions.ProcessException;
import moh.hpc.month.end.services.MEDataService;
import moh.hpc.month.end.support.HospitalDetails;
import moh.hpc.month.end.support.ProvTransitionsStats;
import moh.hpc.month.end.support.Province;
import moh.hpc.month.end.support.Reports;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Dependent
public class MEOutDtlRptPreProcessor extends MonthEndNonResProcessor {

  private Properties prp = null;
  private MEDataService ds = null;
  private Hashtable provStatList = null;

  private String trtProvStartStat = null;
  private String rcvProvStartStat = null;
  private String startingStatus = null;
  private String trtProvNextStat = null;
  private String rcvProvNextStat = null;
  private String nextStatus = null;
  private String successTrans = null;

  private String trtStatusKey = null;
  private String rcvStatusKey = null;
  private String statusKey = null;

  private String trtProvOutDtlStep = null;
  private String rcvProvOutDtlStep = null;
  private String outpatientDtlStep = null;
  private String defaultStep = null;

  private String trtPopulationType = null;
  private String rcvPopulationType = null;
  private String populationType = null;

  private static Logger logger = LoggerFactory.getLogger("MEOutDtlRptPreProcessor");

  public MEOutDtlRptPreProcessor() {
    super();
  }

  /**
   * Sets up class objects (properties, dataservice, province status list) and other variables to be
   * used in the process(). Note that this processor is used by the treating province to create
   * hospital level outpatient detail data for later report processing and by the receiving
   * provinces to create provincial level outpatient detail detail for later report processing.
   *
   * @throws ProcessException
   */
  @Override
  public void initialize() throws ProcessException {
    logger.debug("Calling initialize() started.");
    prp = getProperties();
    ds = getDataService();
    provStatList = getProvStatList();

    // *****************************************************************************
    // Determine whether to use status and step codes based on whether the method
    // is processing hospital outpatient detail reports for the treating province
    // or provincial outpatient detail reports for the receiving provinces
    // *****************************************************************************
    trtProvStartStat = prp.getProperty(PropertyFileKeys.PRP_NONRES_TPROV_STAT_INPDONE);
    trtProvOutDtlStep = prp.getProperty(PropertyFileKeys.PRP_NONRES_TPROV_OUTRPT_STEP);
    trtPopulationType = prp.getProperty(PropertyFileKeys.PRP_NONRES_RPT_DTL_HOSP);

    rcvProvStartStat = prp.getProperty(PropertyFileKeys.PRP_NONRES_RPROV_STAT_INPDONE);
    rcvProvOutDtlStep = prp.getProperty(PropertyFileKeys.PRP_NONRES_RPROV_OUTRPT_STEP);
    rcvPopulationType = prp.getProperty(PropertyFileKeys.PRP_NONRES_RPT_DTL_PROV);

    successTrans = prp.getProperty(PropertyFileKeys.PRP_PROV_TRANS_CAUSE_SUCCESS);
    defaultStep = prp.getProperty(PropertyFileKeys.PRP_NONRES_STEP_DEF);

    try {
      if ((trtProvStartStat.trim().length() == 0)
          || (rcvProvStartStat.trim().length() == 0)
          || (successTrans.trim().length() == 0)
          || (trtProvOutDtlStep.trim().length() == 0)
          || (rcvProvOutDtlStep.trim().length() == 0)
          || (trtPopulationType.trim().length() == 0)
          || (rcvPopulationType.trim().length() == 0)
          || (defaultStep.trim().length() == 0)) {
        logger.error(
            "Some properties for the Outpatient Detail rpt preprocessor are null when they cannot be");
        logger.error(
            "Treating  Province Outpatient Detail Rpt Starting Status:  " + trtProvStartStat);
        logger.error(
            "Treating  Province Outpatient Detail Rpt Step Code:        " + trtProvOutDtlStep);
        logger.error(
            "Treating  Province Population Type:                       " + trtPopulationType);

        logger.error(
            "Receiving Province Outpatient Detail Rpt Starting Status:  " + rcvProvStartStat);
        logger.error(
            "Receiving Province Outpatient Detail Rpt Step Code:        " + rcvProvOutDtlStep);
        logger.error(
            "Receiving  Province Population Type:                      " + rcvPopulationType);

        logger.error("Success Transition Code:                                   " + successTrans);
        logger.error("Default Step Code:                       " + defaultStep);
        throw new ProcessException(new Exception("Config File Parameter error"));
      }
    } catch (NullPointerException npe) {
      logger.error("Missing properties in the config file " + npe);
      throw new ProcessException(npe);
    }

    try {
      trtStatusKey = trtProvStartStat.trim() + ":" + successTrans.trim();
      trtProvNextStat = ((ProvTransitionsStats) (provStatList.get(trtStatusKey))).getEndStatus();
      rcvStatusKey = rcvProvStartStat.trim() + ":" + successTrans.trim();
      rcvProvNextStat = ((ProvTransitionsStats) (provStatList.get(rcvStatusKey))).getEndStatus();
    } catch (NullPointerException npe) {
      logger.error(
          "Treating or Receiving Province Next status not found in transition status list.");
      logger.error("Treating  Province Next Status: " + trtProvNextStat);
      logger.error("Receiving Province Next Status: " + rcvProvNextStat);
      throw new ProcessException(npe);
    }

    logger.debug("Calling initialize() finished.");
  }

  /**
   * Calls the preProcess application for the Outpatient Detail Report. If the preProcessor is
   * called by a treating province then one report request will be generated for each hospital
   * accociated with the treating province. If it is called by a receiving province then one
   * provincial level report request will be generated. The preProcessor will generate and store
   * values in a temp table for each of the reports.
   *
   * @param curProv A treating/receiving province object for the current object being processed.
   * @param stepCode Code indicating whether or not this step of the month end should be executed It
   *     will usually be defaulted to 'ALL'
   * @throws SQLException
   * @throws IOException
   * @throws ProcessException
   */
  @Override
  public void process(Province curProv, String stepCode)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling process() started.");

    curProv.setProvError(false);

    // ***********************************************
    // Ensure province is flagged as either a treating
    // or receving province
    // ***********************************************
    if ((curProv.getProvDetails().getTProvinceFlag())
        && (!curProv.getProvDetails().getRProvinceFlag())) {
      startingStatus = trtProvStartStat;
      nextStatus = trtProvNextStat;
      statusKey = trtStatusKey;
      outpatientDtlStep = trtProvOutDtlStep;
      populationType = trtPopulationType;
      logger.info("Processor Starting Status: " + startingStatus);
      logger.info("Processor Step Code:       " + stepCode);

    } else if ((curProv.getProvDetails().getRProvinceFlag())
        && (!curProv.getProvDetails().getTProvinceFlag())) {
      startingStatus = rcvProvStartStat;
      nextStatus = rcvProvNextStat;
      statusKey = rcvStatusKey;
      outpatientDtlStep = rcvProvOutDtlStep;
      populationType = rcvPopulationType;
      logger.info("Processor Starting Status: " + startingStatus);
      logger.info("Processor Step Code:       " + stepCode);
    } else {
      curProv.setProvError(true);
      logger.error(
          "Province must be identified as either treating OR receiving. It is neither or both. ");
      logger.error("Treating flag is: " + curProv.getProvDetails().getTProvinceFlag());
      logger.error("Receiving flag is: " + curProv.getProvDetails().getRProvinceFlag());
      throw new ProcessException(new Exception("Province is in error: " + curProv.getProvince()));
    }

    String provType = curProv.getProvDetails().getTProvinceFlag() ? "Treating" : "Receiving";
    logger.info("");
    logger.info(
        "Starting Outpatient Detail Rpt Preprocessor step for "
            + provType
            + " province: "
            + curProv.getProvince());
    logger.info("Province Current Status is: " + curProv.getCurStatus());
    // ***********************************************
    // Ensure that the next and current status
    // fields are not null
    // ***********************************************
    if ((nextStatus == null)
        || (nextStatus.trim().length() == 0)
        || (curProv.getCurStatus() == null)
        || (curProv.getCurStatus().trim().length() == 0)) {
      logger.error(
          "One or more of the status fields are null for "
              + provType
              + " province: "
              + curProv.getProvince());
      logger.error("Current Status: " + curProv.getCurStatus());
      logger.error("Next Status:    " + nextStatus);
      throw new ProcessException(new Exception("Province is in error: " + curProv.getProvince()));
    }

    // *************************************************************
    // Only process the province if it is at the correct status,
    // there was no overriding step command and it is valid to run
    // the province at its current status at the current time
    // *************************************************************
    if ((curProv.getCurStatus().equals(startingStatus))
        && ((stepCode.equals(defaultStep)) || (stepCode.equals(outpatientDtlStep)))) {
      if (!validateTime(curProv.getCurStatus(), statusKey, provStatList)) {
        logger.info(
            "The current "
                + provType
                + " province is not allowed to run at this time at its current status");
        logger.info("Province/Status: " + curProv.getProvince() + "/" + curProv.getCurStatus());
        curProv.setProvError(true);
      } else {
        logger.info(
            "Determining the Outpatient Detail Rpt Request Id's for "
                + provType
                + " province: "
                + curProv.getProvince());
        if (curProv.getProvDetails().getTProvinceFlag()) {
          getHospitalLevelRptRequests(curProv);
        } else {
          getProvinceLevelRptRequest(curProv);
        }
      }
    }
    logger.debug("Calling process() finished.");
  }

  /**
   * Generates Outpatient Detail claims data for each hospital of the passed in treating province
   * and stores the data in a temp table for later reporting processing.
   *
   * @param curProv A treating province object for the current object being processed.
   * @throws SQLException, IOException, ProcessException
   */
  private void getHospitalLevelRptRequests(Province curProv)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling getHospitalLevelRptRequests() started.");
    String sessionId = "ME: " + this.getClass().getName();

    ds.lockProvince(curProv.getProvince(), curProv.getProvDetails().getResidencyType(), sessionId);
    int i = 0;
    if (curProv.getHospList().isEmpty()) {
      logger.error(
          "There must be at least one hospital for treating province: " + curProv.getProvince());
      curProv.setProvError(true);
    } else {
      while ((i < curProv.getHospList().size()) && (!curProv.getProvError())) {

        HospitalDetails HospDtls = curProv.getHospital(i);
        HospDtls.setOutDetailReport(null);
        Reports outDtlReport =
            ds.preProcessOutpatientDtlRpt(
                curProv.getProvDetails().getResidencyType(),
                populationType,
                HospDtls.getHospitalNumber(),
                sessionId);

        // Check if a report request id was returned
        if ((outDtlReport == null) || (outDtlReport.getRptRequestId() == 0)) {
          logger.error("Outpatient Detail Rpt PreProcess did not return a report request id for ");
          logger.error("Province: " + curProv.getProvince());
          logger.error("Hospital: " + HospDtls.getHospitalName());
          HospDtls.setOutDetailReport(null);
          curProv.setHospital(HospDtls, i);
          curProv.setProvError(true);
        } else if (outDtlReport.getRptRequestId() == -1) {
          logger.info("Outpatient Detail Rpt Request Id is:  -1");
          logger.info(
              "For Province/Hospital:  "
                  + curProv.getProvince()
                  + "/"
                  + HospDtls.getHospitalName());
          HospDtls.setOutDetailReport(null);
          curProv.setProvError(false);
        } else {
          logger.info("Outpatient Detail Rpt Request Id is:  " + outDtlReport.getRptRequestId());
          logger.info(
              "For Province/Hospital:  "
                  + curProv.getProvince()
                  + "/"
                  + HospDtls.getHospitalName());
          HospDtls.setOutDetailReport(outDtlReport);
          curProv.setHospital(HospDtls, i);
          curProv.setProvError(false);
        }
        i += 1;
      }
    }
    logger.debug("Calling getHospitalLevelRptRequests() ended.");
  }

  /**
   * Generates Outpatient Detail claims data for the passed in receiving province and stores the
   * data in a temp table for later reporting processing.
   *
   * @param curProv A receiving province object for the current object being processed.
   * @throws SQLException, IOException, ProcessException
   */
  private void getProvinceLevelRptRequest(Province curProv)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling getProvinceLevelRptRequest() started.");
    String sessionId = "ME: " + this.getClass().getName();

    ds.lockProvince(curProv.getProvince(), curProv.getProvDetails().getResidencyType(), sessionId);
    curProv.setOutDetailReport(null);
    Reports outDtlReport =
        ds.preProcessOutpatientDtlRpt(
            curProv.getProvDetails().getResidencyType(),
            populationType,
            curProv.getProvince(),
            sessionId);

    // Check if a report request id was returned
    if ((outDtlReport == null) || (outDtlReport.getRptRequestId() == 0)) {
      logger.error("Outpatient Detail Rpt PreProcess did not return a report request id for ");
      logger.error("Province: " + curProv.getProvince());
      curProv.setOutDetailReport(null);
      curProv.setProvError(true);
    } else if (outDtlReport.getRptRequestId() == -1) {
      logger.info("Outpatient Detail Rpt Request Id is:  " + outDtlReport.getRptRequestId());
      logger.info("For Province: " + curProv.getProvince());
      curProv.setOutDetailReport(null);
      curProv.setProvError(false);
    } else {
      logger.info("Outpatient Detail Rpt Request Id is:  " + outDtlReport.getRptRequestId());
      logger.info("For Province: " + curProv.getProvince());
      curProv.setOutDetailReport(outDtlReport);
      curProv.setProvError(false);
    }
    logger.debug("Calling getProvinceLevelRptRequest() ended.");
  }
}
