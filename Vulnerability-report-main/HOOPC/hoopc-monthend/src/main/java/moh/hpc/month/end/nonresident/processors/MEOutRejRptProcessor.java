/**
 * ****************************************************************************** Licensed Materials
 * - Property of IBM * Copyright IBM Canada Ltd 2005 All Rights Reserved * Created on Feb 14, 2005 *
 * ****************************************************************************** Please do not
 * makes any changes to this file without first * updating the revision history below, under
 * description * please include Harvest Change Request or PSO Tools CR that * caused the change. *
 * ****************************************************************************** Revision History:
 * * * Date Name Description * ---------- ----------------
 * --------------------------------------------- * 09-26-2005 Cristina Stepanov Initial Spec *
 * ******************************************************************************
 */
package moh.hpc.month.end.nonresident.processors;

import ca.bc.gov.health.report.model.MEOutRejRptViewModel;
import ca.bc.gov.health.service.MonthEndReportService;
import jakarta.ejb.EJB;
import jakarta.enterprise.context.Dependent;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import moh.hpc.month.end.ReportHelper;
import moh.hpc.month.end.constants.PropertyFileKeys;
import moh.hpc.month.end.exceptions.ProcessException;
import moh.hpc.month.end.services.MEDataService;
import moh.hpc.month.end.support.HospitalDetails;
import moh.hpc.month.end.support.ProvTransitionsStats;
import moh.hpc.month.end.support.Province;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Dependent
public class MEOutRejRptProcessor extends MonthEndNonResProcessor {
  @EJB private MonthEndReportService reportService;
  private Properties prp = null;
  private MEDataService ds = null;
  private Hashtable provStatList = null;
  private ReportHelper rh = null;

  private String trtProvStartStat = null;
  private String startingStatus = null;
  private String trtProvNextStat = null;
  private String nextStatus = null;
  private String successTrans = null;

  private String trtStatusKey = null;
  private String statusKey = null;

  private String trtProvOutRejStep = null;
  private String outpatientRejStep = null;
  private String defaultStep = null;
  private String reportFormat = null;
  private static Logger logger = LoggerFactory.getLogger("MEOutRejRptProcessor");

  // *===========================================================================*/
  // * Name : constructor */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 15 2005 Initial Spec */
  // *===========================================================================*/
  public MEOutRejRptProcessor() {
    super();
  }

  // *===========================================================================*/
  // * Name : initialize */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 15 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Sets up class objects (properties, dataservice, province status list) and other variables to be
   * used in the process().Note that this processor is used by the treating province to create
   * hospital level outpatient detail reports and by the receiving provinces to create provincial
   * level outpatient detail reports
   *
   * @throws ProcessException
   */
  public void initialize() throws ProcessException {
    logger.debug("Calling initialize() started.");
    prp = getProperties();
    ds = getDataService();
    rh = getReportHelper();
    provStatList = getProvStatList();

    // *****************************************************************************
    // Determine whether to use status and step codes based on whether the method
    // is processing hospital outpatient rejected reports for the treating province
    //
    // *****************************************************************************
    trtProvStartStat = prp.getProperty(PropertyFileKeys.PRP_NONRES_TPROV_STAT_INPREJDONE);
    trtProvOutRejStep = prp.getProperty(PropertyFileKeys.PRP_NONRES_TPROV_OUTREJRPT_STEP);

    successTrans = prp.getProperty(PropertyFileKeys.PRP_PROV_TRANS_CAUSE_SUCCESS);
    defaultStep = prp.getProperty(PropertyFileKeys.PRP_NONRES_STEP_DEF);
    reportFormat = prp.getProperty(PropertyFileKeys.PRP_RPT_PDF_FORMAT);

    try {
      if ((trtProvStartStat.trim().length() == 0)
          || (successTrans.trim().length() == 0)
          || (trtProvOutRejStep.trim().length() == 0)
          || (reportFormat.trim().length() == 0)
          || (defaultStep.trim().length() == 0)) {
        logger.error(
            "Some properties for the Outpatient Detail rpt processor are null when they cannot be");
        logger.error(
            "Treating  Province Outpatient Rejected Rpt Starting Status:  " + trtProvStartStat);
        logger.error(
            "Treating  Province Outpatient Rejected Rpt Step Code:        " + trtProvOutRejStep);

        logger.error("Success Transition Code:                                   " + successTrans);
        logger.error("Default Step Code:                                         " + defaultStep);
        logger.error("Report Format:                                             " + reportFormat);
        throw new ProcessException(new Exception("Config File Parameter error"));
      }
    } catch (NullPointerException npe) {
      logger.error("Missing properties in the config file " + npe);
      throw new ProcessException(npe);
    }
    try {
      trtStatusKey = trtProvStartStat.trim() + ":" + successTrans.trim();
      trtProvNextStat = ((ProvTransitionsStats) (provStatList.get(trtStatusKey))).getEndStatus();

    } catch (NullPointerException npe) {
      logger.error(
          "Treating or Receiving Province Next status not found in transition status list.");
      logger.error("Treating  Province Next Status: " + trtProvNextStat);
      throw new ProcessException(npe);
    }

    logger.debug("Calling initialize() finished.");
  }

  // *===========================================================================*/
  // * Name : process */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 15 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * This process handles treating province. For the former the oracle report server will be called
   * multiple times, once for each hospital associated with the province. Each time it is called the
   * report request id generated for a specific hospital will be passed to the server. The returned
   * results will be pdf files converted to byte streams. This streams are then outputted to the
   * database as BLOB data types.
   *
   * @param curProv A treating province object for the current object being processed.
   * @param stepCode Code indicating whether or not this step of the month end should be executed It
   *     will usually be defaulted to 'ALL'
   * @throws SQLException, IOException, ProcessException
   */
  public void process(Province curProv, String stepCode)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling process() started.");
    String sessionId = "ME: " + this.getClass().getName();
    curProv.setProvError(false);

    // ***********************************************
    // Ensure province is flagged as either a treating
    // or receving province
    // ***********************************************
    if ((curProv.getProvDetails().getTProvinceFlag())
        && (!curProv.getProvDetails().getRProvinceFlag())) {
      startingStatus = trtProvStartStat;
      nextStatus = trtProvNextStat;
      statusKey = trtStatusKey;
      outpatientRejStep = trtProvOutRejStep;
      logger.info("Processor Starting Status: " + startingStatus);
      logger.info("Processor Step Code:       " + stepCode);
    } else {
      curProv.setProvError(true);
      logger.error("Province must be identified as treating. ");
      logger.error("Treating flag is: " + curProv.getProvDetails().getTProvinceFlag());
      throw new ProcessException(new Exception("Province is in error: " + curProv.getProvince()));
    }

    String provType = curProv.getProvDetails().getTProvinceFlag() ? "Treating" : "Receiving";
    logger.info("");
    logger.info(
        "Starting Outpatient Rejected Rpt step for "
            + provType
            + " province: "
            + curProv.getProvince());
    logger.info("Province Current Status is: " + curProv.getCurStatus());
    // ***********************************************
    // Ensure that the next, and current status
    // fields are not null
    // ***********************************************
    if ((nextStatus == null)
        || (nextStatus.trim().length() == 0)
        || (curProv.getCurStatus() == null)
        || (curProv.getCurStatus().trim().length() == 0)) {
      logger.error(
          "One or more of the status fields are null for "
              + provType
              + " province: "
              + curProv.getProvince());
      logger.error("Current Status: " + curProv.getCurStatus());
      logger.error("Next Status:    " + nextStatus);
      throw new ProcessException(new Exception("Province is in error: " + curProv.getProvince()));
    }

    // *************************************************************
    // Only process the province if it is at the correct status,
    // there was no overriding step command and it is valid to run
    // the province at its current status at the current time
    // *************************************************************
    if ((curProv.getCurStatus().equals(startingStatus))
        && ((stepCode.equals(defaultStep)) || (stepCode.equals(outpatientRejStep)))) {
      if (!validateTime(curProv.getCurStatus(), statusKey, provStatList)) {
        logger.info(
            "The current "
                + provType
                + " province is not allowed to run at this time at its current status");
        logger.info("Province/Status: " + curProv.getProvince() + "/" + curProv.getCurStatus());
        curProv.setProvError(true);
      } else {
        if (curProv.getProvDetails().getTProvinceFlag()) {
          getHospitalLevelReports(curProv);
        }
      }
    }
    logger.debug("Calling process() finished.");
  }

  // *===========================================================================*/
  // * Name : getHospitalLevelReports */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 15 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Generates Outpatient Rejected claims reports for each hospital of the passed in treating
   * province and stores the report in the database as a BLOB data type.
   *
   * @param curProv A treating province object for the current object being processed.
   * @throws SQLException, IOException, ProcessException
   */
  private void getHospitalLevelReports(Province curProv)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling getHospitalLevelReports() started.");
    String sessionId = "ME: " + this.getClass().getName();

    int i = 0;
    ds.lockProvince(curProv.getProvince(), curProv.getProvDetails().getResidencyType(), sessionId);
    if (curProv.getHospList().size() == 0) {
      logger.error(
          "There must be at least one hospital for treating province: " + curProv.getProvince());
      curProv.setProvError(true);
    } else {
      while ((i < curProv.getHospList().size()) && (!curProv.getProvError())) {
        HospitalDetails HospDtls = new HospitalDetails();
        HospDtls = curProv.getHospital(i);

        if (HospDtls.getOutRejectedReport() != null) {

          logger.info("Running the Outpatient Rejected Rpt for - ");
          logger.info(
              "Province/Hospital:   " + curProv.getProvince() + "/" + HospDtls.getHospitalName());

          byte[] ReportByte = null;
          List<MEOutRejRptViewModel> lstRpt =
              reportService.queryMEOutRejRptPreProcessor(
                  HospDtls.getOutRejectedReport().getRptRequestId());
          ReportByte = createPdfReport(lstRpt);

          if (!(validateRptResults(ReportByte, curProv.getProvince()))) {
            curProv.setProvError(true);
          } else {
            logger.info(
                "Outpatient Rejected Rpt created for Request Id is: "
                    + HospDtls.getOutRejectedReport().getRptRequestId());
            ByteArrayInputStream outpatientBAIS = new ByteArrayInputStream(ReportByte);
            ds.executeStoreReport(
                HospDtls.getOutRejectedReport().getRptRequestId(),
                reportFormat.toUpperCase(),
                sessionId,
                outpatientBAIS);
          }
        }
        i += 1;
      }
    }
    if (!curProv.getProvError()) {
      ds.advanceProvStat(
          curProv.getProvince(),
          curProv.getProvDetails().getResidencyType(),
          sessionId,
          curProv.getCurStatus(),
          successTrans);
      curProv.setCurStatus(nextStatus);
    }

    logger.debug("Calling getHospitalLevelReports() ended.");
  }

  // *===========================================================================*/
  // * Name : validateRptResults */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Checks to ensure the result returned by the report server is a PDF file and that data was
   * actually found to report on.
   *
   * @param province The current province being processed
   * @param rptResults The report results returned by the report server
   */
  private boolean validateRptResults(byte[] rptResults, String province) {
    logger.debug("Calling validateRptResults() started.");

    String reportString = new String(rptResults);
    boolean validRpt = true;
    // ***************************************************************
    // we are expecting a PDF file if an html file has been received
    // it indicates something wrong happened
    // ***************************************************************
    int index = reportString.indexOf("<HTML>");
    if (index != -1) {
      validRpt = false;
      int index1 = reportString.indexOf("<PRE>");
      int index2 = reportString.indexOf("</PRE>");
      String errorMessage = "No Report Returned";
      if ((index1 != -1) && (index2 != -1)) {
        errorMessage = reportString.substring(index1 + 5, index2);
      }

      logger.error("Outpatient Detail Rpt Failed for the province: " + province);
      logger.error(errorMessage);
    } else {
      // ***************************************************************
      // we are expecting a PDF file if file is not html and not pdf then
      // something really wrong happened
      // ***************************************************************
      index = reportString.indexOf("%PDF");
      if (index == -1) {
        validRpt = false;
        logger.error(
            "Outpatient Rejected Rpt did not return a PDF file for the province: " + province);
      } else {
        // ***************************************************************
        // we are expecting a PDF file with data, however a no data found
        // situation is not an error
        // ***************************************************************
        validRpt = true;
        index = reportString.indexOf("Report returns no data");
        if (index != -1) {
          logger.info("Outpatient Rejected Rpt found no data for province: " + province);
        }
      }
    }
    logger.debug("Calling validateRptResults() finished.");
    return validRpt;
  }

  private byte[] createPdfReport(List<MEOutRejRptViewModel> queryList) {
    Map<String, Object> parameters = new HashMap<>();
    if (queryList.isEmpty()) {
      parameters.put("NO_RECORD_FOUND", "No record found");
    } else {
      parameters.put("NO_RECORD_FOUND", "");
    }
    return ReportHelper.invokeJasper(queryList, parameters, "hoopcr0021");
  }
}
