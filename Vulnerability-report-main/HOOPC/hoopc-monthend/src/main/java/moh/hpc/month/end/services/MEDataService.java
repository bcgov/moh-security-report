/**
 * ****************************************************************************** Licensed Materials
 * - Property of IBM * ï¿½ Copyright IBM Canada Ltd 2005 All Rights Reserved * Created on Jan 11, 2004
 * * ****************************************************************************** Please do not
 * makes any changes to this file without first * updating the revision history below, under
 * description * please include Harvest Change Request or PSO Tools CR that * caused the change. *
 * ****************************************************************************** Revision History:
 * * * Date Name Description * ---------- ----------------
 * --------------------------------------------- * 01-11-2005 David Bartlett Initial Specs *
 * 07-06-2005 Ron Merner Added claimType to preProcessClaimRpt() * 09-26-2005 Ron Merner Added
 * preProcessInpatientRejRpt() and * preProcessOutpatientRejRpt(). *
 * ******************************************************************************
 */
package moh.hpc.month.end.services;

import ca.ibm.victoria.oracle.dataservice.objects.BLOBDeserializer;
import ca.ibm.victoria.oracle.dataservice.objects.BLOBSerializer;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.CallableStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Properties;
import moh.hpc.month.end.constants.ApplicationConstants;
import moh.hpc.month.end.constants.PropertyFileKeys;
import moh.hpc.month.end.exceptions.ProcessException;
import moh.hpc.month.end.services.support.OracleParameters;
import moh.hpc.month.end.support.HADetails;
import moh.hpc.month.end.support.HospitalDetails;
import moh.hpc.month.end.support.ProvTransitionsStats;
import moh.hpc.month.end.support.Province;
import moh.hpc.month.end.support.ProvinceDetails;
import moh.hpc.month.end.support.Reports;
import oracle.jdbc.OracleTypes;
import oracle.sql.BLOB;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MEDataService extends DataService {
  // *******************************************************
  // Oracle Stored Procedures for MEDataService (Residents)
  // *******************************************************
  private static final String CALLABLE_GET_PROV_CUR_STATS =
      "{call HOOPC2_MONTHEND.GETMONTHENDSTATUSES(?,?,?,?,?,?)}";

  private static final String CALLABLE_PROCESS_RES_CLAIMS =
      "{call HOOPC2_MONTHEND.PROCESSRESIDENTCLAIMS(?,?,?,?,?,?)}";
  private static final String CALLABLE_PROCESS_RES_ADJ_REQS =
      "{call HOOPC2_MONTHEND.PROCESSRESIDENTADJUSTMENTS(?,?,?,?,?,?)}";
  private static final String CALLABLE_PROCESS_RES_DECL_REQS =
      "{call HOOPC2_MONTHEND.PROCESSRESIDENTDECLARATIONS(?,?,?,?,?,?)}";

  private static final String CALLABLE_PREPROCESS_RES_BALRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0001(?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_RES_REQRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0003(?,?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_RES_ERRRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0002(?,?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_RES_PAYRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0004(?,?,?,?,?,?,?,?)}";

  // ***********************************************************
  // Oracle Stored Procedures for MEDataService (Non-Residents)
  // ***********************************************************
  private static final String CALLABLE_GET_NONRES_PROV_CUR_STATS =
      "{call HOOPC2_MONTHEND.GETMONTHENDSTATUSES(?,?,?,?,?,?,?)}";
  private static final String CALLABLE_GET_NONRES_HOSPITAL_DETAILS =
      "{call ? := HOOPC2_GENERAL.GETPROVINCIALHOSPITALLIST(?,?,?,?,?)}";
  private static final String CALLABLE_GET_NONRES_HA_DETAILS =
      "{call ? := HOOPC2_GENERAL.GETHEALTHAUTHORITYLIST(?,?,?,?)}";
  private static final String CALLABLE_ADVANCE_NONRES_RCV_PROVS_STATS =
      "{call HOOPC2_MONTHEND.SCHEDULENONRESPROVINCES(?,?,?,?,?,?)}";

  private static final String CALLABLE_PROCESS_NONRES_CLAIMS =
      "{call HOOPC2_MONTHEND.PROCESSNONRESCLAIMSANDADJMNTS(?,?,?,?,?)}";
  private static final String CALLABLE_GET_HOSP_RPT_REQUESTS =
      "{call HOOPC2_REPREPOS.GETHOSPREPORTREQUESTS(?,?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_GET_HA_RPT_REQUESTS =
      "{call HOOPC2_REPREPOS.GETHAREPORTREQUESTS(?,?,?,?,?,?,?,?,?)}";

  private static final String CALLABLE_PREPROCESS_NONRES_FINRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0010(?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_NONRES_REIMBURSERPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0009(?,?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_NONRES_INPDETAILRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0006(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_NONRES_OUTDETAILRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0007(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_NONRES_IOFILERPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0015(?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_NONRES_INVOICELETRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0005(?,?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_NONRES_SUMMARYSRVRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0008(?,?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_NONRES_INPREJECTRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0020(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_PREPROCESS_NONRES_OUTREJECTRPT =
      "{call HOOPC2_REPORTS.PREPROCESSREP0021(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)}";

  // *******************************************************
  // Oracle Stored Procedures for MEDataService (Common)
  // *******************************************************
  private static final String CALLABLE_GET_PROCMONTH =
      "{call HOOPC2_MONTHEND.GETPROCESSINGMONTH(?,?,?,?,?,?)}";
  private static final String CALLABLE_GET_PROV_TRANS_STATS =
      "{call HOOPC2_MONTHEND.GETSTATUSTRANSITIONS(?,?,?,?,?,?)}";
  private static final String CALLABLE_GET_PROV_DETAILS =
      "{call HOOPC2_GENERAL.GETPROVDETAILS(?,?,?,?,?,?)}";
  private static final String CALLABLE_LOCK_PROVINCE =
      "{call HOOPC2_MONTHEND.LOCKPROVINCE(?,?,?,?,?,?)}";
  private static final String CALLABLE_ADVANCE_PROV_STAT =
      "{call HOOPC2_MONTHEND.ADVANCEMONTHENDSTATUS(?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_ADVANCE_PROC_MONTH =
      "{call HOOPC2_MONTHEND.ADVANCEPROCESSINGMONTH(?,?,?,?,?)}";

  private static final String CALLABLE_GET_PROV_RPT_REQUESTS =
      "{call HOOPC2_REPREPOS.GETPROVREPORTREQUESTS(?,?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_STOREREPORT =
      "{call HOOPC2_REPREPOS.STOREREPORT(?, ?, ?, ?, ?, ?, ?)}";
  private static final String CALLABLE_RETRIEVEREPORT =
      "{call HOOPC2_REPREPOS.RETRIEVEREPORT(?, ?, ?, ?, ?, ?, ?, ?)}";

  private static final String CALLABLE_INSERT_CLAIM_DATA_SUBMISSSION =
      "{call HOOPC2_GENERAL.INSERTCLAIMDATASUBMISSION (?,?,?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_INSERT_DATA_PROCESSING_GRPS =
      "{call HOOPC2_GENERAL.INSERTDATAPROCESSINGGROUP(?,?,?,?,?,?,?,?)}";
  private static final String CALLABLE_SELECT_IMPORTFILE_INFO =
      "{call HOOPC2_GENERAL.GETIMPORTFILEINFO(?,?,?,?,?,?)}";
  private static final String CALLABLE_UPDATE_CLAIM_DATA_SUBMISSSION =
      "{call HOOPC2_GENERAL.UPDATECLAIMDATASUBMISSION(?,?,?,?,?,?)}";
  private static final String CALLABLE_UPDATE_DATA_PROCESSING_GRPS =
      "{call HOOPC2_GENERAL.UPDATEDATAPROCESSINGGROUP(?,?,?,?,?,?,?,?)}";

  // Other Properites
  private static String MODIFIED_BY;
  private static int BALANCE_ERROR;
  private static int ME_INCOMPLETE_WARN;
  private static int FETCH_SIZE;
  private OracleParameters op = null;
  private static Logger logger = LoggerFactory.getLogger("MEDataService");

  // *===========================================================================*/
  // * Name : Constructor */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  public MEDataService(Properties prp) throws SQLException {
    super(prp);
    logger.debug("MEDataService Constructor is starting");

    int intBenefitYear = 0;
    int dbConnectTimeOut = ApplicationConstants.DEFAULT_DB_CONNECT_TIMEOUT; // default connect
    // timeout value
    int dbQueryTimeOut = ApplicationConstants.DEFAULT_DB_QUERY_TIMEOUT; // default query timeout
    // value
    String hostname = prp.getProperty(PropertyFileKeys.PRP_HOSTNAME, "empty");
    String port = prp.getProperty(PropertyFileKeys.PRP_PORT, ApplicationConstants.DEFAULT_PORT);
    String sid = prp.getProperty(PropertyFileKeys.PRP_SID, "empty");
    String uid = prp.getProperty(PropertyFileKeys.PRP_UID, "empty");
    String batchId = prp.getProperty(PropertyFileKeys.PRP_BATCH_USER, "HPC.MonthEnd");
    String pw = prp.getProperty(PropertyFileKeys.PRP_PW, "empty");
    String dbCTimeout = prp.getProperty(PropertyFileKeys.PRP_DB_CONNECT_TIMEOUT);
    String dbQTimeout = prp.getProperty(PropertyFileKeys.PRP_DB_QUERY_TIMEOUT);
    logger.debug("Oracle Hostname:        " + hostname);
    logger.debug("Oracle Port:            " + port);
    logger.debug("Oracle SID:             " + sid);
    logger.debug("Oracle UID:             " + uid);
    logger.debug("Oracle batchId:         " + batchId);
    logger.debug("Oracle PW:              " + pw);
    logger.debug("Oracle Connect Timeout: " + dbCTimeout);
    logger.debug("Oracle Query Timeout:   " + dbQTimeout);

    try { // Decode password
      pw = simpleDecoder(pw);
    } catch (NullPointerException e) {
      logger.error("Unable to decode Oracle password");
      throw e;
    }
    try { // setup timeout values
      dbConnectTimeOut = Integer.parseInt(dbCTimeout);
      dbQueryTimeOut = Integer.parseInt(dbQTimeout);
    } catch (NumberFormatException e) {
      // Default value set
    }
    // Setup Oracle Parameters object for getting a Connection
    op = new OracleParameters();
    op.setHostname(hostname);
    op.setHostport(port);
    op.setSid(sid);
    op.setUsername(uid);
    op.setPassword(pw);
    op.setDbConnectTimeout(dbConnectTimeOut);
    op.setQueryTimeout(dbQueryTimeOut);
    op.setBatchId(batchId);

    // MODIFIED_BY = prp.getProperty(PropertyFileKeys.PRP_MODIFIED_BY).trim();
    BALANCE_ERROR = Integer.parseInt(prp.getProperty(PropertyFileKeys.PRP_BALANCE_ERROR));
    ME_INCOMPLETE_WARN = Integer.parseInt(prp.getProperty(PropertyFileKeys.PRP_INCOMPLETE_WARN));

    // Create DataSource
    createDataSource(op);

    logger.debug("MEDataService Constructor is ending");
  }

  // *===========================================================================*/
  // * Name : destroy */
  // * Purpose : Closes objects used by DataService as app. shuts down. */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  public void destroy() {
    super.destroy();
  }

  // *===========================================================================*/
  // * Name : getProcMonth */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Gets the Current Processing Month for the given residency type
   *
   * @throws SQLException
   */
  public String getProcMonth(String resType, String sessionId) throws SQLException {
    logger.debug("Calling getProcMonth() started!");

    long error = ApplicationConstants.FAILURE;
    String message = null;
    String procMonth = null;
    CallableStatement cstmt = null;
    logger.debug("ResidencyType:  " + resType);
    logger.debug("Session Id:     " + sessionId);

    try {
      cstmt = createCallableStatement(CALLABLE_GET_PROCMONTH);
      cstmt.setString(1, resType);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(4, Types.VARCHAR);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(5);
      message = cstmt.getString(6);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        procMonth = cstmt.getString(4);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_GET_PROCMONTH);
    }
    logger.debug("Calling getProcMonth() finished!");

    return procMonth;
  }

  // *===========================================================================*/
  // * Name : getProvinces */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Gets the Provinces and their current status for Month End processing based on residency type
   * passed in.
   *
   * @throws SQLException
   */
  public ArrayList getProvinces(String resType, String sessionId) throws SQLException {
    logger.debug("Calling getProvinces() started!");
    logger.debug("Residency Type:  " + resType);
    logger.debug("Session Id:      " + sessionId);

    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;
    ResultSet rs = null;
    ArrayList list = new ArrayList();

    try {
      cstmt = createCallableStatement(CALLABLE_GET_PROV_CUR_STATS);
      cstmt.setString(1, resType);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(4, oracle.jdbc.OracleTypes.CURSOR);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(5);
      message = cstmt.getString(6);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        rs = (ResultSet) cstmt.getObject(4);
        while (rs.next()) {
          Province prov = new Province();
          prov.setProvince(rs.getString(1));
          prov.setCurStatus(rs.getString(2));
          list.add(prov);
        }
      }
    } finally {
      closeResultSet(rs);
      closeCallableStatement(cstmt, CALLABLE_GET_PROV_CUR_STATS);
    }
    logger.debug("Calling getProvinces() finished!");

    return list;
  }

  // *===========================================================================*/
  // * Name : getProvinces */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 11 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Gets a Province and its current status for Month End processing based on a province code passed
   * in and the residency type passed in.
   *
   * @throws SQLException
   */
  public ArrayList getProvinces(String provinceList, String resType, String sessionId)
      throws SQLException {
    logger.debug("Calling getProvinces() started!");
    logger.debug("Residency Type:  " + resType);
    logger.debug("Province List:   " + provinceList);
    logger.debug("Session Id:      " + sessionId);

    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;
    ResultSet rs = null;
    ArrayList list = new ArrayList();

    try {
      cstmt = createCallableStatement(CALLABLE_GET_NONRES_PROV_CUR_STATS);
      cstmt.setString(1, provinceList);
      cstmt.setString(2, resType);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, oracle.jdbc.OracleTypes.CURSOR);
      cstmt.registerOutParameter(6, Types.INTEGER);
      cstmt.registerOutParameter(7, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(6);
      message = cstmt.getString(7);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        rs = (ResultSet) cstmt.getObject(5);
        while (rs.next()) {
          Province prov = new Province();
          prov.setProvince(rs.getString(1));
          prov.setCurStatus(rs.getString(2));
          list.add(prov);
        }
      }
    } finally {
      closeResultSet(rs);
      closeCallableStatement(cstmt, CALLABLE_GET_NONRES_PROV_CUR_STATS);
    }
    logger.debug("Calling getProvinces() finished!");

    return list;
  }

  // *===========================================================================*/
  // * Name : getProvTransStats */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 12 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Gets the list of resident statuses a Province can cycle through
   *
   * @throws SQLException
   */
  public ArrayList getProvTransStats(String resType, String sessionId) throws SQLException {
    logger.debug("Calling getProvTransStats() started!");

    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;
    ResultSet rs = null;
    ArrayList list = new ArrayList();

    logger.debug("Residency Type:  " + resType);
    logger.debug("Session Id:      " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_GET_PROV_TRANS_STATS);
      cstmt.setString(1, resType);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(4, oracle.jdbc.OracleTypes.CURSOR);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(5);
      message = cstmt.getString(6);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        rs = (ResultSet) cstmt.getObject(4);
        while (rs.next()) {
          ProvTransitionsStats provStats = new ProvTransitionsStats();
          provStats.setStartStatus(rs.getString(1));
          provStats.setEndStatus(rs.getString(2));
          provStats.setTransCause(rs.getString(3));
          provStats.setInclStartTime(rs.getFloat(4));
          provStats.setInclEndTime(rs.getFloat(5));
          provStats.setExclStartTime(rs.getFloat(6));
          provStats.setExclEndTime(rs.getFloat(7));
          list.add(provStats);
        }
      }
    } finally {
      closeResultSet(rs);
      closeCallableStatement(cstmt, CALLABLE_GET_PROV_TRANS_STATS);
    }
    logger.debug("Calling getProvTransStats() finished!");
    return list;
  }

  // *===========================================================================*/
  // * Name : getProvinceDetails */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 19 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Gets Province details
   *
   * @throws SQLException
   */
  public ProvinceDetails getProvinceDetails(String province, String sessionId) throws SQLException {
    logger.debug("Calling getProvinceDetails() started!");
    logger.debug("Session Id:  " + sessionId);

    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;
    ResultSet rs = null;
    ProvinceDetails provDtl = null;
    try {
      cstmt = createCallableStatement(CALLABLE_GET_PROV_DETAILS);
      cstmt.setString(1, province);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(4, oracle.jdbc.OracleTypes.CURSOR);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(5);
      message = cstmt.getString(6);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        rs = (ResultSet) cstmt.getObject(4);
        if (rs.next()) {
          provDtl = new ProvinceDetails();
          provDtl.setProvinceName(rs.getString(1));
          provDtl.setPostalCodePrefix(rs.getString(2));
          provDtl.setProvinceCode(rs.getString(3));
          provDtl.setInsuranceFormat(rs.getString(4));
          provDtl.setInsuranceExpiresInd(rs.getString(5));
          provDtl.setInsuranceExpiryImpltnDate(rs.getDate(6));
          provDtl.setOutpatientICD10EffDate(rs.getDate(7));
          provDtl.setElectronicDataSubmitInd(rs.getString(8));
          provDtl.setSubmitIdentifier(rs.getString(9));
          provDtl.setResponsability(rs.getString(10));
          provDtl.setSupplierName(rs.getString(11));
          provDtl.setSupplierAddress1(rs.getString(12));
          provDtl.setSupplierAddress2(rs.getString(13));
          provDtl.setSupplierCity(rs.getString(14));
          provDtl.setSupplierPostalCode(rs.getString(15));
          provDtl.setMonthendStatusCode(rs.getString(16));
          provDtl.setLockEndNum(rs.getInt(17));
        } else {
          logger.error("Result set for province details selection is empty when it should not be");
          logger.error("Province in error is: " + province);
          throw new SQLException(message);
        }
      }
    } finally {
      closeResultSet(rs);
      closeCallableStatement(cstmt, CALLABLE_GET_PROV_DETAILS);
    }
    logger.debug("Calling getProvinceDetails() finished!");

    return provDtl;
  }

  // *===========================================================================*/
  // * Name : getHospitalDetails */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Gets details of hospitals associated with the passed in province.
   *
   * @throws SQLException
   */
  public ArrayList getHospitalDetails(String province, String sessionId) throws SQLException {
    logger.debug("Calling getHospitalDetails() started!");
    logger.debug("Session Id:  " + sessionId);

    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;
    ResultSet rs = null;
    HospitalDetails hospDtl = null;
    ArrayList list = new ArrayList();
    try {
      cstmt = createCallableStatement(CALLABLE_GET_NONRES_HOSPITAL_DETAILS);
      cstmt.setString(2, province);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(1, oracle.jdbc.OracleTypes.CURSOR);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(5);
      message = cstmt.getString(6);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        rs = (ResultSet) cstmt.getObject(1);
        while (rs.next()) {
          hospDtl = new HospitalDetails();
          hospDtl.setHospitalName(rs.getString(1));
          hospDtl.setHospitalNumber(rs.getString(2));
          hospDtl.setAddress1(rs.getString(3));
          hospDtl.setAddress2(rs.getString(4));
          hospDtl.setCity(rs.getString(5));
          hospDtl.setProvince(rs.getString(6));
          hospDtl.setPostalCode(rs.getString(7));
          hospDtl.setHaNumber(rs.getString(8));
          hospDtl.setNotes(rs.getString(9));
          hospDtl.setDataExchangeId(rs.getString(10));
          hospDtl.setLockSeq(rs.getLong(11));
          list.add(hospDtl);
        }
      }
    } finally {
      closeResultSet(rs);
      closeCallableStatement(cstmt, CALLABLE_GET_NONRES_HOSPITAL_DETAILS);
    }
    logger.debug("Calling getHospitalDetails() finished!");

    return list;
  }

  // *===========================================================================*/
  // * Name : getHADetails */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Gets details of Health Authorities associated with the passed in province.
   *
   * @throws SQLException
   */
  public ArrayList getHADetails(String province, String sessionId) throws SQLException {
    logger.debug("Calling getHADetails() started!");
    logger.debug("Session Id:  " + sessionId);

    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;
    ResultSet rs = null;
    HADetails HADtl = null;
    ArrayList list = new ArrayList();
    try {
      cstmt = createCallableStatement(CALLABLE_GET_NONRES_HA_DETAILS);
      // cstmt.setString(1,province);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(1, oracle.jdbc.OracleTypes.CURSOR);
      cstmt.registerOutParameter(4, Types.INTEGER);
      cstmt.registerOutParameter(5, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(4);
      message = cstmt.getString(5);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        rs = (ResultSet) cstmt.getObject(1);
        while (rs.next()) {
          HADtl = new HADetails();
          HADtl.setHANumber(rs.getString(1));
          HADtl.setHAName(rs.getString(2));
          HADtl.setDataExchangeId(rs.getString(3));
          HADtl.setLockSeqNo(rs.getLong(4));
          list.add(HADtl);
        }
      }
    } finally {
      closeResultSet(rs);
      closeCallableStatement(cstmt, CALLABLE_GET_NONRES_HA_DETAILS);
    }
    logger.debug("Calling getHADetails() finished!");

    return list;
  }

  // *===========================================================================*/
  // * Name : lockProvince */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Lock the Province
   *
   * @param sessionId Object that called this method
   * @throws SQLException @Deprecated
   */
  @Deprecated
  public void lockProvince(String province, String resType, String sessionId) throws SQLException {
    // logger.debug("Calling lockProvince() started!");
    //
    // long error = ApplicationConstants.FAILURE;
    // String message = null;
    // CallableStatement cstmt = null;
    //
    // logger.debug("Province: " + province);
    // logger.debug("Residency Type: " + resType);
    // logger.debug("Session Id: " + sessionId);
    //
    // try
    // {
    // cstmt = createCallableStatement(CALLABLE_LOCK_PROVINCE);
    // cstmt.registerOutParameter(5,Types.INTEGER);
    // cstmt.registerOutParameter(6,Types.VARCHAR);
    // cstmt.setString(1,province);
    // cstmt.setString(2,resType);
    // cstmt.setString(3,getBatchId());
    // cstmt.setString(4,sessionId);
    // cstmt.execute();
    // error = cstmt.getLong(5);
    // message = cstmt.getString(6);
    // logger.info("Error Number/Message: " +error+" / "+message);
    // if (error != ApplicationConstants.SUCCESS)
    // {
    // throw new SQLException(message);
    // }
    // }
    // finally
    // {
    // closeCallableStatement(cstmt,CALLABLE_LOCK_PROVINCE);
    // }
    // logger.debug("Calling lockProvince() finished!");
    //
    // return;
  }

  // *===========================================================================*/
  // * Name : advanceProvStat */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 12 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Advances the status of the province to the status given
   *
   * @param province Province whose status is to be advacned
   * @param nxtStatus Status the province is being advanced to
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public void advanceProvStat(
      String province, String resType, String sessionId, String curStatus, String transCause)
      throws SQLException {
    logger.debug("Calling advanceProvStat() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:         " + province);
    logger.debug("Residency Type:   " + resType);
    logger.debug("Session Id:       " + sessionId);
    logger.debug("Current Status:   " + curStatus);
    logger.debug("Transition Cause: " + transCause);
    try {
      cstmt = createCallableStatement(CALLABLE_ADVANCE_PROV_STAT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, province);
      cstmt.setString(2, resType);
      cstmt.setString(3, curStatus);
      cstmt.setString(4, transCause);
      cstmt.setString(5, getBatchId());
      cstmt.setString(6, sessionId);
      cstmt.registerOutParameter(7, Types.INTEGER);
      cstmt.registerOutParameter(8, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(7);
      message = cstmt.getString(8);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_ADVANCE_PROV_STAT);
    }
    logger.debug("Calling advanceProvStat() finished!");
  }

  // *===========================================================================*/
  // * Name : advanceNonResReceivingProvStats */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 15 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * This is only run for the non-resident month end. Once the non-resident treating provinces have
   * been successfully processed the statuses of all the non-resident receiving provinces can be are
   * advanced so they can be procesed by the non-resident month end.
   *
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public void advanceNonResReceivingProvStats(String curStatus, String transCause, String sessionId)
      throws SQLException {
    logger.debug("Calling advanceNonResReceivingProvStats() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Current Status:   " + curStatus);
    logger.debug("Transition Cause: " + transCause);
    logger.debug("Session Id:       " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_ADVANCE_NONRES_RCV_PROVS_STATS);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, curStatus);
      cstmt.setString(2, transCause);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(5);
      message = cstmt.getString(6);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_ADVANCE_NONRES_RCV_PROVS_STATS);
    }
    logger.debug("Calling advanceNonResReceivingProvStats() finished!");
  }

  // *===========================================================================*/
  // * Name : advanceProcMonth */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 08 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Rolls over the processing month to the next month if all provinces of the Resident Month End
   * have been processed for the current processing month
   *
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public long advanceProcMonth(String resType, String sessionId) throws SQLException {
    logger.debug("Calling advanceProcMonth() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Residency Type:   " + resType);
    logger.debug("Session Id:       " + sessionId);

    try {
      cstmt = createCallableStatement(CALLABLE_ADVANCE_PROC_MONTH);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, resType);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(4, Types.INTEGER);
      cstmt.registerOutParameter(5, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(4);
      message = cstmt.getString(5);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        if (error != ME_INCOMPLETE_WARN) throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_ADVANCE_PROC_MONTH);
    }
    logger.debug("Calling advanceProcMonth() finished!");
    return error;
  }

  // *===========================================================================*/
  // * Name : getLastPos */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 08 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Given the name of the an import file, this method checks to see if it has been imported
   * already. If so it returns a count of how many records of the file had been loaded.
   *
   * @param filename The filename to be looked for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public int getLastPos(String filename, String sessionId) throws SQLException {
    logger.debug("Calling getLastPos() started!");
    int lineCnt = 0;
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("FileName:     " + filename);
    logger.debug("Session Id:   " + sessionId);

    // *Created for the day we might use it. For now we always load ALL of a file.
    /*
     * try { cstmt = createCallableStatement(CALLABLE_SELECT_IMPORTFILE_INFO); // Set In Parameters
     * for call to Oracle Stored Procedure cstmt.setString(1, filename); cstmt.setString(2,
     * getBatchId()); cstmt.setString(3, sessionId); cstmt.registerOutParameter(4,Types.INTEGER);
     * cstmt.registerOutParameter(5,Types.INTEGER); cstmt.registerOutParameter(6,Types.VARCHAR);
     * cstmt.execute(); error = cstmt.getLong(5); message = cstmt.getString(6);
     * logger.info("Error Number/Message: " +error+" / "+message); if (error !=
     * ApplicationConstants.SUCCESS) { throw new SQLException(message); } else { lineCnt =
     * cstmt.getInt(4); } } finally { closeCallableStatement(cstmt,CALLABLE_SELECT_IMPORTFILE_INFO);
     * }
     */
    logger.debug("Calling getLastPos() finished!");
    return lineCnt;
  }

  // *===========================================================================*/
  // * Name : preProcessBalanceRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 12 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Provincial Invoice Balance Report which sets up the data
   * for the actual Oracle report
   *
   * @param province Province the preprocess is to run for
   * @param balanceFlag Indicates whether or not the preProcess should return an error if
   *     claims/adjustments for the province don't balance with the invoice totals
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessBalanceRpt(String province, String balanceFlag, String sessionId)
      throws SQLException {
    logger.debug("Calling preProcessBalanceRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports balReport = null;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:    " + province);
    logger.debug("Session Id:  " + sessionId);
    logger.debug("Balance Flag:" + balanceFlag);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_RES_BALRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, province);
      cstmt.setString(2, balanceFlag);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.registerOutParameter(7, Types.INTEGER);
      cstmt.registerOutParameter(8, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getInt(7);
      message = cstmt.getString(8);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        if (error != BALANCE_ERROR) {
          throw new SQLException(message);
        }
      } else {
        balReport = new Reports(cstmt.getLong(5), cstmt.getString(6));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_RES_BALRPT);
    }
    logger.debug("Calling preProcessBalanceRpt() finished!");
    return balReport;
  }

  // *===========================================================================*/
  // * Name : preProcessRequestRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 13 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the appropriate Request Report and sets up the data for the
   * actual Oracle report
   *
   * @param province Province the preprocess is to run for
   * @param requestType Indicates which requests the preprocessor should process
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessRequestRpt(
      String province, String requestType, String claimType, String sessionId) throws SQLException {
    logger.debug("Calling preProcessRequestRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports reqReport = null;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:     " + province);
    logger.debug("Request Type: " + requestType);
    logger.debug("Claim Type:   " + claimType);
    logger.debug("Session Id:   " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_RES_REQRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, province);
      cstmt.setString(2, requestType);
      cstmt.setString(3, claimType);
      cstmt.setString(4, getBatchId());
      cstmt.setString(5, sessionId);
      cstmt.registerOutParameter(6, Types.INTEGER);
      cstmt.registerOutParameter(7, Types.VARCHAR);
      cstmt.registerOutParameter(8, Types.INTEGER);
      cstmt.registerOutParameter(9, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getInt(8);
      message = cstmt.getString(9);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        reqReport = new Reports(cstmt.getLong(6), cstmt.getString(7));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_RES_REQRPT);
    }
    logger.debug("Calling preProcessRequestRpt() finished!");
    return reqReport;
  }

  // *===========================================================================*/
  // * Name : preProcessPaymentRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 13 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Payment Requisitions Report which sets up the data for the
   * actual Oracle report
   *
   * @param province Province the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessPaymentRpt(String resType, String province, String sessionId)
      throws SQLException {
    logger.debug("Calling preProcessPaymentRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports payReport = null;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:    " + province);
    logger.debug("Session Id:  " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_RES_PAYRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, resType);
      cstmt.setString(2, province);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.registerOutParameter(7, Types.INTEGER);
      cstmt.registerOutParameter(8, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getInt(7);
      message = cstmt.getString(8);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        payReport = new Reports(cstmt.getLong(5), cstmt.getString(6));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_RES_PAYRPT);
    }
    logger.debug("Calling preProcessPaymentRpt() finished!");
    return payReport;
  }

  // *===========================================================================*/
  // * Name : preProcessErrorRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 13 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Adjustment Errors Report which sets up the data for the
   * actual Oracle report
   *
   * @param province Province the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessErrorRpt(String province, String sessionId) throws SQLException {
    logger.debug("Calling preProcessErrorRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports errReport = null;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:    " + province);
    logger.debug("Session Id:  " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_RES_ERRRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, province);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(4, Types.INTEGER);
      cstmt.registerOutParameter(5, Types.VARCHAR);
      cstmt.registerOutParameter(6, Types.INTEGER);
      cstmt.registerOutParameter(7, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getInt(6);
      message = cstmt.getString(7);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        errReport = new Reports(cstmt.getLong(4), cstmt.getString(5));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_RES_ERRRPT);
    }
    logger.debug("Calling preProcessErrorRpt() finished!");
    return errReport;
  }

  // *===========================================================================*/
  // * Name : preProcessFinancialRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Financial Summary Report which sets up the data for the
   * actual Oracle report
   *
   * @param province Province the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessFinancialRpt(String province, String sessionId) throws SQLException {
    logger.debug("Calling preProcessFinancialRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports finReport = null;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:    " + province);
    logger.debug("Session Id:  " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_NONRES_FINRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, getBatchId());
      cstmt.setString(2, sessionId);
      cstmt.registerOutParameter(3, Types.INTEGER);
      cstmt.registerOutParameter(4, Types.VARCHAR);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getInt(5);
      message = cstmt.getString(6);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        finReport = new Reports(cstmt.getLong(3), cstmt.getString(4));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_NONRES_FINRPT);
    }
    logger.debug("Calling preProcessFinancialRpt() finished!");
    return finReport;
  }

  // *===========================================================================*/
  // * Name : preProcessReimburseRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Health Authority Reimbursement Report which sets up the
   * data for the actual Oracle report.
   *
   * @param province Province the preprocess is to run for
   * @param healthAuth Health Authoirty the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessReimburseRpt(String province, String HACode, String sessionId)
      throws SQLException {
    logger.debug("Calling preProcessReimburseRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports reimburseReport = null;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:         " + province);
    logger.debug("Health Authority: " + HACode);
    logger.debug("Session Id:       " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_NONRES_REIMBURSERPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, HACode);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(4, Types.INTEGER);
      cstmt.registerOutParameter(5, Types.VARCHAR);
      cstmt.registerOutParameter(6, Types.INTEGER);
      cstmt.registerOutParameter(7, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getInt(6);
      message = cstmt.getString(7);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        reimburseReport = new Reports(cstmt.getLong(4), cstmt.getString(5));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_NONRES_REIMBURSERPT);
    }
    logger.debug("Calling preProcessReimburseRpt() finished!");
    return reimburseReport;
  }

  // *===========================================================================*/
  // * Name : preProcessInpatientDtlRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Inpatient Detail Report which sets up the data for the
   * actual Oracle report. Can be executed at either a province level or hospital level
   *
   * @param province Province the preprocess is to run for
   * @param hospCode Hospital the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessInpatientDtlRpt(
      String resType, String popType, String popId, String sessionId) throws SQLException {
    logger.debug("Calling preProcessInpatientDtlRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports inpDtlReport = null;
    String message = null;
    CallableStatement cstmt = null;
    String nullString = null;
    java.sql.Date nullDate = null;

    logger.debug("Residency Type:  " + resType);
    logger.debug("Population Type: " + popType);
    logger.debug("Population Id:   " + popId);
    logger.debug("Session Id:      " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_NONRES_INPDETAILRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, resType);
      cstmt.setString(2, popType);
      cstmt.setString(3, popId);
      cstmt.setString(4, nullString); // Claim Status
      cstmt.setString(5, nullString); // Override Status
      cstmt.setString(6, nullString); // Adjustment Status
      cstmt.setDate(7, nullDate); // submission Start Date
      cstmt.setDate(8, nullDate); // Submission End Date
      cstmt.setDate(9, nullDate); // Processing Start Date
      cstmt.setDate(10, nullDate); // Processing End Date
      cstmt.setDate(11, nullDate); // Admission Start Date
      cstmt.setDate(12, nullDate); // Admission End Date
      cstmt.setDate(13, nullDate); // Adjustment Req Start Date
      cstmt.setDate(14, nullDate); // Adjustment Req End Date
      cstmt.setDate(15, nullDate); // Adjustment Proc Start Date
      cstmt.setDate(16, nullDate); // Adjstment Proc End Date
      cstmt.setString(17, nullString); // Diagnosis Code
      cstmt.setString(18, nullString); // Procedure Code
      cstmt.setString(19, nullString); // Accident Code
      cstmt.setString(20, nullString); // High Cost Proc Code
      cstmt.setString(21, nullString); // Declaration Request Code
      cstmt.setString(22, nullString); // Claim Review Flag
      cstmt.setString(23, nullString); // Claim Changed Flag
      cstmt.setString(24, nullString); // Report Format
      cstmt.setString(25, getBatchId());
      cstmt.setString(26, sessionId);
      cstmt.registerOutParameter(27, Types.INTEGER); // Report Request Id
      cstmt.registerOutParameter(28, Types.VARCHAR); // Report File Name
      cstmt.registerOutParameter(29, Types.INTEGER); // Error Code
      cstmt.registerOutParameter(30, Types.VARCHAR); // Error Message

      cstmt.execute();
      error = cstmt.getInt(29);
      message = cstmt.getString(30);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        inpDtlReport = new Reports(cstmt.getLong(27), cstmt.getString(28));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_NONRES_INPDETAILRPT);
    }
    logger.debug("Calling preProcessInpatientDtlRpt() finished!");
    return inpDtlReport;
  }

  // *===========================================================================*/
  // * Name : preProcessOutpatientDtlRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Outpatient Detail Report which sets up the data for the
   * actual Oracle report. Can be executed at either a province level or hospital level
   *
   * @param province Province the preprocess is to run for
   * @param hospCode Hospital the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessOutpatientDtlRpt(
      String resType, String popType, String popId, String sessionId) throws SQLException {
    logger.debug("Calling preProcessOutpatientDtlRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports outDtlReport = null;
    String message = null;
    CallableStatement cstmt = null;
    String nullString = null;
    java.sql.Date nullDate = null;

    logger.debug("Residency Type:  " + resType);
    logger.debug("Population Type: " + popType);
    logger.debug("Population Id:   " + popId);
    logger.debug("Session Id:      " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_NONRES_OUTDETAILRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, resType);
      cstmt.setString(2, popType);
      cstmt.setString(3, popId);
      cstmt.setString(4, nullString); // Claim Status
      cstmt.setString(5, nullString); // Override Status
      cstmt.setString(6, nullString); // Adjustment Status
      cstmt.setDate(7, nullDate); // submission Start Date
      cstmt.setDate(8, nullDate); // Submission End Date
      cstmt.setDate(9, nullDate); // Processing Start Date
      cstmt.setDate(10, nullDate); // Processing End Date
      cstmt.setDate(11, nullDate); // Service Start Date
      cstmt.setDate(12, nullDate); // Service End Date
      cstmt.setDate(13, nullDate); // Adjustment Req Start Date
      cstmt.setDate(14, nullDate); // Adjustment Req End Date
      cstmt.setDate(15, nullDate); // Adjustment Proc Start Date
      cstmt.setDate(16, nullDate); // Adjstment Proc End Date
      cstmt.setString(17, nullString); // Diagnosis Code
      cstmt.setString(18, nullString); // Procedure Code
      cstmt.setString(19, nullString); // Declaration Request Code
      cstmt.setString(20, nullString); // Claim Review Flag
      cstmt.setString(21, nullString); // Claim Changed Flag
      cstmt.setString(22, nullString); // Report Format
      cstmt.setString(23, getBatchId());
      cstmt.setString(24, sessionId);
      cstmt.registerOutParameter(25, Types.INTEGER); // Report Request Id
      cstmt.registerOutParameter(26, Types.VARCHAR); // Report File Name
      cstmt.registerOutParameter(27, Types.INTEGER); // Error Code
      cstmt.registerOutParameter(28, Types.VARCHAR); // Error Message

      cstmt.execute();
      error = cstmt.getInt(27);
      message = cstmt.getString(28);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        outDtlReport = new Reports(cstmt.getLong(25), cstmt.getString(26));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_NONRES_OUTDETAILRPT);
    }
    logger.debug("Calling preProcessOutpatientDtlRpt() finished!");
    return outDtlReport;
  }

  // *===========================================================================*/
  // * Name : preProcessClaimRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 14 2005 Initial Spec */
  // * Ron Merner July 6 2005 Added claimType parameter */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Inpatient/Outpatient IO File Claim Report which sets up the
   * data for the actual Oracle report.
   *
   * @param province Province the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessClaimRpt(String province, String claimType, String sessionId)
      throws SQLException {
    logger.debug("Calling preProcessClaimRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports inpClmReport = null;
    String message = null;
    String nullString = null;
    CallableStatement cstmt = null;

    logger.debug("Province:    " + province);
    logger.debug("Session Id:  " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_NONRES_IOFILERPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, province);
      cstmt.setString(2, claimType);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.registerOutParameter(7, Types.INTEGER);
      cstmt.registerOutParameter(8, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getInt(7);
      message = cstmt.getString(8);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        inpClmReport = new Reports(cstmt.getLong(5), cstmt.getString(6));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_NONRES_IOFILERPT);
    }
    logger.debug("Calling preProcessClaimRpt() finished!");
    return inpClmReport;
  }

  // *===========================================================================*/
  // * Name : preProcessInvoiceLetterRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Invoice Letter Report which sets up the data for the actual
   * Oracle report.
   *
   * @param province Province the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessInvoiceLetterRpt(String province, String sessionId) throws SQLException {
    logger.debug("Calling preProcessInvoiceLetterRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports invLetReport = null;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:    " + province);
    logger.debug("Session Id:  " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_NONRES_INVOICELETRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, province);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(4, Types.INTEGER);
      cstmt.registerOutParameter(5, Types.VARCHAR);
      cstmt.registerOutParameter(6, Types.INTEGER);
      cstmt.registerOutParameter(7, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getInt(6);
      message = cstmt.getString(7);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        invLetReport = new Reports(cstmt.getLong(4), cstmt.getString(5));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_NONRES_INVOICELETRPT);
    }
    logger.debug("Calling preProcessInvoiceLetterRpt() finished!");
    return invLetReport;
  }

  // *===========================================================================*/
  // * Name : preProcessSummaryServiceRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 15 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Summary Service Report which sets up the data for the
   * actual Oracle report.
   *
   * @param province Province the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessSummaryServiceRpt(String province, String sessionId)
      throws SQLException {
    logger.debug("Calling preProcessSummaryServiceRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports sumSrvReport = null;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:    " + province);
    logger.debug("Session Id:  " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_NONRES_SUMMARYSRVRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, province);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(4, Types.INTEGER);
      cstmt.registerOutParameter(5, Types.VARCHAR);
      cstmt.registerOutParameter(6, Types.INTEGER);
      cstmt.registerOutParameter(7, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getInt(6);
      message = cstmt.getString(7);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        sumSrvReport = new Reports(cstmt.getLong(4), cstmt.getString(5));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_NONRES_SUMMARYSRVRPT);
    }
    logger.debug("Calling preProcessSummaryServiceRpt() finished!");
    return sumSrvReport;
  }

  // *===========================================================================*/
  // * Name : updateResidentClaims */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Updates all valid resident claims and adjustments to indicate they have been processed.
   *
   * @param province Province whose claims statuses will be updated
   * @param sessionId Object that called this method
   * @param billing period The billing period the updated statuses will be tied to
   * @throws SQLException
   */
  public void updateResidentClaims(String province, String sessionId, String billPeriod)
      throws SQLException {
    logger.debug("Calling updateResidentClaims() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:         " + province);
    logger.debug("Session Id:       " + sessionId);
    logger.debug("Biling Period:    " + billPeriod);
    try {
      cstmt = createCallableStatement(CALLABLE_PROCESS_RES_CLAIMS);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, province);
      cstmt.setString(2, billPeriod);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(5);
      message = cstmt.getString(6);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PROCESS_RES_CLAIMS);
    }
    logger.debug("Calling updateResidentClaims() finished!");
  }

  // *===========================================================================*/
  // * Name : updateNonResidentClaims */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Updates all non-resident valid claims and adjustments to indicate they have been processed. As
   * well, invoices will be generated for each of the receiving provinces whose residents were
   * treated in the passed in treating province.
   *
   * @param province Treating Province whose claims statuses will be updated
   * @param sessionId Object that called this method
   * @param billPeriod The billing period the updated statuses will be tied to
   * @throws SQLException
   */
  public void updateNonResidentClaims(String billPeriod, String sessionId) throws SQLException {
    logger.debug("Calling updateNonResidentClaims() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Biling Period:    " + billPeriod);
    logger.debug("Session Id:       " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PROCESS_NONRES_CLAIMS);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, billPeriod);
      cstmt.setString(2, getBatchId());
      cstmt.setString(3, sessionId);
      cstmt.registerOutParameter(4, Types.INTEGER);
      cstmt.registerOutParameter(5, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(4);
      message = cstmt.getString(5);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PROCESS_NONRES_CLAIMS);
    }
    logger.debug("Calling updateNonResidentClaims() finished!");
  }

  // *===========================================================================*/
  // * Name : updateAdjustmentRequests */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Updates all valid adjustments requests to indicate they have been processed.
   *
   * @param province Province whose adjustment requests statuses will be updated
   * @param sessionId Object that called this method
   * @param billing period The billing period the updated statuses will be tied to
   * @throws SQLException
   */
  public void updateAdjustmentRequests(String province, String sessionId, String billPeriod)
      throws SQLException {
    logger.debug("Calling updateAdjustmentRequests() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:         " + province);
    logger.debug("Session Id:       " + sessionId);
    logger.debug("Biling Period:    " + billPeriod);
    try {
      cstmt = createCallableStatement(CALLABLE_PROCESS_RES_ADJ_REQS);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, province);
      cstmt.setString(2, billPeriod);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(5);
      message = cstmt.getString(6);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PROCESS_RES_ADJ_REQS);
    }
    logger.debug("Calling updateAdjustmentRequests() finished!");
  }

  // *===========================================================================*/
  // * Name : updateDeclarationRequests */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Updates all valid declaration requests to indicate they have been processed.
   *
   * @param province Province whose declaration requests statuses will be updated
   * @param sessionId Object that called this method
   * @param billing period The billing period the updated statuses will be tied to
   * @throws SQLException
   */
  public void updateDeclarationRequests(String province, String sessionId, String billPeriod)
      throws SQLException {
    logger.debug("Calling updateDeclarationRequests() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("Province:         " + province);
    logger.debug("Session Id:       " + sessionId);
    logger.debug("Biling Period:    " + billPeriod);
    try {
      cstmt = createCallableStatement(CALLABLE_PROCESS_RES_DECL_REQS);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, province);
      cstmt.setString(2, billPeriod);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(5);
      message = cstmt.getString(6);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PROCESS_RES_DECL_REQS);
    }
    logger.debug("Calling updateDeclarationRequests() finished!");
  }

  // *===========================================================================*/
  // * Name : insertClaimDataSubmissions */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 10 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Inserts entry into claim_data_submissions regarding the latest resident import file from a
   * receiving province.
   *
   * @param fn Name of the import file
   * @param status Indicates the status of the import load
   * @param dtlCnt Number of detail records in the file
   * @param dltAmt Sum of all detail claim amounts
   * @param province Treating Province whose claims statuses will be updated
   * @param processMonth The current billing period
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public void insertClaimDataSubmissions(
      String fn,
      String status,
      Integer dtlCnt,
      Double dtlAmt,
      String province,
      String processMonth,
      String sessionId)
      throws SQLException, ProcessException {
    logger.debug("Calling insertClaimDataSubmissions() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("FileName:          " + fn);
    logger.debug("Status:            " + status);
    logger.debug("Number of Details: " + dtlCnt);
    logger.debug("Submission Amount: " + dtlAmt);
    logger.debug("Province:          " + province);
    logger.debug("processMonth:      " + processMonth);
    logger.debug("Session Id:        " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_INSERT_CLAIM_DATA_SUBMISSSION);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, fn);
      cstmt.setString(2, status);
      setsInt(cstmt, 3, dtlCnt);
      setsDouble(cstmt, 4, dtlAmt);
      cstmt.setString(5, province);
      cstmt.setString(6, processMonth);
      cstmt.setString(7, getBatchId());
      cstmt.setString(8, sessionId);
      cstmt.registerOutParameter(9, Types.INTEGER);
      cstmt.registerOutParameter(10, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(9);
      message = cstmt.getString(10);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_INSERT_CLAIM_DATA_SUBMISSSION);
    }
    logger.debug("Calling insertClaimDataSubmissions() finished!");
  }

  // *===========================================================================*/
  // * Name : updateClaimDataSubmissions */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 10 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Inserts entry into claim_data_submissions regarding the latest resident import file from a
   * receiving province.
   *
   * @param fn Name of the import file
   * @param status Indicates the status of the import load
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public void updateClaimDataSubmissions(String fn, String status, String sessionId)
      throws SQLException {
    logger.debug("Calling updateClaimDataSubmissions() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("FileName:     " + fn);
    logger.debug("Status:       " + status);
    logger.debug("Session Id:   " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_UPDATE_CLAIM_DATA_SUBMISSSION);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, fn);
      cstmt.setString(2, status);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, Types.INTEGER);
      cstmt.registerOutParameter(6, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(5);
      message = cstmt.getString(6);

      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_UPDATE_CLAIM_DATA_SUBMISSSION);
    }
    logger.debug("Calling updateClaimDataSubmissions() finished!");
  }

  // *===========================================================================*/
  // * Name : insertDataProcessingGroups */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 02 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Inserts entry into data_processing_groups regarding the latest block of claims loaded into
   * HOOPC2 from an import file.
   *
   * @param startRow Starting row in the import file of the block of records loaded
   * @param endRow Ending row in the import file of the block of records loaded
   * @param processMonth The current billing period
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public void insertDataProcessingGroups(
      String fn, Integer startRow, Integer endRow, String status, String sessionId)
      throws SQLException, ProcessException {
    logger.debug("Calling insertDataProcessingGroups() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("FileName:      " + fn);
    logger.debug("Status:        " + status);
    logger.debug("Starting Row:  " + startRow);
    logger.debug("Ending Row:    " + endRow);
    logger.debug("Session Id:    " + sessionId);

    try {
      cstmt = createCallableStatement(CALLABLE_INSERT_DATA_PROCESSING_GRPS);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, fn);
      setsInt(cstmt, 2, startRow);
      setsInt(cstmt, 3, endRow);

      cstmt.setString(4, status);
      cstmt.setString(5, getBatchId());
      cstmt.setString(6, sessionId);
      cstmt.registerOutParameter(7, Types.INTEGER);
      cstmt.registerOutParameter(8, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(7);
      message = cstmt.getString(8);

      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_INSERT_DATA_PROCESSING_GRPS);
    }
    logger.debug("Calling insertDataProcessingGroups() finished!");
  }

  // *===========================================================================*/
  // * Name : updateDataProcessingGroups */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 02 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Updates entry in data_processing_groups regarding the latest block of claims loaded into HOOPC2
   * from an import file.
   *
   * @param startRow Starting row in the import file of the block of records loaded
   * @param endRow Ending row in the import file of the block of records loaded
   * @param processMonth The current billing period
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public void updateDataProcessingGroups(
      String fn, Integer startRow, Integer endRow, String status, String sessionId)
      throws SQLException, ProcessException {
    logger.debug("Calling updateDataProcessingGroups() started!");
    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;

    logger.debug("FileName:          " + fn);
    logger.debug("Status:            " + status);
    logger.debug("Starting Row:  " + startRow);
    logger.debug("Ending Row:    " + endRow);
    logger.debug("Session Id:    " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_UPDATE_DATA_PROCESSING_GRPS);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, fn);
      setsInt(cstmt, 2, startRow);
      setsInt(cstmt, 3, endRow);
      cstmt.setString(4, status);
      cstmt.setString(5, getBatchId());
      cstmt.setString(6, sessionId);
      cstmt.registerOutParameter(7, Types.INTEGER);
      cstmt.registerOutParameter(8, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(7);
      message = cstmt.getString(8);

      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_UPDATE_DATA_PROCESSING_GRPS);
    }
    logger.debug("Calling insertDataProcessingGroups() finished!");
  }

  // *===========================================================================*/
  // * Name : getProvinceRptRequests */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 15 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Gets the requests of all the reports created for a province within a given processing period.
   * It only selects those provinces that can be FTPed.
   *
   * @param province The province whose report requests are to be retrieved
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public ArrayList getProvinceRptRequests(
      String province, String resType, String processMonth, String reportList, String sessionId)
      throws SQLException {
    logger.debug("Calling getProvinceRptRequests() started!");
    logger.debug("Province:        " + province);
    logger.debug("Process Month:   " + processMonth);
    logger.debug("Residency Type:  " + resType);
    logger.debug("Report List:     " + reportList);
    logger.debug("Session Id:      " + sessionId);

    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;
    ResultSet rs = null;
    ArrayList list = new ArrayList();
    String nullString = null;
    try {
      cstmt = createCallableStatement(CALLABLE_GET_PROV_RPT_REQUESTS);
      cstmt.setString(1, reportList);
      cstmt.setString(2, resType);
      cstmt.setString(3, province);
      cstmt.setString(4, processMonth);
      cstmt.registerOutParameter(5, oracle.jdbc.OracleTypes.CURSOR);
      cstmt.setString(6, getBatchId());
      cstmt.setString(7, sessionId);
      cstmt.registerOutParameter(8, Types.INTEGER);
      cstmt.registerOutParameter(9, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(8);
      message = cstmt.getString(9);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        rs = (ResultSet) cstmt.getObject(5);
        while (rs.next()) {
          Reports FTPRep = new Reports();
          FTPRep.setRptRequestId(rs.getLong(1));
          FTPRep.setReportDate(rs.getDate(2));
          FTPRep.setReportCode(rs.getString(3));
          FTPRep.setReportName(rs.getString(4));
          FTPRep.setServerFileName(rs.getString(5));
          FTPRep.setServerFilePrefix(rs.getString(6));
          FTPRep.setDataFormat(rs.getString(7));
          list.add(FTPRep);
        }
      }
    } finally {
      closeResultSet(rs);
      closeCallableStatement(cstmt, CALLABLE_GET_PROV_RPT_REQUESTS);
    }
    logger.debug("Calling getProvinceRptRequests() finished!");

    return list;
  }

  // *===========================================================================*/
  // * Name : getHospitalRptRequests */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 15 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Gets the request of the report created for the hospital of a given province within a given
   * processing period. It only selects the report if it can be FTPed.
   *
   * @param province The province whose hospital report request is to be retrieved
   * @param hospNum The number identifying the hospital whose report request is to be retrieved
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public ArrayList getHospitalRptRequests(
      String hospNum, String resType, String processMonth, String reportList, String sessionId)
      throws SQLException {
    logger.debug("Calling getHospitalRptRequests() started!");
    logger.debug("Hospital Number: " + hospNum);
    logger.debug("Process Month:   " + processMonth);
    logger.debug("Residency Type:  " + resType);
    logger.debug("Report List:     " + reportList);
    logger.debug("Session Id:      " + sessionId);

    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;
    ResultSet rs = null;
    ArrayList list = new ArrayList();
    String nullString = null;
    try {
      cstmt = createCallableStatement(CALLABLE_GET_HOSP_RPT_REQUESTS);
      cstmt.setString(1, reportList);
      cstmt.setString(2, resType);
      cstmt.setString(3, hospNum);
      cstmt.setString(4, processMonth);
      cstmt.registerOutParameter(5, oracle.jdbc.OracleTypes.CURSOR);
      cstmt.setString(6, getBatchId());
      cstmt.setString(7, sessionId);
      cstmt.registerOutParameter(8, Types.INTEGER);
      cstmt.registerOutParameter(9, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(8);
      message = cstmt.getString(9);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        rs = (ResultSet) cstmt.getObject(5);
        while (rs.next()) {
          Reports FTPRep = new Reports();
          FTPRep.setRptRequestId(rs.getLong(1));
          FTPRep.setReportDate(rs.getDate(2));
          FTPRep.setReportCode(rs.getString(3));
          FTPRep.setReportName(rs.getString(4));
          FTPRep.setServerFileName(rs.getString(5));
          FTPRep.setServerFilePrefix(rs.getString(6));
          FTPRep.setDataFormat(rs.getString(7));
          list.add(FTPRep);
        }
      }
    } finally {
      closeResultSet(rs);
      closeCallableStatement(cstmt, CALLABLE_GET_HOSP_RPT_REQUESTS);
    }
    logger.debug("Calling getHospitalRptRequests() finished!");

    return list;
  }

  // *===========================================================================*/
  // * Name : getHARptRequests */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 15 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Gets the requests of all the reports created for the Health Authority of a given province
   * within a given processing period. It only selects the report that can be FTPed.
   *
   * @param HANum The number identifying the Health Authority whose report request is to be
   *     retrieved
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public ArrayList getHARptRequests(
      String HANum, String resType, String processMonth, String reportList, String sessionId)
      throws SQLException {
    logger.debug("Calling getHARptRequests() started!");
    logger.debug("Health Authority Number: " + HANum);
    logger.debug("Process Month:           " + processMonth);
    logger.debug("Residency Type:          " + resType);
    logger.debug("Report List:             " + reportList);
    logger.debug("Session Id:              " + sessionId);

    long error = ApplicationConstants.FAILURE;
    String message = null;
    CallableStatement cstmt = null;
    ResultSet rs = null;
    ArrayList list = new ArrayList();
    String nullString = null;
    try {
      cstmt = createCallableStatement(CALLABLE_GET_HA_RPT_REQUESTS);
      cstmt.setString(1, reportList);
      cstmt.setString(2, resType);
      cstmt.setString(3, HANum);
      cstmt.setString(
          4, processMonth); // Health Authority Lists, we dont care about the HA so leave
      // null
      cstmt.registerOutParameter(5, oracle.jdbc.OracleTypes.CURSOR);
      cstmt.setString(6, getBatchId());
      cstmt.setString(7, sessionId);
      cstmt.registerOutParameter(8, Types.INTEGER);
      cstmt.registerOutParameter(9, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getLong(9);
      message = cstmt.getString(9);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        rs = (ResultSet) cstmt.getObject(5);
        while (rs.next()) {
          Reports FTPRep = new Reports();
          FTPRep.setRptRequestId(rs.getLong(1));
          FTPRep.setReportDate(rs.getDate(2));
          FTPRep.setReportCode(rs.getString(3));
          FTPRep.setReportName(rs.getString(4));
          FTPRep.setServerFileName(rs.getString(5));
          FTPRep.setServerFilePrefix(rs.getString(6));
          FTPRep.setDataFormat(rs.getString(7));
          list.add(FTPRep);
        }
      }
    } finally {
      closeResultSet(rs);
      closeCallableStatement(cstmt, CALLABLE_GET_HA_RPT_REQUESTS);
    }
    logger.debug("Calling getHARptRequests() finished!");

    return list;
  }

  // *===========================================================================*/
  // * Name : executeStoreReport */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Stores a given object (pdf report) in the database as a BLOB
   *
   * @param reportRequestID Id of the report being stored
   * @param dataFormat Format of the report (in this case pdf)
   * @param sessionId Object that called this method
   * @param inputStream The report converted to a byte stream
   * @throws SQLException, IOException
   */
  public void executeStoreReport(
      long reportRequestID, String dataFormat, String sessionId, InputStream inputStream)
      throws IOException, SQLException {
    logger.debug("Calling executeStoreReport() started!");
    logger.debug(
        "executeStoreReport - start:"
            + "\n\t"
            + CALLABLE_STOREREPORT
            + "\n\t\t reportRequestID:"
            + reportRequestID
            + "\n\t\t dataFormat:"
            + dataFormat
            + "\n\t\t userId:"
            + op.getBatchId()
            + "\n\t\t sessionId:"
            + sessionId);
    long error = ApplicationConstants.FAILURE;
    long reportRqstId = 0;
    String message = null;
    CallableStatement cstmt = null;
    BLOB placeHolderBlob;

    try {
      cstmt = createCallableStatement(CALLABLE_STOREREPORT);
      cstmt.setLong(1, reportRequestID);
      cstmt.setString(2, dataFormat);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, Types.BLOB);
      cstmt.registerOutParameter(6, Types.INTEGER);
      cstmt.registerOutParameter(7, Types.VARCHAR);
      cstmt.execute();
      error = cstmt.getInt(6);
      message = cstmt.getString(7);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        placeHolderBlob = (BLOB) cstmt.getBlob(5);
        BLOBSerializer blobSerializer = new BLOBSerializer(inputStream);
        blobSerializer.writeToBLOB(placeHolderBlob);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_STOREREPORT);
    }
    logger.debug("Calling executeStoreReport() finished!");

    return;
  }

  // *===========================================================================*/
  // * Name : executeRetrieveReport */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Retrieves a BLOB object (pdf report) from the database
   *
   * @param reportRequestID Id of the report being stored
   * @param dataFormat Format of the report (in this case pdf)
   * @param sessionId Object that called this method
   * @return outputStream The report converted to a byte stream
   * @throws SQLException, IOException
   */
  public byte[] executeRetrieveReport(long reportRequestID, String dataFormat, String sessionId)
      throws IOException, SQLException {
    logger.debug("Calling executeRetrieveReport() started!");
    logger.debug(
        "executeStoreReport - start:"
            + "\n\t"
            + CALLABLE_RETRIEVEREPORT
            + "\n\t\t reportRequestID:"
            + reportRequestID
            + "\n\t\t dataFormat:"
            + dataFormat
            + "\n\t\t userId:"
            + op.getBatchId()
            + "\n\t\t sessionId:"
            + sessionId);
    long error = ApplicationConstants.FAILURE;
    long reportRqstId = 0;
    String message = null;
    CallableStatement cstmt = null;
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    BLOBDeserializer blobDeserializer = new BLOBDeserializer(outputStream);
    BLOB reportBlob;

    try {
      cstmt = createCallableStatement(CALLABLE_RETRIEVEREPORT);
      cstmt.setLong(1, reportRequestID);
      cstmt.setString(2, dataFormat);
      cstmt.setString(3, getBatchId());
      cstmt.setString(4, sessionId);
      cstmt.registerOutParameter(5, OracleTypes.INTEGER);
      cstmt.registerOutParameter(6, OracleTypes.BLOB);
      cstmt.registerOutParameter(7, OracleTypes.INTEGER);
      cstmt.registerOutParameter(8, OracleTypes.VARCHAR);

      cstmt.execute();
      error = cstmt.getInt(7);
      message = cstmt.getString(8);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        if (error != ApplicationConstants.NO_RECORD_FOUND) {
          throw new SQLException(message);
        }
      } else {
        reportBlob = (BLOB) cstmt.getBlob(6);
        blobDeserializer.readFromBLOB(reportBlob);
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_RETRIEVEREPORT);
      outputStream.close();
      blobDeserializer = null;
    }
    logger.debug("Calling executeRetrieveReport() ended!");
    return (outputStream.toByteArray());
  }

  // *===========================================================================*/
  // * Name : getBatchId */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Retrieves the database batch id username
   *
   * @return username
   * @throws SQLException
   */
  public String getBatchId() {
    return op.getBatchId();
  }

  // *===========================================================================*/
  // * Name : setsInt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett march 10 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Handles cases where an integer may be a null value
   *
   * @throws SQLException
   */
  void setsInt(CallableStatement cs, int parameterIndex, Integer i) throws ProcessException {
    try {
      if (i == null) cs.setBigDecimal(parameterIndex, null);
      else cs.setInt(parameterIndex, i.intValue());
    } catch (SQLException e) {
      new ProcessException(new Exception("setInt(" + parameterIndex + "," + i + ")", e));
    }
  }

  // *===========================================================================*/
  // * Name : setsInt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett march 10 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Handles cases where a double may be a null value
   *
   * @throws SQLException
   */
  void setsDouble(CallableStatement cs, int parameterIndex, Double d) throws ProcessException {
    try {
      if (d == null) cs.setBigDecimal(parameterIndex, null);
      else cs.setDouble(parameterIndex, d.doubleValue());
    } catch (SQLException e) {
      new ProcessException(new Exception("setDouble" + parameterIndex + "," + d + ")", e));
    }
  }

  // *===========================================================================*/
  // * Name : preProcessInpatientRejRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * Ron Merner Sep 26, 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Inpatient Rejects Report which sets up the data for the
   * actual Oracle report. Can only be executed at hospital level
   *
   * @param province Province the preprocess is to run for
   * @param hospCode Hospital the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessInpatientRejRpt(
      String resType, String popType, String popId, String sessionId) throws SQLException {
    logger.debug("Calling preProcessInpatientRejRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports inpRejReport = null;
    String message = null;
    CallableStatement cstmt = null;
    String nullString = null;
    java.sql.Date nullDate = null;

    logger.debug("Residency Type:  " + resType);
    logger.debug("Population Type: " + popType);
    logger.debug("Population Id:   " + popId);
    logger.debug("Session Id:      " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_NONRES_INPREJECTRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, resType); // Always "NRES"
      cstmt.setString(2, popType); // Always "HOSP"
      cstmt.setString(3, popId); // Hospital Number
      cstmt.setString(4, nullString); // Claim Status
      cstmt.setString(5, nullString); // Override Status
      cstmt.setString(6, nullString); // Adjustment Status
      cstmt.setDate(7, nullDate); // submission Start Date
      cstmt.setDate(8, nullDate); // Submission End Date
      cstmt.setDate(9, nullDate); // Processing Start Date
      cstmt.setDate(10, nullDate); // Processing End Date
      cstmt.setDate(11, nullDate); // Admission Start Date
      cstmt.setDate(12, nullDate); // Admission End Date
      cstmt.setDate(13, nullDate); // Adjustment Req Start Date
      cstmt.setDate(14, nullDate); // Adjustment Req End Date
      cstmt.setDate(15, nullDate); // Adjustment Proc Start Date
      cstmt.setDate(16, nullDate); // Adjstment Proc End Date
      cstmt.setString(17, nullString); // Diagnosis Code
      cstmt.setString(18, nullString); // Procedure Code
      cstmt.setString(19, nullString); // Accident Code
      cstmt.setString(20, nullString); // High Cost Proc Code
      cstmt.setString(21, nullString); // Declaration Request Code
      cstmt.setString(22, nullString); // Claim Review Flag
      cstmt.setString(23, nullString); // Claim Changed Flag
      cstmt.setString(24, nullString); // Report Format
      cstmt.setString(25, getBatchId());
      cstmt.setString(26, sessionId);
      cstmt.registerOutParameter(27, Types.INTEGER); // Report Request Id
      cstmt.registerOutParameter(28, Types.VARCHAR); // Report File Name
      cstmt.registerOutParameter(29, Types.INTEGER); // Error Code
      cstmt.registerOutParameter(30, Types.VARCHAR); // Error Message

      cstmt.execute();
      error = cstmt.getInt(29);
      message = cstmt.getString(30);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        inpRejReport = new Reports(cstmt.getLong(27), cstmt.getString(28));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_NONRES_INPREJECTRPT);
    }
    logger.debug("Calling preProcessInpatientRejRpt() finished!");
    return inpRejReport;
  }

  // *===========================================================================*/
  // * Name : preProcessOutpatientRejRpt */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * Ron Merner Sep 26, 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Runs the preprocess routine for the Outpatient Rejects Report which sets up the data for the
   * actual Oracle report. Can only be executed at hospital level
   *
   * @param province Province the preprocess is to run for
   * @param hospCode Hospital the preprocess is to run for
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  public Reports preProcessOutpatientRejRpt(
      String resType, String popType, String popId, String sessionId) throws SQLException {
    logger.debug("Calling preProcessOutpatientRejRpt() started!");
    long error = ApplicationConstants.FAILURE;
    Reports outRejReport = null;
    String message = null;
    CallableStatement cstmt = null;
    String nullString = null;
    java.sql.Date nullDate = null;

    logger.debug("Residency Type:  " + resType);
    logger.debug("Population Type: " + popType);
    logger.debug("Population Id:   " + popId);
    logger.debug("Session Id:      " + sessionId);
    try {
      cstmt = createCallableStatement(CALLABLE_PREPROCESS_NONRES_OUTREJECTRPT);
      // Set In Parameters for call to Oracle Stored Procedure
      cstmt.setString(1, resType); // Always "NRES"
      cstmt.setString(2, popType); // Always "HOSP"
      cstmt.setString(3, popId); // Hospital Number
      cstmt.setString(4, nullString); // Claim Status
      cstmt.setString(5, nullString); // Override Status
      cstmt.setString(6, nullString); // Adjustment Status
      cstmt.setDate(7, nullDate); // Submission Start Date
      cstmt.setDate(8, nullDate); // Submission End Date
      cstmt.setDate(9, nullDate); // Processing Start Date
      cstmt.setDate(10, nullDate); // Processing End Date
      cstmt.setDate(11, nullDate); // Service Start Date
      cstmt.setDate(12, nullDate); // Service End Date
      cstmt.setDate(13, nullDate); // Adjustment Req Start Date
      cstmt.setDate(14, nullDate); // Adjustment Req End Date
      cstmt.setDate(15, nullDate); // Adjustment Proc Start Date
      cstmt.setDate(16, nullDate); // Adjstment Proc End Date
      cstmt.setString(17, nullString); // Diagnosis Code
      cstmt.setString(18, nullString); // Procedure Code
      cstmt.setString(19, nullString); // Declaration Request Code
      cstmt.setString(20, nullString); // Claim Review Flag
      cstmt.setString(21, nullString); // Claim Changed Flag
      cstmt.setString(22, nullString); // Report Format
      cstmt.setString(23, getBatchId());
      cstmt.setString(24, sessionId);
      cstmt.registerOutParameter(25, Types.INTEGER); // Report Request Id
      cstmt.registerOutParameter(26, Types.VARCHAR); // Report File Name
      cstmt.registerOutParameter(27, Types.INTEGER); // Error Code
      cstmt.registerOutParameter(28, Types.VARCHAR); // Error Message

      cstmt.execute();
      error = cstmt.getInt(27);
      message = cstmt.getString(28);
      logger.info("Error Number/Message: " + error + " / " + message);
      if (error != ApplicationConstants.SUCCESS) {
        throw new SQLException(message);
      } else {
        outRejReport = new Reports(cstmt.getLong(25), cstmt.getString(26));
      }
    } finally {
      closeCallableStatement(cstmt, CALLABLE_PREPROCESS_NONRES_OUTREJECTRPT);
    }
    logger.debug("Calling preProcessOutpatientRejRpt() finished!");
    return outRejReport;
  }
}
