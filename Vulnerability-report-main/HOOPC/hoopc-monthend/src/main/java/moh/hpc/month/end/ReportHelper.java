package moh.hpc.month.end;

import ca.bc.gov.health.constants.GlobalConstants;
import ca.bc.gov.health.report.BaseReportBuilder;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import moh.hpc.month.end.constants.PropertyFileKeys;
import moh.hpc.month.end.exceptions.ProcessException;
import moh.hpc.month.end.services.MEDataService;
import net.sf.jasperreports.engine.JRDataSource;
import net.sf.jasperreports.engine.JREmptyDataSource;
import net.sf.jasperreports.engine.JRException;
import net.sf.jasperreports.engine.JasperCompileManager;
import net.sf.jasperreports.engine.JasperExportManager;
import net.sf.jasperreports.engine.JasperFillManager;
import net.sf.jasperreports.engine.JasperPrint;
import net.sf.jasperreports.engine.JasperReport;
import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;
import net.sf.jasperreports.engine.design.JasperDesign;
import net.sf.jasperreports.engine.xml.JRXmlLoader;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.contrib.ssl.EasySSLProtocolSocketFactory;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.httpclient.protocol.Protocol;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ReportHelper {

  private static Logger logger = LoggerFactory.getLogger(ReportHelper.class.getName());

  private String rptPdfFormat = null;
  private String rptTxtFormat = null;
  private String lProtocol = null;
  private String lServer = null;
  private String lKeymapEntry = null;
  private String lCGIBinScript = null;
  private String rptIdParmLabel = null;
  private String rptDesFormatLabel = null;
  private String rptAllowedExcps = null;

  private List<String[]> allowedExceptionsList;
  private int rptMaxRetry = 0;
  private int rptRetryWaitTime = 1;
  private int rptRetryCount;

  private Properties properties = null;
  private Properties prp = null;
  private MEDataService dataService = null;
  private MEDataService ds = null;

  private static final String LIST_PREFIX = "{";
  private static final String LIST_POSTFIX = "}";
  private static final String LIST_DELIMITER = "\\};\\{";
  private static final String PAIR_DELIMITER = ",";
  private static final int PAIR_DELIMITER_LIMIT = 2;
  private static final int EXCEPTION_CLASS_NAME = 0;
  private static final int EXCEPTION_MESSAGE = 1;

  // *===========================================================================*/
  // * Name    : constructor                                                     */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 13 2005   Initial Spec                            */
  // *===========================================================================*/
  public ReportHelper() {
    super();
  }

  // *===========================================================================*/
  // * Name    : initialize                                                      */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 12 2005   Initial Spec                            */
  // *===========================================================================*/
  public void initialize() throws ProcessException {
    logger.debug("Calling Initialize started");

    prp = getProperties();
    rptPdfFormat = prp.getProperty(PropertyFileKeys.PRP_RPT_PDF_FORMAT);
    rptTxtFormat = prp.getProperty(PropertyFileKeys.PRP_RPT_TXT_FORMAT);
    lProtocol = prp.getProperty(PropertyFileKeys.PRP_RPT_SRVR_PROT);
    lServer = prp.getProperty(PropertyFileKeys.PRP_RPT_SRVR_ADDR);
    lKeymapEntry = prp.getProperty(PropertyFileKeys.PRP_RPT_SRVR_KEYMAP);
    lCGIBinScript = prp.getProperty(PropertyFileKeys.PRP_RPT_SRVR_CGIBIN);
    rptIdParmLabel = prp.getProperty(PropertyFileKeys.PRP_REPORT_ID);
    rptDesFormatLabel = prp.getProperty(PropertyFileKeys.PRP_RPT_DESFORMAT);
    rptDesFormatLabel = prp.getProperty(PropertyFileKeys.PRP_RPT_DESFORMAT);
    rptAllowedExcps = prp.getProperty(PropertyFileKeys.PRP_RPT_ALLOWED_EXCPS);

    logger.debug("Report PDF Format:         " + rptPdfFormat);
    logger.debug("Report TXT Format:         " + rptTxtFormat);
    logger.debug("Report Server Protocol:    " + lProtocol);
    logger.debug("Report Server Address:     " + lServer);
    logger.debug("Report Key Map Entry:      " + lKeymapEntry);
    logger.debug("Report CGI Bin:            " + lCGIBinScript);
    logger.debug("Report Id Parm Label:      " + rptIdParmLabel);
    logger.debug("Report Des Format Label:   " + rptDesFormatLabel);
    logger.debug("Report Allowed Exceptions: " + rptAllowedExcps);

    try {
      if ((rptPdfFormat.length() == 0)
          || (rptTxtFormat.length() == 0)
          || (lProtocol.length() == 0)
          || (lServer.length() == 0)
          || (lKeymapEntry.length() == 0)
          || (rptIdParmLabel.length() == 0)
          || (rptIdParmLabel.length() == 0)
          || (rptDesFormatLabel.length() == 0)
          || (rptAllowedExcps.length() == 0)) {
        logger.error("Some properties for the report helperare null when they cannot be");
        logger.error("Report PDF Format:         " + rptPdfFormat);
        logger.error("Report TXT Format:         " + rptTxtFormat);
        logger.error("Report Server Protocol:    " + lProtocol);
        logger.error("Report Server Address:     " + lServer);
        logger.error("Report Key Map Entry:      " + lKeymapEntry);
        logger.error("Report CGI Bin:            " + lCGIBinScript);
        logger.error("Report Id Parm Label:      " + rptIdParmLabel);
        logger.error("Report Des Format Label:   " + rptDesFormatLabel);
        logger.error("Report Allowed Exceptions: " + rptAllowedExcps);

        throw new ProcessException(new Exception("Config File Parameter error"));
      }
    } catch (NullPointerException npe) {
      logger.error("Missing properties in the config file" + npe);
      throw new ProcessException(npe);
    }

    try {
      logger.debug("Parsing report retry count for ReportHandler");
      rptMaxRetry = Integer.parseInt(prp.getProperty(PropertyFileKeys.PRP_RPT_MAX_RETRY).trim());
      logger.debug("Parsing report retry wait time duration for ReportHandler");
      rptRetryWaitTime =
          Integer.parseInt(prp.getProperty(PropertyFileKeys.PRP_RPT_RETRY_WAIT_TIME).trim());
      logger.debug("Parsing allowed exceptions list for ReportHandler");
      allowedExceptionsList = parseAllowedExceptionsList(rptAllowedExcps);
      rptRetryCount = 0;
    } catch (NumberFormatException e) {
      // we have a default value
    }
    logger.debug("Calling Initialize ended");
  }

  // *===========================================================================*/
  // * Name    : runURLPdfReport                                                 */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 12 2005   Initial Spec                            */
  // *===========================================================================*/
  public byte[] runURLPdfReport(String aReportName, long reportID, String aUserid)
      throws ProcessException {

    logger.debug("Calling runURLPdfReport started");
    byte[] reportByte = null;

    try {
      Hashtable aParameters = new Hashtable();
      aParameters.put(rptIdParmLabel, Long.toString(reportID));
      aParameters.put(rptDesFormatLabel, rptPdfFormat);
      reportByte = runURLReport(aReportName, aParameters);
    } catch (Exception e) {
      logger.error(
          "Severe error occurred accessing while trying to access the report server for report "
              + aReportName);
      throw new ProcessException(new Exception(e));
    }

    logger.debug("Calling runURLPdfReport ended");
    return reportByte;
  }

  // *===========================================================================*/
  // * Name    : runURLCsvReport                                                 */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   February 15 2005  Initial Spec                            */
  // *===========================================================================*/
  public byte[] runURLCsvReport(String aReportName, long reportID, String aUserid)
      throws ProcessException {

    logger.debug("Calling runURLCsvReport started");
    byte[] reportByte = null;

    try {
      Hashtable aParameters = new Hashtable();
      aParameters.put(rptIdParmLabel, Long.toString(reportID));
      aParameters.put(rptDesFormatLabel, rptTxtFormat);
      aParameters.put("DELIMITED_HDR", "NO");
      aParameters.put("delimiter", "none");
      reportByte = runURLReport(aReportName, aParameters);
    } catch (Exception e) {
      logger.error(
          "Severe error occurred accessing while trying to access the report server for report "
              + aReportName);
      throw new ProcessException(new Exception(e));
    }

    logger.debug("Calling runURLCsvReport ended");
    return reportByte;
  }
  // *===========================================================================*/
  // * Name    : runURLReport                                                    */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 14 2005   Initial Spec                            */
  // *===========================================================================*/
  // runa report directly using the URL to a reports server

  private byte[] runURLReport(String aReportName, Hashtable aParameters) throws Exception {

    byte[] responseByte = null;
    logger.debug("Calling runURLReport started");
    logger.debug("doReportExecute report: " + aReportName);

    try {
      // Enable SSL support , we must insert this provider as number 1, or
      // else the IBM provider will be used and cause an exception
      //		System.setProperty("java.protocol.handler.pkgs", "com.ibm.net.ssl.internal.www.protocol");
      //		java.security.Security.insertProviderAt(new com.ibm.jsse.IBMJSSEProvider(), 1);

      // Assume all certificates are trusted
      Protocol.registerProtocol(
          lProtocol, new Protocol(lProtocol, new EasySSLProtocolSocketFactory(), 443));

      // build report URL using parameters
      String lFullpath = buildReportURL(aReportName, aParameters);
      logger.debug("doReportExecute URL: " + lFullpath);

      HttpClient lHttpclient = new HttpClient();
      GetMethod lHttpget = new GetMethod(lFullpath);
      lHttpclient.executeMethod(lHttpget);

      responseByte = lHttpget.getResponseBody();

      // System.out.println("StatusCode: " + lHttpget.getStatusCode() + " StatusText: " +
      // lHttpget.getStatusText());
      logger.debug("Calling runURLReport ended");
    } catch (Exception e) {
      // Check if the number of attempts to retry accessing the report server is below threshold
      if (rptRetryCount < rptMaxRetry) {
        boolean validException = false;
        String[] allowedException;
        Iterator i = allowedExceptionsList.iterator();

        // Iterate through list of allowed exceptions
        while (!validException && i.hasNext()) {
          allowedException = (String[]) i.next();

          // Check to see if caught exception's class name = the current allowedException class name
          // and
          // if caught exception's message = the current allowedException message
          if (e.getClass().getName().equals(allowedException[EXCEPTION_CLASS_NAME])
              && e.getMessage().equals(allowedException[EXCEPTION_MESSAGE])) {

            rptRetryCount++;
            logger.debug("Increasing report retry attempt count to " + rptRetryCount);

            validException = true;
            logger.warn(
                "Found: {"
                    + e.getClass().getName()
                    + ": "
                    + e.getMessage()
                    + "}"
                    + " in allowed exception list");

            // Sleep for the maximum retry wait time duration
            Thread.sleep(rptRetryWaitTime * 1000);

            // Recursive call to runURLReport
            return runURLReport(aReportName, aParameters);
          }
        }

        if (!validException) {
          logger.error(
              "Not Found: {"
                  + e.getClass().getName()
                  + ": "
                  + e.getMessage()
                  + "}"
                  + " in allowed exception list");
          throw new ProcessException(new Exception(e));
        }
      } else {
        logger.error(
            "Maximum number of attempts to retry accessing the report server ("
                + rptMaxRetry
                + ")"
                + " has been exceeded for report "
                + aReportName);
        throw new ProcessException(new Exception(e));
      }
    }

    return responseByte;
  }

  // *===========================================================================*/
  // * Name    : buildReportURL                                                  */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 14 2005   Initial Spec                            */
  // *	  Ron Merner    February 01 2006  Modified building of lFullpath          */
  // *===========================================================================*/

  private String buildReportURL(String aReportName, Hashtable aParameters) {

    /*
       String lFullpath =
           lProtocol + "://" + lServer + "/" + "cgi-bin/" + lCGIBinScript + "?" + lKeymapEntry + "+report=" + aReportName + ".rdf";
    */
    String lFullpath =
        lProtocol
            + "://"
            + lServer
            + "/"
            + lCGIBinScript
            + "?"
            + lKeymapEntry
            + "+report="
            + aReportName
            + ".rdf";

    for (Enumeration e = aParameters.keys(); e.hasMoreElements(); ) {
      String lName = ((String) e.nextElement()).trim();
      String lValue = (String) aParameters.get(lName);
      lFullpath = lFullpath + "+" + lName.substring(lName.indexOf(".") + 1) + "=" + lValue;
    }
    logger.debug("lFullpath: " + lFullpath);
    return lFullpath;
  }

  /**
   * Parses list of allowed exceptions defined in monthEnd.props property file. This allowed
   * exceptions list should be a semi-colon delimited (';') string of the format:
   *
   * <p>"{<class_name>,<message>};{<class_name>,<message>};{<class_name>,<message>};{...}"
   *
   * <p>where exceptions are defined as a class name and message pairing separated by a comma
   * delimiter (',') and surrounded by curly braces ('{'...'}')
   *
   * @param exceptionsList list of exception class names and messages imported from properties file
   * @return list of allowed exceptions defined in monthEnd.props property file
   */
  private static ArrayList<String[]> parseAllowedExceptionsList(String exceptionsList) {

    ArrayList<String[]> allowedExceptionsList = new ArrayList();
    String[] exception;

    // Check that allowed exceptions list is not empty and has the proper prefix and postfix
    // characters
    if (exceptionsList != null
        && !exceptionsList.isEmpty()
        && exceptionsList.startsWith(LIST_PREFIX)
        && exceptionsList.endsWith(LIST_POSTFIX)) {
      // Strip the LIST_PREFIX and LIST_POSTFIX characters from the start/end of the list,
      // then split on the LIST_DELIMITER
      String[] exceptionPairs =
          (exceptionsList.substring(
                  exceptionsList.indexOf(LIST_PREFIX) + 1,
                  exceptionsList.lastIndexOf(LIST_POSTFIX)))
              .split(LIST_DELIMITER);
      for (String exceptionPair : exceptionPairs) {
        try {
          // Split on the first PAIR_DELIMITER only as the exception's message could have commas
          exception = exceptionPair.split(PAIR_DELIMITER, PAIR_DELIMITER_LIMIT);

          // Check if the class can be found; ClassNotFoundException will be thrown otherwise
          if (Class.forName(exception[EXCEPTION_CLASS_NAME]) != null) {
            allowedExceptionsList.add(exception);
            logger.debug(
                "Adding: {"
                    + exception[EXCEPTION_CLASS_NAME]
                    + ":"
                    + exception[EXCEPTION_MESSAGE]
                    + "} to allowed exceptions list");
          }
        } catch (ClassNotFoundException cnfe) {
          // Ignore the exception's class as it does not exist
          logger.warn("Class Not Found for allowed exception");
        }
      }
    } else {
      logger.debug("Allowed exceptions list is empty");
    }

    return allowedExceptionsList;
  }

  // *===========================================================================*/
  // * Name    : getProperties                                                   */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 14 2005   Initial Spec                            */
  // *===========================================================================*/

  /**
   * Gets the properties
   *
   * @return Returns a java.util.Properties
   */
  public Properties getProperties() {
    return properties;
  }

  // *===========================================================================*/
  // * Name    : getProperty                                                     */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 14 2005   Initial Spec                            */
  // *===========================================================================*/
  protected String getProperty(String propertyName) {
    return properties.getProperty(propertyName);
  }

  // *===========================================================================*/
  // * Name    : setProperties                                                   */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 14 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * Sets the properties
   *
   * @param properties The properties to set
   */
  public void setProperties(Properties properties) {
    this.properties = properties;
  }
  // *===========================================================================*/
  // * Name    : getDataService                                                  */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 14 2005   Initial Spec                            */
  // *===========================================================================*/

  /**
   * Gets the ds
   *
   * @return Returns a moh.hpc.month.end.MEDataService
   */
  public MEDataService getDataService() {
    return dataService;
  }

  // *===========================================================================*/
  // * Name    : setDataService                                                  */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 14 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * Sets the ds
   *
   * @param ds The ds to set
   */
  public void setDataService(MEDataService ds) {
    this.dataService = ds;
  }

  /**
   * Loads the Jasper template {@value GlobalConstants#REPORT_TEMPLATE}/{@code reportFilename} from
   * the file system, compiles it, fills it, and returns the PDF data in a byte array.
   *
   * @param data report data.
   * @param parameters report parameters.
   * @param reportFilename Jasper template filename at {@value
   *     GlobalConstants#REPORT_TEMPLATE}/{@code reportFilename}.
   * @return PDF data in a byte array.
   */
  public static byte[] invokeJasper(
      List<?> data, Map<String, Object> parameters, String reportFilename) {
    try {
      JRDataSource dataSource;
      if (!data.isEmpty()) {
        dataSource = new JRBeanCollectionDataSource(data);
      } else dataSource = new JREmptyDataSource();

      JasperDesign jasDesign =
          JRXmlLoader.load(
              BaseReportBuilder.class
                  .getClassLoader()
                  .getResourceAsStream(
                      MessageFormat.format(GlobalConstants.REPORT_TEMPLATE, reportFilename)));
      JasperReport jasReport = JasperCompileManager.compileReport(jasDesign);

      JasperPrint jprint = JasperFillManager.fillReport(jasReport, parameters, dataSource);
      return JasperExportManager.exportReportToPdf(jprint);
    } catch (JRException ex) {
      throw new IllegalStateException(ex);
    }
  }
}
