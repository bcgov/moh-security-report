/**
 * ****************************************************************************** Licensed Materials
 * - Property of IBM * ï¿½ Copyright IBM Canada Ltd 2005 All Rights Reserved * Created on Jan 05, 2005
 * * ****************************************************************************** Please do not
 * makes any changes to this file without first * updating the revision history below, under
 * description * please include Harvest Change Request or PSO Tools CR that * caused the change. *
 * ****************************************************************************** Revision History:
 * * * Date Name Reference Description * ---------- ---------------- ----------
 * --------------------------------- * 01-10-2005 David Bartlett Initial Spec *
 * ******************************************************************************
 */
package moh.hpc.month.end.handlers;

import jakarta.ejb.Lock;
import jakarta.ejb.LockType;
import jakarta.ejb.Singleton;
import jakarta.enterprise.inject.spi.CDI;
import java.io.File;
import java.io.IOException;
import java.net.ServerSocket;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import moh.hpc.month.end.EmailHelper;
import moh.hpc.month.end.HandlerMonitor;
import moh.hpc.month.end.Runner;
import moh.hpc.month.end.constants.ApplicationConstants;
import moh.hpc.month.end.constants.PropertyFileKeys;
import moh.hpc.month.end.exceptions.ProcessException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Singleton
@Lock(LockType.WRITE)
public class OpsHandler extends Handler {
  private Properties p;
  private ServerSocket lockSocket;
  private Hashtable handlers;
  private ArrayList handlerList;

  // Shutdown Wait Time and stop file
  private static long SHUTDOWN_WAIT_TIME;
  private File stopFile = null;

  // Max Running Time
  private static long MAX_RUNNING_TIME;

  // Email Notification option
  private boolean emailOption;
  private String emailMessage;
  private String emailSubject;

  private HandlerMonitor handlerMonitor;
  private boolean resStatusSet;
  private boolean nonResStatusSet;

  private Logger logger = LoggerFactory.getLogger("OpsHandler");

  // *===========================================================================*/
  // * Name    : constructor                                                     */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  public OpsHandler() throws ProcessException {
    super();
  }

  // *===========================================================================*/
  // * Name    : destroy                                                         */
  // * Purpose : Closes objects used by opsHandler as application shuts down.    */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  public void destroy() {
    super.destroy();

    if (handlerMonitor != null) {
      handlerMonitor = null;
    }
    setDead(true);
    closeLockSocket();
  }

  // *===========================================================================*/
  // * Name    : finalize                                                        */
  // * Purpose : Method that ensure the destroy method is executed when          */
  // *           application shuts down.                                         */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  protected void finalize() throws Throwable {
    try {
      destroy();
    } finally {
      super.finalize();
    }
  }

  // *===========================================================================*/
  // * Name    : closeLockSocket                                                 */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * Closes Lock Socket.
   *
   * <p>When the Thread first starts up, the application obtains a lock port and holds onto it until
   * the application has completed. This method releases the application's hold on the lock socket.
   */
  private void closeLockSocket() {
    logger.debug("Calling closeLockSocket() started.");
    if (lockSocket != null) {
      try {
        logger.debug("Closing Operator Lock Socket");
        lockSocket.close();
      } catch (IOException e) {
        logger.error("Unable to close Operator Lock Socket ", e);
      } finally {
        lockSocket = null;
      }
    }
    logger.debug("Calling closeLockSocket() finished.");
  }

  // *===========================================================================*/
  // * Name    : initialize                                                      */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * Initializes application setup for this Handler. Sets up values and objects needed for
   * application use.
   *
   * @throws ProcessException
   */
  public void initialize() throws ProcessException {
    super.initialize();
    logger = LoggerFactory.getLogger(getThreadName());
    p = getPrp();
    logger.info("Establishing connection to Ops Lock Socket");
    lockSocket = Runner.createLock(p.getProperty(PropertyFileKeys.PRP_OPS_LOCK_PORT), logger);
    if (lockSocket == null) {
      throw new ProcessException(new Exception("Unable to establish operator lock socket"));
    }

    long maxTime = ApplicationConstants.DEFAULT_MAX_RUNNING_TIME;
    long sleep = ApplicationConstants.DEFAULT_OPERATOR_SLEEP;
    long shutdownWaitTime = ApplicationConstants.DEFAULT_SHUTDOWN_WAIT_TIME;
    try {
      logger.debug("Parsing sleep duration for Operator Queue");
      logger.debug("Parsing shutdown wait time for OpsHandler");
      shutdownWaitTime =
          Long.parseLong(p.getProperty(PropertyFileKeys.PRP_SHUTDOWN_WAIT_TIME).trim());
      logger.debug("Parsing shutdown max running time for OpsHandler");
      maxTime = Long.parseLong(p.getProperty(PropertyFileKeys.PRP_MAX_RUNNING_TIME).trim());
    } catch (NumberFormatException e) {
      // we have a default value
    }
    SLEEP_DURATION = sleep;
    SHUTDOWN_WAIT_TIME = shutdownWaitTime;
    MAX_RUNNING_TIME = maxTime * 60 * 1000;

    logger.debug("Sleep Duration for Ops Queue: " + (SLEEP_DURATION / 1000) + " seconds");
    logger.debug("Shutdown Wait Time: " + (SHUTDOWN_WAIT_TIME / 1000) + " seconds");
    logger.debug("Maximum Program Running Time: " + maxTime + " hours");

    // Creating reference to Stop File
    String shutdownFile = p.getProperty(PropertyFileKeys.PRP_SHUTDOWN_FILE);
    stopFile = new File(shutdownFile);

    String option = p.getProperty(PropertyFileKeys.PRP_EMAIL_NOTIFICATION).trim();
    emailOption = Boolean.valueOf(option).booleanValue();
    emailMessage = p.getProperty(PropertyFileKeys.PRP_EMAIL_STANDARD_MESSAGE).trim();
    emailSubject = EMAIL_NORMAL_SUBJECT;

    // Setup Handlers
    handlerMonitor = new HandlerMonitor(p);
    try {
      loadHandlers();
    } catch (ProcessException ce) {
      logger.error("Unable to load Handlers: " + ce);
      throw ce;
    }
    logger.debug("Calling initialize() finished.");
  }

  // *===========================================================================*/
  // * Name    : loadHandlers                                                    */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * Loads Handlers to be used for this application. Handlers are objects that processes data
   * retrieved from the database. Handlers do the following: communicate with the database via
   * DataService objects, communicate with the report server via ReportHelper objects.
   *
   * @throws ProcessException
   */
  private void loadHandlers() throws ProcessException {
    logger.debug("Calling loadHandlers() started.");
    Enumeration enum1 = p.keys();
    handlers = new Hashtable();
    handlerList = new ArrayList();
    String classKey = null;
    String origKey = null;
    String key = null;
    String value = null;
    Class c = null;
    Handler handler = null;
    try {
      while (enum1.hasMoreElements()) {
        origKey = (String) enum1.nextElement();
        if (origKey.startsWith(PropertyFileKeys.PRP_HANDLER_NAME)) {
          key = p.getProperty(origKey).trim();
          classKey =
              PropertyFileKeys.PRP_HANDLER_CODE
                  + origKey.substring(PropertyFileKeys.PRP_HANDLER_NAME_LENGTH);
          value = p.getProperty(classKey);
          handlers.put(key, value);
          logger.info(value + " added to Hashtable based on the following key: " + key);
          try {
            c = Class.forName(value);
            handler = (Handler) CDI.current().select(c).get();
            logger.info(handler.getClass().getName() + " created.");
            handler.setPrp(getPrp());
            handler.setMonitor(handlerMonitor);
            // handler.execute();
            logger.info(handler.getClass().getName() + " started.");
            handlerList.add(handler);
            logger.info(handler.getClass().getName() + " added to list.");
          } catch (Exception e) {
            logger.error("Unable to get class reference for key: " + classKey, e);
            throw new ProcessException(new Exception("Failed to load handlers " + e));
          }
        }
      }
    } catch (NullPointerException npe) {
      logger.error("Handlers not set up properly in config file");
      throw new ProcessException(npe);
    }
    if (handlerList.size() == 0) {
      logger.error("There are no active Handlers running.");
      throw new ProcessException(new Exception("There are no active Handlers running."));
    }
    logger.debug("Calling loadHandlers() finished.");
  }

  /**
   * Stops a Handler's thread by calling the Thread's interrupt().
   *
   * <p>This method will loop through a list of Handlers and will try to stop that Handler's thread
   * by calling the Thread's interrupt(). This is considered a Hard Stop.
   */
  // *===========================================================================*/
  // * Name    : handlerKill                                                     */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  private void handlerKill() {
    logger.debug("Calling handlerKill() started.");
    if (handlerList != null) {
      for (int i = 0; i < handlerList.size(); i++) {
        Handler handler = (Handler) handlerList.get(i);
        if (!handler.isDead()) {
          logger.info("Killing thread: " + handler.getClass().getName());
          handler.kill();
        }
      }
    }
    logger.debug("Calling handlerKill() finished.");
  }

  // *===========================================================================*/
  // * Name    : handlerStart                                                    */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * This method will loop through a list of Handlers and will try to start that Handler's thread by
   * calling the Thread's execute().
   */
  private void handlerStart() {
    logger.debug("Calling handlerStart() started.");
    if (handlerList != null) {
      for (int i = 0; i < handlerList.size(); i++) {
        Handler handler = (Handler) handlerList.get(i);
        if (!handler.isDead()) {
          logger.info("Starting thread: " + handler.getClass().getName());
          handler.execute();
        }
      }
    }
    logger.debug("Calling handlerStart() finished.");
  }

  // *===========================================================================*/
  // * Name    : handlerStop                                                     */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * This method will loop through a list of Handlers and will try to stop that Handler's thread by
   * calling the Thread's setStopRequest(). This is considered a Soft Stop.
   */
  private void handlerStop() {
    logger.debug("Calling handlerStop() started.");
    if (handlerList != null) {
      handlerMonitor.setStopRequest(true);
      for (int i = 0; i < handlerList.size(); i++) {
        Handler handler = (Handler) handlerList.get(i);
        if (!handler.isDead()) {
          logger.info("Stopping thread: " + handler.getClass().getName());
          handler.stop();
          handler.setPreviousHandlerFinished(true);
        }
      }
    }
    logger.debug("Calling handlerStop() finished.");
  }

  // *===========================================================================*/
  // * Name    : oracleStop                                                      */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * This method will loop through a list of active Handler's threads and then call the Handler's
   * cancelOracle(). The cancelOracle() will loop though a list of CallableStatements and
   * PreparedStatements that are being used and then use the statement's cancel() to directly
   * contact Oracle and stop those transactions.
   */
  private void oracleStop() {
    if (handlerList != null) {
      for (int i = 0; i < handlerList.size(); i++) {
        Handler handler = (Handler) handlerList.get(i);
        if (!handler.isDead()) {
          logger.debug("Cancelling Oracle Commands for thread: " + handler.getClass().getName());
          handler.cancelOracle();
        }
      }
    }
  }

  // *===========================================================================*/
  // * Name    : checkHandlers                                                   */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * This method will loop through a list of active Handler's threads and checks to see if they are
   * still active.
   */
  private boolean checkHandlers() {
    boolean safeToShutDown = false;
    int active = 0;

    if (handlerList != null) {
      for (int i = 0; i < handlerList.size(); i++) {
        Handler handler = (Handler) handlerList.get(i);
        if (!handler.isDead()) {
          logger.debug(handler.getClass().getName() + " thread is still active.");
          active++;
        }
      }
      if (active > 0) {
        if (handlerMonitor.isHandlerFailed()) {
          logger.error("A Handler has failed to process ... Shutting down.");
        }
      } else {
        logger.info("There are no active Handlers running ... Shutting down.");
        safeToShutDown = true;
      }
    }
    return safeToShutDown;
  }

  // *===========================================================================*/
  // * Name    : checkHandlerMonitor                                             */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * This method will check the HandlerMonitor object, which is passed into the ???Handler to see if
   * that thread has finished it's processing or not. When the Handler has finished processing, the
   * Handler will set a boolean value in the HandlerMonitor object tobe retrieved by the OpsHandler.
   * The OpsHandler will then attempt to set a boolean value in the ???Handler's thread's that is
   * dependent on the completion of the ???Handler that has just finished processing.
   */
  private void checkHandlerMonitor() throws ProcessException {
    if (handlerMonitor.isHandlerFailed()) {
      shutDown();
    } else {
      if (handlerMonitor.isResHandlerFinished() && !resStatusSet) {
        logger.info(RES_HANDLER + " has finished processing.");
        logger.info("Preparing " + NONRES_HANDLER + " for shutdown.");
        stopHandler(NONRES_HANDLER);
        resStatusSet = true;
      }

      if (handlerMonitor.isNonResHandlerFinished() && !nonResStatusSet) {
        logger.info(NONRES_HANDLER + " has finished processing.");
        nonResStatusSet = true;
      }
    }
  }

  // *===========================================================================*/
  // * Name    : stopHandler                                                     */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * This method will attempt to stop a specified Handler's thread by calling the setStopRequest().
   *
   * @param String containing Handler Name
   */
  private void stopHandler(String s) throws ProcessException {
    logger.info("Retrieving class name from Hashtable for " + s);
    Handler handler = null;
    String className = (String) handlers.get(s);
    Class c = null;

    try {
      logger.info("Instantiating handler " + s + " (" + className + ")");
      c = Class.forName(className);
    } catch (Exception e) {
      logger.error("Unable to get class reference for key " + s, e);
      throw new ProcessException(
          new Exception("Unable to get class reference for key " + s + " : " + e));
    }

    if (handlerList != null) {
      for (int i = 0; i < handlerList.size(); i++) {
        handler = (Handler) handlerList.get(i);

        if (c.isInstance(handler)) {
          if (!handler.isDead()) {
            logger.info("Setting stopRequest boolean variable for " + handler.getThreadName());
            handler.setPreviousHandlerFinished(true);
            handler = null;
          }
        }
      }
    }
  }

  // *===========================================================================*/
  // * Name    : shutDown                                                        */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * A serious problem has occurred. Handler threads are not shutting down properly. Something is
   * hanging. This method will attempt to first stop all Handler threads with a soft kill. However
   * if the Threads are still active after that, then an attempt to directly shutdown an Oracle
   * transaction will be made by contacting the Database directly. If that still does not work, then
   * an attempt to shut each Handler thread will be made by calling the Thread's interrupt(). If the
   * Thread or Threads are still not dead, then an email will be sent out stating that fact.
   */
  private void shutDown() {
    logger.info("Calling shutdown() started.");

    // Try shutting down application softly
    logger.info("Trying to stop handlers by setting the Thread's stopRequested boolean value.");
    handlerStop();
    try { // Sleep
      Thread.sleep(SHUTDOWN_WAIT_TIME);
    } catch (InterruptedException ie) {
      logger.error("Awoken during sleep ... continue checking other Handler objects.");
    }
    if (checkHandlers()) {
      stop();
    } else {
      logger.error(
          "Normal shutdown not possible. Try stopping Oracle Calls directly with Database.");
      // Normal shutdown not possible. Try stopping Oracle Calls directly with Database
      oracleStop();
      try { // Sleep
        Thread.sleep(SHUTDOWN_WAIT_TIME);
      } catch (InterruptedException ie) {
        logger.error("Awoken during sleep ... continue checking other Handler objects.");
      }
      // Check if handlers have shutdown
      if (checkHandlers()) {
        stop();
      } else {
        logger.error(
            "Unable to shutdown via Oracle. Try stopping Handler's thread by interrupting the thread.");
        // Try interrupting Handler's thread
        handlerKill();
      }
      try { // Sleep
        Thread.sleep(SHUTDOWN_WAIT_TIME);
      } catch (InterruptedException ie) {
        logger.error("Awoken during sleep ... continue checking other Handler objects.");
      }
      if (checkHandlers()) {
        stop();
      } else {
        logger.error(
            "Serious Error!!! Unable to shutdown Handlers. Please contact OSG to manually kill all processes related to Month End.");
        emailMessage =
            "Serious Error!!! Unable to shutdown Handlers. Please contact OSG to manually kill all processes related to MPM.";
        emailSubject = EMAIL_ERROR_SUBJECT;
      }
    }
    logger.info("Calling shutDown() finished.");
  }

  // *===========================================================================*/
  // * Name    : run                                                             */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /** @see java.lang.Runnable#run() */
  public void run() {
    logger.info("Operator Control Starting (run)");
    EmailHelper eh = getEmailHelper();
    String msg = null;
    long before = System.currentTimeMillis();
    long after = 0;
    float duration = 0;

    // Start Handlers
    handlerStart();

    // Start Getting Messages off of the Ops Queue
    try {
      while (!isStopRequested()) {
        if (stopFile.exists()) {
          logger.info("***** Shutdown file exists. Shutting down application.*****");
          shutDown();
        } else { // Sleep
          Thread.sleep(SLEEP_DURATION);

          // Check HandlerMonitor to see completion status of Handlers.
          checkHandlerMonitor();

          // Sleep a little more to ensure Hanlder shutdown before calling checkHandlers()
          Thread.sleep(SLEEP_DURATION);

          after = System.currentTimeMillis();
          duration = ((after - before) / 1000F);

          if (checkHandlers()) { // No more active Handlers; safe to shutdown.
            logger.info("Month End has completed ...Time: " + duration + " seconds.");
            stop();
          } else { // If program is running longer than maximum allowed running time, then Shutdown
            if (duration > MAX_RUNNING_TIME) {
              logger.error(
                  "Program is running longer than maximum allowed running time...shutting down");
              logger.error("Program run time is " + duration + " seconds.");
              shutDown();
            }
          }
        }
      }
    } catch (ProcessException e) {
      logger.error("Caught Process error ... Shutting down", e);
      emailMessage = "Caught Process error ... Shutting down" + e;
      emailSubject = EMAIL_ERROR_SUBJECT;
      shutDown();
    } catch (InterruptedException e) {
      logger.info("Awoken during sleep ... Shutting down");
      if (!isStopRequested()) {
        shutDown();
      }
    } catch (Exception e) {
      logger.error("Caught unexpected execption ... Shutting down", e);
      emailMessage = "Caught unexpected execption ... Shutting down" + e;
      emailSubject = EMAIL_ERROR_SUBJECT;
      shutDown();
    } finally {
      if (emailOption) {
        if (eh != null) {
          try {
            eh.sendEmail(DESTINATION, emailSubject, emailMessage);
            logger.info("Email notification has been sent to: " + DESTINATION);
          } catch (ProcessException ce) {
            logger.error("Unable to send email notification to " + DESTINATION + " : " + ce);
          }
        }
      }
      System.out.println("Month End Process finished.....");
      destroy();
    }
    logger.info("Operator Control ended (run)");
  }

  // *===========================================================================*/
  // * Name    : execute                                                         */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 10 2005   Initial Spec                            */
  // *===========================================================================*/
  /** @see moh.hpc.month.end.handlers.Handler#execute() */
  public void execute() {
    logger.debug("Calling execute() called.");
    start();
    logger.debug("Calling execute() finished.");
  }
}
