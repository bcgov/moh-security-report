/**
 * ****************************************************************************** Licensed Materials
 * - Property of IBM * ï¿½ Copyright IBM Canada Ltd 2005 All Rights Reserved * Created on Jan 11, 2005
 * * ****************************************************************************** Please do not
 * makes any changes to this file without first * updating the revision history below, under
 * description * please include Harvest Change Request or PSO Tools CR that * caused the change. *
 * ****************************************************************************** Revision History:
 * * * Date Name Description * ---------- ----------------
 * --------------------------------------------- * Jan-11-2005 David Bartlett Initial Specs *
 * Apr-27-2005 David Bartlett Added handler monitor to processor setup. * Sep-19-2005 Ron Merner
 * Added steps for detail reports. *
 * ******************************************************************************
 */
package moh.hpc.month.end.handlers;

import jakarta.enterprise.context.Dependent;
import jakarta.enterprise.inject.spi.CDI;
import java.io.IOException;
import java.net.ServerSocket;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import moh.hpc.month.end.EmailHelper;
import moh.hpc.month.end.HandlerMonitor;
import moh.hpc.month.end.ReportHelper;
import moh.hpc.month.end.Runner;
import moh.hpc.month.end.constants.ApplicationConstants;
import moh.hpc.month.end.constants.PropertyFileKeys;
import moh.hpc.month.end.exceptions.ProcessException;
import moh.hpc.month.end.resident.processors.MonthEndResProcessor;
import moh.hpc.month.end.services.MEDataService;
import moh.hpc.month.end.support.ProvTransitionsStats;
import moh.hpc.month.end.support.Province;
import moh.hpc.month.end.support.ProvinceDetails;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Dependent
public class ResidentsHandler extends Handler {

  private MEDataService ds = null;
  private Properties prp = null;
  private EmailHelper eh = null;
  private ReportHelper rh = null;
  private HandlerMonitor hm = null;
  private Hashtable processors = null;
  private ArrayList trtProvinces = null;
  private Hashtable provStatList = null;
  // Month End Province Statuses
  private String provinceMEStatus01 = null;
  private String provinceMEStatus02 = null;
  private String provinceMEStatus03 = null;
  private String provinceMEStatus04 = null;
  private String provinceMEStatus05 = null;
  private String provinceMEStatus06 = null;
  private String provinceMEStatus07 = null;
  private String provinceMEStatus08 = null;
  private String provinceMEStatus09 = null;
  private String provinceMEStatus10 = null;
  private String provinceMEStatus11 = null;
  private String provinceMEStatus12 = null;
  private String provinceMEStatus13 = null;
  private String provinceMEStatusError = null;
  private String provinceStep01 = null;
  private String provinceStep02 = null;
  private String provinceStep03 = null;
  private String provinceStep04 = null;
  private String provinceStep05 = null;
  private String provinceStep06 = null;
  private String provinceStep07 = null;
  private String provinceStep08 = null;
  private String provinceStep09 = null;
  private String provinceStep10 = null;
  private String provinceStep11 = null;
  private String provinceStepDef = null;
  private float inclStartTimeOff = 0;
  private float inclEndTimeOff = 0;
  private float exclStartTimeOff = 0;
  private float exclEndTimeOff = 0;
  private String stepCode = null;
  private String balanceFlag = null;
  private String residencyType = null;
  private String processingMonth = null;
  private String rcvProvCodes = null;
  private static String runResidentME = null;
  private ArrayList rcvProvList = null;
  // Lock Socket
  private ServerSocket lockSocket = null;
  // Email Notification option
  private String emailMessage;
  private static Logger logger = LoggerFactory.getLogger("ResidentsHandler");
  private Boolean emailOption;

  // *===========================================================================*/
  // * Name : constructor */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  public ResidentsHandler() throws ProcessException {
    super();
  }

  // *===========================================================================*/
  // * Name : destroy */
  // * Purpose : Closes objects used by the ResidentsHandler as app. shuts down. */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  public void destroy() {
    if (rh != null) {
      rh = null;
    }
    if (trtProvinces != null) {
      trtProvinces = null;
    }
    if ((provStatList != null) && (provStatList.size() != 0)) {
      provStatList.clear();
      provStatList = null;
    }

    if (ds != null) {
      ds.destroy();
      ds = null;
    }
    if (processors != null) {
      processors.clear();
      processors = null;
    }
    closeLockSocket();
    setDead(true);
  }

  // *===========================================================================*/
  // * Name : finalize */
  // * Purpose : Method that ensure the destroy method is executed when */
  // * application shuts down. */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  protected void finalize() throws Throwable {
    try {
      destroy();
    } finally {
      super.finalize();
    }
  }

  // *===========================================================================*/
  // * Name : initialize */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  /** Sets up class variables retrieved from the properties file to be used in the process(). */
  public void initialize() throws ProcessException {
    logger.debug("ResidentsHandler initialize() starting");
    super.initialize();
    String sessionId = "ME: " + this.getClass().getName();

    eh = getEmailHelper();
    // ********************
    // Set handler monitor
    // ********************
    hm = getMonitor();
    // JHOOPC-822: Reset to false so Resident ME can run when Non Resident has errors.
    hm.setHandlerFailed(false);
    if (hm == null) {
      throw new ProcessException(new Exception("Handler Monitor object is null. Cannot proceed"));
    }

    // *******************************************
    // Set properties file and extract properties
    // *******************************************
    prp = getPrp();
    if (prp == null) {
      throw new ProcessException(new Exception("Property object is null. Cannot proceed"));
    }

    // ********************
    // Setting up lock socket
    // ********************
    try {
      logger.info("Acquiring MonthEndHandler Lock Socket");
      lockSocket =
          Runner.createLock(prp.getProperty(PropertyFileKeys.PRP_RES_HANDLER_LOCK_PORT), logger);
    } catch (Exception e) {
      throw new ProcessException(new Exception("Unable to acquire MonthEndHandler Lock Socket"));
    }
    if (lockSocket == null) {
      throw new ProcessException(new Exception("Unable to acquire MonthEndHandler Lock Socket"));
    }

    // ******************************************************
    // Extract required values from property file and check
    // the resident flag. If it is N then the resident
    // handler is not allowed to run and there is no
    // need to proceed further
    // ******************************************************
    extractProperties();
    if (runResidentME.equals("Y")) {
      // ******************************************************
      // Set DataService object to communicate with Oracle
      // ******************************************************
      createMEDataService();
      ds = getMeDataService();
      if (ds == null) {
        throw new ProcessException(new Exception("Data Service object is null. Cannot proceed"));
      }

      // ****************************
      // Retrieving processing month
      // ****************************
      try {
        processingMonth = ds.getProcMonth(residencyType, sessionId);
      } catch (SQLException se) {
        logger.error("Unable to obtain current processing month");
        throw new ProcessException(se);
      }
      logger.info("Processing Month: " + processingMonth);
      // ***********************************************
      // 1) Setup the report helper
      // 2) Retrieve Treating Provinces and their current status,
      // 3) Retrieve province transition statues
      // 4) Load processors
      // **********************************************
      rh = new ReportHelper();
      rh.setDataService(ds);
      rh.setProperties(prp);
      rh.initialize();

      loadProvinces();
      loadProvinceStatuses();
      setupProcessors();
    }
    logger.debug("ResidentsHandler initialize() ending");
  }
  // *===========================================================================*/
  // * Name : extractProperties */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 2005 Initial Spec */
  // *===========================================================================*/

  /** Extracts the required properties the resident handler needs from the property fil */
  private void extractProperties() throws ProcessException {
    logger.debug("calling extractProperties started");

    // ***********************************
    // Retrieving required codes and flag
    // ***********************************
    stepCode = prp.getProperty(PropertyFileKeys.PRP_RES_STEP_CODE);
    provinceStep01 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_STEP);
    provinceStep02 = prp.getProperty(PropertyFileKeys.PRP_RES_BALRPT_STEP);
    provinceStep03 = prp.getProperty(PropertyFileKeys.PRP_RES_BALSTAT_STEP);
    provinceStep04 = prp.getProperty(PropertyFileKeys.PRP_RES_REQRPT_STEP);
    provinceStep05 = prp.getProperty(PropertyFileKeys.PRP_RES_REQSTAT_STEP);
    provinceStep06 = prp.getProperty(PropertyFileKeys.PRP_RES_PAYRPT_STEP);
    provinceStep07 = prp.getProperty(PropertyFileKeys.PRP_RES_ERRRPT_STEP);
    provinceStep08 = prp.getProperty(PropertyFileKeys.PRP_RES_INPRPT_STEP);
    provinceStep09 = prp.getProperty(PropertyFileKeys.PRP_RES_OUTRPT_STEP);
    provinceStep10 = prp.getProperty(PropertyFileKeys.PRP_RES_FTP_STEP);
    provinceStep11 = prp.getProperty(PropertyFileKeys.PRP_RES_ROLLOVER_STEP);
    provinceStepDef = prp.getProperty(PropertyFileKeys.PRP_RES_STEP_DEF);
    balanceFlag = prp.getProperty(PropertyFileKeys.PRP_BALANCE_FLAG);

    provinceMEStatus01 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_IMPORT);
    provinceMEStatus02 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_INIT);
    provinceMEStatus03 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_START);
    provinceMEStatus04 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_BALDONE);
    provinceMEStatus05 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_CLMDONE);
    provinceMEStatus06 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_REQ1DONE);
    provinceMEStatus07 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_REQ2DONE);
    provinceMEStatus08 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_PAYDONE);
    provinceMEStatus09 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_INPDONE);
    provinceMEStatus10 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_OUTDONE);
    provinceMEStatus11 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_BATCHDONE);
    provinceMEStatus12 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_FTPPEND);
    provinceMEStatus13 = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_FTPDONE);
    provinceMEStatusError = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_ERROR);
    runResidentME = prp.getProperty(PropertyFileKeys.PRP_RES_FLAG);
    residencyType = prp.getProperty(PropertyFileKeys.PRP_RES_RESIDENCY_TYPE);
    rcvProvCodes = prp.getProperty(PropertyFileKeys.PRP_DRIVING_PROV);
    emailOption = Boolean.valueOf(prp.getProperty(PropertyFileKeys.PRP_EMAIL_NOTIFICATION));

    // ************************************
    // Validating required codes and flags
    // ************************************
    try {
      if ((stepCode.length() == 0)
          || (provinceStep01.length() == 0)
          || (provinceStep02.length() == 0)
          || (provinceStep03.length() == 0)
          || (provinceStep04.length() == 0)
          || (provinceStep05.length() == 0)
          || (provinceStep06.length() == 0)
          || (provinceStep07.length() == 0)
          || (provinceStep08.length() == 0)
          || (provinceStep09.length() == 0)
          || (provinceStep10.length() == 0)
          || (provinceStep11.length() == 0)
          || (provinceStepDef.length() == 0)
          || (balanceFlag.length() == 0)
          || (runResidentME.length() == 0)
          || (residencyType.length() == 0)
          || (rcvProvCodes.trim().length() == 0)
          || (provinceMEStatus01.length() == 0)
          || (provinceMEStatus02.length() == 0)
          || (provinceMEStatus03.length() == 0)
          || (provinceMEStatus04.length() == 0)
          || (provinceMEStatus05.length() == 0)
          || (provinceMEStatus06.length() == 0)
          || (provinceMEStatus07.length() == 0)
          || (provinceMEStatus08.length() == 0)
          || (provinceMEStatus09.length() == 0)
          || (provinceMEStatus10.length() == 0)
          || (provinceMEStatus11.length() == 0)
          || (provinceMEStatus12.length() == 0)
          || (provinceMEStatusError.length() == 0)) {
        logger.error("Some properties for the resident handler are null when they cannot be");
        logger.error("Current Step Code:           " + stepCode);
        logger.error("Step code 1:                 " + provinceStep01);
        logger.error("Step code 2:                 " + provinceStep02);
        logger.error("Step code 3:                 " + provinceStep03);
        logger.error("Step code 4:                 " + provinceStep04);
        logger.error("Step code 5:                 " + provinceStep05);
        logger.error("Step code 6:                 " + provinceStep06);
        logger.error("Step code 7:                 " + provinceStep07);
        logger.error("Step code 8:                 " + provinceStep08);
        logger.error("Step code 9:                 " + provinceStep09);
        logger.error("Step code 10:                " + provinceStep10);
        logger.error("Step code 11:                " + provinceStep11);
        logger.error("Step Default:                " + provinceStepDef);
        logger.error("Status code 1:               " + provinceMEStatus01);
        logger.error("Status code 2:               " + provinceMEStatus02);
        logger.error("Status code 3:               " + provinceMEStatus03);
        logger.error("Status code 4:               " + provinceMEStatus04);
        logger.error("Status code 5:               " + provinceMEStatus05);
        logger.error("Status code 6:               " + provinceMEStatus06);
        logger.error("Status code 7:               " + provinceMEStatus07);
        logger.error("Status code 8:               " + provinceMEStatus08);
        logger.error("Status code 9:               " + provinceMEStatus09);
        logger.error("Status code 10:              " + provinceMEStatus10);
        logger.error("Status code 11:              " + provinceMEStatus11);
        logger.error("Status code 12:              " + provinceMEStatus12);
        logger.error("Status code 13:              " + provinceMEStatus13);
        logger.error("Status code Error:           " + provinceMEStatusError);
        logger.error("Receiving Provinces:         " + rcvProvCodes);
        logger.error("Balance Flag:                " + balanceFlag);
        logger.error("Run Resident Month End Flag: " + runResidentME);
        logger.error("Residency Type Code:         " + residencyType);
        throw new ProcessException(new Exception("Config File Parameter error"));
      }
    } catch (NullPointerException npe) {
      logger.error("Missing properties in the config file" + npe);
      throw new ProcessException(npe);
    }

    // **************************
    // Retreive offsets
    // **************************
    String IStart = null;
    String IEnd = null;
    String EStart = null;
    String EEnd = null;
    try {
      IStart = prp.getProperty(PropertyFileKeys.PRP_RES_INCL_START_TIME_OFFSET);
      IEnd = prp.getProperty(PropertyFileKeys.PRP_RES_INCL_END_TIME_OFFSET);
      EStart = prp.getProperty(PropertyFileKeys.PRP_RES_EXCL_START_TIME_OFFSET);
      EEnd = prp.getProperty(PropertyFileKeys.PRP_RES_EXCL_END_TIME_OFFSET);
      inclStartTimeOff = Float.parseFloat(IStart);
      inclEndTimeOff = Float.parseFloat(IEnd);
      exclStartTimeOff = Float.parseFloat(EStart);
      exclEndTimeOff = Float.parseFloat(EEnd);
    } catch (NumberFormatException ne) {
      logger.error("Time offsets must be numeric");
      logger.error("Include Start Time Offset: " + IStart);
      logger.error("Include End Time Offset:   " + IEnd);
      logger.error("Exclude Start Time Offset: " + EStart);
      logger.error("Exclude End Time Offset:   " + EEnd);
      throw new ProcessException(new Exception("Numeric value error occurred " + ne));
    }

    logger.debug("calling extractProperties ended");
  }
  // *===========================================================================*/
  // * Name : closeLockSocket */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 10 2005 Initial Spec */
  // *===========================================================================*/

  /** Closes and releases lock port for ResidentsHandler. */
  private void closeLockSocket() {
    if (lockSocket != null) {
      try {
        logger.debug("Closing ResidentsHandler Lock Socket");
        lockSocket.close();
      } catch (IOException e) {
        logger.error("Unable to close ResidentsHandler Lock Socket", e);
      } finally {
        lockSocket = null;
      }
    }
  }
  // *===========================================================================*/
  // * Name : shutDown */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 10 2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Calls HandlerMonitor objects shutdown(). This is called when the MonthEndHandler has failed and
   * the program needs to be shutdown. This action will cause the other handlers to shutdown if they
   * haven't already.
   */
  private void shutDown() {
    if (hm != null) {
      hm.shutdown();
    }
  }
  // *===========================================================================*/
  // * Name : loadProvinces */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Gets a list of the treating Provinces and their current statuses. The status of each province
   * is checked against a list of month end statuses and those treating provinces that are not one
   * of the month end states are removed from the list. As well, a list of the receiving provinces
   * (there should only be one) just to get their provincial details for use in the batch import.
   */
  private void loadProvinces() throws ProcessException {

    logger.debug("calling loadProvinces started");
    String sessionId = "ME: " + this.getClass().getName();

    // *******************************************************************
    // Retrieve the receiving province(s) for the resident month end.
    // Normally there will be only one the code have been created so that
    // it can accept more than one.
    // *******************************************************************
    int idx1 = 0;
    int idx2 = rcvProvCodes.length();
    int scanIdx = rcvProvCodes.length();
    int provIdx = 0;
    boolean validProvince = true;
    rcvProvList = new ArrayList();
    while ((idx2 > 0)) {
      idx1 =
          rcvProvCodes.lastIndexOf(",", scanIdx) != -1
              ? rcvProvCodes.lastIndexOf(",", scanIdx) + 1
              : 0;
      String provCode = rcvProvCodes.substring(idx1, idx2);
      idx2 = idx1 - 1;
      scanIdx = idx1 - 2;
      logger.info("Resident Month End Receiving Driving Province: " + provCode);
      ProvinceDetails rcvProvDtls = null;
      try {
        rcvProvDtls = ds.getProvinceDetails(provCode, sessionId);
      } catch (SQLException se) {
        logger.error("Problems occurred retrieving details of the receiving province");
        throw new ProcessException(se);
      }
      rcvProvList.add(rcvProvDtls);
      rcvProvDtls = null;
      provIdx += 1;
    }
    if (rcvProvList.size() == 0) {
      logger.error("No receiving province(s) details for the receiving province(s) were found.");
      throw new ProcessException(new Exception("No Receiving Province Details found"));
    }

    // *******************************************************************
    // Retrieve the treating province(s) for the resident month end.
    // There are the provinces that treated residents of the receiving
    // province(s) and hence will need to bill the receiving province(s).
    // *******************************************************************
    trtProvinces = new ArrayList();
    try {
      trtProvinces = ds.getProvinces(residencyType, sessionId);
    } catch (SQLException se) {
      logger.error("Problems occurred retrieving the list of treating Provinces");
      throw new ProcessException(se);
    }
    int i = 0;
    logger.info(
        "The following treating Provinces have been selected to be processed by the month end");
    while (i < trtProvinces.size()) {
      Province tmpProv = (Province) trtProvinces.get(i);
      if ((tmpProv.getCurStatus().equals(provinceMEStatus01))
          || (tmpProv.getCurStatus().equals(provinceMEStatus02))
          || (tmpProv.getCurStatus().equals(provinceMEStatus03))
          || (tmpProv.getCurStatus().equals(provinceMEStatus04))
          || (tmpProv.getCurStatus().equals(provinceMEStatus05))
          || (tmpProv.getCurStatus().equals(provinceMEStatus06))
          || (tmpProv.getCurStatus().equals(provinceMEStatus07))
          || (tmpProv.getCurStatus().equals(provinceMEStatus08))
          || (tmpProv.getCurStatus().equals(provinceMEStatus09))
          || (tmpProv.getCurStatus().equals(provinceMEStatus10))
          || (tmpProv.getCurStatus().equals(provinceMEStatus11))
          || (tmpProv.getCurStatus().equals(provinceMEStatus12))
          || (tmpProv.getCurStatus().equals(provinceMEStatus13))) {
        // *******************************************************
        // If Province is at the correct status then retrieve
        // its detail information
        // *******************************************************
        logger.info("Province: " + tmpProv.getProvince() + " at Status: " + tmpProv.getCurStatus());
        ProvinceDetails trtProvDtls = null;
        try {
          trtProvDtls = ds.getProvinceDetails(tmpProv.getProvince(), sessionId);
          trtProvDtls.setResidencyType(residencyType);
        } catch (SQLException se) {
          logger.error("Problems occurred retrieving details of the treating province");
          throw new ProcessException(se);
        }
        tmpProv.setProvDetails(trtProvDtls);
        trtProvinces.set(i, tmpProv);
        trtProvDtls = null;
        i += 1;
      } else {
        // *******************************************************
        // If Province is not the correct status then remove
        // it from the list.
        // *******************************************************
        trtProvinces.remove(i);
      }
      tmpProv = null;
    }
    if (trtProvinces.size() == 0) {
      logger.error("No valid trtProvinces were found");
    }
    logger.debug("calling loadProvinces ended");
  }

  // *===========================================================================*/
  // * Name : loadProvinceStatuses */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 14 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Loads the statuses used by the treating Provinces. This also includes the transition statuses
   * and time restrictions on each status (when the month end is allowed to run a province at a
   * particular status)
   *
   * @throws ProcessException
   */
  private void loadProvinceStatuses() throws ProcessException {
    logger.debug("Calling loadProvinceStatuses() started.");
    String sessionId = "ME: " + this.getClass().getName();

    logger.info("Retrieving Province Status Transitions");
    ArrayList tmpArray = new ArrayList();
    provStatList = new Hashtable();
    try {
      try {
        tmpArray = ds.getProvTransStats(residencyType, sessionId);
      } catch (SQLException se) {
        logger.error("Unable to obtain a list of the province statuses");
        throw new ProcessException(se);
      }
      if ((tmpArray == null) || (tmpArray.size() == 0)) {
        logger.error("Unable to obtain a list of the province statuses");
        throw new ProcessException(
            new Exception("Unable to obtain a list of the province statuses"));
      }

      logger.info("Converting time restrictions to minutes.");
      int i = 0;
      while (i < tmpArray.size()) {
        try {
          ProvTransitionsStats tmpPS = (ProvTransitionsStats) tmpArray.get(i);
          logger.debug("Include Start Time: " + tmpPS.getInclStartTime());
          logger.debug("Include End Time:   " + tmpPS.getInclEndTime());
          logger.debug("Exclude Start Time: " + tmpPS.getExclStartTime());
          logger.debug("Exclude End Time:   " + tmpPS.getExclEndTime());

          tmpPS.setInclStartTimeMins((tmpPS.getInclStartTime()) * 60);
          tmpPS.setInclEndTimeMins((tmpPS.getInclEndTime()) * 60);
          tmpPS.setExclStartTimeMins((tmpPS.getExclStartTime()) * 60);
          tmpPS.setExclEndTimeMins((tmpPS.getExclEndTime()) * 60);

          if ((inclStartTimeOff != 0) && (tmpPS.getInclStartTimeMins() != 0)) {
            tmpPS.setInclStartTimeMins((tmpPS.getInclStartTimeMins()) + inclStartTimeOff);
            tmpPS.setInclStartTime(tmpPS.getInclStartTimeMins() / 60);
          }

          if ((inclEndTimeOff != 0) && (tmpPS.getInclEndTimeMins() != 0)) {
            tmpPS.setInclEndTimeMins((tmpPS.getInclEndTimeMins()) + inclEndTimeOff);
            tmpPS.setInclEndTime(tmpPS.getInclEndTimeMins() / 60);
          }

          if ((exclStartTimeOff != 0) && (tmpPS.getExclStartTimeMins() != 0)) {
            tmpPS.setExclStartTimeMins((tmpPS.getExclStartTimeMins()) + exclStartTimeOff);
            tmpPS.setExclStartTime(tmpPS.getExclStartTimeMins() / 60);
          }

          if ((exclEndTimeOff != 0) && (tmpPS.getExclEndTimeMins() != 0)) {
            tmpPS.setExclEndTimeMins((tmpPS.getExclEndTimeMins()) + exclEndTimeOff);
            tmpPS.setExclEndTime(tmpPS.getExclEndTimeMins() / 60);
          }
          String key = tmpPS.getStartStatus().trim() + ":" + tmpPS.getTransCause().trim();
          provStatList.put(key, tmpPS);
          tmpPS = null;
          i += 1;
        } catch (NumberFormatException nfe) {
          logger.error(
              "Problem occurred formatting time restrictions. One or more values are not numeric");
          throw new ProcessException(new Exception("Numeric value error occurred" + nfe));
        }
      }

    } finally {
      tmpArray = null;
    }

    logger.debug("Calling loadProvinceStatuses() ended.");
  }
  // *===========================================================================*/
  // * Name : setupProcessors */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 13 2005 Initial Spec */
  // * DC Bartlett April 27 2005 Set monitor for processors. */
  // *===========================================================================*/

  /**
   * Sets up processors to be used on each resident province. Processors will determine what
   * business requirements need to be implemented for that particular provnices status code.
   *
   * @throws ProcessException
   */
  private void setupProcessors() throws ProcessException {
    logger.debug("Calling setupProcessors() started.");
    Enumeration enum1 = prp.keys();
    processors = new Hashtable();
    String origKey = null;
    String key = null;
    String value = null;
    Class c = null;
    MonthEndResProcessor process = null;
    while (enum1.hasMoreElements()) {
      origKey = (String) enum1.nextElement();
      if (origKey.startsWith(PropertyFileKeys.PRP_ME_RES_PROCESSOR)) {
        key = origKey.substring(PropertyFileKeys.PRP_ME_RES_PROCESSOR_LENGTH);
        value = prp.getProperty(origKey);
        try {
          c = Class.forName(value);
          process = (MonthEndResProcessor) CDI.current().select(c).get();
          // process = (MonthEndResProcessor) c.newInstance();
          process.setProperties(prp);
          process.setDataService(ds);
          process.setProvStatList(provStatList);
          process.setReportHelper(rh);
          process.setEmailHelper(eh);
          process.setProcessMonth(processingMonth);
          process.setRcvProvList(rcvProvList);
          process.setMonitor(hm);
          process.initialize();
          processors.put(key, process);
        } catch (ProcessException ce) {
          logger.error("Unable to initialize processor: " + ce);
          throw ce;
        } catch (Exception e) {
          logger.error("Unable to get class reference for key " + origKey + e);
          throw new ProcessException(e);
        }
      }
    }
    logger.debug("Calling setupProcessors() finished.");
  }
  // *===========================================================================*/
  // * Name : getProperties */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Returns Properties containing the properties file that is being used.
   *
   * @return Properties containing prp
   */
  public Properties getProperties() {
    return prp;
  }

  // *===========================================================================*/
  // * Name : setProperties */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Sets prp containing a Properties value for a properties file. This value determines the
   * properties file that is being used.
   *
   * @param properties containing a Properties value for prp
   */
  public void setProperties(Properties properties) {
    prp = properties;
  }

  // *===========================================================================*/
  // * Name : getDataService */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Returns MEDataService object which contains access methods that communicate with Oracle Stored
   * Procedures on the Fair Pharmacare Database.
   *
   * @return MEDataService containing fpDataService
   */
  public MEDataService getDataService() {
    return ds;
  }

  // *===========================================================================*/
  // * Name : setDataService */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Sets MEDataService object which contains access methods that communicate with Oracle Stored
   * Procedures on the Fair Pharmacare Database.
   *
   * @param service containing MEDataService
   */
  public void setDataService(MEDataService service) {
    ds = service;
  }

  // *===========================================================================*/
  // * Name : getMonitor */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Returns HandlerMonitor object which contains access methods used to indicate that status of the
   * application (whether a request has been made to stop it).
   *
   * @return HandlerMonitor
   */
  public HandlerMonitor getMonitor() {
    return hm;
  }
  // *===========================================================================*/
  // * Name : setMonitor */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 11 2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Sets HanlderMonitor object which contains access methods used to indicate that status of the
   * application (whether a request has been made to stop it).
   *
   * @param monitor containing HanderMonitor
   */
  public void setMonitor(HandlerMonitor monitor) {
    this.hm = monitor;
  }
  // *===========================================================================*/
  // * Name : processProvince */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 12 2005 Initial Spec */
  // *===========================================================================*/

  /** */
  private void processProvince(Province curProv) {
    logger.debug("Calling processProvince() started.");
    MonthEndResProcessor processor = null;
    MonthEndResProcessor.setMECompleteFlag(false);

    try {
      // *****************************************************************
      // Have to subtract 1 from the processors.size count to ensure the
      // default processoris not run
      // *****************************************************************
      logger.info("Processing Province: " + curProv.getProvince());
      int steps = 0;
      while ((steps < (processors.size() - 1))
          && (!isStopRequested())
          && (!hm.isHandlerFailed())
          && (!curProv.getProvError())) {
        ds.createSavePoint(ApplicationConstants.SAVEPOINT);
        processor = (MonthEndResProcessor) processors.get(String.valueOf(String.valueOf(steps)));
        processor =
            processor != null
                ? processor
                : (MonthEndResProcessor) processors.get(PropertyFileKeys.PRP_ME_RES_PROCESSOR_DEF);
        if (processor != null) {
          try {
            processor.process(curProv, stepCode);
            ds.commit();
            if (MonthEndResProcessor.getMECompleteFlag()) {
              stop();
            }
          } catch (IOException ie) {
            emailMessage =
                "Problem processing Province/Status: "
                    + curProv.getProvince()
                    + "/"
                    + curProv.getCurStatus()
                    + " "
                    + ie;
            logger.error("Problem processing Province: " + curProv.getProvince(), ie);
            logger.error("Province halted while at status: " + curProv.getCurStatus());
            logger.error("Application will be shutdown");
            ds.rollback(ApplicationConstants.SAVEPOINT);
            ds.commit();
            stop();
            shutDown();
          } catch (ProcessException ce) {
            emailMessage =
                "Problem processing Province/Status: "
                    + curProv.getProvince()
                    + "/"
                    + curProv.getCurStatus()
                    + " "
                    + ce;
            logger.error("Problem processing Province: " + curProv.getProvince(), ce);
            logger.error("Province halted while at status: " + curProv.getCurStatus());
            logger.error("Application will be shutdown");
            ds.rollback(ApplicationConstants.SAVEPOINT);
            ds.commit();
            stop();
            shutDown();
          } catch (SQLException se) {
            if (se.getErrorCode() == ApplicationConstants.ERR_LOCK_SEQ) { // If the error code is a
              // custom error from
              // oracle then we will
              // ignore, otherwise
              // rethrow exception
              logger.error("Problem processing Province: " + curProv.getProvince(), se);
              logger.error("Error indicates data for Province was externally modified");
              logger.error("Province skipped while at status: " + curProv.getCurStatus());
              ds.rollback(ApplicationConstants.SAVEPOINT);
              ds.commit();
            } else {
              emailMessage =
                  "Oracle problem occurred while processing province "
                      + curProv.getProvince()
                      + " "
                      + se;
              logger.error(
                  "Oracle problem occurred while processing province: " + curProv.getProvince(),
                  se);
              logger.error("Shutting down ResidentsHandler.");
              ds.rollback(ApplicationConstants.SAVEPOINT);
              ds.commit();
              stop();
              shutDown();
            }
          }
        } else {
          emailMessage =
              "Processor is null, default processor not set or defined incorrectly for "
                  + curProv.getProvince();
          logger.error("Processor is null, default processor not set or defined incorrectly!!!");
          logger.error("Province: " + curProv.getProvince() + " Status: " + curProv.getCurStatus());
          stop();
          shutDown();
        }
        steps += 1;
      }
    } catch (SQLException se) {
      if (emailMessage == null) {
        emailMessage = "Problem processing Provinces from Oracle: " + " " + se;
      }
      logger.error("Problem processing Provinces from Oracle: ", se);
      logger.error("Shutting down ResidentsHandler.");
      stop();
      shutDown();
    }
    logger.debug("Calling processProvince() finished.");
  }

  // *===========================================================================*/
  // * Name : process */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett January 12 2005 Initial Spec */
  // *===========================================================================*/
  /** Resident Handling for all treating provinces */
  public void run() {
    logger.info("Calling ResidentsHandler run() started.");
    String sessionId = "ME: " + this.getClass().getName();
    String msg = null;
    long before = 0;
    long after = 0;
    long sleepBefore = 0;
    long sleepAfter = 0;
    int processed = 0;
    int totalProcessed = 0;

    try { // Initialize objects required
      initialize();
      if (!(runResidentME.equals("Y"))) {
        hm.shutdown(RES_HANDLER);
        logger.info("Resident flag is not set. Resident Handler will not be run");
      } else {
        try {
          int i = 0;

          while ((i < trtProvinces.size()) && (!isStopRequested())) {
            before = System.currentTimeMillis();
            processProvince((Province) trtProvinces.get(i));
            after = System.currentTimeMillis();
            logger.info(
                "Total Time taken: "
                    + ((after - before) / 1000F)
                    + " seconds to process province "
                    + ((Province) trtProvinces.get(i)).getProvince());
            i += 1;
          }

          if (!hm.isHandlerFailed()) {
            logger.info("Shutting down ResidentHandler");
            hm.shutdown(RES_HANDLER);
          }
        } catch (Exception e) { // Catch all for inner loop
          if (emailMessage == null) {
            emailMessage = "Caught unexpected exception ...Shutting down " + e;
          }
          logger.error("Caught unexpected exception ...Shutting down ", e);
          stop();
          shutDown();
        }
      }
    } catch (ProcessException e) {
      if (emailMessage == null) {
        emailMessage = "Unable to initialize ResidentsHandler ...Shutting down " + e;
      }
      logger.error("Unable to initialize ResidentsHandler ...Shutting down ", e);
      stop();
      shutDown();
    } catch (Exception e) { // Catch all for outer loop
      if (emailMessage == null) {
        emailMessage =
            "Caught unexpected exception,Unable to initialize ResidentsHandler ...Shutting down "
                + e;
      }
      logger.error(
          "Caught unexpected exception,Unable to initialize ResidentsHandler ...Shutting down ", e);
      stop();
      shutDown();
    } finally { // Summary of transactions
      logger.info("Resident Handler Finished");
      if (emailMessage != null && !emailMessage.equals("")) {
        try {
          if (eh != null) {
            if (emailOption) {
              eh.sendEmail(DESTINATION, EMAIL_ERROR_SUBJECT, emailMessage);
              logger.info("Email notification has been sent to: " + DESTINATION);
            }
          } else {
            logger.info(
                "Email notification cannot be sent: " + DESTINATION + " as email helper not setup");
          }
        } catch (Exception ce) {
          logger.error("Unable to send email notification to " + DESTINATION + " : " + ce);
        } finally {
            logger.info("ResidentsHandler Before Destroyed");
            emailMessage = "";
        }
      }
      destroy();
    }
    logger.info("Calling ResidentsHandler run() finished.");
    logger.info("******************************************");
    logger.info(" ");
  }

  public void execute() {
    logger.debug("Calling execute() called.");
    start();
    logger.debug("Calling execute() finished.");
  }
}
