/**
 * ****************************************************************************** Licensed Materials
 * - Property of IBM * Copyright IBM Canada Ltd 2005 All Rights Reserved * Created on Feb 15, 2005 *
 * ****************************************************************************** Please do not
 * makes any changes to this file without first * updating the revision history below, under
 * description * please include Harvest Change Request or PSO Tools CR that * caused the change. *
 * ****************************************************************************** Revision History:
 * * * Date Name Description * ---------- ----------------
 * --------------------------------------------- * 02-15-2005 David Bartlett Initial Spec 06-28-2006
 * Cathy HU Modified getProvinceRpts for the name of * claim file to ON. *
 * ******************************************************************************
 */
package moh.hpc.month.end.nonresident.processors;

import com.ibm.network.sftp.Sftp;
import jakarta.enterprise.context.Dependent;
import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Properties;
import moh.broker.utils.PasswordUtility;
import moh.hpc.month.end.FileHelper;
import moh.hpc.month.end.SFTPHelper;
import moh.hpc.month.end.constants.PropertyFileKeys;
import moh.hpc.month.end.exceptions.ProcessException;
import moh.hpc.month.end.services.MEDataService;
import moh.hpc.month.end.support.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Dependent
public class MEFTPProcessor extends MonthEndNonResProcessor {

  private Properties prp = null;
  private MEDataService ds = null;
  private Hashtable provStatList = null;
  private String processMonth = null;
  private String trtProvStartStat = null;
  private String rcvProvStartStat = null;
  private String startingStatus = null;
  private String trtProvNextStat = null;
  private String rcvProvNextStat = null;
  private String nextStatus = null;
  private String successTrans = null;
  private String trtStatusKey = null;
  private String rcvStatusKey = null;
  private String statusKey = null;
  private String trtProvFtpStep = null;
  private String rcvProvFtpStep = null;
  private String ftpStatusStep = null;
  private String defaultStep = null;
  private String ftpAllowed = null;
  private String ftpHostName = null;
  private String ftpUserName = null;
  private boolean ftpUseKey;
  private String ftpPrivateKeyPath = null;
  private String ftpKnownHostsPath = null;
  private String ftpPswd = null;
  private String ftpDir = null;
  private String sourceDir = null;
  private String pdfExt = null;
  private String txtExt = null;
  private String pdfFileFormat = null;
  private String txtFileFormat = null;
  private String mbxCmd = null;
  private String trtProvRpts = null;
  private String rcvProvRpts = null;
  private String provRpts = null;
  private String hospRpts = null;
  private String HARpts = null;
  private static Logger logger = LoggerFactory.getLogger("MEFTPProcessor");

  public MEFTPProcessor() {
    super();
  }

  /**
   * Sets up class objects (properties, dataservice, province status list) and other variables to be
   * used in the process().
   *
   * @throws ProcessException
   */
  @Override
  public void initialize() throws ProcessException {
    logger.debug("Calling initialize() started.");
    prp = getProperties();
    ds = getDataService();
    provStatList = getProvStatList();
    processMonth = getProcessMonth();

    trtProvStartStat = prp.getProperty(PropertyFileKeys.PRP_NONRES_TPROV_STAT_FTPPEND);
    trtProvFtpStep = prp.getProperty(PropertyFileKeys.PRP_NONRES_TPROV_FTP_STEP);
    trtProvRpts = prp.getProperty(PropertyFileKeys.PRP_NONRES_TPROV_RPTS);
    rcvProvStartStat = prp.getProperty(PropertyFileKeys.PRP_NONRES_RPROV_STAT_FTPPEND);
    rcvProvFtpStep = prp.getProperty(PropertyFileKeys.PRP_NONRES_RPROV_FTP_STEP);
    rcvProvRpts = prp.getProperty(PropertyFileKeys.PRP_NONRES_RPROV_RPTS);
    hospRpts = prp.getProperty(PropertyFileKeys.PRP_NONRES_TPROV_HOSP_RPTS);
    HARpts = prp.getProperty(PropertyFileKeys.PRP_NONRES_TPROV_HA_RPTS);
    successTrans = prp.getProperty(PropertyFileKeys.PRP_PROV_TRANS_CAUSE_SUCCESS);
    defaultStep = prp.getProperty(PropertyFileKeys.PRP_RES_STEP_DEF);

    sourceDir = prp.getProperty(PropertyFileKeys.PRP_RPT_DIR);
    pdfExt = prp.getProperty(PropertyFileKeys.PRP_RPT_PDF_EXT);
    txtExt = prp.getProperty(PropertyFileKeys.PRP_RPT_TXT_EXT);
    txtFileFormat = prp.getProperty(PropertyFileKeys.PRP_RPT_TXT_FORMAT);
    pdfFileFormat = prp.getProperty(PropertyFileKeys.PRP_RPT_PDF_FORMAT);
    mbxCmd = prp.getProperty(PropertyFileKeys.PRP_MAILBOX_CMD);
    ftpAllowed = prp.getProperty(PropertyFileKeys.PRP_NONRES_FTP_FLAG);
    ftpHostName = prp.getProperty(PropertyFileKeys.PRP_FTP_SRVR);
    ftpUserName = prp.getProperty(PropertyFileKeys.PRP_FTP_USER);
    ftpUseKey = Boolean.parseBoolean(prp.getProperty(PropertyFileKeys.PRP_FTP_USE_KEY));
    ftpKnownHostsPath = prp.getProperty(PropertyFileKeys.PRP_FTP_KNOWN_HOSTS_PATH);

    if (ftpUseKey) {
      ftpPrivateKeyPath = prp.getProperty(PropertyFileKeys.PRP_FTP_PRIVATE_KEY_PATH);
    } else {
      ftpPswd = prp.getProperty(PropertyFileKeys.PRP_FTP_PWD);
    }

    ftpDir = prp.getProperty(PropertyFileKeys.PRP_FTP_OUTDIR);

    try {
      if ((trtProvStartStat.trim().length() == 0)
          || (trtProvFtpStep.trim().length() == 0)
          || (rcvProvStartStat.trim().length() == 0)
          || (rcvProvFtpStep.trim().length() == 0)
          || (successTrans.trim().length() == 0)
          || (ftpAllowed.trim().length() == 0)
          || (defaultStep.trim().length() == 0)
          || (ftpHostName.trim().length() == 0)
          || (ftpUserName.trim().length() == 0)
          || (txtFileFormat.trim().length() == 0)
          || (pdfFileFormat.trim().length() == 0)
          || (trtProvRpts.trim().length() == 0)
          || (rcvProvRpts.trim().length() == 0)
          || (hospRpts.trim().length() == 0)
          || (HARpts.trim().length() == 0)
          || (ftpUseKey && ftpPrivateKeyPath.trim().isEmpty())
          || (!ftpUseKey && ftpPswd.trim().isEmpty())) {
        logger.error("Some properties for the ftp processor are null when they cannot be");
        logger.error("FTP Treating  Province Starting Status: " + trtProvStartStat);
        logger.error("FTP Receiving Province Starting Status: " + rcvProvStartStat);
        logger.error("FTP Treating  Province Step Code:       " + trtProvFtpStep);
        logger.error("FTP Receiving Province Step Code:       " + rcvProvFtpStep);
        logger.error("Success Transition Code:                " + successTrans);
        logger.error("Text File Format:                       " + txtFileFormat);
        logger.error("PDF File Format:                        " + pdfFileFormat);
        logger.error("FTP Allowed:                            " + ftpAllowed);
        logger.error("Default Step Code:                      " + defaultStep);
        logger.error("FTP Host Name:                          " + ftpHostName);
        logger.error("FTP User Name:                          " + ftpUserName);
        logger.error("FTP Use Private Key:                    " + ftpUseKey);
        logger.error("FTP Private Key File Path:              " + ftpPrivateKeyPath);
        logger.error("FTP Password:                           " + ftpPswd);
        logger.error("Text File Format:                       " + txtFileFormat);
        logger.error("Treating Province Report List:          " + trtProvRpts);
        logger.error("Receiving Province Report List:         " + rcvProvRpts);
        logger.error("Hospital Report List:                   " + hospRpts);
        logger.error("Health Authority Report List:           " + HARpts);
        throw new ProcessException(new Exception("Config File Parameter error"));
      }
    } catch (NullPointerException npe) {
      logger.error("Missing properties in the config file " + npe);
      throw new ProcessException(npe);
    }
    // *********************************************
    // Determine next status
    // *********************************************
    try {
      trtStatusKey = trtProvStartStat.trim() + ":" + successTrans.trim();
      trtProvNextStat = ((ProvTransitionsStats) (provStatList.get(trtStatusKey))).getEndStatus();
      rcvStatusKey = rcvProvStartStat.trim() + ":" + successTrans.trim();
      rcvProvNextStat = ((ProvTransitionsStats) (provStatList.get(rcvStatusKey))).getEndStatus();
    } catch (NullPointerException npe) {
      logger.error(
          "Treating or Receiving Province Next status not found in transition status list. ");
      logger.error("Treating  Province Next Status: " + trtProvNextStat);
      logger.error("Receiving Province Next Status: " + rcvProvNextStat);
      throw new ProcessException(npe);
    }
    // *********************************************
    // Decode FTP Password
    // *********************************************
    try {
      // Attempt decoding only if using pasword
      if (!ftpUseKey) {
        ftpPswd = PasswordUtility.simpleDecoder(ftpPswd);
      }
    } catch (NullPointerException npe) {
      logger.error("FTP Server password can not be decoded " + npe);
      throw new ProcessException(npe);
    }

    logger.debug("Calling initialize() finished.");
  }

  /**
   * Retrieves all reports that were processed for a particular province in the given processing
   * month but only if they have been tagged as being ftpable. If so then once they are retrieved
   * they are FTPed to the appropriate mailboxes
   *
   * @param curProv A province object for the current object being processed.
   * @param stepCode Code indicating whether or not this step of the month end should be executed It
   *     will usually be defaulted to 'ALL'
   * @throws SQLException
   * @throws IOException
   * @throws ProcessException
   */
  @Override
  public void process(Province curProv, String stepCode)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling process() started.");
    logger.info("");
    logger.info(
        "Starting FTP step for Province/Status: "
            + curProv.getProvince()
            + "/"
            + curProv.getCurStatus());

    String sessionId = "ME: " + this.getClass().getName() + logger.getName();
    curProv.setProvError(false);

    // ***********************************************
    // Ensure province is flagged as either a treating
    // or receving province
    // ***********************************************
    if ((curProv.getProvDetails().getTProvinceFlag())
        && (!curProv.getProvDetails().getRProvinceFlag())) {
      startingStatus = trtProvStartStat;
      nextStatus = trtProvNextStat;
      statusKey = trtStatusKey;
      ftpStatusStep = trtProvFtpStep;
      provRpts = trtProvRpts;
      logger.info("Processor Starting Status: " + startingStatus);
      logger.info("Processor Step Code:       " + stepCode);
    } else if ((curProv.getProvDetails().getRProvinceFlag())
        && (!curProv.getProvDetails().getTProvinceFlag())) {
      startingStatus = rcvProvStartStat;
      nextStatus = rcvProvNextStat;
      statusKey = rcvStatusKey;
      ftpStatusStep = rcvProvFtpStep;
      provRpts = rcvProvRpts;
      logger.info("Processor Starting Status: " + startingStatus);
      logger.info("Processor Step Code:       " + stepCode);
    } else {
      curProv.setProvError(true);
      logger.error(
          "Province must be identified as either treating OR receiving. It is neither or both. ");
      logger.error("Treating flag is: " + curProv.getProvDetails().getTProvinceFlag());
      logger.error("Receiving flag is: " + curProv.getProvDetails().getRProvinceFlag());
      throw new ProcessException(new Exception("Province is in error: " + curProv.getProvince()));
    }

    // ***********************************************
    // Ensure that the next and current status
    // fields are not null
    // ***********************************************
    if ((nextStatus == null)
        || (nextStatus.trim().length() == 0)
        || (curProv.getCurStatus() == null)
        || (curProv.getCurStatus().trim().length() == 0)) {
      logger.error(
          "One or more of the status fields are null for province: " + curProv.getProvince());
      logger.error("Current Status: " + curProv.getCurStatus());
      logger.error("Next Status:    " + nextStatus);
      throw new ProcessException(new Exception("Province is in error: " + curProv.getProvince()));
    }

    // *************************************************************
    // Only process the province if it is at the correct status,
    // there was no overriding step command and it is valid to run
    // the province at its current status at the current time
    // *************************************************************
    if (!(ftpAllowed.equals("Y"))) {
      logger.info("Flag has been set to dissallow FTP");
    } else {
      if ((curProv.getCurStatus().equals(startingStatus))
          && ((stepCode.equals(defaultStep)) || (stepCode.equals(ftpStatusStep)))) {
        if (!validateTime(curProv.getCurStatus(), statusKey, provStatList)) {
          logger.info(
              "The current Province is not allowed to run at this time at its current status");
          logger.info("Province/Status: " + curProv.getProvince() + "/" + curProv.getCurStatus());
          curProv.setProvError(true);
        } else {
          logger.info("FTP reports for province: " + curProv.getProvince());
          if (curProv.getProvDetails().getTProvinceFlag()) {
            ftpTreatingProvinceRpts(curProv, sessionId);
          } else {
            ftpReceivingProvinceRpts(curProv, sessionId);
          }
        }
      }
    }

    logger.debug("Calling process() finished.");
  }

  /**
   * FTP's all reports related to a treating province. This includes province, hospital and Health
   * Authority reports.
   *
   * @param curProv A province object for the current object being processed.
   * @param sessionId Object that called this method
   * @throws SQLException, IOException, ProcessException
   */
  private void ftpTreatingProvinceRpts(Province curProv, String sessionId)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling ftpTreatingProvinceRpts() started.");

    ArrayList rptRequests = null;
    try {
      rptRequests = getProvinceRpts(curProv, sessionId);
      rptRequests.addAll(getHospitalRpts(curProv, sessionId));
      rptRequests.addAll(getHARpts(curProv, sessionId));

      ftpProvinceRpts(curProv, rptRequests, sessionId);
    } finally {
      cleanupProvinceRpts(curProv, rptRequests, sessionId);
    }

    logger.info("Reports FTPed for Province: " + curProv.getProvince());
    curProv.setProvError(false);
    ds.advanceProvStat(
        curProv.getProvince(),
        curProv.getProvDetails().getResidencyType(),
        sessionId,
        curProv.getCurStatus(),
        successTrans);
    curProv.setCurStatus(nextStatus);

    logger.debug("Calling ftpTreatingProvinceRpts() ended.");
  }

  /**
   * FTP's all reports related to a treating province
   *
   * @param curProv A province object for the current object being processed.
   * @param sessionId Object that called this method
   * @throws SQLException, IOException, ProcessException
   */
  private void ftpReceivingProvinceRpts(Province curProv, String sessionId)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling ftpReceivingProvinceRpts() started.");

    ArrayList rptRequests = null;
    try {
      rptRequests = getProvinceRpts(curProv, sessionId);
      ftpProvinceRpts(curProv, rptRequests, sessionId);
    } finally {
      cleanupProvinceRpts(curProv, rptRequests, sessionId);
    }

    logger.info("Reports FTPed for Province: " + curProv.getProvince());
    curProv.setProvError(false);
    ds.advanceProvStat(
        curProv.getProvince(),
        curProv.getProvDetails().getResidencyType(),
        sessionId,
        curProv.getCurStatus(),
        successTrans);
    curProv.setCurStatus(nextStatus);
    logger.debug("Calling ftpReceivingProvinceRpts() ended.");
  }

  /**
   * Retrieves all reports that were processed for a particular treating/receiving province in the
   * given processing month but only if they have been tagged as being ftpable.
   *
   * @param curProv A treating/receiving province object for the current object being processed.
   * @param sessionId Object that called this method
   * @throws SQLException, IOException, ProcessException
   */
  private ArrayList getProvinceRpts(Province curProv, String sessionId)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling getProvinceRpts() started.");

    ArrayList provRptRequest =
        ds.getProvinceRptRequests(
            curProv.getProvince(),
            curProv.getProvDetails().getResidencyType(),
            processMonth,
            provRpts,
            sessionId);

    if (!provRptRequest.isEmpty()) {
      int i = 0;
      FileHelper fh = new FileHelper();
      try {
        while (i < provRptRequest.size()) {
          Reports tmpRpt = (Reports) provRptRequest.get(i);

          byte[] rptBytes =
              ds.executeRetrieveReport(tmpRpt.getRptRequestId(), tmpRpt.getDataFormat(), sessionId);

          if (rptBytes.length != 0) {
            String tmpDEI =
                curProv.getProvDetails().getSubmitIdentifier().trim() == null
                    ? ""
                    : curProv.getProvDetails().getSubmitIdentifier().trim();
            String tmpSFP =
                tmpRpt.getServerFilePrefix() == null ? "" : tmpRpt.getServerFilePrefix();

            String fname;
            java.io.File f;
            String ext = tmpRpt.getDataFormat().equalsIgnoreCase(pdfExt) ? pdfExt : txtExt;
            //BCMOHAD-9616-3Mar22: Removing the extension modification for Ontario files as its not needed to treat it separately.

            //BCMOHAM-21683 add "NonRes" to file name
            
            
              //fname = mbxCmd + tmpDEI + "." + curProv.getProvince().trim() + tmpSFP;
              
              fname = mbxCmd + tmpDEI + "." + curProv.getProvince().trim() + tmpSFP + " NONRES";
              
              f = fh.createFile(fname, sourceDir, ext);

            fh.writeFile(rptBytes, f.getAbsolutePath());
            tmpRpt.setFileName(f.getName());
            tmpRpt.setFilePath(f.getAbsolutePath());
            provRptRequest.set(i, tmpRpt);
            logger.info("File created: " + f.getAbsolutePath());
            i += 1;
          } else {
            provRptRequest.remove(i);
          }
        }
        if (provRptRequest.isEmpty()) {
          logger.info(
              "No reports found for selected request ids for province: " + curProv.getProvince());
        }
      } finally {
        if (fh != null) {
          fh = null;
        }
      }
    }

    logger.debug("Calling getProvinceRpts() ended.");
    return provRptRequest;
  }

  /**
   * Retrieves all hospital reports that were processed for a particular province in the given
   * processing month but only if they have been tagged as being ftpable.
   *
   * @param curProv A province object for the current object being processed.
   * @param sessionId Object that called this method
   * @throws SQLException, IOException, ProcessException
   */
  private ArrayList getHospitalRpts(Province curProv, String sessionId)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling getHospitalRpts() started.");

    int hospIdx = 0;
    ArrayList rptRequests = new ArrayList();
    ArrayList hospList = curProv.getHospList();

    // *******************************************************************
    // Loop through each hospital associated with the passed in province.
    // *******************************************************************
    try {
      while (hospIdx < hospList.size()) {
        HospitalDetails hospDtl = (HospitalDetails) hospList.get(hospIdx);

        ArrayList hospRptRequests =
            ds.getHospitalRptRequests(
                hospDtl.getHospitalNumber(),
                curProv.getProvDetails().getResidencyType(),
                processMonth,
                hospRpts,
                sessionId);
        if (!hospRptRequests.isEmpty()) {
          int i = 0;
          FileHelper fh = new FileHelper();
          // *********************************************************
          // Retrive the most current reports created in the current
          // processing month for the hospital being processed.
          // *********************************************************
          while (i < hospRptRequests.size()) {
            Reports tmpRpt = (Reports) hospRptRequests.get(i);
            byte[] rptBytes =
                ds.executeRetrieveReport(
                    tmpRpt.getRptRequestId(), tmpRpt.getDataFormat(), sessionId);
            if (rptBytes.length != 0) {
              String tmpDEI =
                  hospDtl.getDataExchangeId() == null ? "" : hospDtl.getDataExchangeId();
              String tmpSFP =
                  tmpRpt.getServerFilePrefix() == null ? "" : tmpRpt.getServerFilePrefix();
              String fname = mbxCmd + tmpDEI + "." + curProv.getProvince().trim() + tmpSFP;

              java.io.File f =
                  fh.createFile(
                      fname,
                      sourceDir,
                      tmpRpt.getDataFormat().equalsIgnoreCase(pdfExt) ? pdfExt : txtExt);

              // **************************************************
              // Write each report retrieved for the hospital being
              // processed out to the server as a flat file.
              // **************************************************
              fh.writeFile(rptBytes, f.getAbsolutePath());
              tmpRpt.setFileName(f.getName());
              tmpRpt.setFilePath(f.getAbsolutePath());
              hospRptRequests.set(i, tmpRpt);
              logger.info("File created: " + f.getAbsolutePath());
              i += 1;
            } else {
              hospRptRequests.remove(i);
            }
          }
          if (!hospRptRequests.isEmpty()) {
            rptRequests.addAll(hospRptRequests);
          }
          fh = null;
        }
        hospIdx += 1;
      }
      if (rptRequests.isEmpty()) {
        logger.info("No hospital reports found for province: " + curProv.getProvince());
      }
    } finally {
      if (hospList != null) {
        hospList = null;
      }
    }

    logger.debug("Calling getHospitalRpts() ended.");
    return rptRequests;
  }

  /**
   * Retrieves all Health Authority reports that were processed for a particular province in the
   * given processing month but only if they have been tagged as being ftpable.
   *
   * @param curProv A province object for the current object being processed.
   * @param sessionId Object that called this method
   * @throws SQLException, IOException, ProcessException
   */
  private ArrayList getHARpts(Province curProv, String sessionId)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling getHARpts() started.");

    int HAIdx = 0;
    ArrayList rptRequests = new ArrayList();
    ArrayList HAList = curProv.getHAList();

    // ***************************************************************************
    // Loop through each Health Authority associated with the passed in province.
    // ***************************************************************************
    try {
      while (HAIdx < HAList.size()) {
        HADetails HADtl = (HADetails) HAList.get(HAIdx);

        ArrayList HARptRequests =
            ds.getHARptRequests(
                HADtl.getHANumber(),
                curProv.getProvDetails().getResidencyType(),
                processMonth,
                HARpts,
                sessionId);

        if (!HARptRequests.isEmpty()) {
          int i = 0;
          FileHelper fh = new FileHelper();
          // ************************************************************
          // Retrive the most current reports created in the current
          // processing month for the Health Authority  being processed.
          // ***********************************************************
          while (i < HARptRequests.size()) {
            Reports tmpRpt = (Reports) HARptRequests.get(i);

            byte[] rptBytes =
                ds.executeRetrieveReport(
                    tmpRpt.getRptRequestId(), tmpRpt.getDataFormat(), sessionId);
            if (rptBytes.length != 0) {
              String tmpDEI = HADtl.getDataExchangeId() == null ? "" : HADtl.getDataExchangeId();
              String tmpSFP =
                  tmpRpt.getServerFilePrefix() == null ? "" : tmpRpt.getServerFilePrefix();
              String fname = mbxCmd + tmpDEI + "." + curProv.getProvince().trim() + tmpSFP;

              java.io.File f =
                  fh.createFile(
                      fname,
                      sourceDir,
                      tmpRpt.getDataFormat().equalsIgnoreCase(pdfExt) ? pdfExt : txtExt);

              // **************************************************
              // Write each report retrieved for the Health Authority
              // being processed out to the server as a flat file.
              // **************************************************
              fh.writeFile(rptBytes, f.getAbsolutePath());
              tmpRpt.setFileName(f.getName());
              tmpRpt.setFilePath(f.getAbsolutePath());
              HARptRequests.set(i, tmpRpt);
              logger.info("File created: " + f.getAbsolutePath());
              i += 1;
            } else {
              HARptRequests.remove(i);
            }
          }
          if (!HARptRequests.isEmpty()) {
            rptRequests.addAll(HARptRequests);
          }
          fh = null;
        }
        HAIdx += 1;
      }
      if (rptRequests.isEmpty()) {
        logger.info("No Health Authority reports found for province: " + curProv.getProvince());
      }
    } finally {
      if (HAList != null) {
        HAList = null;
      }
    }
    logger.debug("Calling getHARpts() ended.");
    return rptRequests;
  }

  /**
   * FTP's a given list of files to the appropriate mailboxes
   *
   * @param curProv A province object for the current object being processed.
   * @param rptRequests List of reports for the province that need to be FTPed
   * @param sessionId Object that called this method
   * @throws SQLException, IOException, ProcessException
   */
  private void ftpProvinceRpts(Province curProv, ArrayList rptRequests, String sessionId)
      throws IOException, ProcessException {
    logger.debug("Calling ftpProvinceRpts() started.");

    if ((rptRequests == null) || (rptRequests.isEmpty())) {
      logger.info("No FTPable reports found for province: " + curProv.getProvince());
    } else {
      // *********************
      // Connect to FTP Server
      // *********************
      int j = 0;
      Sftp sftp =
          ftpUseKey
              ? SFTPHelper.connectUsingKeys(
                  ftpHostName, ftpUserName, ftpPrivateKeyPath, ftpKnownHostsPath)
              : SFTPHelper.connectUsingPassword(
                  ftpHostName, ftpUserName, ftpPswd, ftpKnownHostsPath);

      try {
        if (sftp == null || !sftp.isConnected()) {
          throw new ProcessException(new Exception("Could not connect to SFTP Server"));
        }

        // *************************************************
        // If remote directory provided then change to it
        // otherwise stay in directory automatically placed
        // in when ftp connection is made
        // *************************************************
        if ((ftpDir.length() != 0) && (ftpDir != null)) {
          int retval = SFTPHelper.setRemoteDir(ftpDir, sftp);
          if (retval != Sftp.SUCCESS) {
            throw new ProcessException(
                new Exception("Problems occurred changing to remote dir: " + ftpDir));
          }
        }
        // **********************************
        // FTP all reports for the province
        // **********************************
        while (j < rptRequests.size()) {
          Reports ftpRpt = (Reports) rptRequests.get(j);

          int retval =
              SFTPHelper.sendSFTPFile(sourceDir, ftpRpt.getFileName(), ftpRpt.getFileName(), sftp);
          if (retval != Sftp.SUCCESS) {
            throw new ProcessException(
                new Exception("Problems occurred Ftping file: " + ftpRpt.getFileName()));
          }
          j += 1;
        }
      } finally {
        if (sftp != null) {
          sftp.disconnect();
        }
      }
    }
    logger.debug("Calling ftpProvinceRpts() ended.");
  }

  /**
   * Removes a given list of files from the source directory
   *
   * @param curProv A province object for the current object being processed.
   * @param rptRequests List of reports for the province that need to be deleted
   * @param sessionId Object that called this method
   * @throws SQLException, IOException, ProcessException
   */
  private void cleanupProvinceRpts(Province curProv, ArrayList rptRequests, String sessionId)
      throws ProcessException {
    logger.debug("Calling cleanupProvinceRpts() started.");

    if ((rptRequests != null) && (!rptRequests.isEmpty())) {
      int j = 0;
      FileHelper fh = new FileHelper();
      Reports tmpRpt = null;
      try {
        while (j < rptRequests.size()) {
          tmpRpt = (Reports) rptRequests.get(j);
          if ((tmpRpt.getFilePath().trim().length() != 0)
              && (!(tmpRpt.getFilePath().equals(null)))) {
            logger.info("Deleting file from source directory: " + tmpRpt.getFilePath());
            fh.deleteFile(tmpRpt.getFilePath());
          }
          j += 1;
        }
      } catch (IOException ie) {
        logger.error("Problems occurred trying to delete file: " + tmpRpt.getFilePath());
        throw new ProcessException(ie);
      }
    }
    logger.debug("Calling cleanupProvinceRpts() ended.");
  }
}
