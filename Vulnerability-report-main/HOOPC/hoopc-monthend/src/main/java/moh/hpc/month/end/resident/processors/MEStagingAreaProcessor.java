/*
 *  * 02-25-2005 David Bartlett Initial Spec *
 * 04-27-2005 David Bartlett Added handler monitor handling and ftp flag * 07-05-2005 Ron Merner
 * Modified createOutClaim() to use the ICD09 * versions of the diagnosis and procedure *
 * attributes. * 04-06-2006 Christine Root Changed to comply with newer file format * 05-31-2006
 * Cathy Hu Changed to comply with newer file format * for the mandatory fields change * 08-05-2007
 * C Stepanov Major rewrite to load the submission files * into the staging area and validate as *
 * per new set of rules *
 * ******************************************************************************
 */
package moh.hpc.month.end.resident.processors;

import com.ibm.network.sftp.Sftp;
import jakarta.enterprise.context.Dependent;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Hashtable;
import java.util.Properties;
import moh.broker.utils.PasswordUtility;
import moh.common.business.services.utils.CommonValidator;
import moh.common.business.services.utils.Helper;
import moh.hoopc.app.Ric;
import moh.hoopc.app.Roc;
import moh.hoopc.services.ClaimDataService;
import moh.hoopc.services.util.ServiceFailedException;
import moh.hoopc.staging.SADetailRecord;
import moh.hoopc.staging.SAHeaderRecord;
import moh.hoopc.util.Init;
import moh.hpc.month.end.EmailHelper;
import moh.hpc.month.end.FileHelper;
import moh.hpc.month.end.HandlerMonitor;
import moh.hpc.month.end.SFTPHelper;
import moh.hpc.month.end.constants.ApplicationConstants;
import moh.hpc.month.end.constants.PropertyFileKeys;
import moh.hpc.month.end.constants.batch.imprt.DtlCmn;
import moh.hpc.month.end.constants.batch.imprt.DtlInp;
import moh.hpc.month.end.constants.batch.imprt.DtlOutp;
import moh.hpc.month.end.constants.batch.imprt.Hdr;
import moh.hpc.month.end.exceptions.ProcessException;
import moh.hpc.month.end.services.MEDataService;
import moh.hpc.month.end.support.ImportFileDetails;
import moh.hpc.month.end.support.Province;
import moh.hpc.month.end.support.ProvinceDetails;
import moh.hpc.month.end.support.ProvinceFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Dependent
public class MEStagingAreaProcessor extends MonthEndResProcessor {

  private HandlerMonitor hmont = null;
  private Properties prp = null;
  private MEDataService ds = null;
  private Hashtable provStatList = null;
  private String processMonth = null;
  private ProvinceFilter pf = null;
  private EmailHelper eh = null;
  private CommonValidator cv = null;
  private ArrayList rpList = null;
  private ArrayList importList = null;
  private String startingStatus = null;
  private String nextStatus = null;
  private String successTrans = null;
  private String statusKey = null;
  private String importStep = null;
  private String defaultStep = null;
  private String loadStartStatus = null;
  private String loadDoneStatus = null;
  private String ftpFormat = null;
  private String ftpAllowed = null;
  private String ftpHostName = null;
  private String ftpUserName = null;
  private boolean ftpUseKey;
  private String ftpPrivateKeyPath = null;
  private String ftpKnownHostsPath = null;
  private String ftpPswd = null;
  private String ftpInDir = null;
  private String ftpOutDir = null;
  private String inputDirStr = null;
  private String processDirStr = null;
  private String trashDirStr = null;
  private String errorDirStr = null;
  private String reportDirStr = null;
  private String ext = null;
  private String mbxCmd = null;
  private String importRptName = null;
  private String importRptMsg1 = null;
  private String importRptMsg2 = null;
  private String importRptMsg3 = null;
  private String importRptMsg4 = null;
  private String importRptMsg5 = null;
  private String importRptMsg6 = null;
  private String importRptMsg7 = null;
  private String importRptMsg8 = null;
  private String replaceStr = null;
  private int commitSize = 0;
  private int retention = 0;
  private File inpDir = null;
  private File processDir = null;
  private File trashDir = null;
  private File errorDir = null;
  private File reportDir = null;
  private String emailMessage = "";
  private String DESTINATION = null;
  private String EMAIL_WARN_SUBJECT = null;
  private String EMAIL_ERROR_SUBJECT = null;
  private String EMAIL_NORMAL_SUBJECT = null;
  private static Logger logger = LoggerFactory.getLogger("MEStagingAreaProcessor");
  private int fileval;
  private BufferedReader inFile1;

  private Boolean EMAIL_OPTION;

  ClaimDataService claimDS;

  // *===========================================================================*/
  // * Name : constructor */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 25 2005 Initial Spec */
  // *===========================================================================*/
  public MEStagingAreaProcessor() {
    super();
  }

  /**
   * Sets up class objects (properties, dataservice, province status list) and other variables to be
   * used in the process().
   *
   * @throws ProcessException
   */
  public void initialize() throws ProcessException {
    logger.debug("Calling initialize() started.");
    String sessionId = "ME: " + this.getClass().getName();
    prp = getProperties();
    ds = getDataService();
    eh = getEmailHelper();
    hmont = getMonitor();
    provStatList = getProvStatList();
    processMonth = getProcessMonth();
    rpList = getRcvProvList();

    startingStatus = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_IMPORT);
    loadStartStatus = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_IMPORT_LOAD_INIT);
    loadDoneStatus = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_IMPORT_LOAD_DONE);
    successTrans = prp.getProperty(PropertyFileKeys.PRP_PROV_TRANS_CAUSE_SUCCESS);
    importStep = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_STEP);
    defaultStep = prp.getProperty(PropertyFileKeys.PRP_RES_STEP_DEF);

    inputDirStr = prp.getProperty(PropertyFileKeys.PRP_INPUT_DIR);
    processDirStr = prp.getProperty(PropertyFileKeys.PRP_PROCESS_DIR);
    trashDirStr = prp.getProperty(PropertyFileKeys.PRP_TRASH_DIR);
    errorDirStr = prp.getProperty(PropertyFileKeys.PRP_ERROR_DIR);
    reportDirStr = prp.getProperty(PropertyFileKeys.PRP_RPT_DIR);

    ext = prp.getProperty(PropertyFileKeys.PRP_RPT_TXT_EXT);
    importRptName = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_NAME);
    importRptMsg1 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG1);
    importRptMsg2 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG2);
    importRptMsg3 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG3);
    importRptMsg4 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG4);
    importRptMsg5 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG5);
    importRptMsg6 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG6);
    importRptMsg7 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG7);
    importRptMsg8 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG8);
    replaceStr = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_REPLACE_STRING);

    mbxCmd = prp.getProperty(PropertyFileKeys.PRP_MAILBOX_CMD);
    ftpAllowed = prp.getProperty(PropertyFileKeys.PRP_RES_BI_FTP_FLAG);
    ftpHostName = prp.getProperty(PropertyFileKeys.PRP_FTP_SRVR);
    ftpUserName = prp.getProperty(PropertyFileKeys.PRP_FTP_USER);
    ftpUseKey = Boolean.parseBoolean(prp.getProperty(PropertyFileKeys.PRP_FTP_USE_KEY));
    ftpKnownHostsPath = prp.getProperty(PropertyFileKeys.PRP_FTP_KNOWN_HOSTS_PATH);

    if (ftpUseKey) {
      ftpPrivateKeyPath = prp.getProperty(PropertyFileKeys.PRP_FTP_PRIVATE_KEY_PATH);
    } else {
      ftpPswd = prp.getProperty(PropertyFileKeys.PRP_FTP_PWD);
    }
    ftpInDir = prp.getProperty(PropertyFileKeys.PRP_FTP_INDIR);
    ftpOutDir = prp.getProperty(PropertyFileKeys.PRP_FTP_OUTDIR);
    ftpFormat = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_FTP_FORMAT);

    EMAIL_WARN_SUBJECT = prp.getProperty(PropertyFileKeys.PRP_EMAIL_WARN_SUBJECT).trim();
    EMAIL_ERROR_SUBJECT = prp.getProperty(PropertyFileKeys.PRP_EMAIL_ERROR_SUBJECT).trim();
    EMAIL_NORMAL_SUBJECT = prp.getProperty(PropertyFileKeys.PRP_EMAIL_NORMAL_SUBJECT).trim();
    DESTINATION = prp.getProperty(PropertyFileKeys.PRP_EMAIL_DESTINATION).trim();
    EMAIL_OPTION = Boolean.valueOf(prp.getProperty(PropertyFileKeys.PRP_EMAIL_NOTIFICATION));

    // ******************
    // Get Commit Size
    // ******************
    commitSize = ApplicationConstants.DEFAULT_COMMITSIZE;
    try {
      logger.debug("Parsing Commit Size.");
      commitSize =
          Integer.parseInt(prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_COMMIT_CNT).trim());
    } catch (NumberFormatException e) {
      /* we have a default value */

    }

    // ******************
    // Get Retention
    // ******************
    retention = ApplicationConstants.DEFAULT_RETENTION;
    try {
      logger.debug("Parsing Retention Period.");
      retention =
          Integer.parseInt(prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RETENTION).trim());
    } catch (NumberFormatException e) {
      /* we have a default value */

    }

    try {
      if ((startingStatus.trim().length() == 0)
          || (loadStartStatus.trim().length() == 0)
          || (loadDoneStatus.trim().length() == 0)
          || (successTrans.trim().length() == 0)
          || (importStep.trim().length() == 0)
          || (processMonth == null)
          || (inputDirStr == null)
          || (processDirStr == null)
          || (trashDirStr == null)
          || (errorDirStr == null)
          || (reportDirStr == null)
          || (replaceStr == null)
          || (ftpAllowed.trim().length() == 0)
          || (defaultStep.trim().length() == 0)
          || (ftpHostName.trim().length() == 0)
          || (ftpUserName.trim().length() == 0)
          || (ftpFormat.trim().length() == 0)
          || (ftpUseKey && ftpPrivateKeyPath.trim().isEmpty())
          || (!ftpUseKey && ftpPswd.trim().isEmpty())) {
        logger.error("Some properties for the import processor are null when they cannot be");
        logger.error("Import Starting Status:   " + startingStatus);
        logger.error("Load Starting Status:     " + loadStartStatus);
        logger.error("Load Ending Status:       " + loadDoneStatus);
        logger.error("Success Transition Code:  " + successTrans);
        logger.error("Import Step Code:         " + importStep);
        logger.error("Default Step Code:        " + defaultStep);
        logger.error("Process Month:            " + processMonth);
        logger.error("Input Directory:          " + inputDirStr);
        logger.error("Process Directory:        " + processDirStr);
        logger.error("Trash Directory:          " + trashDirStr);
        logger.error("Error Directory:          " + errorDirStr);
        logger.error("Report Directory:         " + reportDirStr);
        logger.error("FTP Allowed:              " + ftpAllowed);
        logger.error("Default Step Code:        " + defaultStep);
        logger.error("FTP Host Name:            " + ftpHostName);
        logger.error("FTP User Name:            " + ftpUserName);
        logger.error("FTP Use Private Key:                    " + ftpUseKey);
        logger.error("FTP Private Key File Path:              " + ftpPrivateKeyPath);
        logger.error("FTP Password:                           " + ftpPswd);
        logger.error("FTP Import Format:        " + ftpFormat);
        logger.error("Substitution String:      " + replaceStr);
        throw new ProcessException(new Exception("Config File Parameter error"));
      }
    } catch (NullPointerException npe) {
      logger.error("Missing properties in the config file " + npe);
      throw new ProcessException(npe);
    }
    statusKey = startingStatus.trim() + ":" + successTrans.trim();
    // *********************************************
    // Decode FTP Password
    // *********************************************
    if (ftpAllowed.equals("Y")) {
      try {
        // Attempt decoding only if using pasword
        if (!ftpUseKey) {
          ftpPswd = PasswordUtility.simpleDecoder(ftpPswd);
        }
      } catch (NullPointerException npe) {
        logger.error("FTP Server password can not be decoded " + npe);
        throw new ProcessException(npe);
      }
    }

    // ***********************
    // Setting up directories
    // ***********************
    FileHelper fh = new FileHelper();
    try {
      inpDir = fh.createDir(inputDirStr);
      if (!(inpDir.exists())) {
        throw new ProcessException(new Exception("Directory does not exist: " + inpDir));
      }
    } catch (IOException ie1) {
      throw new ProcessException(new Exception(ie1 + " " + inputDirStr));
    }

    try {
      processDir = fh.createDir(processDirStr);
      if (!(processDir.exists())) {
        throw new ProcessException(new Exception("Directory does not exist: " + inpDir));
      }
    } catch (IOException ie2) {
      throw new ProcessException(new Exception(ie2 + " " + processDirStr));
    }

    try {
      trashDir = fh.createDir(trashDirStr);
      if (!(trashDir.exists())) {
        throw new ProcessException(new Exception("Directory does not exist: " + inpDir));
      }
    } catch (IOException ie3) {
      throw new ProcessException(new Exception(ie3 + " " + trashDirStr));
    }

    try {
      errorDir = fh.createDir(errorDirStr);
      if (!(errorDir.exists())) {
        throw new ProcessException(new Exception("Directory does not exist: " + inpDir));
      }
    } catch (IOException ie4) {
      throw new ProcessException(new Exception(ie4 + " " + errorDirStr));
    }

    try {
      reportDir = fh.createDir(reportDirStr);
      if (!(reportDir.exists())) {
        throw new ProcessException(new Exception("Directory does not exist: " + inpDir));
      }
    } catch (IOException ie5) {
      throw new ProcessException(new Exception(ie5 + " " + reportDirStr));
    }

    fh = null;
    logger.debug("Calling initialize() ended.");
  }

  /**
   * Import claims submitted by the provinces that treated B.C. residents in their hospitals. This
   * process wil ftp over to the appropriate server to retrieve any files sumbitted by the
   * provinces, validate the format of the files and load the data within them into the HOOPC
   * database if the file is fine.
   *
   * @param curProv A province object for the current object being processed.
   * @param stepCode Code indicating whether or not this step of the month end should be executed It
   *     will usually be defaulted to 'ALL'
   * @throws SQLException, IOException, ProcessException
   */
  public void process(Province curProv, String stepCode)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling process() started.");
    logger.info("");
    logger.info(
        "Starting Import step for Province/Status: "
            + curProv.getProvince()
            + "/"
            + curProv.getCurStatus());
    logger.info("Processor Starting Status: " + startingStatus);
    logger.info("Processor Step Code:       " + stepCode);

    String sessionId = "ME: " + this.getClass().getName();
    curProv.setProvError(false);
    emailMessage = "";

    // ***********************************************
    // Ensure that the next and current status
    // fields are not null
    // ***********************************************
    if ((curProv.getCurStatus() == null) || (curProv.getCurStatus().trim().length() == 0)) {
      logger.error(
          "One or more of the status fields are null for province: " + curProv.getProvince());
      logger.error("Current Status: " + curProv.getCurStatus());
      logger.error("Next Status:    " + nextStatus);
      throw new ProcessException(new Exception("Province is in error: " + curProv.getProvince()));
    }

    // *************************************************************
    // Only process the province if it is at the correct status,
    // there was no overriding step command and it is valid to run
    // the province at its current status at the current time
    // *************************************************************
    try {
      if ((curProv.getCurStatus().equals(startingStatus))
          && ((stepCode.equals(defaultStep)) || (stepCode.equals(importStep)))) {
        if (!validateTime(curProv.getCurStatus(), statusKey, provStatList)) {
          logger.info(
              "The current Province is not allowed to run at this time at its current status");
          logger.info("Province/Status: " + curProv.getProvince() + "/" + curProv.getCurStatus());
          curProv.setProvError(true);
        } else {
          logger.info("Imports resident Claims into HOOPC from province: " + curProv.getProvince());

          ds.lockProvince(
              curProv.getProvince(), curProv.getProvDetails().getResidencyType(), sessionId);
          pf = new ProvinceFilter(curProv.getProvince());
          FileHelper fh = new FileHelper();
          ArrayList importList = null;

          // *********************
          // Process Import Files
          // *********************
          checkOldImports(curProv);
          if (!(curProv.getProvError())) {
            retrieveImportFiles(curProv);
            preProcessProvinceFiles(curProv);
            importList = processImportFiles(curProv, fh, sessionId);
            importList = createMailingRpts(curProv, importList, fh);
            ftpMailingRpts(curProv, importList);

            cleanupFiles(curProv, importList, fh);
            cleanupReports(curProv, importList, fh);
            purgeTrash();

            logger.info("Import File processing completed for Province: " + curProv.getProvince());
          }
          pf = null;
          fh = null;
          importList = null;
        }
      }
    } finally {
      if (emailMessage.trim().length() != 0) {
        if (eh != null) {
          if (EMAIL_OPTION) {
            eh.sendEmail(DESTINATION, EMAIL_ERROR_SUBJECT, emailMessage);
            logger.info("Email notification has been sent to: " + DESTINATION);
          }

        } else {
          logger.info(
              "Email notification cannot be sent: " + DESTINATION + " as email helper not setup");
        }
      }
    }
    logger.debug("Calling process() ended.");
  }

  /**
   * Currently for Ontario only. It needs the pre-process the file to AB format
   *
   * @param curProv
   */
  private void preProcessProvinceFiles(Province curProv) {
    logger.debug(
        "Calling preProcessProvinceFiles() started." + "Province:" + curProv.getProvince());
    if ("ON".equalsIgnoreCase(curProv.getProvince())) {
      MEFilePreProcessor mfpp = new MEFilePreProcessor();
      mfpp.setInputPath(inputDirStr);
      mfpp.setProcessedPath(processDirStr);
      mfpp.setTrashPath(trashDirStr);
      mfpp.processFiles(curProv.getProvince());
    }
    logger.debug("Calling preProcessProvinceFiles() ended.");
  }

  /**
   * Checks that there are no old import files for the given province left behind from a prior run.
   *
   * @param curProv A Receiving province object for the current object being processed.
   * @return retval Code indicating whether process dir empty or not
   * @throws ProcessException
   */
  private void checkOldImports(Province curProv) throws ProcessException {
    logger.debug("Calling checkOldImports() started.");
    pf = new ProvinceFilter(curProv.getProvince());

    File[] list = processDir.listFiles(pf);
    if (list.length != 0) {
      logger.error("Files were left behind in the process directory. Batch Import abended");
      emailMessage =
          emailMessage
              + "Files were left behind in the process directory. Batch Import abended."
              + "\r\n";
      curProv.setProvError(true);
    }
    logger.debug("Calling checkOldImports() ended.");
  }

  /**
   * Retrieves import files sent by the receiving provinces. It contains claims for B.C. residents
   * who were treating in the hospital(s) of the receiving provinces.
   *
   * @param curProv A Receiving province object for the current object being processed.
   * @throws ProcessException
   */
  private void retrieveImportFiles(Province curProv) throws ProcessException {
    logger.debug("Calling retrieveImportFiles() started.");

    if (!ftpAllowed.equals("Y")) {
      logger.info("FTP disabled in property file.");
    } else {
      // *********************
      // Connect to FTP Server
      // *********************
      int j = 0;
      Sftp sftp =
          ftpUseKey
              ? SFTPHelper.connectUsingKeys(
                  ftpHostName, ftpUserName, ftpPrivateKeyPath, ftpKnownHostsPath)
              : SFTPHelper.connectUsingPassword(
                  ftpHostName, ftpUserName, ftpPswd, ftpKnownHostsPath);
      try {
        if (sftp == null) {
          throw new ProcessException(new Exception("Could not connect to FTP Server"));
        }

        // *************************************************
        // If remote directory provided then change to it
        // otherwise stay in directory automatically placed
        // in when ftp connection is made
        // *************************************************
        if ((ftpInDir.length() != 0) && (ftpInDir != null)) {
          int retval = SFTPHelper.setRemoteDir(ftpInDir, sftp);
          if (retval != ApplicationConstants.SUCCESS) {
            throw new ProcessException(
                new Exception("Problems occurred changing to remote dir: " + ftpInDir));
          }
        }
        // *******************************************
        // Retrieve all Import files for the province
        // *******************************************

        int retval = SFTPHelper.getSFTPFiles(sftp, curProv.getProvince(), inputDirStr);
        if (retval != ApplicationConstants.SUCCESS) {
          throw new ProcessException(
              new Exception(
                  "Problems occurred Ftping files for province: " + curProv.getProvince()));
        }

      } finally {
        if (sftp != null) {
          sftp.disconnect();
        }
      }
    }
    logger.debug("Calling retrieveImportFiles() ended.");
    return;
  }

  /**
   * Validates file structure of the import files files sent by the receiving provinces.
   *
   * @param curProv A Receiving province object for the current object being processed.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param sessionId Object that called this method
   * @return ArrayList Contains import objects. Each object contains the name of an import file, the
   *     report created for it, and a flag indicating whether or not the import failed.
   * @throws ProcessException, IOException, SQLException
   */
  private ArrayList processImportFiles(Province curProv, FileHelper fh, String sessionId)
      throws ProcessException, IOException, SQLException {
    logger.debug("Calling processImportFiles() started.");

    int retval = ApplicationConstants.SUCCESS;

    File[] list = inpDir.listFiles(pf);
    Arrays.sort(list);
    File inputFile = null;
    File processFile = null;
    File importRptStg1 = null;
    File importRptStg2 = null;
    PrintWriter pwt1 = null;
    PrintWriter pwt2 = null;
    ImportFileDetails impFileDtl = null;
    String fileName;
    int subId = 0;
    ArrayList imports = new ArrayList();
    ClaimDataService claimDS = new ClaimDataService(ds.getCon(), ds.getBatchId(), sessionId);

    try {
      int i = 0;
      while ((i < list.length) && (!(curProv.getProvError())) && (!hmont.isStopRequested())) {
        try {
          logger.info("Processing import file: " + ((File) list[i]).getName());
          logger.info("Processing import file count: " + list.length);
          // ********************************
          // Move import file to process dir
          // ********************************
          impFileDtl = new ImportFileDetails();
          impFileDtl.setImportError(true);

          inputFile = new File(inpDir, ((File) list[i]).getName());
          processFile = new File(processDir, ((File) list[i]).getName());
          fileName = processFile.getName();
          ((File) list[i]).renameTo(processFile);
          impFileDtl.setImportFile(processFile);

          if ((inputFile.exists()) || (!(processFile.exists()))) {
            emailMessage =
                emailMessage
                    + "Problem occurred moving file "
                    + inputFile.getName()
                    + " from input dir to process dir for province "
                    + curProv.getProvince()
                    + "\r\n";
            logger.error(
                "Problem occurred moving file "
                    + inputFile.getName()
                    + " from input dir to process dir for province "
                    + curProv.getProvince());
            curProv.setProvError(true);
          } else { // ************
            // Setup Validation report
            // ************
            String rptFnameStg1 = processFile.getName() + "." + importRptName;
            importRptStg1 = fh.createFile(rptFnameStg1, reportDir.getPath(), ext);
            pwt1 = fh.createWriter(importRptStg1.getPath());

            impFileDtl.setImportRptStg1(importRptStg1);
            // imports.add(impFileDtl);
            // ************
            // Process File
            // ************

            int startPos = checkImportFilePrevRun(processFile, sessionId);
            validateImportFile(curProv, fh, processFile, pwt1, startPos, claimDS, sessionId);
            if (!(curProv.getProvError())) {

              // ************
              // Setup Validation notification
              // ************
              logger.info(
                  "Processing import file no validation errors: " + ((File) list[i]).getName());
              String rptFnameStg2 = processFile.getName() + "." + importRptName;
              importRptStg2 = fh.createFile(rptFnameStg2, reportDir.getPath(), ext);
              pwt2 = fh.createWriter(importRptStg2.getPath());

              impFileDtl.setImportRptStg1(importRptStg2);
              impFileDtl.setImportRptStg2(importRptStg1);
              // imports.add(impFileDtl);

              removeImportFileFromServer(curProv, processFile);
              subId = loadImportFile(curProv, fh, processFile, pwt2, startPos, claimDS, sessionId);
            }

            if (!(curProv.getProvError())) {
              logger.info(
                  "Processing import file stage 2 validation errors: "
                      + ((File) list[i]).getName());
              runValidationProcess(subId, processFile.getName(), claimDS, sessionId);

              {
                if (eh != null) {
                  String msg5 = importRptMsg5.replaceFirst(replaceStr, processFile.getName());
                  msg5 = msg5.replaceFirst(replaceStr, curProv.getProvDetails().getProvinceName());
                  if (EMAIL_OPTION) {
                    eh.sendEmail(DESTINATION, EMAIL_NORMAL_SUBJECT, msg5);
                    logger.info("Validation Email notification has been sent to: " + DESTINATION);
                  }
                } else {
                  logger.info(
                      "Email notification cannot be sent: "
                          + DESTINATION
                          + " as email helper not setup");
                }
              }
            }
          }
          imports.add(impFileDtl);

          if (!curProv.getProvError()) {
            impFileDtl.setImportError(false);
          }
          logger.info("Processing import file completed " + ((File) list[i]).getName());

        } catch (Exception e) {
          throw new ProcessException(
              new Exception("Problem occurred during processing of import file " + e));
        } finally {
          if (pwt1 != null) {
            fh.closeWriter(pwt1);
            pwt1 = null;
          }
          if (pwt2 != null) {
            fh.closeWriter(pwt2);
            pwt2 = null;
          }
          if (impFileDtl != null) {
            impFileDtl = null;
          }

          importRptStg1 = null;
          importRptStg2 = null;
          inputFile = null;
          processFile = null;
        }
        i++;
      }
    } finally {
      list = null;
      if (claimDS != null) {
        claimDS = null;
      }
    }
    logger.debug("Calling processImportFiles() ended.");
    return imports;
  }

  /**
   * @param subId
   * @param claimDS
   * @param sessionId
   */
  private void runValidationProcess(
      int subId, String fileName, ClaimDataService claimDS, String sessionId)
      // TODO Auto-generated method stub
      throws ProcessException, IOException, SQLException {
    logger.debug("Calling runStage2Validations() started.");
    int fromLine = 0;

    try {
      claimDS.runValidations(subId, fileName);

    } catch (Exception e) {
      logger.error("Unhandled Exception while loading import file", e);
      throw new ProcessException(e);
    }

    logger.debug("Calling runStage2Validations() ended.");
  }

  /**
   * Checks to see if import file has been partially loaded
   *
   * @param processFile The import file to be processed
   * @param sessionId Object that called this method
   * @throws SQLException
   */
  private int checkImportFilePrevRun(File processFile, String sessionId) throws SQLException {
    int lineCnt = 0;
    logger.debug("Calling checkImportFilePrevRun() started.");
    lineCnt = ds.getLastPos(processFile.getName(), sessionId);
    // lineCnt = 47;//daves
    if (lineCnt != 0) {
      lineCnt += 1;
    }

    logger.debug("Calling checkImportFilePrevRun() started.");
    return lineCnt;
  }

  /**
   * Once the file contents have been validates (but not loaded) the file can be removed off of the
   * ftp server
   *
   * @param curProv A Receiving province object for the current object being processed.
   * @param processFile The import file to be processed
   * @throws ProcessException
   */
  private void removeImportFileFromServer(Province curProv, File processFile)
      throws ProcessException {
    logger.debug("Calling removeImportFileFromServer() started.");

    // *********************
    // Connect to FTP Server
    // *********************
    if (!ftpAllowed.equals("Y")) {
      logger.info("FTP disabled in property file.");
    } else {
      int j = 0;
      Sftp sftp =
          ftpUseKey
              ? SFTPHelper.connectUsingKeys(
                  ftpHostName, ftpUserName, ftpPrivateKeyPath, ftpKnownHostsPath)
              : SFTPHelper.connectUsingPassword(
                  ftpHostName, ftpUserName, ftpPswd, ftpKnownHostsPath);
      try {
        if (sftp == null) {
          throw new ProcessException(new Exception("Could not connect to FTP Server"));
        }

        // *************************************************
        // If remote directory provided then change to it
        // otherwise stay in directory automatically placed
        // in when ftp connection is made
        // *************************************************
        if ((ftpInDir.length() != 0) && (ftpInDir != null)) {
          int retval = SFTPHelper.setRemoteDir(ftpInDir, sftp);

          if (retval != Sftp.SUCCESS) {
            throw new ProcessException(
                new Exception("Problems occurred changing to remote dir: " + ftpInDir));
          }
        }
        // *******************************
        // Remove import file from server
        // *******************************
        String processFileName = processFile.getName();
        if ("ON".equalsIgnoreCase(curProv.getProvince())) {
          processFileName = processFileName.substring(0, processFileName.length() - 3);
        }
        logger.debug("removing file:" + processFileName);
        int retval = SFTPHelper.deleteSFTPFile(sftp, processFileName);
        if (retval != Sftp.SUCCESS) {
          emailMessage =
              emailMessage
                  + "Note: Could not find file on ftp server to delete: "
                  + processFile.getName()
                  + "\r\n";
          logger.info("Could not find file on ftp server to delete: " + processFile.getName());
          logger.info("File may have been left behind from a previous run.");
        }
      } finally {
        if (sftp != null) {
          sftp.disconnect();
        }
      }
    }
    logger.debug("Calling retrieveImportFiles() ended.");
    return;
  }

  /**
   * Validates file structure of the import files files sent by the receiving provinces.
   *
   * @param curProv A Receiving province object for the current object being processed.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param processFile The import file to be processed
   * @param importRptFile PrintWriter object where report file error messages are to be written to
   * @param startPos Where in the import file to start
   * @param claimDS A ClaimDataService object used to access the dataservice on the web side of
   *     hoopc
   * @param sessionId Object that called this method
   * @throws ProcessException, IOException, SQLException
   */
  private void validateImportFile(
      Province curProv,
      FileHelper fh,
      File processFile,
      PrintWriter importRptFile,
      int startPos,
      ClaimDataService claimDS,
      String sessionId)
      throws ProcessException, IOException, SQLException, ServiceFailedException {
    logger.debug("Calling validateImportFile() started.");

    int retval = ApplicationConstants.SUCCESS;
    int hdrCnt = 0;
    int dtlCnt = 0;
    int lineCnt = 1;
    int firstDtlLine = 0;
    double hdrTotal = 0.0;
    double dtlTotal = 0.0;
    String inputLine = null;
    String hdrCode = ApplicationConstants.IMPORT_FILE_HDR_CODE;
    String dtlCode = ApplicationConstants.IMPORT_FILE_DTL_CODE;
    String inpCode = ApplicationConstants.IMPORT_FILE_DTL_INPATIENT_CODE;
    String outCode = ApplicationConstants.IMPORT_FILE_DTL_OUTPATIENT_CODE;
    String msg1 = null;
    String msg2 = null;
    String msg3 = null;
    String msg6 = null;
    String msg8 = null;
    String subDate = null;

    if (startPos == 0) {
      firstDtlLine = DtlCmn.firstLinePos;
    } else {
      firstDtlLine = startPos;
    }

    BufferedReader inFile = fh.createReader(processFile.getPath());
    logger.info("Create report header: " + processFile.getName());
    msg1 = importRptMsg1.replaceFirst(replaceStr, processFile.getName());
    msg1 = msg1.replaceFirst(replaceStr, curProv.getProvDetails().getProvinceName());
    fh.writeLine(msg1, importRptFile);
    fh.writeLine("", importRptFile);
    try {
      // Loop Through File
      inputLine = fh.readLine(inFile);
      logger.info("Validating File: " + processFile.getName());
      while ((inputLine != null)) {
        retval = ApplicationConstants.SUCCESS;
        if (inputLine.trim().length() == 0) {
          msg6 = importRptMsg6;
          // emailMessage =emailMessage+msg6+"\r\n";
          fh.writeLine(msg6, importRptFile);
          logger.error(msg6);
          retval = ApplicationConstants.FAILURE;
        }

        if (retval == ApplicationConstants.SUCCESS) {

          // ****************************************************
          // Ensure Code used to identify type of header record is valid
          // ****************************************************

          if (lineCnt == 1) {
            String inputLineH = inputLine.substring(Hdr.ColStrt_01, Hdr.ColEnd_01 + 1);
            retval =
                checkMandatoryChars(
                    inputLineH,
                    Hdr.ColName_01,
                    curProv.getProvDetails().getProvinceName(),
                    fh,
                    importRptFile,
                    1);
            if (retval != ApplicationConstants.FAILURE) {
              retval =
                  checkInvalidValue(
                      inputLineH,
                      "H",
                      null,
                      Hdr.ColName_01,
                      curProv.getProvDetails().getProvinceName(),
                      fh,
                      importRptFile,
                      1);
            }

            // **********************
            // Validate Header Record
            // **********************

            if (retval != ApplicationConstants.FAILURE) {
              if ((inputLine.substring(Hdr.ColStrt_01, Hdr.ColEnd_01 + 1))
                  .equalsIgnoreCase(hdrCode)) {

                retval =
                    validateHeader(
                        inputLine,
                        curProv.getProvDetails().getProvinceName(),
                        fh,
                        importRptFile,
                        processFile.getName());
                if (retval == ApplicationConstants.FAILURE) {
                  fileval = ApplicationConstants.FAILURE;
                }

                if (fileval == ApplicationConstants.SUCCESS) {
                  hdrCnt =
                      Integer.parseInt(
                          inputLine.substring(Hdr.ColStrt_05, Hdr.ColEnd_05 + 1).trim());
                  hdrTotal =
                      Double.parseDouble(
                          inputLine.substring(Hdr.ColStrt_06, Hdr.ColEnd_06 + 1).trim());
                  subDate = inputLine.substring(Hdr.ColStrt_08, Hdr.ColEnd_08 + 1).trim();
                }
              }
            }

            if (retval == ApplicationConstants.FAILURE) {
              fileval = ApplicationConstants.FAILURE;
            }
          }

          // *******************************
          // Validate Patient Batch
          // (Mandatory)
          // *******************************
          if (lineCnt > 1) {
            {
              retval = ApplicationConstants.SUCCESS;
              String inputField1 =
                  inputLine.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1).trim();
              retval =
                  checkMandatoryChars(
                      inputField1,
                      DtlCmn.ColName_01,
                      curProv.getProvDetails().getProvinceName(),
                      fh,
                      importRptFile,
                      lineCnt);
              if (retval != ApplicationConstants.FAILURE) {
                if (!inputLine
                        .substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1)
                        .equalsIgnoreCase(inpCode)
                    && !(inputLine.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1))
                        .equalsIgnoreCase(outCode)) {
                  msg1 = "(Line number:" + lineCnt + ") " + importRptMsg7;
                  msg1 = msg1.replaceFirst(replaceStr, inputField1);
                  msg1 = msg1.replaceFirst(replaceStr, DtlCmn.ColName_01);
                  msg1 = msg1.replaceFirst(replaceStr, inpCode + "\"" + " or " + "\"" + outCode);
                  msg1 = msg1.replaceFirst(replaceStr, inpCode);
                  fh.writeLine(msg1, importRptFile);
                  logger.error(msg1);
                  fileval = ApplicationConstants.FAILURE;
                }
              } else {
                fileval = ApplicationConstants.FAILURE;
              }
            }

            // *******************************
            // Validate Adjustment Flag
            // (Mandatory)
            // *******************************
            if (inputLine
                .substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1)
                .equalsIgnoreCase(inpCode)) {
              retval = ApplicationConstants.SUCCESS;
              retval =
                  checkMandatoryChars(
                      inputLine.substring(DtlInp.ColStrt_38, DtlInp.ColEnd_38 + 1),
                      DtlInp.ColName_38,
                      curProv.getProvDetails().getProvinceName(),
                      fh,
                      importRptFile,
                      lineCnt);
              if (retval == ApplicationConstants.FAILURE) {
                fileval = ApplicationConstants.FAILURE;
              } else {
                retval =
                    checkInvalidValue(
                        inputLine.substring(DtlInp.ColStrt_38, DtlInp.ColEnd_38 + 1),
                        "Y",
                        "N",
                        DtlInp.ColName_38,
                        curProv.getProvDetails().getProvinceName(),
                        fh,
                        importRptFile,
                        lineCnt);
                if (retval == ApplicationConstants.FAILURE) {
                  fileval = ApplicationConstants.FAILURE;
                }
              }
            }

            if (inputLine
                .substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1)
                .equalsIgnoreCase(outCode)) {
              retval = ApplicationConstants.SUCCESS;
              String inputString = inputLine.substring(DtlOutp.ColStrt_22, DtlOutp.ColEnd_22 + 1);
              retval =
                  checkMandatoryChars(
                      inputString,
                      DtlOutp.ColName_22,
                      curProv.getProvDetails().getProvinceName(),
                      fh,
                      importRptFile,
                      lineCnt);
              if (retval == ApplicationConstants.FAILURE) {
                fileval = ApplicationConstants.FAILURE;
              } else {

                retval =
                    checkInvalidValue(
                        inputLine.substring(DtlOutp.ColStrt_22, DtlOutp.ColEnd_22 + 1),
                        "Y",
                        "N",
                        DtlOutp.ColName_22,
                        curProv.getProvDetails().getProvinceName(),
                        fh,
                        importRptFile,
                        lineCnt);

                if (retval == ApplicationConstants.FAILURE) {
                  fileval = ApplicationConstants.FAILURE;
                }
              }
            }

            // *******************************
            // Validate Header/Details Counts
            // *******************************
            if (fileval != ApplicationConstants.FAILURE) {

              if (!(inputLine.substring(Hdr.ColStrt_01, Hdr.ColEnd_01 + 1))
                  .equalsIgnoreCase(hdrCode)) {
                // ************************************************************
                // * If header counts/totals do not match detail
                // counts/totals
                // * then flag import in error and sent out messages
                // ************************************************************
                dtlCnt++;
                if ((inputLine.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1))
                    .equalsIgnoreCase(inpCode)) {
                  int decAllowed = 4;
                  if (inputLine
                      .substring(DtlInp.ColStrt_38, DtlInp.ColEnd_38 + 1)
                      .trim()
                      .equals("Y")) {
                    int numResult =
                        CommonValidator.isNumeric(
                            inputLine.substring(DtlInp.ColStrt_32, DtlInp.ColEnd_32 + 1).trim(),
                            decAllowed);
                    if (numResult == CommonValidator.NUMBER_OK) {
                      dtlTotal =
                          round(
                              dtlTotal
                                  - Double.parseDouble(
                                      inputLine
                                          .substring(DtlInp.ColStrt_32, DtlInp.ColEnd_32 + 1)
                                          .trim()),
                              2);
                    }
                  } else {
                    int numResult =
                        CommonValidator.isNumeric(
                            inputLine.substring(DtlInp.ColStrt_32, DtlInp.ColEnd_32 + 1).trim(),
                            decAllowed);
                    if (numResult == CommonValidator.NUMBER_OK) {
                      dtlTotal =
                          round(
                              dtlTotal
                                  + Double.parseDouble(
                                      inputLine
                                          .substring(DtlInp.ColStrt_32, DtlInp.ColEnd_32 + 1)
                                          .trim()),
                              2);
                    }
                  }
                } else if ((inputLine.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1))
                    .equalsIgnoreCase(outCode)) {
                  int decAllowed = 4;
                  if (inputLine
                      .substring(DtlOutp.ColStrt_22, DtlOutp.ColEnd_22 + 1)
                      .trim()
                      .equals("Y")) {
                    int numResult =
                        CommonValidator.isNumeric(
                            inputLine.substring(DtlOutp.ColStrt_21, DtlOutp.ColEnd_21 + 1).trim(),
                            decAllowed);
                    if (numResult == CommonValidator.NUMBER_OK) {
                      dtlTotal =
                          round(
                              dtlTotal
                                  - Double.parseDouble(
                                      inputLine
                                          .substring(DtlOutp.ColStrt_21, DtlOutp.ColEnd_21 + 1)
                                          .trim()),
                              2);
                    }
                  } else {
                    int numResult =
                        CommonValidator.isNumeric(
                            inputLine.substring(DtlOutp.ColStrt_21, DtlOutp.ColEnd_21 + 1).trim(),
                            decAllowed);
                    if (numResult == CommonValidator.NUMBER_OK) {
                      dtlTotal =
                          round(
                              dtlTotal
                                  + Double.parseDouble(
                                      inputLine
                                          .substring(DtlOutp.ColStrt_21, DtlOutp.ColEnd_21 + 1)
                                          .trim()),
                              2);
                    }
                  }
                }
              }
            }
          } // end if line > 1 check
        }

        lineCnt++;
        inputLine = fh.readLine(inFile);
        if ((lineCnt % commitSize == 0)) {
          logger.info("Validated up to line: " + lineCnt);
        }
      } // End of While Loop

      if (fileval
          == ApplicationConstants
              .SUCCESS) { // ************************************************************
        // * If header counts/totals do not match detail counts/totals
        // * then flag import in error and sent out messages
        // ************************************************************

        NumberFormat numberForm = NumberFormat.getNumberInstance();
        numberForm.setMaximumFractionDigits(2);
        numberForm.setMinimumFractionDigits(2);

        DecimalFormat df = (DecimalFormat) numberForm;
        df.applyPattern("0.00");
        df.format(hdrTotal);

        if ((dtlCnt != hdrCnt) || (round(dtlTotal, 2) != round(hdrTotal, 2))) {
          msg1 = importRptMsg3.replaceFirst(replaceStr, curProv.getProvDetails().getProvinceName());
          msg2 =
              "Header Counts = "
                  + fh.padStringLeading((String.valueOf(hdrCnt)).trim(), 8, " ")
                  + "     $$ = "
                  + fh.padStringLeading((String.valueOf(df.format(hdrTotal))).trim(), 12, " ");
          msg3 =
              "File Counts   = "
                  + fh.padStringLeading((String.valueOf(dtlCnt)).trim(), 8, " ")
                  + "     $$ = "
                  + fh.padStringLeading((String.valueOf(df.format(+dtlTotal))).trim(), 12, " ");
          emailMessage = msg1 + "\r\n";
          emailMessage = emailMessage + msg2 + "\r\n";
          emailMessage = emailMessage + msg3 + "\r\n";
          fh.writeLine(msg1, importRptFile);
          fh.writeLine(msg2, importRptFile);
          fh.writeLine(msg3, importRptFile);
          logger.error(msg1);
          logger.error(msg2);
          logger.error(msg3);
          fileval = ApplicationConstants.FAILURE;
        }
      }

      // **********************************************
      // Loop Through File; validate the detail records
      // **********************************************
      if (fileval == ApplicationConstants.SUCCESS) {

        if (fileval == ApplicationConstants.SUCCESS) {
          inFile1 = fh.createReader(processFile.getPath());
          String inputLine1 = fh.readLine(inFile1);
          logger.info("Validating File: " + processFile.getName());
          dtlCnt = 0;
          lineCnt = 0;
          while ((inputLine1 != null)) {

            {
              // *********************************
              // Validate Inpatient Detail Record
              // *********************************
              if ((inputLine1.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1)).equals(inpCode)) {
                dtlCnt++;
                if (lineCnt >= startPos) // { retval = validateInpatientDetail(inputLine1,dtlCnt+1,
                // curProv.getProvDetails().getProvinceName(),fh,importRptFile);
                {
                  retval =
                      validateInpatientDetail(
                          inputLine1,
                          dtlCnt,
                          curProv.getProvDetails().getProvinceCode(),
                          fh,
                          importRptFile);
                  if (retval == ApplicationConstants.FAILURE) {
                    fileval = ApplicationConstants.FAILURE;
                  }
                }
              } // *********************************
              // Validate Outpatient Detail Record
              // *********************************
              else if ((inputLine1.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1))
                  .equals(outCode)) {
                dtlCnt++;

                if (lineCnt >= startPos) {
                  retval =
                      validateOutpatientDetail(
                          inputLine1,
                          dtlCnt,
                          curProv.getProvDetails().getProvinceCode(),
                          fh,
                          importRptFile);
                  if (retval == ApplicationConstants.FAILURE) {
                    fileval = ApplicationConstants.FAILURE;
                  }
                }
              }
            }
            logger.debug("Calling validateImportFile() ended.");
            lineCnt++;
            inputLine1 = fh.readLine(inFile1);
            if ((lineCnt % commitSize == 0)) {
              logger.info("Validated up to line: " + lineCnt);
            }
          } // End of While Loop
        }
      }
      if (fileval == ApplicationConstants.FAILURE) {
        curProv.setProvError(true);
        // send notification email

        logger.debug("Send notification email: " + processFile.getName());
        msg1 = importRptMsg1.replaceFirst(replaceStr, processFile.getName());
        msg1 = msg1.replaceFirst(replaceStr, curProv.getProvDetails().getProvinceName());
        emailMessage = emailMessage + msg1 + "\r\n";
      } else {
        curProv.setProvError(false);
      }
    } finally {
      if (inFile != null) {
        fh.closeReader(inFile);
        inFile = null;
      }

      if (inFile1 != null) {
        fh.closeReader(inFile1);
        inFile1 = null;
      }
    }

    logger.debug("Calling validateImportFile() ended." + curProv.getProvError());
  }

  /**
   * @param inputLineH
   * @param string
   * @param object
   * @param colName_01
   * @param provinceName
   * @param fh
   * @param importRptFile
   * @param i
   * @return
   */
  private int checkInvalidValue(
      String chars_in,
      String chars_1,
      String chars_2,
      String fieldName,
      String prov,
      FileHelper fh,
      PrintWriter importRptFile,
      int lineNum)
      throws ProcessException {
    String msg = null;
    if (chars_2 != null && chars_2.trim().length() != 0) {
      if (!chars_in.equalsIgnoreCase(chars_2) && !chars_in.equalsIgnoreCase(chars_1)) {
        msg = "(Line number:" + lineNum + ") " + importRptMsg7;
        msg = msg.replaceFirst(replaceStr, chars_in);
        msg = msg.replaceFirst(replaceStr, fieldName);
        msg = msg.replaceFirst(replaceStr, chars_1 + " or " + chars_2);
        msg = msg.replaceFirst(replaceStr, chars_1);
        // emailMessage = emailMessage+msg+"\r\n";
        fh.writeLine(msg, importRptFile);
        logger.error(msg);
        logger.error(
            "Line: "
                + lineNum
                + ". Field "
                + fieldName
                + " has invalid value: "
                + chars_in
                + " Expected value "
                + chars_1
                + ", "
                + chars_2);
        return ApplicationConstants.FAILURE;
      } else {
        return ApplicationConstants.SUCCESS;
      }

    } else if (chars_2 == null || chars_2.trim().length() == 0) {
      if (!chars_in.equalsIgnoreCase(chars_1)) {
        msg = "(Line number:" + lineNum + ") " + importRptMsg7;
        msg = msg.replaceFirst(replaceStr, chars_in);
        msg = msg.replaceFirst(replaceStr, fieldName);
        msg = msg.replaceFirst(replaceStr, chars_1);
        // emailMessage = emailMessage+msg+"\r\n";
        fh.writeLine(msg, importRptFile);
        logger.error(msg);
        logger.error(
            "Line: "
                + lineNum
                + ". Field "
                + fieldName
                + " has invalid value: "
                + chars_in
                + " Expected value "
                + chars_1);
        return ApplicationConstants.FAILURE;
      } else {
        return ApplicationConstants.SUCCESS;
      }
    } else {
      return ApplicationConstants.SUCCESS;
    }
  }

  /**
   * @param chars_in
   * @param chars_1
   * @param fieldName
   * @param fh
   * @param importRptFile
   * @param lineNum
   * @return
   * @throws ProcessException
   */
  private int checkOntarioRecordType(
      String chars_in,
      String chars_1,
      String fieldName,
      FileHelper fh,
      PrintWriter importRptFile,
      int lineNum)
      throws ProcessException {
    if (!chars_in.equalsIgnoreCase(chars_1)) {
      String msg = "(Line number:" + lineNum + ") " + importRptMsg7;
      msg = msg.replaceFirst(replaceStr, chars_in);
      msg = msg.replaceFirst(replaceStr, fieldName);
      msg = msg.replaceFirst(replaceStr, "D");
      fh.writeLine(msg, importRptFile);
      logger.error(msg);
      logger.error(
          "Line: "
              + lineNum
              + ". Field "
              + fieldName
              + " has invalid value: "
              + chars_in
              + " Expected value D");
      return ApplicationConstants.FAILURE;
    } else {
      return ApplicationConstants.SUCCESS;
    }
  }

  // *===========================================================================*/
  // * Name : validateHeader */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 02,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Validates the structure of a header record.
   *
   * @param inputLine The record to be checked.
   * @param prov The Province whose field is being checked.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param importRptFile PrintWriter object where report file error messages are to be written to
   * @return int Code indicating sucess or failure of test
   * @exception ProcessException,IOException
   */
  private int validateHeader(
      String inputLine, String prov, FileHelper fh, PrintWriter importRptFile, String fileName)
      throws ProcessException, IOException {
    logger.debug("Calling validateHeader() started.");
    int retval = ApplicationConstants.SUCCESS;
    int valRecord = ApplicationConstants.SUCCESS;
    int decAllowed = 4;
    int noDecAllowedPosOnly = 2;
    String inputField = null;

    // No need to check this as last column in record will not be padded out
    // retval = checkLineLength(inputLine,
    // ApplicationConstants.IMPORT_FILE_HDR_LENGTH, 1, prov,fh,
    // importRptFile);

    // ************************
    // Validate Billing Period
    // ************************
    logger.debug("Validate Billing Period started." + inputLine.toString());

    {
      inputField = null;
      inputField = inputLine.substring(Hdr.ColStrt_04, Hdr.ColEnd_04 + 1).trim();
      retval = checkMandatoryChars(inputField, Hdr.ColName_04, prov, fh, importRptFile, 1);
      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkDate(
                inputField,
                ApplicationConstants.BILL_PERIOD_FORMAT,
                Hdr.ColName_04,
                prov,
                fh,
                importRptFile,
                1);
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
      logger.debug("Validate Billing Period ended.");
    }

    // ************************
    // Validate Treating Province
    // ************************

    {
      logger.debug("Validate Treating Province started.");
      inputField = null;
      inputField = inputLine.substring(Hdr.ColStrt_02, Hdr.ColEnd_02 + 1).trim();
      retval = checkMandatoryChars(inputField, Hdr.ColName_02, prov, fh, importRptFile, 1);
      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkInvalidValue(
                inputField,
                fileName.substring(0, 2),
                null,
                Hdr.ColName_02,
                prov,
                fh,
                importRptFile,
                1);
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }

    // ************************
    // Validate Receiving Province
    // ************************

    {
      logger.debug("Validate Receiving Province started.");
      inputField = null;
      inputField = inputLine.substring(Hdr.ColStrt_03, Hdr.ColEnd_03 + 1).trim();
      retval = checkMandatoryChars(inputField, Hdr.ColName_03, prov, fh, importRptFile, 1);
      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkInvalidValue(inputField, "BC", null, Hdr.ColName_03, prov, fh, importRptFile, 1);
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }

    // *********************************
    // Validate Total Number of Details
    // *********************************

    {
      logger.debug(" Validate Total Number of Details started.");
      inputField = null;
      inputField = inputLine.substring(Hdr.ColStrt_05, Hdr.ColEnd_05 + 1).trim();
      retval = checkMandatoryChars(inputField, Hdr.ColName_05, prov, fh, importRptFile, 1);
      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkNumber(
                inputField, Hdr.ColName_05, prov, fh, importRptFile, 1, noDecAllowedPosOnly);
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
      logger.debug(" Validate Total Number of Details ended.");
    }

    // ************************
    // Validate Total Amount
    // ************************

    {
      logger.debug(" Validate Total Amount started.");
      inputField = null;
      inputField = inputLine.substring(Hdr.ColStrt_06, Hdr.ColEnd_06 + 1).trim();
      retval = checkMandatoryChars(inputField, Hdr.ColName_06, prov, fh, importRptFile, 1);
      if (retval != ApplicationConstants.FAILURE) {
        retval = checkNumber(inputField, Hdr.ColName_06, prov, fh, importRptFile, 1, decAllowed);
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
      logger.debug(" Validate Total Amount ended.");
    }
    // ************************
    // Validate Date Submitted
    // ************************

    {
      logger.debug(" Validate Date Submitted. started");
      inputField = null;
      inputLine = inputLine + "        "; // in case the submitted date is
      // missing
      inputField = inputLine.substring(Hdr.ColStrt_08, Hdr.ColEnd_08 + 1).trim();
      retval = checkMandatoryChars(inputField, Hdr.ColName_08, prov, fh, importRptFile, 1);
      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkDate(
                inputField,
                ApplicationConstants.SUBMITTED_DATE_FORMAT,
                Hdr.ColName_08,
                prov,
                fh,
                importRptFile,
                1);
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
      logger.debug(" Validate Date Submitted. ended ");
    }
    logger.debug("Calling validateHeader() ended." + retval);
    return valRecord;
  }
  // *===========================================================================*/
  // * Name : validateInpatientDetail */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 02,2005 Initial Spec */
  // * C Stepanov August 05,2007 Added validations for the business keys*/
  // *===========================================================================*/

  /**
   * Validates the structure of an inpatient detail record.
   *
   * @param inputLine The record to be checked.
   * @param lineCnt Position in file the record the field belongs to
   * @param prov The Province whose field is being checked.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param importRptFile PrintWriter object where report file error messages are to be written to
   * @return int Code indicating sucess or failure of test
   * @exception ProcessException , IOException
   */
  private int validateInpatientDetail(
      String inputLine, int lineCnt, String prov, FileHelper fh, PrintWriter importRptFile)
      throws ProcessException, IOException {
    logger.debug("Calling validateInpatientDetail() started.");
    int retval = ApplicationConstants.SUCCESS;
    int valRecord = ApplicationConstants.SUCCESS; // ApplicationConstants.FAILURE;
    int decAllowed = 4;
    int decAllowedPosOnly = 6;
    int noDecAllowedPosOnly = 2;
    String inputField1 = null;
    String inputField2 = null;
    String dateFormat = null;

    // No need to check this as last column in record will not be padded out

    // *******************************
    // Validate Patient Batch
    // (Mandatory)
    // *******************************
    {
      inputField1 = inputLine.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField1, DtlCmn.ColName_01, prov, fh, importRptFile, (lineCnt + 1));
      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkInvalidValue(
                inputField1, "I", null, DtlCmn.ColName_01, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
      logger.debug(" Validate Patient Batch." + valRecord);
    }

    // *******************************
    // Validate Record Type
    // (Mandatory)
    // *******************************
    {
      inputField1 = inputLine.substring(DtlCmn.ColStrt_02, DtlCmn.ColEnd_02 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField1, DtlCmn.ColName_02, prov, fh, importRptFile, (lineCnt + 1));
      if (retval != ApplicationConstants.FAILURE) {
        if ("AB".equalsIgnoreCase(prov)) {
          retval =
              checkInvalidValue(
                  inputField1,
                  "D",
                  null,
                  DtlCmn.ColName_02,
                  prov,
                  fh,
                  importRptFile,
                  (lineCnt + 1));
        } else if ("ON".equalsIgnoreCase(prov)) {
          retval =
              checkOntarioRecordType(
                  inputField1, "E", DtlCmn.ColName_02, fh, importRptFile, (lineCnt + 1));
        }
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }

      logger.debug(" Validate Record Type." + valRecord);
    }

    // *******************************
    // Validate Hospital Number
    // (Mandatory)
    // *******************************

    {
      inputField1 = inputLine.substring(DtlCmn.ColStrt_03, DtlCmn.ColEnd_03 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField1, DtlCmn.ColName_03, prov, fh, importRptFile, (lineCnt + 1));
      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkNumber(
                inputField1,
                DtlCmn.ColName_03,
                prov,
                fh,
                importRptFile,
                (lineCnt + 1),
                noDecAllowedPosOnly);
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
      logger.debug(" Validate Hospital Number." + valRecord);
    }
    // *******************************
    // Validate Insurance Card Number
    // (Mandatory)
    // *******************************

    {
      inputField1 = inputLine.substring(DtlCmn.ColStrt_05, DtlCmn.ColEnd_05 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField1, DtlCmn.ColName_05, prov, fh, importRptFile, (lineCnt + 1));
      // if (retval == ApplicationConstants.FAILURE) {
      // valRecord = ApplicationConstants.FAILURE;
      //
      // }
      /*
       * CAST-19454: Commented to enable letters in the PHN from Quebec. Defect: 422
       */
      /*
       * if (retval != ApplicationConstants.FAILURE) { retval = checkNumber(inputField1,
       * DtlCmn.ColName_05, prov, fh, importRptFile, (lineCnt + 1), noDecAllowedPosOnly); }
       */
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
      logger.debug(" Insurance Card Number." + valRecord);
    }
    // *******************************
    // Validate Insurance Expiry Date
    // (Optional)
    // *******************************

    {
      inputField1 = inputLine.substring(DtlCmn.ColStrt_06, DtlCmn.ColEnd_06 + 1).trim();

      if ((inputField1 != null) && (inputField1.trim().length() != 0)) {
        if (inputField1.length() == 6) {
          dateFormat = ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT2;
        } else {
          dateFormat = ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT1;
        }
        retval =
            checkDate(
                inputField1, dateFormat, DtlCmn.ColName_06, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }

    // ************************
    // Validate Birth Date
    // (Mandatory)
    // ************************

    {
      inputField1 = inputLine.substring(DtlInp.ColStrt_14, DtlInp.ColEnd_14 + 1).trim();

      retval =
          checkMandatoryChars(
              inputField1, DtlInp.ColName_14, prov, fh, importRptFile, (lineCnt + 1));
      if (retval != ApplicationConstants.FAILURE) {
        dateFormat = ApplicationConstants.BIRTH_DATE_FORMAT;
        retval =
            checkDate(
                inputField1, dateFormat, DtlInp.ColName_14, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
      logger.debug(" Validate Birth Date." + valRecord);
    }

    // ****************************
    // High Cost Procedure Date 1
    // (Optional)
    // ****************************

    {
      dateFormat = ApplicationConstants.HIGH_COST_PROC_DATE_FORMAT1;
      inputField2 = inputLine.substring(DtlInp.ColStrt_23, DtlInp.ColEnd_23 + 1).trim();

      if (inputField2 != null && inputField2.length() != 0) {
        retval =
            checkDate(
                inputField2, dateFormat, DtlInp.ColName_23, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }
    // ****************************
    // High Cost Procedure Date 2
    // (Optional)
    // ****************************
    // if (retval == ApplicationConstants.SUCCESS)
    {
      dateFormat = ApplicationConstants.HIGH_COST_PROC_DATE_FORMAT2;
      inputField2 = inputLine.substring(DtlInp.ColStrt_25, DtlInp.ColEnd_25 + 1).trim();

      if (inputField2 != null && inputField2.length() != 0) {
        retval =
            checkDate(
                inputField2, dateFormat, DtlInp.ColName_25, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }
    // ****************************
    // High Cost Procedure Date 3
    // (Optional)
    // ****************************

    {
      dateFormat = ApplicationConstants.HIGH_COST_PROC_DATE_FORMAT3;
      inputField2 = inputLine.substring(DtlInp.ColStrt_27, DtlInp.ColEnd_27 + 1).trim();

      if (inputField2 != null && inputField2.length() != 0) {
        retval =
            checkDate(
                inputField2, dateFormat, DtlInp.ColName_27, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }
    // *************************
    // Admission Date
    // (Mandatory)
    // *************************
    {
      inputField1 = inputLine.substring(DtlInp.ColStrt_28, DtlInp.ColEnd_28 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField1, DtlInp.ColName_28, prov, fh, importRptFile, (lineCnt + 1));

      if (retval != ApplicationConstants.FAILURE) {
        dateFormat = ApplicationConstants.ADMISSION_DATE_FORMAT;
        retval =
            checkDate(
                inputField1, dateFormat, DtlInp.ColName_28, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
      logger.debug(" Admission  Date." + valRecord);
    }
    // ****************
    // Discharge Date
    // (Mandatory)
    // ****************
    {
      inputField1 = inputLine.substring(DtlInp.ColStrt_29, DtlInp.ColEnd_29 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField1, DtlInp.ColName_29, prov, fh, importRptFile, (lineCnt + 1));

      if (retval != ApplicationConstants.FAILURE) {
        dateFormat = ApplicationConstants.DISCHARGE_DATE_FORMAT;
        retval =
            checkDate(
                inputField1, dateFormat, DtlInp.ColName_29, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
      logger.debug("Discharge  Date." + valRecord);
    }
    // *********************
    // Validate Total Days
    // (Optional)
    // *********************
    {
      inputField1 = inputLine.substring(DtlInp.ColStrt_30, DtlInp.ColEnd_30 + 1).trim();
      if ((inputField1 != null) && (inputField1.trim().length() != 0)) {
        retval =
            checkNumber(
                inputField1,
                DtlInp.ColName_30,
                prov,
                fh,
                importRptFile,
                (lineCnt + 1),
                noDecAllowedPosOnly);
        if (retval == ApplicationConstants.FAILURE) {
          valRecord = ApplicationConstants.FAILURE;
        }
      }
      logger.debug("Validate Total Days." + valRecord);
    }
    // ***********************
    // Validate Per Diem Rate
    // (Optional)
    // ***********************
    {
      inputField1 = inputLine.substring(DtlInp.ColStrt_31, DtlInp.ColEnd_31 + 1).trim();
      if ((inputField1 != null) && (inputField1.trim().length() != 0)) {
        retval =
            checkNumber(
                inputField1,
                DtlInp.ColName_31,
                prov,
                fh,
                importRptFile,
                (lineCnt + 1),
                decAllowedPosOnly);
        if (retval == ApplicationConstants.FAILURE) {
          valRecord = ApplicationConstants.FAILURE;
        }
      }
      logger.debug("Validate Per Diem Rate." + valRecord);
    }
    // ***************************
    // Validate Total Amt Claimed
    // (Mandatory)
    // ***************************

    {
      inputField1 = inputLine.substring(DtlInp.ColStrt_32, DtlInp.ColEnd_32 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField1, DtlInp.ColName_32, prov, fh, importRptFile, (lineCnt + 1));

      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkNumber(
                inputField1, DtlInp.ColName_32, prov, fh, importRptFile, (lineCnt + 1), decAllowed);
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }

      logger.debug("Validate Total Amt Claimed." + valRecord);
    }

    // *******************************
    // Validate adjusmtent flag
    // (Mandatory)
    // *******************************
    {
      inputField1 = inputLine.substring(DtlInp.ColStrt_38, DtlInp.ColStrt_38 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField1, DtlInp.ColName_38, prov, fh, importRptFile, (lineCnt + 1));
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      } else {
        if (retval
            != checkInvalidValue(
                inputField1, "Y", "N", DtlInp.ColName_38, prov, fh, importRptFile, (lineCnt + 1))) {
          valRecord = ApplicationConstants.FAILURE;
        }
      }

      logger.debug("CValidate adjusmtent flag." + valRecord);
    }

    logger.debug("Calling validateInpatientDetail() ended." + valRecord);
    return valRecord;
  }
  // *===========================================================================*/
  // * Name : validateOutpatientDetail */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 02,2005 Initial Spec */
  // * C Stepanov August 05,2007 Added validations for the business keys*/
  // *===========================================================================*/

  /**
   * Validates the structure of an outpatient detail record.
   *
   * @param inputLine The record to be checked.
   * @param lineCnt Position in file the record the field belongs to
   * @param prov The Province whose field is being checked.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param importRptFile PrintWriter object where report file error messages are to be written to
   * @return int Code indicating sucess or failure of test
   * @exception ProcessException, IOException
   */
  private int validateOutpatientDetail(
      String inputLine, int lineCnt, String prov, FileHelper fh, PrintWriter importRptFile)
      throws ProcessException, IOException {
    logger.debug("Calling validateOutpatientDetail() started.");
    int retval = ApplicationConstants.SUCCESS;
    int noDecAllowed = 0;
    int decAllowed = 4;
    String inputField = null;
    String dateFormat = null;
    int noDecAllowedPosOnly = 2;
    int valRecord = ApplicationConstants.SUCCESS; // ApplicationConstants.FAILURE;

    // No need to check this as last column in record will not be padded out
    // retval = checkLineLength(inputLine,
    // ApplicationConstants.IMPORT_FILE_DTL_OUTPATIENT_LENGTH, lineCnt,
    // prov,
    // fh, importRptFile);

    // *******************************
    // Validate Patient Batch
    // (Mandatory)
    // *******************************
    {
      inputField = inputLine.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField, DtlCmn.ColName_01, prov, fh, importRptFile, (lineCnt + 1));
      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkInvalidValue(
                inputField, "O", null, DtlCmn.ColName_01, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }

    // *******************************
    // Validate Record Type
    // (Mandatory)
    // *******************************
    {
      inputField = inputLine.substring(DtlCmn.ColStrt_02, DtlCmn.ColEnd_02 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField, DtlCmn.ColName_02, prov, fh, importRptFile, (lineCnt + 1));
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      } else {

        if ("AB".equalsIgnoreCase(prov)) {
          retval =
              checkInvalidValue(
                  inputField, "D", null, DtlCmn.ColName_02, prov, fh, importRptFile, (lineCnt + 1));
        } else if ("ON".equalsIgnoreCase(prov)) {
          retval =
              checkOntarioRecordType(
                  inputField, "E", DtlCmn.ColName_02, fh, importRptFile, (lineCnt + 1));
        }

        if (retval == ApplicationConstants.FAILURE) {
          valRecord = ApplicationConstants.FAILURE;
        }
      }
    }

    // *******************************
    // Validate Hospital Number
    // (Mandatory)
    // *******************************

    {
      inputField = inputLine.substring(DtlCmn.ColStrt_03, DtlCmn.ColEnd_03 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField, DtlCmn.ColName_03, prov, fh, importRptFile, (lineCnt + 1));
      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkNumber(
                inputField,
                DtlCmn.ColName_03,
                prov,
                fh,
                importRptFile,
                (lineCnt + 1),
                noDecAllowedPosOnly);
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }
    // *******************************
    // Validate Insurance Card Number
    // (Mandatory)
    // *******************************
    {
      inputField = inputLine.substring(DtlCmn.ColStrt_05, DtlCmn.ColEnd_05 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField, DtlCmn.ColName_05, prov, fh, importRptFile, (lineCnt + 1));
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }
    // *******************************
    // Validate Insurance Expiry Date
    // (Optional)
    // *******************************
    {
      inputField = inputLine.substring(DtlCmn.ColStrt_06, DtlCmn.ColEnd_06 + 1).trim();
      if ((inputField != null) && (inputField.trim().length() != 0)) {
        if (inputField.length() == 6) {
          dateFormat = ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT2;
        } else {
          dateFormat = ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT1;
        }
        retval =
            checkDate(
                inputField, dateFormat, DtlCmn.ColName_06, prov, fh, importRptFile, (lineCnt + 1));
        if (retval == ApplicationConstants.FAILURE) {
          valRecord = ApplicationConstants.FAILURE;
        }
      }
    }
    // ********************
    // Validate Birth Date
    // (Mandatory)
    // ********************
    {
      inputField = inputLine.substring(DtlOutp.ColStrt_10, DtlOutp.ColEnd_10 + 1).trim();
      dateFormat = ApplicationConstants.BIRTH_DATE_FORMAT;
      retval =
          checkMandatoryChars(
              inputField, DtlOutp.ColName_10, prov, fh, importRptFile, (lineCnt + 1));
      if (retval != ApplicationConstants.FAILURE) {
        retval =
            checkDate(
                inputField, dateFormat, DtlOutp.ColName_10, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }

    // ***********************
    // Validate Service Code
    // (Mandatory)
    // ***********************
    {
      inputField = inputLine.substring(DtlOutp.ColStrt_15, DtlOutp.ColEnd_15 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField, DtlOutp.ColName_15, prov, fh, importRptFile, (lineCnt + 1));
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }
    // **********************
    // Validate Service Date
    // (Mandatory)
    // **********************
    {
      retval = ApplicationConstants.SUCCESS;
      inputField = inputLine.substring(DtlOutp.ColStrt_19, DtlOutp.ColEnd_19 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField, DtlOutp.ColName_19, prov, fh, importRptFile, (lineCnt + 1));
      if (retval == ApplicationConstants.SUCCESS) {
        dateFormat = ApplicationConstants.SERVICE_DATE_FORMAT;
        retval =
            checkDate(
                inputField, dateFormat, DtlOutp.ColName_19, prov, fh, importRptFile, (lineCnt + 1));
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }
    // ***********************
    // Total Amount Claimed
    // (Mandatory)
    // ***********************
    {
      retval = ApplicationConstants.SUCCESS;
      inputField = inputLine.substring(DtlOutp.ColStrt_21, DtlOutp.ColEnd_21 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField, DtlOutp.ColName_21, prov, fh, importRptFile, (lineCnt + 1));
      if (retval == ApplicationConstants.SUCCESS) {
        retval =
            checkNumber(
                inputField, DtlOutp.ColName_21, prov, fh, importRptFile, (lineCnt + 1), decAllowed);
      }
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      }
    }
    // **************************
    // Validate Adjustment Flag
    // (Mandatory)
    // **************************
    {
      inputField = inputLine.substring(DtlOutp.ColStrt_22, DtlOutp.ColEnd_22 + 1).trim();
      retval =
          checkMandatoryChars(
              inputField, DtlOutp.ColName_22, prov, fh, importRptFile, (lineCnt + 1));
      if (retval == ApplicationConstants.FAILURE) {
        valRecord = ApplicationConstants.FAILURE;
      } else {
        if (retval
            != checkInvalidValue(
                inputField, "Y", "N", DtlOutp.ColName_22, prov, fh, importRptFile, (lineCnt + 1))) {
          valRecord = ApplicationConstants.FAILURE;
        }
      }
    }

    logger.debug("Calling validateOutpatientDetail() ended.");
    return valRecord;
  }
  // *===========================================================================*/
  // * Name : loadImportFile */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 09,2005 Initial Spec */
  // * DC Bartlett April 27, 2005 Modified to check if shutdown requested.*/
  // * C Stepanov August 05, 2007 Modified to load the stagign area. */
  // *===========================================================================*/

  /**
   * Loads claims and adjustments from an import file sent by one of the provinces into the
   * database. After each commit a record is inserted into the data processing groups table
   * indicating how many records were inserted and where they reside in the import file. The data
   * processing group is tied back to a claim data submissions table which contains the name of the
   * file being imported.
   *
   * @param curProv A Receiving province object for the current object being processed.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param processFile The import file to be processed
   * @param importRptFile PrintWriter object where report file error messages are to be written to
   * @param claimDS A ClaimDataService object used to access the dataservice on the web side of
   *     hoopc
   * @param sessionId Object that called this method
   * @throws ProcessException, IOException,SQLException
   */
  private int loadImportFile(
      Province curProv,
      FileHelper fh,
      File processFile,
      PrintWriter importRptFile,
      int startPos,
      ClaimDataService claimDS,
      String sessionId)
      throws ProcessException, IOException, SQLException {
    logger.debug("Calling loadImportFile() started.");
    int fromLine = 0;
    int curLine = 1;
    int unCommittedCnt = 0;
    String inputLine = null;
    String hdrCode = ApplicationConstants.IMPORT_FILE_HDR_CODE;
    String inpCode = ApplicationConstants.IMPORT_FILE_DTL_INPATIENT_CODE;
    String outCode = ApplicationConstants.IMPORT_FILE_DTL_OUTPATIENT_CODE;
    String msg = null;
    Init.setPrpUtil(prp);
    int subId = 0;

    BufferedReader inFile = fh.createReader(processFile.getPath());
    logger.info("Loading File: " + processFile.getName());

    try {
      inputLine = fh.readLine(inFile);

      if ((inputLine.substring(Hdr.ColStrt_01, Hdr.ColEnd_01 + 1)).equalsIgnoreCase(hdrCode)) {
        SAHeaderRecord headerRec =
            createHeaderRecord(
                curProv.getProvince(), inputLine, claimDS, curLine, processFile.getName());
        try {
          subId = claimDS.createSAHeadRec(headerRec);

        } catch (Exception e) {
          logger.error("Unhandled Exception while loading import file", e);
          throw new ProcessException(e);
        }
      }
    } catch (Exception e) {
      logger.error(
          "Problem occurred inserting claim/adjustment from batch import file: "
              + processFile.getName());
      logger.error("Province: " + curProv.getProvince());
      logger.error("Detail Line Cnt(header not included in count): " + curLine);
      throw new ProcessException(e);
    }

    if (subId != 0) {
      try {
        // Loop Through File
        inputLine = fh.readLine(inFile);
        while ((inputLine != null) && (!hmont.isStopRequested())) {
          // ********************************
          // Do not process the header record
          // ********************************
          if (!(inputLine.substring(Hdr.ColStrt_01, Hdr.ColEnd_01 + 1)).equalsIgnoreCase(hdrCode)) {
            if ((inputLine.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1))
                .equalsIgnoreCase(inpCode)) {
              // ************************************
              // create new resident inpatient claim
              // ************************************
              if (curLine >= startPos) {
                unCommittedCnt++;
                logger.info("Here comes the code to insert the records into the staging area ");

                SADetailRecord detailInpRec =
                    createSAInpatientRecord(
                        curProv.getProvince(),
                        inputLine,
                        claimDS,
                        curLine,
                        processFile.getName(),
                        subId);
                try {
                  detailInpRec = claimDS.createSADetRec(detailInpRec);

                } catch (Exception e) {
                  logger.error("Unhandled Exception while loading import file", e);
                  throw new ProcessException(e);
                }
              }
            } else if ((inputLine.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1))
                .equalsIgnoreCase(outCode)) {

              {
                // ************************************
                // create new resident inpatient claim
                // ************************************
                if (curLine >= startPos) {
                  unCommittedCnt++;
                  SADetailRecord detailOutRec =
                      createSAOutpatientRecord(
                          curProv.getProvince(),
                          inputLine,
                          claimDS,
                          curLine,
                          processFile.getName(),
                          subId);
                  try {
                    detailOutRec = claimDS.createSADetRec(detailOutRec);

                  } catch (Exception e) {
                    logger.error("Unhandled Exception while loading import file", e);
                    throw new ProcessException(e);
                  }
                }
              }
            }
          }

          curLine++;
          inputLine = fh.readLine(inFile);
        } // End of While Loop

        String msg2 = importRptMsg2.replaceFirst(replaceStr, processFile.getName());
        msg2 = msg2.replaceFirst(replaceStr, curProv.getProvDetails().getProvinceName());
        fh.writeLine(msg2, importRptFile);
        fh.writeLine("", importRptFile);

        logger.info(msg2);
        curProv.setProvError(false);

        {
          if (eh != null) {

            if (EMAIL_OPTION) {
              eh.sendEmail(DESTINATION, EMAIL_NORMAL_SUBJECT, msg2);
              logger.info(
                  "Email notification has been sent to: " + DESTINATION + EMAIL_NORMAL_SUBJECT);
            }

          } else {
            logger.info(
                "Email notification cannot be sent: " + DESTINATION + " as email helper not setup");
          }
        }

        logger.debug("Calling loadImportFile() ended.");

      } finally {
        if (inFile != null) {
          fh.closeReader(inFile);
          inFile = null;
        }
      }
    }
    return subId;
  }
  // *===========================================================================*/
  // * Name : createInpClaim */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 07,2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Given a input string, breaks it up into the components required for the inpatient claim
   *
   * @param inputLine Inpatient Detail Record
   * @return RIC claim oject
   * @throws ProcessException
   */
  private Ric createInpClaim(
      String prov, String inputLine, ClaimDataService claimDS, int lineCnt, String fname)
      throws ProcessException, IOException {
    logger.debug("Calling createInpClaim() started.");
    String tmpDate = null;
    String year = null;
    String month = null;
    String day = null;
    Ric claim = null;
    try {
      // ***********************
      // * Insurance Expiry Date
      // ***********************
      claim = new Ric(claimDS);
      tmpDate = (inputLine.substring(DtlCmn.ColStrt_06, DtlCmn.ColEnd_06 + 1)).trim();

      if ((tmpDate.trim().length() != 0) && (tmpDate.trim().length() == 8)) {
        claim.setInsuranceCardExpiryDate(
            convertToDate(
                tmpDate, ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT1, DtlCmn.ColName_06));
      } else if ((tmpDate.trim().length() != 0) && (tmpDate.trim().length() == 6)) {
        claim.setInsuranceCardExpiryDate(
            convertToDate(
                tmpDate, ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT2, DtlCmn.ColName_06));
      } else if ((tmpDate.trim().length() == 0)) {
        claim.setInsuranceCardExpiryDate(convertToDate(tmpDate, null, DtlCmn.ColName_06));
      }

      // ************
      // * Birth Date
      // ************
      tmpDate = (inputLine.substring(DtlInp.ColStrt_14, DtlInp.ColEnd_14 + 1)).trim();
      claim.setBirthDate(
          convertToDate(tmpDate, ApplicationConstants.BIRTH_DATE_FORMAT, DtlInp.ColName_14));

      // ****************************
      // * High Cost Procedure Date 1
      // ****************************
      tmpDate = (inputLine.substring(DtlInp.ColStrt_23, DtlInp.ColEnd_23 + 1)).trim();
      claim.setHighCost1Date(
          convertToDate(
              tmpDate, ApplicationConstants.HIGH_COST_PROC_DATE_FORMAT1, DtlInp.ColName_23));

      // ****************************
      // * High Cost Procedure Date 2
      // ****************************
      tmpDate = (inputLine.substring(DtlInp.ColStrt_25, DtlInp.ColEnd_25 + 1)).trim();
      claim.setHighCost2Date(
          convertToDate(
              tmpDate, ApplicationConstants.HIGH_COST_PROC_DATE_FORMAT2, DtlInp.ColName_25));

      // ****************************
      // * High Cost Procedure Date 3
      // ****************************
      tmpDate = (inputLine.substring(DtlInp.ColStrt_27, DtlInp.ColEnd_27 + 1)).trim();
      claim.setHighCost3Date(
          convertToDate(
              tmpDate, ApplicationConstants.HIGH_COST_PROC_DATE_FORMAT3, DtlInp.ColName_27));

      // ****************
      // * Admission Date
      // ****************
      tmpDate = (inputLine.substring(DtlInp.ColStrt_28, DtlInp.ColEnd_28 + 1)).trim();
      claim.setAdmissionDate(
          convertToDate(tmpDate, ApplicationConstants.ADMISSION_DATE_FORMAT, DtlInp.ColName_28));

      // ****************
      // * Discharge Date
      // ****************
      tmpDate = (inputLine.substring(DtlInp.ColStrt_29, DtlInp.ColEnd_29 + 1)).trim();
      claim.setDischargeDate(
          convertToDate(tmpDate, ApplicationConstants.DISCHARGE_DATE_FORMAT, DtlInp.ColName_29));

      // ****************
      // * Billing Period
      // ****************
      claim.setBillingPeriod(
          convertToDate(processMonth, ApplicationConstants.BILL_PERIOD_FORMAT, "Billing Period"));

      claim.setHospitalNumber(
          convertToString((inputLine.substring(DtlCmn.ColStrt_03, DtlCmn.ColEnd_03 + 1)).trim()));
      // For fix #335 - don't worry about the name of the hospital, just the number
      // claim.setHospitalName
      // (convertToString((inputLine.substring(DtlCmn.ColStrt_04,DtlCmn.ColEnd_04+1)).trim()));
      claim.setInsuranceNumber(
          convertToString((inputLine.substring(DtlCmn.ColStrt_05, DtlCmn.ColEnd_05 + 1)).trim()));
      claim.setLastName(
          convertToString((inputLine.substring(DtlCmn.ColStrt_07, DtlCmn.ColEnd_07 + 1)).trim()));
      claim.setFirstName(
          convertToString((inputLine.substring(DtlCmn.ColStrt_08, DtlCmn.ColEnd_08 + 1)).trim()));
      claim.setAddress1(
          convertToString((inputLine.substring(DtlInp.ColStrt_09, DtlInp.ColEnd_09 + 1)).trim()));
      claim.setAddress2(
          convertToString((inputLine.substring(DtlInp.ColStrt_10, DtlInp.ColEnd_10 + 1)).trim()));
      claim.setCity(
          convertToString((inputLine.substring(DtlInp.ColStrt_11, DtlInp.ColEnd_11 + 1)).trim()));
      claim.setProvince(
          convertToString((inputLine.substring(DtlInp.ColStrt_12, DtlInp.ColEnd_12 + 1)).trim()));
      claim.setPostalCode(
          convertToString((inputLine.substring(DtlInp.ColStrt_13, DtlInp.ColEnd_13 + 1)).trim()));
      claim.setGender(
          convertToString((inputLine.substring(DtlInp.ColStrt_15, DtlInp.ColEnd_15 + 1)).trim()));
      claim.setDiagnosis1(
          convertToString((inputLine.substring(DtlInp.ColStrt_16, DtlInp.ColEnd_16 + 1)).trim()));
      claim.setDiagnosis2(
          convertToString((inputLine.substring(DtlInp.ColStrt_17, DtlInp.ColEnd_17 + 1)).trim()));
      claim.setDiagnosis3(
          convertToString((inputLine.substring(DtlInp.ColStrt_18, DtlInp.ColEnd_18 + 1)).trim()));
      claim.setProcedure1(
          convertToString((inputLine.substring(DtlInp.ColStrt_19, DtlInp.ColEnd_19 + 1)).trim()));
      claim.setProcedure2(
          convertToString((inputLine.substring(DtlInp.ColStrt_20, DtlInp.ColEnd_20 + 1)).trim()));
      claim.setProcedure3(
          convertToString((inputLine.substring(DtlInp.ColStrt_21, DtlInp.ColEnd_21 + 1)).trim()));
      claim.setHighCost1Code(
          convertToString((inputLine.substring(DtlInp.ColStrt_22, DtlInp.ColEnd_22 + 1)).trim()));
      claim.setHighCost2Code(
          convertToString((inputLine.substring(DtlInp.ColStrt_24, DtlInp.ColEnd_24 + 1)).trim()));
      claim.setHighCost3Code(
          convertToString((inputLine.substring(DtlInp.ColStrt_26, DtlInp.ColEnd_26 + 1)).trim()));
      claim.setTotalDaysStay(
          convertToInteger((inputLine.substring(DtlInp.ColStrt_30, DtlInp.ColEnd_30 + 1)).trim()));
      claim.setPerDiemRate(
          convertToDouble((inputLine.substring(DtlInp.ColStrt_31, DtlInp.ColEnd_31 + 1)).trim()));
      claim.setTotalAmountClaimed(
          convertToDouble((inputLine.substring(DtlInp.ColStrt_32, DtlInp.ColEnd_32 + 1)).trim()));
      claim.setDeceasedFlag(
          convertToString((inputLine.substring(DtlInp.ColStrt_33, DtlInp.ColEnd_33 + 1)).trim()));
      claim.setLongTermFlag(
          convertToString((inputLine.substring(DtlInp.ColStrt_34, DtlInp.ColEnd_34 + 1)).trim()));
      claim.setAccidentIndicator(
          convertToString((inputLine.substring(DtlInp.ColStrt_35, DtlInp.ColEnd_35 + 1)).trim()));
      claim.setAccidentCode(
          convertToString((inputLine.substring(DtlInp.ColStrt_36, DtlInp.ColEnd_36 + 1)).trim()));
      claim.setProvincialClaimNumber(
          convertToString((inputLine.substring(DtlInp.ColStrt_37, DtlInp.ColEnd_37 + 1)).trim()));

      // ************************************************************
      // Hospital notes are at the end of the record and there is no
      // guarantee they will be padded out to the end of the line
      // ************************************************************
      try {
        String tmpStr = convertToString((inputLine.substring(DtlInp.ColStrt_39)).trim());
        if (tmpStr.length() > DtlInp.ColLength_39) {
          tmpStr = tmpStr.substring(0, DtlInp.ColLength_39);
        }

        claim.setNotes(tmpStr);
      } catch (IndexOutOfBoundsException ioub1) {
        claim.setNotes("");
      }

      claim.setImportFileName(convertToString((fname)));
      claim.setImportRowNum(lineCnt);
      claim.setClaimSource(convertToString((DtlCmn.dataSource)));
      claim.setChangeReason("");
      claim.setTreatingProvince(prov);
      claim.setUserId(ds.getBatchId());
      logger.debug("Calling createInpClaim() ended.");
    } catch (StringIndexOutOfBoundsException sioobe) {
      logger.error(
          "Record is too short. It must be in a fixed format and hence must be padded out.."
              + sioobe);
      throw new ProcessException(new Exception(sioobe));
    } catch (Exception e) {
      logger.error("Problem occurred creating inpatient claim record." + e);
      throw new ProcessException(new Exception(e));
    }
    logger.debug("Calling createInpClaim() ended.");
    return claim;
  }

  // *===========================================================================*/
  // * Name : createOutClaim */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 08,2005 Initial Spec */
  // * Ron Merner July 5, 2005 Now uses ICD09 versions of attributes */
  // *===========================================================================*/
  /**
   * Given a input string, breaks it up into the components required for the outpatient claim
   *
   * @param inputLine Outpatient Detail Record
   * @return ROC claim oject
   * @throws ProcessException
   */
  private Roc createOutClaim(
      String prov, String inputLine, ClaimDataService claimDS, int lineCnt, String fname)
      throws ProcessException, IOException {
    logger.debug("Calling createOutClaim() started.");
    String tmpDate = null;
    String year = null;
    String month = null;
    String day = null;
    Roc claim = null;

    try {
      claim = new Roc(claimDS);

      // ***********************
      // * Insurance Expiry Date
      // ***********************
      tmpDate = (inputLine.substring(DtlCmn.ColStrt_06, DtlCmn.ColEnd_06 + 1)).trim();

      if ((tmpDate.trim().length() != 0) && (tmpDate.trim().length() == 8)) {
        claim.setInsuranceCardExpiryDate(
            convertToDate(
                tmpDate, ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT1, DtlCmn.ColName_06));
      } else if ((tmpDate.trim().length() != 0) && (tmpDate.trim().length() == 6)) {
        claim.setInsuranceCardExpiryDate(
            convertToDate(
                tmpDate, ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT2, DtlCmn.ColName_06));
      } else if ((tmpDate.trim().length() == 0)) {
        claim.setInsuranceCardExpiryDate(convertToDate(tmpDate, null, DtlCmn.ColName_06));
      }

      // ************
      // * Birth Date
      // ************
      tmpDate = (inputLine.substring(DtlOutp.ColStrt_10, DtlOutp.ColEnd_10 + 1)).trim();
      claim.setBirthDate(
          convertToDate(tmpDate, ApplicationConstants.BIRTH_DATE_FORMAT, DtlOutp.ColName_10));

      // **************
      // * Service Date
      // **************
      tmpDate = (inputLine.substring(DtlOutp.ColStrt_19, DtlOutp.ColEnd_19 + 1)).trim();
      claim.setServiceDate(
          convertToDate(tmpDate, ApplicationConstants.SERVICE_DATE_FORMAT, DtlOutp.ColName_19));

      // ****************
      // * Billing Period
      // ****************
      claim.setBillingPeriod(
          convertToDate(processMonth, ApplicationConstants.BILL_PERIOD_FORMAT, "Billing Period"));

      claim.setHospitalNumber(
          convertToString((inputLine.substring(DtlCmn.ColStrt_03, DtlCmn.ColEnd_03 + 1)).trim()));
      // Took out for bug fix #335
      // claim.setHospitalName
      // (convertToString((inputLine.substring(DtlCmn.ColStrt_04,DtlCmn.ColEnd_04+1)).trim()));

      claim.setInsuranceNumber(
          convertToString((inputLine.substring(DtlCmn.ColStrt_05, DtlCmn.ColEnd_05 + 1)).trim()));
      claim.setLastName(
          convertToString((inputLine.substring(DtlCmn.ColStrt_07, DtlCmn.ColEnd_07 + 1)).trim()));
      claim.setFirstName(
          convertToString((inputLine.substring(DtlCmn.ColStrt_08, DtlCmn.ColEnd_08 + 1)).trim()));
      claim.setProvince(
          convertToString((inputLine.substring(DtlOutp.ColStrt_09, DtlOutp.ColEnd_09 + 1)).trim()));
      claim.setGender(
          convertToString((inputLine.substring(DtlOutp.ColStrt_11, DtlOutp.ColEnd_11 + 1)).trim()));
      claim.setDiagnosis1(
          convertToString((inputLine.substring(DtlOutp.ColStrt_12, DtlOutp.ColEnd_12 + 1)).trim()));
      claim.setDiagnosis2(
          convertToString((inputLine.substring(DtlOutp.ColStrt_12, DtlOutp.ColEnd_12 + 1)).trim()));
      claim.setServiceCode(
          convertToString((inputLine.substring(DtlOutp.ColStrt_15, DtlOutp.ColEnd_15 + 1)).trim()));
      claim.setProcedure1(
          convertToString((inputLine.substring(DtlOutp.ColStrt_14, DtlOutp.ColEnd_14 + 1)).trim()));
      claim.setProcedure2(
          convertToString((inputLine.substring(DtlOutp.ColStrt_16, DtlOutp.ColEnd_16 + 1)).trim()));
      claim.setProvincialClaimNumber(
          convertToString((inputLine.substring(DtlOutp.ColStrt_20, DtlOutp.ColEnd_20 + 1)).trim()));
      claim.setTotalAmountClaimed(
          convertToDouble((inputLine.substring(DtlOutp.ColStrt_21, DtlOutp.ColEnd_21 + 1)).trim()));

      // ************************************************************
      // Hospital notes are at the end of the record and there is no
      // guarantee they will be padded out to the end of the line
      // ************************************************************
      try {
        String tmpStr = convertToString((inputLine.substring(DtlOutp.ColStrt_23)).trim());
        if (tmpStr.length() > DtlOutp.ColLength_23) {
          tmpStr = tmpStr.substring(0, DtlOutp.ColLength_23);
        }

        claim.setNotes(tmpStr);

      } catch (IndexOutOfBoundsException ioub1) {
        claim.setNotes("");
      }

      claim.setAddress1("");
      claim.setAddress2("");
      claim.setCity("");
      claim.setPostalCode("");
      claim.setDiagnosis2("");
      claim.setDiagnosis1(""); // ICD10 Diagnosis
      claim.setDiagnosis3("");
      claim.setProcedure2("");
      claim.setProcedure1(""); // ICD10 Procedure
      claim.setProcedure3("");
      claim.setHighCost1Code("");
      claim.setHighCost2Code("");
      claim.setHighCost3Code("");
      claim.setTotalDaysStay(convertToInteger(""));
      claim.setPerDiemRate(convertToDouble(""));
      claim.setDeceasedFlag("");
      claim.setLongTermFlag("");
      claim.setAccidentIndicator("");
      claim.setAccidentCode("");
      claim.setChangeReason("");

      claim.setImportFileName(convertToString(fname));
      claim.setImportRowNum(lineCnt);
      claim.setClaimSource(convertToString(DtlCmn.dataSource));
      claim.setTreatingProvince(prov);
      claim.setUserId(ds.getBatchId());

    } catch (StringIndexOutOfBoundsException sioobe) {
      logger.error(
          "Record is too short. It must be in a fixed format and hence must be padded out.."
              + sioobe);
      throw new ProcessException(new Exception(sioobe));
    } catch (Exception e) {
      logger.error("Problem occurred creating outpatient claim record." + e);
      throw new ProcessException(new Exception(e));
    }
    logger.debug("Calling createOutClaim() ended.");
    return claim;
  }

  // *===========================================================================*/
  // * Name : createMailingRpts */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 09 ,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Given the reports generated by the import, this process generates mailing reports. The reports
   * must be sent out to the treating province (the province that sent the import file in the first
   * place) and the receiving province(s). The reports will be duplicated for each province they are
   * to be sent to. The mailbox id of each province will be prefixed to the name of the reports the
   * province is to reveive. This method will then return a list of all the mailing reports it
   * generated.
   *
   * @param curProv The treating province (the one that submitted the import file).
   * @param imports Contains import objects. Each object contains the name of an import file, the
   *     report created for it, and a flag indicating whether or not the import failed.
   * @param fh FileHelper object to help make copies of the reports.
   * @return ArrayList Same arraylist of import objects that was passed in only the outgoing list
   *     contains a list of mailing reports for each import file. the report created for it, and a
   *     flag indicating whether or not the import failed.
   * @throws IOException
   */
  private ArrayList createMailingRpts(Province curProv, ArrayList imports, FileHelper fh)
      throws ProcessException {
    logger.debug("Calling createMailingRpts() started.");

    ArrayList mailingRptList = null;

    if ((imports != null) && (imports.size() != 0)) {
      int i = 0;
      try {
        while (i < imports.size()) {
          // stage 1
          mailingRptList = new ArrayList();
          ImportFileDetails ifd = (ImportFileDetails) imports.get(i);
          File rptFile = ifd.getImportRptStg1();
          String fname1 =
              mbxCmd
                  + curProv.getProvDetails().getSubmitIdentifier().trim()
                  + "."
                  + rptFile.getName();
          java.io.File f1 = fh.createFile(fname1, rptFile.getParent());
          rptFile.renameTo(f1);
          mailingRptList.add(f1);
          int j = 0;

          // clean up the unwanted reports
          File rptFileR = ifd.getImportRptStg2();
          if (rptFileR != null) {
            rptFileR.delete();
          }
          // File trashFile = new File(trashDir,rptFileR.getName());
          // (rptFileR).renameTo(trashFile);

          while (j < rpList.size()) {
            String fname2 =
                mbxCmd
                    + ((ProvinceDetails) rpList.get(j)).getSubmitIdentifier()
                    + "."
                    + rptFile.getName();
            java.io.File f2 = fh.createFile(fname2, rptFile.getParent());
            fh.copyFile(f1, f2);
            mailingRptList.add(f2);
            j++;
            f2 = null;
            fname2 = null;
          }
          ifd.setMailingRpts(mailingRptList);
          imports.set(i, ifd);
          mailingRptList = null;
          ifd = null;
          f1 = null;
          fname1 = null;
          i++;
        }
      } catch (Exception e) {
        throw new ProcessException(
            new Exception("Problem occurred during creation of mailing reports " + e));
      }
    }
    logger.debug("Calling createMailingRpts() ended.");
    return imports;
  }
  // *===========================================================================*/
  // * Name : ftpMailingRpts */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 09, 2005 Initial Spec */
  // * DC Bartlett April 27,2005 Disallow ftp if flag is set. This way */
  // * can test process by simpy dropping file */
  // * to be processed into the applications */
  // * input directory instead of into a */
  // * mailbox on some server the process needs*/
  // * to ftp to and the reports will also not */
  // * needt to be ftped and instead can be */
  // * viewed in the apps trash or error dir. */
  // *===========================================================================*/

  /**
   * FTP's a given list of files to the appropriate mailboxes
   *
   * @param curProv A province object for the current object being processed.
   * @param imports Contains import objects. Each object contains the name of an import file, a list
   *     of reports created for it, and a flag indicating whether or not the import failed.
   * @throws IOException, ProcessException
   */
  private void ftpMailingRpts(Province curProv, ArrayList imports)
      throws IOException, ProcessException {
    logger.debug("Calling ftpMailingRpts() started.");

    if (!ftpAllowed.equals("Y")) {
      logger.info("FTP disabled in property file.");
    } else {
      int i = 0;
      while (i < imports.size()) {
        ImportFileDetails idf = (ImportFileDetails) imports.get(i);
        ArrayList rpts = idf.getMailingRpts();
        if ((rpts == null) || (rpts.size() == 0)) {
          logger.info(
              "No FTPable reports found for province/import file: "
                  + curProv.getProvince()
                  + "/"
                  + idf.getImportFile());
        } else {
          // *********************
          // Connect to FTP Server
          // *********************
          int j = 0;

          Sftp sftp =
              ftpUseKey
                  ? SFTPHelper.connectUsingKeys(
                      ftpHostName, ftpUserName, ftpPrivateKeyPath, ftpKnownHostsPath)
                  : SFTPHelper.connectUsingPassword(
                      ftpHostName, ftpUserName, ftpPswd, ftpKnownHostsPath);
          try {
            if (sftp == null || !sftp.isConnected()) {
              throw new ProcessException(new Exception("Could not connect to FTP Server"));
            }

            // *************************************************
            // If remote directory provided then change to it
            // otherwise stay in directory automatically placed
            // in when ftp connection is made
            // *************************************************
            if ((ftpOutDir.length() != 0) && (ftpOutDir != null)) {
              int retval = SFTPHelper.setRemoteDir(ftpOutDir, sftp);
              if (retval != Sftp.SUCCESS) {
                throw new ProcessException(
                    new Exception("Problems occurred changing to remote dir: " + ftpOutDir));
              }
            }
            // ************************
            // FTP all mailing reports
            // ************************
            while (j < rpts.size()) {
              File rptFile = (File) rpts.get(j);
              int retval =
                  SFTPHelper.sendSFTPFile(
                      rptFile.getParent(), rptFile.getName(), rptFile.getName(), sftp);
              if (retval != Sftp.SUCCESS) {
                throw new ProcessException(
                    new Exception("Problems occurred Ftping file: " + rptFile.getName()));
              }
              j++;
            }
          } finally {
            if (sftp != null) {
              sftp.disconnect();
            }
          }
        }
        idf = null;
        rpts = null;
        i++;
      }
    }
    logger.debug("Calling ftpMailingRpts() ended.");
  }
  // *===========================================================================*/
  // * Name : cleanupFiles */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett Match 09, 2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Moves a given list of import files from the process directory to either the error or trash
   * directory depending on whether or not the import files were successfully loaded.
   *
   * @param curProv A province object for the current object being processed.
   * @param imports Contains import objects. Each object contains the name of an import file, a list
   *     of reports created for it, and a flag indicating whether or not the import failed.
   * @param fh FileHelper object to help move files
   * @throws ProcessException
   */
  public void cleanupFiles(Province curProv, ArrayList imports, FileHelper fh)
      throws ProcessException {
    logger.debug("Calling cleanupFiles() started.");

    File processFile = null;
    File errorFile = null;
    File trashFile = null;
    File reportFile = null;
    ImportFileDetails idf = null;
    ArrayList rpts = null;

    int idx1 = 0;
    while ((idx1 < imports.size())) { // ******************
      // Move import files.
      // ******************
      try {
        idf = (ImportFileDetails) imports.get(idx1);

        if (idf.getImportError()) { // ************************************************
          // If there were errors during the import then move
          // import file to the error directory
          // ************************************************
          errorFile = new File(errorDir, idf.getImportFile().getName());
          (idf.getImportFile()).renameTo(errorFile);

          if ((idf.getImportFile().exists()) || (!(errorFile.exists()))) {
            emailMessage =
                emailMessage
                    + "Problem occurred moving file "
                    + idf.getImportFile().getName()
                    + " from process dir to error dir for province "
                    + curProv.getProvince()
                    + "\r\n";
            logger.error(
                "Problem occurred moving file "
                    + idf.getImportFile().getName()
                    + " from process dir to error dir for province "
                    + curProv.getProvince());
            logger.error("File either still exists in process dir or does not exist in error dir.");
            logger.error(
                "A move may fail if a file of the same name already exists in the error dir.");

            curProv.setProvError(true);
          }
        } else { // ************************************************
          // If there were no errors during the import then move
          // import file to the trash directory
          // ************************************************
          trashFile = new File(trashDir, idf.getImportFile().getName());
          (idf.getImportFile()).renameTo(trashFile);

          if ((idf.getImportFile().exists()) || (!(trashFile.exists()))) {
            emailMessage =
                emailMessage
                    + "Problem occurred moving file "
                    + idf.getImportFile().getName()
                    + " from process dir to trash dir for province "
                    + curProv.getProvince()
                    + "\r\n";
            logger.error(
                "Problem occurred moving file "
                    + idf.getImportFile().getName()
                    + " from process dir to trash dir for province "
                    + curProv.getProvince());
            logger.error("File either still exists in process dir or does not exist in trash dir.");
            logger.error(
                "A move may fail if a file of the same name already exists in the trash dir.");
            curProv.setProvError(true);
          }
        }
      } catch (Exception e) {
        throw new ProcessException(
            new Exception(
                "Problem occurred moving import files from process dir to error or trash dir" + e));
      } finally {
        trashFile = null;
        errorFile = null;
        idf = null;
      }
      idx1++;
    }

    logger.debug("Calling cleanupFiles() ended.");
  }
  // *===========================================================================*/
  // * Name : cleanupReports */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett Match 09, 2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Moves a given list of reports from the output directory to either the error or trash directory
   * depending on whether or not the import file they are tied to was successfully loaded.
   *
   * @param curProv A province object for the current object being processed.
   * @param imports Contains import objects. Each object contains the name of an import file, a list
   *     of reports created for it, and a flag indicating whether or not the import failed.
   * @param fh FileHelper object to help move files
   * @throws ProcessException
   */
  public void cleanupReports(Province curProv, ArrayList imports, FileHelper fh)
      throws ProcessException {
    logger.debug("Calling cleanupReports() started.");

    File processFile = null;
    File errorFile = null;
    File trashFile = null;
    File reportFile = null;
    ImportFileDetails idf = null;
    ArrayList rpts = null;

    int idx2 = 0;
    while ((idx2 < imports.size())) {
      try {
        idf = (ImportFileDetails) imports.get(idx2);
        rpts = idf.getMailingRpts();
        int j = 0;
        while (j < rpts.size()) { // ************
          // Move reports
          // ************
          reportFile = (File) rpts.get(j);
          if (idf.getImportError()) { // ************************************************
            // If there were errors during the import then move
            // reports to the error directory
            // ************************************************
            errorFile = new File(errorDir, reportFile.getName());
            if (errorFile.exists()) {
              errorFile = fh.updateFileName(reportFile.getName(), errorDir.getPath());
            }
            reportFile.renameTo(errorFile);

            if ((reportFile.exists()) || (!(errorFile.exists()))) {
              emailMessage =
                  emailMessage
                      + "Problem occurred moving file "
                      + reportFile.getName()
                      + " from output dir to error dir for province "
                      + curProv.getProvince()
                      + "\r\n";
              logger.error(
                  "Problem occurred moving file "
                      + reportFile.getName()
                      + " from output dir to error dir for province "
                      + curProv.getProvince());
              logger.error(
                  "File either still exists in output dir or does not exist in error dir.");
              logger.error(
                  "A move may fail if a file of the same name already exists in the error dir.");
              curProv.setProvError(true);
            }
          } else { // ************************************************
            // If there were no errors during the import then move
            // reports to the trash directory
            // ************************************************
            trashFile = new File(trashDir, reportFile.getName());
            if (trashFile.exists()) {
              trashFile = fh.updateFileName(reportFile.getName(), trashDir.getPath());
            }
            reportFile.renameTo(trashFile);

            if ((reportFile.exists()) || (!(trashFile.exists()))) {
              emailMessage =
                  emailMessage
                      + "\r\n"
                      + "Problem occurred moving file "
                      + reportFile.getName()
                      + " from output dir to trash dir for province "
                      + curProv.getProvince()
                      + "\r\n";
              logger.error(
                  "Problem occurred moving file "
                      + reportFile.getName()
                      + " from output dir to trash dir for province "
                      + curProv.getProvince());
              logger.error(
                  "File either still exists in output dir or does not exist in trash dir.");
              logger.error(
                  "A move may fail if a file of the same name already exists in the trash dir.");
              curProv.setProvError(true);
            }
          }
          j++;
          reportFile = null;
          trashFile = null;
          errorFile = null;
        }
      } catch (Exception e) {
        throw new ProcessException(
            new Exception(
                "Problem occurred moving reports from output dir to error or trash dir" + e));
      } finally {
        idf = null;
        rpts = null;
      }
      idx2++;
    }

    logger.debug("Calling cleanupReports() ended.");
  }
  // *===========================================================================*/
  // * Name : purgeTrash */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 10,2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Looks for files in the trash directory that are older than some retention period and deletes
   * them if they are
   *
   * @throws ProcessException
   */
  private void purgeTrash() throws ProcessException {
    logger.debug("Calling purgeTrash() started.");

    if (retention != ApplicationConstants.DEFAULT_RETENTION) {
      File[] list = trashDir.listFiles();
      File trashFile = null;
      Date trashDate = null;
      Date curDate = null;

      try {
        int i = 0;
        while ((i < list.length)) {
          try { // ********************************
            // Move import file to process dir
            // ********************************
            trashFile = new File(trashDir, ((File) list[i]).getName());
            trashDate = new Date(trashFile.lastModified());

            Calendar cal = new GregorianCalendar();
            cal.add(Calendar.DAY_OF_YEAR, retention * -1);

            curDate = cal.getTime();
            if (curDate.after(trashDate)) {
              trashFile.delete();
            }
          } finally {
            trashFile = null;
            trashDate = null;
            curDate = null;
          }
          i++;
        }
      } catch (Exception e) {
        logger.error("Problems occurred while trying to purge files from trash directory." + e);
        emailMessage =
            emailMessage
                + "Problems occurred while trying to purge files from trash directory."
                + e
                + "\r\n";
        throw new ProcessException(new Exception(e));
      } finally {
        list = null;
      }
    }
    logger.debug("Calling purgeTrash() ended.");
  }
  // *===========================================================================*/
  // * Name : checkLineLength */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 02,2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Checking line length of a specific line type. If line length does not equal value specified in
   * ApplicationConstants class for that line type then return an error
   *
   * @param line The line to be checked.
   * @param lineLength The expected length of the line
   * @param linenum Position in file the record the field belongs to
   * @param prov The Province whose field is being checked.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param importRptFile PrintWriter object where report file error messages are to be written to
   * @return int Code indicating sucess or failure of test
   * @exception ProcessException
   */
  private int checkLineLength(
      String line,
      int lineLength,
      int linesRead,
      String prov,
      FileHelper fh,
      PrintWriter importRptFile)
      throws ProcessException {
    int fileLineLength = line.length();
    String msg = null;
    if (fileLineLength < lineLength) {
      msg = importRptMsg1.replaceFirst(replaceStr, prov);
      // emailMessage = msg;
      fh.writeLine(msg, importRptFile);
      logger.error(msg);
      logger.error("Line " + linesRead + " Length: " + line.length());
      logger.error("The input file's length is incorrect!");
      return ApplicationConstants.FAILURE;
    } else {
      return ApplicationConstants.SUCCESS;
    }
  }
  // *===========================================================================*/
  // * Name : checkMandatoryChars */
  // *===========================================================================*/

  /**
   * Check to see if String value passed in is not a null or empty value.
   *
   * @param chars_in The field to be checked.
   * @param fieldName The name of the field being checked.
   * @param prov The Province whose field is being checked.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param importRptFile PrintWriter object where report file error messages are to be written to
   * @param linenum Position in file the record the field belongs to
   * @return int Code indicating sucess or failure of test
   * @exception ProcessException
   */
  private int checkMandatoryChars(
      String chars_in,
      String fieldName,
      String prov,
      FileHelper fh,
      PrintWriter importRptFile,
      int lineNum)
      throws ProcessException {
    String msg = null;
    if ((chars_in == null) || (chars_in.trim().length() == 0)) {
      // msg = "(Line:" + lineNum + ")" + importRptMsg4.replaceFirst(replaceStr,prov);
      msg = "(Line number:" + lineNum + ") " + importRptMsg8;
      msg = msg.replaceFirst(replaceStr, fieldName);
      // emailMessage = emailMessage+msg+"\r\n";
      fh.writeLine(msg, importRptFile);
      logger.error(msg);
      logger.error("Line: " + lineNum + ". Field " + fieldName + " is mandatory.");
      return ApplicationConstants.FAILURE;
    } else {
      return ApplicationConstants.SUCCESS;
    }
  }

  // *===========================================================================*/
  // * Name : checkDate */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 02,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Checks to see if field passed in is a valid date
   *
   * @param dt The field to be checked.
   * @param dtFormat The format the field is be in.
   * @param fieldName The name of the field being checked.
   * @param prov The Province whose field is being checked.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param importRptFile PrintWriter object where report file error messages are to be written to
   * @param linenFum Position in file the record the field belongs to
   * @return int Code indicating sucess or failure of test
   * @exception ProcessException
   */
  private int checkDate(
      String dt,
      String dtFormat,
      String dtName,
      String prov,
      FileHelper fh,
      PrintWriter importRptFile,
      int lineNum)
      throws ProcessException {
    int retval = ApplicationConstants.SUCCESS;
    String invalid = "-";
    String strDt = Helper.removeInvalidChars(dt, invalid);
    String msg = null;

    if (strDt == null) {
      retval = ApplicationConstants.FAILURE;
    } else if (dtFormat.equals(ApplicationConstants.DEFAULT_DATE_FORMAT1)) {
      if (strDt.length() == 8) {
        String year = strDt.substring(0, 4);
        String month = strDt.substring(4, 6);
        String day = strDt.substring(6, 8);

        if (CommonValidator.isValidDate(year, month, day) != CommonValidator.DATE_OK) {
          retval = ApplicationConstants.FAILURE;
        }
      } else {
        retval = ApplicationConstants.FAILURE;
      }
    } else if (dtFormat.equals(ApplicationConstants.DEFAULT_DATE_FORMAT2)) {
      if (strDt.length() == 6) {
        String year = strDt.substring(0, 4);
        String month = strDt.substring(4, 6);
        String day = "01";

        if (CommonValidator.isValidDate(year, month, day) != CommonValidator.DATE_OK) {
          retval = ApplicationConstants.FAILURE;
        }
      } else {
        retval = ApplicationConstants.FAILURE;
      }
    } else {
      logger.error("Date Format not one recognized by Import Process.");
      retval = ApplicationConstants.FAILURE;
    }
    if (retval == ApplicationConstants.FAILURE) {
      msg = "(Line number:" + lineNum + ") " + importRptMsg4;
      // msg = importRptMsg4.replaceFirst(replaceStr,prov);
      msg = msg.replaceFirst(replaceStr, dtName);
      msg = msg.replaceFirst(replaceStr, dtFormat);
      // emailMessage = emailMessage + msg + "\r\n";
      fh.writeLine(msg, importRptFile);
      logger.error(msg);
      logger.error(
          "Line: " + lineNum + ". Date or Date Format invalid. Field " + dtName + "=" + dt);
      logger.error("Date Format: " + dtFormat);
      return ApplicationConstants.FAILURE;
    }
    return ApplicationConstants.SUCCESS;
  }
  // *===========================================================================*/
  // * Name : checkNumber */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 02,2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Check to see if String value passed in is a numeric value.
   *
   * @param num_in The field to be checked.
   * @param fieldName The name of the field being checked.
   * @param prov The Province whose field is being checked.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param importRptFile PrintWriter object where report file error messages are to be written to
   * @param linenum Position in file the record the field belongs to
   * @param numTypeAllowed Indicates numeric type allowed for the passed in value: Decimal, No
   *     Decimal, Positive Only
   * @return int Code indicating sucess or failure of test
   * @exception ProcessException
   */
  private int checkNumber(
      String num_in,
      String fieldName,
      String prov,
      FileHelper fh,
      PrintWriter importRptFile,
      int lineNum,
      int numTypeAllowed)
      throws ProcessException {
    int decAllowed = 4;
    int decAllowedPosOnly = 6;
    int noDecAllowedPosOnly = 2;
    int noDecAllowed = 0;

    String msg = null;
    int numResult = CommonValidator.isNumeric(num_in, numTypeAllowed);
    if (numResult != CommonValidator.NUMBER_OK) {
      msg = "(Line number:" + lineNum + ") " + importRptMsg4;
      msg = msg.replaceFirst(replaceStr, fieldName);
      logger.error(msg);
      logger.error(
          "Line: " + lineNum + ". Numeric Field invalid. Field " + fieldName + "=" + num_in);
      if (numTypeAllowed == decAllowed) {
        logger.error("a numeric field, can be a decimal, positive or negative.");
        msg =
            msg.replaceFirst(replaceStr, "a numeric field, can be a decimal, positive or negative");
      }
      if (numTypeAllowed == decAllowedPosOnly) {
        logger.error("a numeric field, can be a decimal and cannot be negative");
        msg =
            msg.replaceFirst(
                replaceStr, "a numeric field, can be a decimal and cannot be negative");
      }
      if (numTypeAllowed == noDecAllowedPosOnly) {
        logger.error("a numeric field, cannot be a decimal and cannot be negative");
        msg =
            msg.replaceFirst(
                replaceStr, "a numeric field, cannot be a decimal and cannot be negative");
      }
      if (numTypeAllowed == noDecAllowed) {
        logger.error("a numeric field, cannot be a decimal but can be negative or positive");
        msg =
            msg.replaceFirst(
                replaceStr,
                "a numeric field, cannot be a decimal but can be negative or positive.");
      }

      // emailMessage = emailMessage + msg + "\r\n";
      fh.writeLine(msg, importRptFile);
      return ApplicationConstants.FAILURE;
    } else {
      return ApplicationConstants.SUCCESS;
    }
  }
  // *===========================================================================*/
  // * Name : convertToDate */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 07,2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Takes a date string in the YYYYMMDD format and changes it to a date
   *
   * @param dateStr Date value as a string type. If the string is empty a null is returned
   * @return java.util.Date Passed in string convereted to a date.
   * @throws ProcessException
   */
  private static java.util.Date convertToDate(String dateStr, String dateFormat, String dateName)
      throws ProcessException {
    logger.debug("Calling convertToDate() started.");
    if (dateStr == null || dateStr.equals("")) {
      return null;
    }

    String year, month, day;

    if (dateFormat.equals(ApplicationConstants.DEFAULT_DATE_FORMAT1)) {
      if (dateStr.matches("^[0-9]{4}[-/]?[0-9]{2}[-/]?[0-9]{2}$")) {
        dateStr = dateStr.replaceAll("[-/]", "");
        year = dateStr.substring(0, 4);
        month = dateStr.substring(4, 6);
        day = dateStr.substring(6, 8);
      } else {
        throw new ProcessException(
            new Exception(("Invalid date \"" + dateStr + "\"" + "for field" + dateName)));
      }
    } else if (dateFormat.equals(ApplicationConstants.DEFAULT_DATE_FORMAT2)) {
      if (dateStr.matches("^[0-9]{4}[-/]?[0-9]{2}$")) {
        dateStr = dateStr.replaceAll("[-/]", "");
        year = dateStr.substring(0, 4);
        month = dateStr.substring(4, 6);
        day = "1";
      } else {
        throw new ProcessException(
            new Exception("Invalid date \"" + dateStr + "\"" + "for field" + dateName));
      }
    } else {
      throw new ProcessException(
          new Exception("Invalid date \"" + dateStr + "\"" + "for field" + dateName));
    }

    logger.debug("Calling convertToDate() ended.");
    return Helper.getDate(year, month, day);
  }

  // *===========================================================================*/
  // * Name : convertToInteger */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 07,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Takes a date string and changes it to an Integer object
   *
   * @param s Integer value as a string type. If the string is empty a null is returned
   * @return Integer Passed in string convereted to an Integer.
   */
  private static Integer convertToInteger(String s) {

    logger.debug("Calling convertToInteger() started.");

    if (s == null || s.equals("")) {
      return null;
    }

    logger.debug("Calling convertToInteger() ended.");

    return new Integer(s);
  }

  // *===========================================================================*/
  // * Name : convertToDouble */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 07,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Takes a date string and changes it to a Double object
   *
   * @param s Double value as a string type. If the string is empty a null is returned
   * @return Double Passed in string convereted to a Double type.
   * @throws ProcessException
   */
  private static Double convertToDouble(String s) {

    logger.debug("Calling convertToDouble() started.");

    if (s == null || s.equals("")) {
      return null;
    }

    logger.debug("Calling convertToDouble() ended.");

    return new Double(s);
  }

  // *===========================================================================*/
  // * Name : convertToString */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 07,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Ensures any null string is changed to ""
   *
   * @param s String value. If the string is null then "" is returend.
   * @return String Passed in string passed back unless is null in which case "" is passed back
   * @throws ProcessException
   */
  private static String convertToString(String s) {

    logger.debug("Calling convertToString() started.");

    if (s == null) {
      return "";
    }

    logger.debug("Calling convertToString() ended.");

    return s;
  }
  // *===========================================================================*/
  // * Name : round */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 14,2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Round a double value to a specified number of decimal places.
   *
   * @param val the value to be rounded.
   * @param places the number of decimal places to round to.
   * @return val rounded to places decimal places.
   */
  public static double round(double val, int places) {
    long factor = (long) Math.pow(10, places);

    // Shift the decimal the correct number of places
    // to the right.
    val = val * factor;

    // Round to the nearest integer.
    long tmp = Math.round(val);

    // Shift the decimal the correct number of places
    // back to the left.
    return (double) tmp / factor;
  }

  /**
   * @param province
   * @param inputLine
   * @param claimDS
   * @param curLine
   * @param name
   * @return
   */
  private SAHeaderRecord createHeaderRecord(
      String province, String inputLine, ClaimDataService claimDS, int curLine, String name)
      throws ProcessException {
    // TODO Auto-generated method stub
    SAHeaderRecord record = new SAHeaderRecord();
    String hdrCode = ApplicationConstants.IMPORT_FILE_HDR_CODE;

    try {

      if ((inputLine.substring(Hdr.ColStrt_01, Hdr.ColEnd_01 + 1)).equalsIgnoreCase(hdrCode)) {

        record.setRecordType(
            convertToString(
                (inputLine.substring(Hdr.ColStrt_01, Hdr.ColEnd_01 + 1).trim().toUpperCase())));
        record.setTreatingProvince(
            convertToString(
                (inputLine.substring(Hdr.ColStrt_02, Hdr.ColEnd_02 + 1).trim().toUpperCase())));
        record.setReceivingProvince(
            convertToString((inputLine.substring(Hdr.ColStrt_03, Hdr.ColEnd_03 + 1).trim())));
        record.setBillingPeriod(
            convertToString((inputLine.substring(Hdr.ColStrt_04, Hdr.ColEnd_04 + 1).trim())));
        record.setTotalNumberDetails(
            convertToString((inputLine.substring(Hdr.ColStrt_05, Hdr.ColEnd_05 + 1).trim())));
        record.setTotalAmount(
            convertToString(
                inputLine.substring(Hdr.ColStrt_06, Hdr.ColEnd_06 + 1).trim().toUpperCase()));
        record.setVersionIdentifier(
            convertToString((inputLine.substring(Hdr.ColStrt_07, Hdr.ColEnd_07 + 1).trim())));
        record.setDateSubmitted(
            convertToString(inputLine.substring(Hdr.ColStrt_08, Hdr.ColEnd_08 + 1).trim()));
        record.setImportFileName(name);
      }

      logger.debug("Calling createHeaderRecord() ended.");

    } catch (Exception e) {
      logger.error("Problem occurred creating inpatient claim record." + e);
      throw new ProcessException(new Exception(e));
    }
    logger.debug("Calling createSADetailRecord() ended.");
    return record;
  }
  // *===========================================================================*/
  // * Name : createSADetailRecord */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * C. Stepanov May 02,2007 Initial Spec */
  // *===========================================================================*/

  /**
   * Given a input string, breaks it up into the components required for the staging area record
   *
   * @param inputLine Inpatient Detail Record
   * @return SARecord claim oject
   * @throws ProcessException
   */
  private SADetailRecord createSAInpatientRecord(
      String prov, String inputLine, ClaimDataService claimDS, int lineCnt, String fname, int subId)
      throws ProcessException, IOException {
    logger.debug("Calling createSADetailRecord() started.");
    String tmpDate = null;
    String year = null;
    String month = null;
    String day = null;
    SADetailRecord record = new SADetailRecord();
    try {

      record.setSubId(subId);

      // ************
      // * Record Type
      // ************
      record.setPatientBatch(
          convertToString(
              (inputLine.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1)).trim().toUpperCase()));

      // ************
      // * Batch Type
      // ************
      record.setRecordType2(
          convertToString(
              (inputLine.substring(DtlCmn.ColStrt_02, DtlCmn.ColEnd_02 + 1)).trim().toUpperCase()));

      // ***********************
      // * Insurance Expiry Date
      // ***********************
      record.setInsuranceCardExpiryDate(
          convertToString((inputLine.substring(DtlCmn.ColStrt_06, DtlCmn.ColEnd_06 + 1)).trim()));

      // ************
      // * Birth Date
      // ************
      record.setBirthDate(
          convertToString((inputLine.substring(DtlInp.ColStrt_14, DtlInp.ColEnd_14 + 1)).trim()));

      // ****************************
      // * High Cost Procedure Date 1
      // ****************************
      record.setHighCostProcedureDate1(
          convertToString((inputLine.substring(DtlInp.ColStrt_23, DtlInp.ColEnd_23 + 1)).trim()));

      // ****************************
      // * High Cost Procedure Date 2
      // ****************************
      record.setHighCostProcedureDate2(
          convertToString((inputLine.substring(DtlInp.ColStrt_25, DtlInp.ColEnd_25 + 1)).trim()));

      // ****************************
      // * High Cost Procedure Date 3
      // ****************************
      record.setHighCostProcedureDate3(
          convertToString((inputLine.substring(DtlInp.ColStrt_27, DtlInp.ColEnd_27 + 1)).trim()));

      // ****************
      // * Admission Date
      // ****************
      record.setAdmissionDate(
          convertToString((inputLine.substring(DtlInp.ColStrt_28, DtlInp.ColEnd_28 + 1)).trim()));

      // ****************
      // * Discharge Date
      // ****************
      record.setDischargeDate(
          convertToString((inputLine.substring(DtlInp.ColStrt_29, DtlInp.ColEnd_29 + 1)).trim()));

      record.setHospitalNumber(
          convertToString((inputLine.substring(DtlCmn.ColStrt_03, DtlCmn.ColEnd_03 + 1)).trim()));
      record.setHospitalName(
          convertToString((inputLine.substring(DtlCmn.ColStrt_04, DtlCmn.ColEnd_04 + 1)).trim()));
      record.setInsuranceCardNumber(
          convertToString((inputLine.substring(DtlCmn.ColStrt_05, DtlCmn.ColEnd_05 + 1)).trim()));
      record.setLastName(
          convertToString((inputLine.substring(DtlCmn.ColStrt_07, DtlCmn.ColEnd_07 + 1)).trim()));
      record.setFirstName(
          convertToString((inputLine.substring(DtlCmn.ColStrt_08, DtlCmn.ColEnd_08 + 1)).trim()));
      record.setAddress1(
          convertToString((inputLine.substring(DtlInp.ColStrt_09, DtlInp.ColEnd_09 + 1)).trim()));
      record.setAddress2(
          convertToString((inputLine.substring(DtlInp.ColStrt_10, DtlInp.ColEnd_10 + 1)).trim()));
      record.setCity(
          convertToString((inputLine.substring(DtlInp.ColStrt_11, DtlInp.ColEnd_11 + 1)).trim()));
      record.setProvince(
          convertToString(
              (inputLine.substring(DtlInp.ColStrt_12, DtlInp.ColEnd_12 + 1)).trim().toUpperCase()));
      record.setPostalCode(
          convertToString((inputLine.substring(DtlInp.ColStrt_13, DtlInp.ColEnd_13 + 1)).trim()));
      record.setSexCode(
          convertToString(
              (inputLine.substring(DtlInp.ColStrt_15, DtlInp.ColEnd_15 + 1)).trim().toUpperCase()));
      record.setDiagnosCode1(
          convertToString((inputLine.substring(DtlInp.ColStrt_16, DtlInp.ColEnd_16 + 1)).trim()));
      record.setDiagnosCode2(
          convertToString((inputLine.substring(DtlInp.ColStrt_17, DtlInp.ColEnd_17 + 1)).trim()));
      record.setDiagnosCode3(
          convertToString((inputLine.substring(DtlInp.ColStrt_18, DtlInp.ColEnd_18 + 1)).trim()));
      record.setProcedureCode1(
          convertToString((inputLine.substring(DtlInp.ColStrt_19, DtlInp.ColEnd_19 + 1)).trim()));
      record.setProcedureCode2(
          convertToString((inputLine.substring(DtlInp.ColStrt_20, DtlInp.ColEnd_20 + 1)).trim()));
      record.setProcedureCode3(
          convertToString((inputLine.substring(DtlInp.ColStrt_21, DtlInp.ColEnd_21 + 1)).trim()));
      record.setHighCostProcedureCode1(
          convertToString((inputLine.substring(DtlInp.ColStrt_22, DtlInp.ColEnd_22 + 1)).trim()));
      record.setHighCostProcedureCode2(
          convertToString((inputLine.substring(DtlInp.ColStrt_24, DtlInp.ColEnd_24 + 1)).trim()));
      record.setHighCostProcedureCode3(
          convertToString((inputLine.substring(DtlInp.ColStrt_26, DtlInp.ColEnd_26 + 1)).trim()));
      record.setTotalDaysStay(
          convertToString((inputLine.substring(DtlInp.ColStrt_30, DtlInp.ColEnd_30 + 1)).trim()));
      record.setPerDiemRate(
          convertToString((inputLine.substring(DtlInp.ColStrt_31, DtlInp.ColEnd_31 + 1)).trim()));
      record.setTotalAmountClaimed(
          convertToString((inputLine.substring(DtlInp.ColStrt_32, DtlInp.ColEnd_32 + 1)).trim()));
      record.setTotalAmountClaimed(
          convertToString((inputLine.substring(DtlInp.ColStrt_32, DtlInp.ColEnd_32 + 1)).trim()));
      record.setDeceasedFlag(
          convertToString((inputLine.substring(DtlInp.ColStrt_33, DtlInp.ColEnd_33 + 1)).trim()));
      record.setLongTermStayInd(
          convertToString((inputLine.substring(DtlInp.ColStrt_34, DtlInp.ColEnd_34 + 1)).trim()));
      record.setAccidentInd(
          convertToString((inputLine.substring(DtlInp.ColStrt_35, DtlInp.ColEnd_35 + 1)).trim()));
      record.setAccidentCode(
          convertToString((inputLine.substring(DtlInp.ColStrt_36, DtlInp.ColEnd_36 + 1)).trim()));
      record.setProvincialClaimId(
          convertToString((inputLine.substring(DtlInp.ColStrt_37, DtlInp.ColEnd_37 + 1)).trim()));
      record.setAdjFlag(
          convertToString(
              (inputLine.substring(DtlInp.ColStrt_38, DtlInp.ColEnd_38 + 1)).trim().toUpperCase()));
      // record.setAdjFlag
      // (convertToString((inputLine.substring(DtlInp.ColStrt_38,DtlInp.ColEnd_38+1)).trim()));

      // record.setServiceCode("");
      // record.setServiceDate("");
      record.setUserId(ds.getBatchId());

      // ************************************************************
      // Hospital notes are at the end of the record and there is no
      // guarantee they will be padded out to the end of the line
      // ************************************************************
      try {
        String tmpStr = convertToString((inputLine.substring(DtlInp.ColStrt_39)).trim());
        if (tmpStr.length() > DtlInp.ColLength_39) {
          tmpStr = tmpStr.substring(0, DtlInp.ColLength_39);
        }

        record.setNotes(tmpStr);
      } catch (IndexOutOfBoundsException ioub1) {
        record.setNotes("");
      }

      record.setUserId(ds.getBatchId());
      logger.debug("Calling createInpClaim() ended.");
    } catch (StringIndexOutOfBoundsException sioobe) {
      logger.error(
          "Record is too short. It must be in a fixed format and hence must be padded out.."
              + sioobe);
      throw new ProcessException(new Exception(sioobe));
    } catch (Exception e) {
      logger.error("Problem occurred creating inpatient claim record." + e);
      throw new ProcessException(new Exception(e));
    }
    logger.debug("Calling createSADetailRecord() ended.");
    return record;
  }

  // *===========================================================================*/
  // * Name : createOutClaim */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 08,2005 Initial Spec */
  // * Ron Merner July 5, 2005 Now uses ICD09 versions of attributes */
  // *===========================================================================*/
  /**
   * Given a input string, breaks it up into the components required for the outpatient claim
   *
   * @param inputLine Outpatient Detail Record
   * @return ROC claim oject
   * @throws ProcessException
   */
  private SADetailRecord createSAOutpatientRecord(
      String prov, String inputLine, ClaimDataService claimDS, int lineCnt, String fname, int subId)
      throws ProcessException, IOException {
    logger.debug("Calling createOutClaim() started.");
    String tmpDate = null;
    String year = null;
    String month = null;
    String day = null;
    SADetailRecord record = new SADetailRecord();
    try {
      // record = new SADetailRecord(claimDS);
      record.setSubId(subId);

      // ***********************
      // * Insurance Expiry Date
      // ***********************
      // tmpDate = (inputLine.substring(DtlCmn.ColStrt_06,DtlCmn.ColEnd_06+1)).trim();

      // if ((tmpDate.trim().length()!=0) && (tmpDate.trim().length()==8))
      record.setInsuranceCardExpiryDate(
          convertToString(inputLine.substring(DtlCmn.ColStrt_06, DtlCmn.ColEnd_06 + 1)).trim());

      // else if ((tmpDate.trim().length()!=0) && (tmpDate.trim().length()==6))
      // {
      // record.setInsuranceCardExpiryDate(convertToDate(tmpDate,ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT2,DtlCmn.ColName_06));}
      //
      // else if ((tmpDate.trim().length()==0))
      // { record.setInsuranceCardExpiryDate(convertToDate(tmpDate,null,DtlCmn.ColName_06));}

      // ************
      // * Birth Date
      // ************
      record.setBirthDate(
          convertToString(inputLine.substring(DtlOutp.ColStrt_10, DtlOutp.ColEnd_10 + 1)).trim());

      // **************
      // * Service Date
      // **************
      record.setServiceDate(
          convertToString(inputLine.substring(DtlOutp.ColStrt_19, DtlOutp.ColEnd_19 + 1)).trim());
      ;

      // ****************
      // * Billing Period
      // ****************
      // record.setsetBillingPeriod(convertToString(processMonth,ApplicationConstants.BILL_PERIOD_FORMAT,"Billing
      // Period"));

      // ************
      // * Record Type
      // ************
      record.setPatientBatch(
          convertToString(
              (inputLine.substring(DtlCmn.ColStrt_01, DtlCmn.ColEnd_01 + 1)).trim().toUpperCase()));

      // ************
      // * Batch Type
      // ************
      record.setRecordType2(
          convertToString(
              (inputLine.substring(DtlCmn.ColStrt_02, DtlCmn.ColEnd_02 + 1)).trim().toUpperCase()));

      record.setHospitalNumber(
          convertToString((inputLine.substring(DtlCmn.ColStrt_03, DtlCmn.ColEnd_03 + 1)).trim()));
      record.setHospitalName(
          convertToString((inputLine.substring(DtlCmn.ColStrt_04, DtlCmn.ColEnd_04 + 1)).trim()));
      record.setInsuranceCardNumber(
          convertToString((inputLine.substring(DtlCmn.ColStrt_05, DtlCmn.ColEnd_05 + 1)).trim()));
      record.setLastName(
          convertToString((inputLine.substring(DtlCmn.ColStrt_07, DtlCmn.ColEnd_07 + 1)).trim()));
      record.setFirstName(
          convertToString((inputLine.substring(DtlCmn.ColStrt_08, DtlCmn.ColEnd_08 + 1)).trim()));
      record.setProvince(
          convertToString(
              (inputLine.substring(DtlOutp.ColStrt_09, DtlOutp.ColEnd_09 + 1))
                  .trim()
                  .toUpperCase()));
      record.setSexCode(
          convertToString(
              (inputLine.substring(DtlOutp.ColStrt_11, DtlOutp.ColEnd_11 + 1))
                  .trim()
                  .toUpperCase()));
      record.setDiagnosCode1(
          convertToString((inputLine.substring(DtlOutp.ColStrt_12, DtlOutp.ColEnd_12 + 1)).trim()));
      record.setServiceCode(
          convertToString((inputLine.substring(DtlOutp.ColStrt_15, DtlOutp.ColEnd_15 + 1)).trim()));
      record.setProcedureCode1(
          convertToString((inputLine.substring(DtlOutp.ColStrt_16, DtlOutp.ColEnd_16 + 1)).trim()));
      record.setProvincialClaimId(
          convertToString((inputLine.substring(DtlOutp.ColStrt_20, DtlOutp.ColEnd_20 + 1)).trim()));
      record.setTotalAmountClaimed(
          convertToString((inputLine.substring(DtlOutp.ColStrt_21, DtlOutp.ColEnd_21 + 1)).trim()));
      record.setAdjFlag(
          convertToString(
              (inputLine.substring(DtlOutp.ColStrt_22, DtlOutp.ColEnd_22 + 1))
                  .trim()
                  .toUpperCase()));
      // ************************************************************
      // Hospital notes are at the end of the record and there is no
      // guarantee they will be padded out to the end of the line
      // ************************************************************
      try {
        String tmpStr = convertToString((inputLine.substring(DtlOutp.ColStrt_23)).trim());
        if (tmpStr.length() > DtlOutp.ColLength_23) {
          tmpStr = tmpStr.substring(0, DtlOutp.ColLength_23);
        }

        record.setNotes(tmpStr);

      } catch (IndexOutOfBoundsException ioub1) {
        record.setNotes("");
      }

      record.setAddress1("");
      record.setAddress2("");
      record.setCity("");
      record.setPostalCode("");
      // claim.setDiagnosis2 ("");
      record.setDiagnosCode2(""); // ICD10 Diagnosis
      // record.setDiagnosCode1 ("");
      record.setDiagnosCode3("");
      // claim.setProcedure2 ("");
      record.setProcedureCode2(""); // ICD10 Procedure
      record.setProcedureCode3("");
      record.setHighCostProcedureCode1("");
      record.setHighCostProcedureCode2("");
      record.setHighCostProcedureCode3("");
      record.setTotalDaysStay("");
      record.setPerDiemRate("");
      record.setDeceasedFlag("");
      record.setLongTermStayInd("");
      record.setAccidentInd("");
      record.setAccidentCode("");
      // record.setChangesetChangeReason ("");

      // record.setImportFileName (convertToString(fname));
      // record.setImportRowNum (lineCnt);
      // record.setClaimSource (convertToString(DtlCmn.dataSource));
      // record.setTresetTreatingProvince (prov);
      record.setUserId(ds.getBatchId());

    } catch (StringIndexOutOfBoundsException sioobe) {
      logger.error(
          "Record is too short. It must be in a fixed format and hence must be padded out.."
              + sioobe);
      throw new ProcessException(new Exception(sioobe));
    } catch (Exception e) {
      logger.error("Problem occurred creating outpatient claim record." + e);
      throw new ProcessException(new Exception(e));
    }
    logger.debug("Calling createOutClaim() ended.");
    return record;
  }
}
