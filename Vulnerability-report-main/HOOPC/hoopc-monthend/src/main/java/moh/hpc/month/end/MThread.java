/**
 * ****************************************************************************** Licensed Materials
 * - Property of IBM * Copyright IBM Canada Ltd 2005 All Rights Reserved * Created on Jan 10, 2005 *
 * ****************************************************************************** Please do not
 * makes any changes to this file without first * updating the revision history below, under
 * description * please include Harvest Change Request or PSO Tools CR that * caused the change. *
 * ****************************************************************************** Revision History:
 * * * Date Name Description * ---------- ----------------
 * --------------------------------------------- * 01-10-2005 David Bartlett Initial Specs *
 * ******************************************************************************
 */
package moh.hpc.month.end;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class MThread implements Runnable {
  private static Logger logger = LoggerFactory.getLogger("MThread");

  private Thread myThread = null;

  private boolean previousHandlerFinished = false;
  private boolean pause = false;
  private boolean dead = false;
  private static long threadNumber = 0;
  private String threadName = null;
  private long paceRate = 0;
  public static int RC_OK = 0;
  public static int RC_ERR = -1;
  private boolean stopRequest = false;
  private int resultCode = RC_ERR;

  private static synchronized long getThreadNumber() {
    return threadNumber++;
  }

  public MThread() {
    createThreadName();
    myThread = new Thread(this, threadName);
  }

  public void kill() {
    myThread.interrupt();
  }

  public void start() {
    /*
    [JHOOPC-552] We replace 'start' with 'run' here to make the code synchronous
    and single-threaded to run in a Java EE application server.
     */
    // myThread.start();
    myThread.run();
  }

  public boolean isDead() {
    return dead;
  }

  protected void setDead(boolean dead) {
    this.dead = dead;
  }

  private void createThreadName() {
    logger.debug("method: createThreadName started");
    String tmpStr = getClass().getName();
    long threadNumber = getThreadNumber();

    int i = tmpStr.lastIndexOf(".");
    if (i != -1) {
      tmpStr = tmpStr.substring(i + 1);
    }

    tmpStr = "Thread: " + tmpStr + " " + threadNumber;
    threadName = tmpStr;
    logger.debug("method: createThreadName finished");
  }

  public String getThreadName() {
    return threadName;
  }

  /**
   * Gets the pause
   *
   * @return Returns a boolean
   */
  public boolean isPaused() {
    return pause;
  }
  /**
   * Sets the pause
   *
   * @param pause The pause to set
   */
  public void setPaused(boolean pause) {
    this.pause = pause;
  }

  public void stop() {
    stop(RC_OK);
  }

  public void stop(int resultCode) {
    stopRequest = true;
    setResultCode(resultCode);
  }

  public boolean isStopRequested() {
    return stopRequest;
  }

  public void setStopRequest(boolean b) {
    stopRequest = b;
  }

  /**
   * Gets the resultCode
   *
   * @return Returns a int
   */
  public synchronized int getResultCode() {
    return resultCode;
  }
  /**
   * Sets the resultCode
   *
   * @param resultCode The resultCode to set
   */
  private synchronized void setResultCode(int resultCode) {
    this.resultCode = resultCode;
  }

  /**
   * Gets the paceRate
   *
   * @return Returns a long
   */
  public long getPaceRate() {
    return paceRate;
  }

  /**
   * Sets the paceRate
   *
   * @param paceRate The paceRate to set
   */
  public void setPaceRate(long paceRate) {
    this.paceRate = paceRate;
  }

  /**
   * Returns boolean containing completion status of a Handler.
   *
   * <p>Returns boolean containing completion status of a Handler. That is the Handler that is
   * processing records for the current handler.
   *
   * @return boolean containing previousHandlerFinished
   */
  public boolean isPreviousHandlerFinished() {
    return previousHandlerFinished;
  }

  /**
   * Sets boolean containing completion status of a Handler.
   *
   * <p>Sets boolean containing completion status of a Handler. That is the Handler that is
   * processing records for the current handler.
   *
   * @param b containing boolean previousHandlerFinished
   */
  public void setPreviousHandlerFinished(boolean b) {
    previousHandlerFinished = b;
  }
}
