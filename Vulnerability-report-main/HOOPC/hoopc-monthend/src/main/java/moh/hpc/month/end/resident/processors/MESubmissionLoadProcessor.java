/**
 * ****************************************************************************** Licensed Materials
 * - Property of IBM * Copyright IBM Canada Ltd 2005 All Rights Reserved * Created on Feb 25, 2005 *
 * ****************************************************************************** Please do not
 * makes any changes to this file without first * updating the revision history below, under
 * description * please include Harvest Change Request or PSO Tools CR that * caused the change. *
 * ****************************************************************************** Revision History:
 * * * Date Name Description * ---------- ----------------
 * --------------------------------------------- * 02-25-2005 David Bartlett Initial Spec *
 * 04-27-2005 David Bartlett Added handler monitor handling and ftp flag * 07-05-2005 Ron Merner
 * Modified createOutClaim() to use the ICD09 * versions of the diagnosis and procedure *
 * attributes. * 04-06-2006 Christine Root Changed to comply with newer file format * 05-31-2006
 * Cathy Hu Changed to comply with newer file format * for the mandatory fields change * 08-05-2007
 * C Stepanov Major rewrite to load the submission files * into the staging area and validate as *
 * per new set of rules *
 * ******************************************************************************
 */
package moh.hpc.month.end.resident.processors;

import com.ibm.network.sftp.Sftp;
import com.orion.symphonia3.InvalidKeyException;
import jakarta.enterprise.context.Dependent;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import moh.broker.utils.PasswordUtility;
import moh.common.business.services.utils.CommonValidator;
import moh.common.business.services.utils.Helper;
import moh.hoopc.app.Ric;
import moh.hoopc.app.Roc;
import moh.hoopc.services.ClaimDataService;
import moh.hoopc.services.ClaimDataServiceBridge;
import moh.hoopc.services.util.ServiceFailedException;
import moh.hoopc.staging.SADetailRecord;
import moh.hoopc.staging.SAHeaderRecord;
import moh.hoopc.staging.SARejectReport;
import moh.hoopc.util.Init;
import moh.hpc.month.end.EmailHelper;
import moh.hpc.month.end.FileHelper;
import moh.hpc.month.end.HandlerMonitor;
import moh.hpc.month.end.SFTPHelper;
import moh.hpc.month.end.constants.ApplicationConstants;
import moh.hpc.month.end.constants.PropertyFileKeys;
import moh.hpc.month.end.constants.batch.imprt.DtlCmn;
import moh.hpc.month.end.constants.batch.imprt.DtlInp;
import moh.hpc.month.end.constants.batch.imprt.DtlOutp;
import moh.hpc.month.end.exceptions.ProcessException;
import moh.hpc.month.end.services.MEDataService;
import moh.hpc.month.end.support.Province;
import moh.hpc.month.end.support.ProvinceDetails;
import moh.hpc.month.end.support.ProvinceFilter;
import moh.hpc.month.end.support.SubmissionDetails;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Dependent
public class MESubmissionLoadProcessor extends MonthEndResProcessor {

  private HandlerMonitor hmont = null;
  private Properties prp = null;
  private MEDataService ds = null;
  private Hashtable provStatList = null;
  private String processMonth = null;
  private ProvinceFilter pf = null;
  private EmailHelper eh = null;
  private CommonValidator cv = null;
  private ArrayList rpList = null;
  private ArrayList importList = null;
  private String startingStatus = null;
  private String nextStatus = null;
  private String successTrans = null;
  private String statusKey = null;
  private String importStep = null;
  private String defaultStep = null;
  private String loadStartStatus = null;
  private String loadDoneStatus = null;
  private String ftpFormat = null;
  private String ftpAllowed = null;
  private String ftpHostName = null;
  private String ftpUserName = null;
  private boolean ftpUseKey;
  private String ftpPrivateKeyPath = null;
  private String ftpKnownHostsPath = null;
  private String ftpPswd = null;
  private String ftpInDir = null;
  private String ftpOutDir = null;
  private String inputDirStr = null;
  private String processDirStr = null;
  private String trashDirStr = null;
  private String errorDirStr = null;
  private String reportDirStr = null;
  private String ext = null;
  private String mbxCmd = null;
  private String importRptName = null;
  private String importRptMsg1 = null;
  // private String importRptMsg2 = null;
  private String importRptMsg3 = null;
  private String importRptMsg4 = null;
  private String importRptMsg5 = null;
  private String importRptMsg6 = null;
  private String importRptMsg9 = null;
  private String importRptMsg10 = null;
  private String importRptMsg11 = null;
  private String replaceStr = null;
  private int commitSize = 0;
  private int retention = 0;
  private File inpDir = null;
  private File processDir = null;
  private File trashDir = null;
  private File errorDir = null;
  private File reportDir = null;
  private String emailMessage = "";
  private String DESTINATION = null;
  private String EMAIL_WARN_SUBJECT = null;
  private String EMAIL_ERROR_SUBJECT = null;
  private String EMAIL_NORMAL_SUBJECT = null;
  private static Logger logger = LoggerFactory.getLogger("MESubmissionLoadProcessor");
  private Boolean emailOption;

  // *===========================================================================*/
  // * Name : constructor */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 25 2005 Initial Spec */
  // *===========================================================================*/
  public MESubmissionLoadProcessor() {
    super();
  }

  // *===========================================================================*/
  // * Name : initialize */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 25 2005 Initial Spec */
  // * DC Bartlett April 27 2005 Setup handler monitor and ftp flag. */
  // * C. Stepanov August 05 2007 Major rewrite to load approved */
  // * submissions from the staging area */
  // *===========================================================================*/
  /**
   * Sets up class objects (properties, dataservice, province status list) and other variables to be
   * used in the process().
   *
   * @throws ProcessException
   */
  public void initialize() throws ProcessException {
    logger.debug("Calling initialize() started.");
    String sessionId = "ME: " + this.getClass().getName();
    prp = getProperties();
    ds = getDataService();
    eh = getEmailHelper();
    hmont = getMonitor();
    provStatList = getProvStatList();
    processMonth = getProcessMonth();
    rpList = getRcvProvList();

    startingStatus = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_IMPORT);
    loadStartStatus = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_IMPORT_LOAD_INIT);
    loadDoneStatus = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_IMPORT_LOAD_DONE);
    successTrans = prp.getProperty(PropertyFileKeys.PRP_PROV_TRANS_CAUSE_SUCCESS);
    importStep = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_STEP);
    defaultStep = prp.getProperty(PropertyFileKeys.PRP_RES_STEP_DEF);

    inputDirStr = prp.getProperty(PropertyFileKeys.PRP_INPUT_DIR);
    processDirStr = prp.getProperty(PropertyFileKeys.PRP_PROCESS_DIR);
    trashDirStr = prp.getProperty(PropertyFileKeys.PRP_TRASH_DIR);
    errorDirStr = prp.getProperty(PropertyFileKeys.PRP_ERROR_DIR);
    reportDirStr = prp.getProperty(PropertyFileKeys.PRP_RPT_DIR);

    ext = prp.getProperty(PropertyFileKeys.PRP_RPT_TXT_EXT);
    importRptName = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_NAME);
    importRptMsg1 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG1);
    // importRptMsg2 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG2);
    importRptMsg3 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG3);
    importRptMsg4 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG4);
    importRptMsg5 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG5);
    importRptMsg6 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG6);
    importRptMsg9 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG9);
    importRptMsg10 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG10);
    importRptMsg11 = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_MSG11);

    replaceStr = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RPT_REPLACE_STRING);

    mbxCmd = prp.getProperty(PropertyFileKeys.PRP_MAILBOX_CMD);
    ftpAllowed = prp.getProperty(PropertyFileKeys.PRP_RES_BI_FTP_FLAG);
    ftpHostName = prp.getProperty(PropertyFileKeys.PRP_FTP_SRVR);
    ftpUserName = prp.getProperty(PropertyFileKeys.PRP_FTP_USER);
    ftpUseKey = Boolean.parseBoolean(prp.getProperty(PropertyFileKeys.PRP_FTP_USE_KEY));
    ftpKnownHostsPath = prp.getProperty(PropertyFileKeys.PRP_FTP_KNOWN_HOSTS_PATH);

    if (ftpUseKey) {
      ftpPrivateKeyPath = prp.getProperty(PropertyFileKeys.PRP_FTP_PRIVATE_KEY_PATH);
    } else {
      ftpPswd = prp.getProperty(PropertyFileKeys.PRP_FTP_PWD);
    }
    ftpInDir = prp.getProperty(PropertyFileKeys.PRP_FTP_INDIR);
    ftpOutDir = prp.getProperty(PropertyFileKeys.PRP_FTP_OUTDIR);
    ftpFormat = prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_FTP_FORMAT);
    EMAIL_NORMAL_SUBJECT = prp.getProperty(PropertyFileKeys.PRP_EMAIL_NORMAL_SUBJECT);
    EMAIL_WARN_SUBJECT = prp.getProperty(PropertyFileKeys.PRP_EMAIL_WARN_SUBJECT).trim();
    EMAIL_ERROR_SUBJECT = prp.getProperty(PropertyFileKeys.PRP_EMAIL_ERROR_SUBJECT).trim();
    DESTINATION = prp.getProperty(PropertyFileKeys.PRP_EMAIL_DESTINATION).trim();
    emailOption = Boolean.valueOf(prp.getProperty(PropertyFileKeys.PRP_EMAIL_NOTIFICATION));

    // ******************
    // Get Commit Size
    // ******************
    commitSize = ApplicationConstants.DEFAULT_COMMITSIZE;
    try {
      logger.debug("Parsing Commit Size.");
      commitSize =
          Integer.parseInt(prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_COMMIT_CNT).trim());
    } catch (NumberFormatException e) {
      /* we have a default value */

    }

    // ******************
    // Get Retention
    // ******************
    retention = ApplicationConstants.DEFAULT_RETENTION;
    try {
      logger.debug("Parsing Retention Period.");
      retention =
          Integer.parseInt(prp.getProperty(PropertyFileKeys.PRP_RES_IMPORT_RETENTION).trim());
    } catch (NumberFormatException e) {
      /* we have a default value */

    }

    try {
      if ((startingStatus.trim().length() == 0)
          || (loadStartStatus.trim().length() == 0)
          || (loadDoneStatus.trim().length() == 0)
          || (successTrans.trim().length() == 0)
          || (importStep.trim().length() == 0)
          || (processMonth == null)
          || (inputDirStr == null)
          || (processDirStr == null)
          || (trashDirStr == null)
          || (errorDirStr == null)
          || (reportDirStr == null)
          || (replaceStr == null)
          || (ftpAllowed.trim().length() == 0)
          || (defaultStep.trim().length() == 0)
          || (ftpHostName.trim().length() == 0)
          || (ftpUserName.trim().length() == 0)
          || (ftpFormat.trim().length() == 0)
          || (ftpUseKey && ftpPrivateKeyPath.trim().isEmpty())
          || (!ftpUseKey && ftpPswd.trim().isEmpty())) {
        logger.error("Some properties for the import processor are null when they cannot be");
        logger.error("Import Starting Status:   " + startingStatus);
        logger.error("Load Starting Status:     " + loadStartStatus);
        logger.error("Load Ending Status:       " + loadDoneStatus);
        logger.error("Success Transition Code:  " + successTrans);
        logger.error("Import Step Code:         " + importStep);
        logger.error("Default Step Code:        " + defaultStep);
        logger.error("Process Month:            " + processMonth);
        logger.error("Input Directory:          " + inputDirStr);
        logger.error("Process Directory:        " + processDirStr);
        logger.error("Trash Directory:          " + trashDirStr);
        logger.error("Error Directory:          " + errorDirStr);
        logger.error("Report Directory:         " + reportDirStr);
        logger.error("FTP Allowed:              " + ftpAllowed);
        logger.error("Default Step Code:        " + defaultStep);
        logger.error("FTP Host Name:            " + ftpHostName);
        logger.error("FTP User Name:            " + ftpUserName);
        logger.error("FTP Use Private Key:                    " + ftpUseKey);
        logger.error("FTP Private Key File Path:              " + ftpPrivateKeyPath);
        logger.error("FTP Password:                           " + ftpPswd);
        logger.error("FTP Import Format:        " + ftpFormat);
        logger.error("Substitution String:      " + replaceStr);
        throw new ProcessException(new Exception("Config File Parameter error"));
      }
    } catch (NullPointerException npe) {
      logger.error("Missing properties in the config file " + npe);
      throw new ProcessException(npe);
    }
    statusKey = startingStatus.trim() + ":" + successTrans.trim();
    // *********************************************
    // Decode FTP Password
    // *********************************************
    if (ftpAllowed.equals("Y")) {
      try {

        // Attemp decoding only if using pasword
        if (!ftpUseKey) {
          ftpPswd = PasswordUtility.simpleDecoder(ftpPswd);
        }
      } catch (NullPointerException npe) {
        logger.error("FTP Server password can not be decoded " + npe);
        throw new ProcessException(npe);
      }
    }

    // ***********************
    // Setting up directories
    // ***********************
    FileHelper fh = new FileHelper();
    try {
      inpDir = fh.createDir(inputDirStr);
      if (!(inpDir.exists())) {
        throw new ProcessException(new Exception("Directory does not exist: " + inpDir));
      }
    } catch (IOException ie1) {
      throw new ProcessException(new Exception(ie1 + " " + inputDirStr));
    }

    try {
      processDir = fh.createDir(processDirStr);
      if (!(processDir.exists())) {
        throw new ProcessException(new Exception("Directory does not exist: " + inpDir));
      }
    } catch (IOException ie2) {
      throw new ProcessException(new Exception(ie2 + " " + processDirStr));
    }

    try {
      trashDir = fh.createDir(trashDirStr);
      if (!(trashDir.exists())) {
        throw new ProcessException(new Exception("Directory does not exist: " + inpDir));
      }
    } catch (IOException ie3) {
      throw new ProcessException(new Exception(ie3 + " " + trashDirStr));
    }

    try {
      errorDir = fh.createDir(errorDirStr);
      if (!(errorDir.exists())) {
        throw new ProcessException(new Exception("Directory does not exist: " + inpDir));
      }
    } catch (IOException ie4) {
      throw new ProcessException(new Exception(ie4 + " " + errorDirStr));
    }

    try {
      reportDir = fh.createDir(reportDirStr);
      if (!(reportDir.exists())) {
        throw new ProcessException(new Exception("Directory does not exist: " + inpDir));
      }
    } catch (IOException ie5) {
      throw new ProcessException(new Exception(ie5 + " " + reportDirStr));
    }

    fh = null;
    logger.debug("Calling initialize() ended.");
  }

  // *===========================================================================*/
  // * Name : process */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett February 25 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Process the approced submission files in the staging area. This process wil ftp over to the
   * appropriate server to retrieve any files sumbitted by the provinces, validate the format of the
   * files and load the data within them into the HOOPC database if the file is fine.
   *
   * @param curProv A province object for the current object being processed.
   * @param stepCode Code indicating whether or not this step of the month end should be executed It
   *     will usually be defaulted to 'ALL'
   * @throws SQLException, IOException, ProcessException
   */
  public void process(Province curProv, String stepCode)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling process() started.");
    logger.info("");
    logger.info(
        "Starting Import step for Province/Status: "
            + curProv.getProvince()
            + "/"
            + curProv.getCurStatus());
    logger.info("Processor Starting Status: " + startingStatus);
    logger.info("Processor Step Code:       " + stepCode);

    String sessionId = "ME: " + this.getClass().getName();
    curProv.setProvError(false);
    emailMessage = "";

    // ***********************************************
    // Ensure that the next and current status
    // fields are not null
    // ***********************************************
    if ((curProv.getCurStatus() == null) || (curProv.getCurStatus().trim().length() == 0)) {
      logger.error(
          "One or more of the status fields are null for province: " + curProv.getProvince());
      logger.error("Current Status: " + curProv.getCurStatus());
      logger.error("Next Status:    " + nextStatus);
      throw new ProcessException(new Exception("Province is in error: " + curProv.getProvince()));
    }

    // *************************************************************
    // Only process the province if it is at the correct status,
    // there was no overriding step command and it is valid to run
    // the province at its current status at the current time
    // *************************************************************
    try {
      if ((curProv.getCurStatus().equals(startingStatus))
          && ((stepCode.equals(defaultStep)) || (stepCode.equals(importStep)))) {
        if (!validateTime(curProv.getCurStatus(), statusKey, provStatList)) {
          logger.info(
              "The current Province is not allowed to run at this time at its current status");
          logger.info("Province/Status: " + curProv.getProvince() + "/" + curProv.getCurStatus());
          curProv.setProvError(true);
        } else {
          logger.info(
              "Loads the approved Submissions in the Staging Area into HOOPC for province: "
                  + curProv.getProvince());

          ds.lockProvince(
              curProv.getProvince(), curProv.getProvDetails().getResidencyType(), sessionId);
          pf = new ProvinceFilter(curProv.getProvince());
          FileHelper fh = new FileHelper();
          ArrayList approvedSubList = null;

          // *********************
          // Process Approved Submissions
          // *********************

          if (!(curProv.getProvError())) {
            approvedSubList = processApprovedSubmissions(curProv, fh, sessionId);

            approvedSubList = createMailingRpts(curProv, approvedSubList, fh);
            ftpMailingRpts(curProv, approvedSubList);
            // cleanupFiles (curProv, approvedSubList, fh);
            cleanupReports(curProv, approvedSubList, fh);
            purgeTrash();

            logger.info("Submission processing completed for Province: " + curProv.getProvince());
          }
          pf = null;
          fh = null;
        }

        // TODO CHHU }

        // TODO CHHU {
        logger.info(
            "Reports the rejected Submissions in the Staging Area: " + curProv.getProvince());

        FileHelper fh = new FileHelper();
        ArrayList rejectSubList = null;

        // *********************
        // Process Reject Submissions in the Staging Area
        // *********************

        if (!(curProv.getProvError())) {
          rejectSubList = processRejectSubmissions(curProv, fh, sessionId);

          rejectSubList = createMailingRpts(curProv, rejectSubList, fh);
          ftpMailingRpts(curProv, rejectSubList);
          // cleanupFiles (curProv, rejectSubList, fh);
          cleanupReports(curProv, rejectSubList, fh);
          purgeTrash();

          logger.info("Report Rejects processing completed for Province: " + curProv.getProvince());
        }
        pf = null;
        fh = null;
      }
    } finally {
      if (emailMessage.trim().length() != 0) {
        if (eh != null && emailOption) {
          eh.sendEmail(DESTINATION, EMAIL_ERROR_SUBJECT, emailMessage);
          logger.info("Email notification has been sent to: " + DESTINATION);
          logger.info("emailMessage: " + emailMessage.toString());
        } else {
          logger.info(
              "Email notification cannot be sent: " + DESTINATION + " as email helper not setup");
        }
      }
    }
    logger.debug("Calling process() ended.");
  }

  /**
   * @param curProv
   * @param fh
   * @param sessionId
   * @return
   */
  private ArrayList processRejectSubmissions(Province curProv, FileHelper fh, String sessionId)
      throws ProcessException, IOException, SQLException {
    logger.debug("Calling processImportFiles() started.");

    int retval = ApplicationConstants.SUCCESS;
    List list;
    File rptFile = null;
    PrintWriter pwt = null;
    SubmissionDetails subDtl = null;
    ArrayList imports = new ArrayList();
    ClaimDataService claimDS = new ClaimDataServiceBridge(ds.getCon(), ds.getBatchId(), sessionId);
    String importFile;

    try {
      list = claimDS.getRejectedSubmissions(curProv.getProvince());

      try {
        int i = 0;
        while ((i < list.size()) && (!(curProv.getProvError())) && (!hmont.isStopRequested())) {
          try {
            logger.info("Processing reject submisison for : " + curProv.getProvince());
            // ********************************
            // Retrieve the rejected submission
            // ********************************
            subDtl = new SubmissionDetails();
            subDtl.setImportError(true);

            SAHeaderRecord rejHeader = ((SAHeaderRecord) list.get(i));
            importFile = rejHeader.getImportFileName();

            { // ************
              // Setup report
              // ************
              String rptFname = rejHeader.getImportFileName() + "." + importRptName;
              rptFile = fh.createFile(rptFname, reportDir.getPath(), ext);
              pwt = fh.createWriter(rptFile.getPath());

              subDtl.setRejectReport(rptFile);

              imports.add(subDtl);

              // ************
              // Run Reject Reports
              // ************
              if (!(curProv.getProvError())) {
                runRejectSubsReport(curProv, fh, rejHeader, pwt, claimDS, sessionId);
              }

              // ************
              // CleanUp Rejected Submissions
              // ************

              if (!(curProv.getProvError())) {
                String cleanType = "R"; // cleanType Reject
                cleanupSubmissions(curProv, rejHeader, cleanType, claimDS, sessionId);

                {
                  if (eh != null && emailOption) {
                    String msg1 =
                        importRptMsg9.replaceFirst(replaceStr, rejHeader.getImportFileName());
                    msg1 =
                        msg1.replaceFirst(replaceStr, curProv.getProvDetails().getProvinceName());
                    eh.sendEmail(DESTINATION, EMAIL_NORMAL_SUBJECT, msg1);
                    logger.info("Reject Email notification has been sent to: " + DESTINATION);

                  } else {
                    logger.info(
                        "Email notification cannot be sent: "
                            + DESTINATION
                            + " as email helper not setup");
                  }
                }
              }
            }
            if (!curProv.getProvError()) {
              subDtl.setImportError(false);
            }
            imports.set(i, subDtl);

          } catch (Exception e) {
            throw new ProcessException(
                new Exception("Problem occurred during processing of import file " + e));
          } finally {
            if (pwt != null) {
              fh.closeWriter(pwt);
              pwt = null;
            }
            if (subDtl != null) {
              subDtl = null;
            }
            rptFile = null;
          }
          i++;
        }
      } finally {
        if (list != null) {
          list = null;
        }
        if (claimDS != null) {
          claimDS = null;
        }
      }

    } catch (ServiceFailedException e) {
      logger.error("Problem occurred during processImportFiles for : " + curProv.getProvince());
      throw new ProcessException(e);
    }

    logger.debug("Calling processImportFiles() ended.");
    return imports;
  }

  /**
   * @param curProv
   * @param fh
   * @param rejHeader
   * @param pwt
   * @param claimDS
   * @param sessionId
   */
  private void runRejectSubsReport(
      Province curProv,
      FileHelper fh,
      SAHeaderRecord rejHeader,
      PrintWriter importRptFile,
      ClaimDataService claimDS,
      String sessionId)
      throws ProcessException, IOException, SQLException {
    logger.debug("Calling runRejectSubsReport() started.");
    String msg = null;
    Init.setPrpUtil(prp);
    List reportErrors;

    logger.info("Run Reject Submission Report for: " + rejHeader.getImportFileName());

    if (rejHeader.getImportFileName() != null) {

      String msg1 = null;
      msg1 = importRptMsg9.replaceFirst(replaceStr, rejHeader.getImportFileName());
      msg1 = msg1.replaceFirst(replaceStr, curProv.getProvDetails().getProvinceName());
      fh.writeLine(msg1, importRptFile);
      fh.writeLine("", importRptFile);
      msg1 = importRptMsg10.replaceFirst(replaceStr, curProv.getProvDetails().getProvinceName());
      fh.writeLine(msg1, importRptFile);
      fh.writeLine("", importRptFile);
      logger.debug(msg1);

      try {
        reportErrors = claimDS.getRejectReport(rejHeader.getSubId());
      } catch (ServiceFailedException e) {
        logger.error("Problem occurred during runRejectSubsReport for : " + curProv.getProvince());
        throw new ProcessException(e);
      }

      try {

        // write the report
        Iterator repErr = reportErrors.iterator();
        while (repErr.hasNext()) {
          SARejectReport errorMess = (SARejectReport) repErr.next();

          fh.writeLine(errorMess.getPhn(), importRptFile);
          fh.writeLine(
              errorMess.getValidationCode() + " " + errorMess.getValidationMess(), importRptFile);
        }
      } finally {

        if (importRptFile != null) {
          fh.closeWriter(importRptFile);
          importRptFile = null;
        }
      }

      logger.debug("Calling runRejectSubsReport() ended.");
    }
  }

  /**
   * Process the approved submission files in the staging area.
   *
   * @param curProv A Receiving province object for the current object being processed.
   * @param fh FileHelper object to help write out any error message to the report file.
   * @param sessionId Object that called this method
   * @return ArrayList Contains import objects. Each object contains the name of an submission file,
   *     the report created for it, and a flag indicating whether or not the import failed.
   * @throws ProcessException, IOException, SQLException
   */
  private ArrayList processApprovedSubmissions(Province curProv, FileHelper fh, String sessionId)
      throws ProcessException, IOException, SQLException {
    logger.debug("Calling processImportFiles() started.");

    int retval = ApplicationConstants.SUCCESS;
    List list;
    File rptFile = null;
    PrintWriter pwt = null;
    SubmissionDetails subDtl = null;
    ArrayList submissions = new ArrayList();
    ClaimDataService claimDS = new ClaimDataServiceBridge(ds.getCon(), ds.getBatchId(), sessionId);

    try {
      int loop_limit = 100;
      list = new ArrayList<>();

      /*
       * Added a loop protection on the claim creation.
       * Starting from 100 to 0, so if anything happens with the claim creation and
       * it restart processing the same submission each iteration then
       * it will stop when it will reach 0 or if the size of list variable
       * equals 0 then it breaks the loop.
       */
      while (loop_limit > 0 && !curProv.getProvError() && !hmont.isStopRequested()) {
        loop_limit--;

        logger.info("Processing approved submisison for : " + curProv.getProvince());
        list = claimDS.getApprovedSubmissions(curProv.getProvince());

        if (list.size() == 0) break;

        // ********************************
        // Retrieve the approved submission
        // ********************************
        subDtl = new SubmissionDetails();
        subDtl.setImportError(true);
        int subId = ((Integer) list.get(0)).intValue();
        SAHeaderRecord headerRecord = claimDS.getApprovedHeader(subId); // retrieves subId.
        List detailRecords = claimDS.getDetailsList(subId);

        // ************
        // Setup report
        // ************
        String rptFname = headerRecord.getImportFileName() + "." + importRptName;
        rptFile = fh.createFile(rptFname, reportDir.getPath(), ext);
        pwt = fh.createWriter(rptFile.getPath());

        subDtl.setImportRpt(rptFile);

        submissions.add(subDtl);
        // ************
        // Process submission
        // ************

        if (!(curProv.getProvError())) {
          loadApprovedSubs(curProv, fh, headerRecord, detailRecords, pwt, claimDS, sessionId);
        }

        // ************
        // CleanUp Approved Submissions
        // ************

        if (!(curProv.getProvError())) {
          String cleanType = "A"; // cleanType Approve
          cleanupSubmissions(curProv, headerRecord, cleanType, claimDS, sessionId);

          if (eh != null && emailOption) {
            String msg11 =
                importRptMsg11.replaceFirst(replaceStr, headerRecord.getImportFileName());
            msg11 = msg11.replaceFirst(replaceStr, curProv.getProvDetails().getProvinceName()); //
            eh.sendEmail(DESTINATION, EMAIL_NORMAL_SUBJECT, msg11);
            logger.info("Approve Email notification has been sent to: " + DESTINATION);
          } else {
            logger.info(
                "Email notification cannot be sent: " + DESTINATION + " as email helper not setup");
          }
        }

        if (!curProv.getProvError()) {
          subDtl.setImportError(false);
        }

        if (pwt != null) {
          fh.closeWriter(pwt);
          pwt = null;
        }
      }

    } catch (Exception e) {
      logger.error(
          "Problem occurred during processImportFiles for : "
              + curProv.getProvince()
              + " / Error:"
              + e.getMessage());
      throw new ProcessException(e);

    } finally {
      if (pwt != null) {
        fh.closeWriter(pwt);
        pwt = null;
      }
      if (subDtl != null) {
        subDtl = null;
      }
      rptFile = null;

      list = null;
      if (claimDS != null) {
        claimDS = null;
      }
    }

    logger.debug("Calling processImportFiles() ended.");
    return submissions;
  }

  /**
   * @param curProv
   * @param fh
   * @param headerRecord
   * @param claimDS
   * @param sessionId
   */
  private void cleanupSubmissions(
      Province curProv,
      SAHeaderRecord headerRecord,
      String cleanType,
      ClaimDataService claimDS,
      String sessionId)
      throws ProcessException, SQLException {

    // clean up all the records in the staging area for the already loaded submission

    try {
      claimDS.cleanupStagingArea(headerRecord.getSubId(), cleanType);
    } catch (ServiceFailedException e) {
      logger.error(
          "Problem occurred while cleaning staging area for : " + headerRecord.getImportFileName());
      logger.error("Province:                                      " + curProv.getProvince());
      logger.error("cleanupSubmissions : " + headerRecord.getImportFileName());
      throw new ProcessException(e);
    }
  }

  /**
   * @param curProv
   * @param fh
   * @param headerRecord
   * @param detailRecords
   * @param pwt
   * @param startPos
   * @param claimDS
   * @param sessionId
   * @throws ServiceFailedException
   */
  private void loadApprovedSubs(
      Province curProv,
      FileHelper fh,
      SAHeaderRecord headerRecord,
      List detailRecords,
      PrintWriter importRptFile,
      ClaimDataService claimDS,
      String sessionId)
      throws ProcessException, IOException, SQLException, ServiceFailedException {
    {
      logger.debug("Calling loadImportFile() started.");
      int fromLine = 1;
      int curLine = 1;
      int startPos = 0;
      int unCommittedCnt = 0;
      String hdrCode = ApplicationConstants.IMPORT_FILE_HDR_CODE;
      String inpCode = ApplicationConstants.IMPORT_FILE_DTL_INPATIENT_CODE;
      String outCode = ApplicationConstants.IMPORT_FILE_DTL_OUTPATIENT_CODE;
      String msg = null;
      Init.setPrpUtil(prp);

      logger.info("Loading Submission: " + headerRecord.getImportFileName());

      // ************************************************************
      // * If header counts/totals do match detail counts/totals
      // * create records to mange loading of import. Only the claim
      // * data submission record will be committed so that if a failure
      // * occurs beore the data processing group record below can be
      // * updated in the load method then it will be discarded.
      // ************************************************************
      if (headerRecord.getTotalNumberDetails() != null) {
        Integer iCnt = new Integer(headerRecord.getTotalNumberDetails());
        Double dTotal = new Double(headerRecord.getTotalAmount());
        Integer iDtlLine = new Integer(1);

        {
          claimDS.insertClaimDataSubmissions(
              headerRecord.getImportFileName(),
              loadStartStatus,
              iCnt,
              dTotal,
              curProv.getProvince(),
              processMonth);
          ds.createSavePoint(ApplicationConstants.SAVEPOINT);
          claimDS.insertDataProcessingGroups(
              headerRecord.getImportFileName(), iDtlLine, null, loadStartStatus);
          ds.commit();
        }

        String msg1 = importRptMsg11.replaceFirst(replaceStr, headerRecord.getImportFileName());
        msg1 = msg1.replaceFirst(replaceStr, curProv.getProvDetails().getProvinceName());
        fh.writeLine(msg1, importRptFile);
        logger.info(msg1);
        iCnt = null;
        dTotal = null;
        iDtlLine = null;
      }

      try {

        logger.info(
            "!!!!!!!START Loading Submission: detailRecords.size() = " + detailRecords.size());

        Iterator detRecI = detailRecords.iterator();
        while (detRecI.hasNext() && (!hmont.isStopRequested())) {
          SADetailRecord detail = (SADetailRecord) detRecI.next();
          // ********************************
          // Do not process the header recod
          // ********************************
          {
            if ((detail
                .getPatientBatch()
                .trim()
                .equals(inpCode))) { // ************************************
              // create new resident inpatient claim
              // ************************************
              if (curLine >= startPos) {
                unCommittedCnt++;

                Ric claim =
                    createInpClaim(
                        curProv.getProvince(),
                        detail,
                        claimDS,
                        curLine,
                        headerRecord.getImportFileName());
                try {
                  if (detail.getAdjFlag().trim().equals("Y")) {
                    claim = claimDS.createAdj(claim);
                  } else {
                    claim = (Ric) claim.create();
                  }
                } catch (ServiceFailedException e) {
                  logger.error(
                      "Problem occurred inserting claim/adjustment from batch import file: "
                          + headerRecord.getImportFileName());
                  logger.error(
                      "Province:                                      " + curProv.getProvince());
                  logger.error("Detail Line Cnt(header not included in count): " + curLine);
                  throw new ProcessException(e);
                } catch (InvalidKeyException ike) {
                  logger.error(
                      "Invalid Key Exception, Symphonia Properties file may be missing ", ike);
                  throw new ProcessException(ike);
                } catch (Exception e) {
                  logger.error("Unhandled Exception while loading import file", e);
                  throw new ProcessException(e);
                }

                claim = null;
              }
            } else { // *************************************
              // create new resident outpatient claim
              // *************************************
              if (curLine >= startPos) {
                unCommittedCnt++;

                Roc claim =
                    createOutClaim(
                        curProv.getProvince(),
                        detail,
                        claimDS,
                        curLine,
                        headerRecord.getImportFileName());
                try {
                  if (detail.getAdjFlag().trim().equals("Y")) {
                    claim = claimDS.createAdj(claim);
                  } else {
                    claim = (Roc) claim.create();
                  }
                } catch (ServiceFailedException e) {
                  logger.error(
                      "Problem occurred inserting claim/adjustment from batch import file: "
                          + headerRecord.getImportFileName());
                  logger.error(
                      "Province:                                      " + curProv.getProvince());
                  logger.error("Detail Line Cnt(header not included in count): " + curLine);
                  throw new ProcessException(e);
                } catch (InvalidKeyException ike) {
                  logger.error(
                      "Invalid Key Exception, Symphonia Properties file may be missing ", ike);
                  throw new ProcessException(ike);
                } catch (Exception e) {
                  logger.error("Unhandled Exception while loading import file", e);
                  throw new ProcessException(e);
                }
                claim = null;
              }
            }
          } // created the claim records for inp and outp
          // ********************************************************************************/
          // Check if can Commit. If so update "to row number" of the last DPG child record*/
          // created with the count of the last record inserted. Commit the update and all */
          // the hospital claims inserted. Then create a new child (DPG) with the "from row*/
          // number" set to the last record inserted + 1. The "to row number" will be left */
          // null until next commit. */
          // *******************************************************************************/
          if ((unCommittedCnt % commitSize == 0) && (unCommittedCnt != 0)) {
            try {
              Integer oldFrom = new Integer(fromLine);
              Integer oldTo = new Integer(curLine);
              Integer newFrom = new Integer(curLine + 1);
              fromLine = curLine + 1;
              logger.info("Commiting after " + curLine + " families processed");
              claimDS.updateDataProcessingGroups(
                  headerRecord.getImportFileName(), oldFrom, oldTo, loadDoneStatus);
              ds.commit();
              ds.createSavePoint(ApplicationConstants.SAVEPOINT);
              ds.lockProvince(
                  curProv.getProvince(), curProv.getProvDetails().getResidencyType(), sessionId);
              claimDS.insertDataProcessingGroups(
                  headerRecord.getImportFileName(), newFrom, null, loadStartStatus);
              unCommittedCnt = 0;
              oldFrom = null;
              oldTo = null;
              newFrom = null;
            } catch (SQLException e) {
              logger.error(
                  "Failure occurred while commiting batch import records from file: "
                      + headerRecord.getImportFileName());
              throw e;
            } catch (ServiceFailedException sfe) {
              logger.error(
                  "Failure occurred while commiting batch import records from file: "
                      + headerRecord.getImportFileName());
              throw new ProcessException(sfe);
            }
          }

          curLine++;
        } // End of While Loop

        // ************************************************************************************/
        // Check for any remaining records that need to be committed and write a message to */
        // the report. As well, it wraps up the child (DPG) and parent (CDS) records.If there*/
        // are remaining records to commit then update "to row number" of the last DPG child */
        // record created with the count of the last record inserted. Also set the status of */
        // CDS parent record to indicate imoprt completed successfully. Perform a commit to */
        // save them and all uncommitted hospital claims. If there are no remaining records */
        // to commit then delete the last DPG child record created (roll it back) and simply */
        // update status of the CDS parent record to indicate import completed successfully. */
        // ************************************************************************************/
        try {
          if ((unCommittedCnt != 0)) {
            Integer oldFrom = new Integer(fromLine);
            Integer oldTo = new Integer(curLine - 1);
            logger.info("Commiting after " + curLine + " families processed");
            claimDS.updateDataProcessingGroups(
                headerRecord.getImportFileName(), oldFrom, oldTo, loadDoneStatus);
            claimDS.updateClaimDataSubmissions(headerRecord.getImportFileName(), loadDoneStatus);
            ds.commit();
            ds.createSavePoint(ApplicationConstants.SAVEPOINT);
            ds.lockProvince(
                curProv.getProvince(), curProv.getProvDetails().getResidencyType(), sessionId);
            oldFrom = null;
            oldTo = null;
          } else {
            if (curLine > 1) {
              ds.rollback(ApplicationConstants.SAVEPOINT);
              ds.updateClaimDataSubmissions(
                  headerRecord.getImportFileName(), loadDoneStatus, sessionId);
              ds.commit();
              ds.createSavePoint(ApplicationConstants.SAVEPOINT);
            }
          }
        } catch (SQLException e) {
          logger.error(
              "Failure occurred while commiting batch import records from file: "
                  + headerRecord.getImportFileName());
          throw e;
        } catch (ServiceFailedException sfe) {
          logger.error(
              "Failure occurred while commiting batch import records from file: "
                  + headerRecord.getImportFileName());
          throw new ProcessException(sfe);
        }

        // msg = importRptMsg5.replaceFirst(replaceStr,curProv.getProvDetails().getProvinceName());
        // fh.writeLine(msg,importRptFile);
        // logger.info(msg);
        curProv.setProvError(false);

      } finally {
        logger.debug("Calling loadImportFile() ended.");
      }
      // logger.debug("Calling loadImportFile() ended.");
    }
  }

  /**
   * @param province
   * @param detail
   * @param claimDS
   * @param importFileName
   * @return
   */
  private Roc createOutClaim(
      String province,
      SADetailRecord detail,
      ClaimDataService claimDS,
      int recNum,
      String importFileName)
      throws ProcessException, IOException {
    logger.debug("Calling createOutClaim() started.");
    String tmpDate = null;
    String year = null;
    String month = null;
    String day = null;
    Roc claim = null;

    try {
      claim = new Roc(claimDS);

      // ***********************
      // * Insurance Expiry Date
      // ***********************
      tmpDate = detail.getInsuranceCardExpiryDate().trim();

      if ((tmpDate.trim().length() != 0) && (tmpDate.trim().length() == 8)) {
        claim.setInsuranceCardExpiryDate(
            convertToDate(
                tmpDate, ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT1, DtlCmn.ColName_06));
      } else if ((tmpDate.trim().length() != 0) && (tmpDate.trim().length() == 6)) {
        claim.setInsuranceCardExpiryDate(
            convertToDate(
                tmpDate, ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT2, DtlCmn.ColName_06));
      } else if ((tmpDate.trim().length() == 0)) {
        claim.setInsuranceCardExpiryDate(convertToDate(tmpDate, null, DtlCmn.ColName_06));
      }

      // ************
      // * Birth Date
      // ************
      tmpDate = detail.getBirthDate().trim();
      claim.setBirthDate(
          convertToDate(tmpDate, ApplicationConstants.BIRTH_DATE_FORMAT, DtlOutp.ColName_10));

      // **************
      // * Service Date
      // **************
      tmpDate = detail.getServiceDate().trim();
      claim.setServiceDate(
          convertToDate(tmpDate, ApplicationConstants.SERVICE_DATE_FORMAT, DtlOutp.ColName_19));

      // ****************
      // * Billing Period
      // ****************
      claim.setBillingPeriod(
          convertToDate(processMonth, ApplicationConstants.BILL_PERIOD_FORMAT, "Billing Period"));

      claim.setHospitalNumber(detail.getHospitalNumber().trim());
      // Took out for bug fix #335
      // claim.setHospitalName
      // (convertToString((inputLine.substring(DtlCmn.ColStrt_04,DtlCmn.ColEnd_04+1)).trim()));

      claim.setInsuranceNumber(detail.getInsuranceCardNumber().trim());
      claim.setLastName(detail.getLastName().trim());
      claim.setFirstName(detail.getFirstName().trim());
      claim.setProvince(detail.getProvince().trim());
      claim.setGender(detail.getSexCode().trim());
      claim.setDiagnosis1(
          detail
              .getDiagnosCode2()
              .trim()); // convertToString((inputLine.substring(DtlOutp.ColStrt_12,DtlOutp.ColEnd_12+1)).trim()));
      claim.setDiagnosis2(detail.getDiagnosCode1().trim());
      claim.setServiceCode(detail.getServiceCode().trim());
      claim.setProcedure1(
          detail
              .getProcedureCode2()
              .trim()); // inputLine.substring(DtlOutp.ColStrt_14,DtlOutp.ColEnd_14+1)).trim()));
      claim.setProcedure2(detail.getProcedureCode1().trim());
      claim.setProvincialClaimNumber(detail.getProvincialClaimId().trim());
      claim.setTotalAmountClaimed(convertToDouble(detail.getTotalAmountClaimed().trim()));

      // ************************************************************
      // Hospital notes are at the end of the record and there is no
      // guarantee they will be padded out to the end of the line
      // ************************************************************

      claim.setNotes(detail.getNotes().trim());

      claim.setAddress1("");
      claim.setAddress2("");
      claim.setCity("");
      claim.setPostalCode("");
      // claim.setDiagnosis2 ("");
      // claim.setDiagnosis1 (""); // ICD10 Diagnosis
      claim.setDiagnosis3("");
      // claim.setProcedure2 ("");
      // claim.setProcedure1 (""); // ICD10 Procedure
      claim.setProcedure3("");
      claim.setHighCost1Code("");
      claim.setHighCost2Code("");
      claim.setHighCost3Code("");
      claim.setTotalDaysStay(convertToInteger(""));
      claim.setPerDiemRate(convertToDouble(""));
      claim.setDeceasedFlag("");
      claim.setLongTermFlag("");
      claim.setAccidentIndicator("");
      claim.setAccidentCode("");
      claim.setChangeReason("");

      claim.setImportFileName(convertToString(importFileName).trim());
      claim.setImportRowNum(recNum);
      claim.setClaimSource(convertToString(DtlCmn.dataSource).trim());
      claim.setTreatingProvince(detail.getTreatingProvince().trim());
      claim.setUserId(ds.getBatchId().trim());

      try {
        claim.setCodingScheme(claimDS.getClaimScheme(claim));
      } catch (Exception gcsE) {
        claim.setCodingScheme("ICD10");
      }

    } catch (StringIndexOutOfBoundsException sioobe) {
      logger.error(
          "Record is too short. It must be in a fixed format and hence must be padded out.."
              + sioobe);
      throw new ProcessException(new Exception(sioobe));
    } catch (Exception e) {
      logger.error("Problem occurred creating outpatient claim record." + e);
      throw new ProcessException(new Exception(e));
    }
    logger.debug("Calling createOutClaim() ended.");

    return claim;
  }

  /**
   * @param province
   * @param detail
   * @param claimDS
   * @param curLine
   * @param importFileName
   * @return
   */
  private Ric createInpClaim(
      String province,
      SADetailRecord detail,
      ClaimDataService claimDS,
      int recNum,
      String importFileName)
      throws ProcessException, IOException {
    logger.debug("Calling createInpClaim() started.");
    String tmpDate = null;
    String year = null;
    String month = null;
    String day = null;
    Ric claim = null;
    try {
      // ***********************
      // * Insurance Expiry Date
      // ***********************
      claim = new Ric(claimDS);
      // tmpDate = (inputLine.substring(DtlCmn.ColStrt_06,DtlCmn.ColEnd_06+1)).trim();
      tmpDate = detail.getInsuranceCardExpiryDate().trim();

      if ((tmpDate.trim().length() != 0) && (tmpDate.trim().length() == 8)) {
        claim.setInsuranceCardExpiryDate(
            convertToDate(
                tmpDate, ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT1, DtlCmn.ColName_06));
      } else if ((tmpDate.trim().length() != 0) && (tmpDate.trim().length() == 6)) {
        claim.setInsuranceCardExpiryDate(
            convertToDate(
                tmpDate, ApplicationConstants.INSURANCE_EXPIRY_DATE_FORMAT2, DtlCmn.ColName_06));
      } else if ((tmpDate.trim().length() == 0)) {
        claim.setInsuranceCardExpiryDate(convertToDate(tmpDate, null, DtlCmn.ColName_06));
      }

      // ************
      // * Birth Date
      // ************
      tmpDate = detail.getBirthDate().trim();
      claim.setBirthDate(
          convertToDate(tmpDate, ApplicationConstants.BIRTH_DATE_FORMAT, DtlInp.ColName_14));

      // ****************************
      // * High Cost Procedure Date 1
      // ****************************
      tmpDate = detail.getHighCostProcedureDate1().trim();
      claim.setHighCost1Date(
          convertToDate(
              tmpDate, ApplicationConstants.HIGH_COST_PROC_DATE_FORMAT1, DtlInp.ColName_23));

      // ****************************
      // * High Cost Procedure Date 2
      // ****************************
      tmpDate = detail.getHighCostProcedureDate2().trim();
      claim.setHighCost2Date(
          convertToDate(
              tmpDate, ApplicationConstants.HIGH_COST_PROC_DATE_FORMAT2, DtlInp.ColName_25));

      // ****************************
      // * High Cost Procedure Date 3
      // ****************************
      tmpDate = tmpDate = detail.getHighCostProcedureDate3().trim();
      claim.setHighCost3Date(
          convertToDate(
              tmpDate, ApplicationConstants.HIGH_COST_PROC_DATE_FORMAT3, DtlInp.ColName_27));

      // ****************
      // * Admission Date
      // ****************
      tmpDate = detail.getAdmissionDate().trim();
      claim.setAdmissionDate(
          convertToDate(tmpDate, ApplicationConstants.ADMISSION_DATE_FORMAT, DtlInp.ColName_28));

      // ****************
      // * Discharge Date
      // ****************
      tmpDate = detail.getDischargeDate().trim();
      claim.setDischargeDate(
          convertToDate(tmpDate, ApplicationConstants.DISCHARGE_DATE_FORMAT, DtlInp.ColName_29));

      // ****************
      // * Billing Period
      // ****************
      claim.setBillingPeriod(
          convertToDate(processMonth, ApplicationConstants.BILL_PERIOD_FORMAT, "Billing Period"));

      claim.setHospitalNumber(detail.getHospitalNumber().trim());
      // For fix #335 - don't worry about the name of the hospital, just the number
      // claim.setHospitalName
      // (convertToString((inputLine.substring(DtlCmn.ColStrt_04,DtlCmn.ColEnd_04+1)).trim()));
      claim.setInsuranceNumber(detail.getInsuranceCardNumber().trim());
      claim.setLastName(detail.getLastName().trim());
      claim.setFirstName(detail.getFirstName().trim());
      claim.setAddress1(detail.getAddress1().trim());
      claim.setAddress2(detail.getAddress2().trim());
      claim.setCity(detail.getCity().trim());
      claim.setProvince(detail.getProvince().trim());
      claim.setPostalCode(detail.getPostalCode().trim());
      claim.setGender(detail.getSexCode().trim());
      claim.setDiagnosis1(detail.getDiagnosCode1().trim());
      claim.setDiagnosis2(detail.getDiagnosCode2().trim());
      claim.setDiagnosis3(detail.getDiagnosCode3().trim());
      claim.setProcedure1(detail.getProcedureCode1().trim());
      claim.setProcedure2(detail.getProcedureCode2().trim());
      claim.setProcedure3(detail.getProcedureCode3().trim());
      claim.setHighCost1Code(detail.getHighCostProcedureCode1().trim());
      claim.setHighCost2Code(detail.getHighCostProcedureCode2().trim());
      claim.setHighCost3Code(detail.getHighCostProcedureCode3().trim());
      claim.setTotalDaysStay(convertToInteger(detail.getTotalDaysStay().trim()));
      claim.setPerDiemRate(convertToDouble(detail.getPerDiemRate().trim()));
      claim.setTotalAmountClaimed(convertToDouble(detail.getTotalAmountClaimed().trim()));
      claim.setDeceasedFlag(detail.getDeceasedFlag().trim());
      claim.setLongTermFlag(detail.getLongTermStayInd().trim());
      claim.setAccidentIndicator(detail.getAccidentInd().trim());
      claim.setAccidentCode(detail.getAccidentCode().trim());
      claim.setProvincialClaimNumber(detail.getProvincialClaimId().trim());
      claim.setNotes(detail.getNotes().trim());

      claim.setImportFileName(convertToString((importFileName).trim()));
      claim.setImportRowNum(recNum);
      claim.setClaimSource(convertToString((DtlCmn.dataSource).trim()));
      claim.setChangeReason("");
      claim.setTreatingProvince(detail.getTreatingProvince().trim());
      claim.setUserId(ds.getBatchId());

      try {
        claim.setCodingScheme(claimDS.getClaimScheme(claim));
      } catch (Exception gcsE) {
        claim.setCodingScheme("ICD10");
      }

      logger.debug("Calling createInpClaim() ended.");
    } catch (StringIndexOutOfBoundsException sioobe) {
      logger.error(
          "Record is too short. It must be in a fixed format and hence must be padded out.."
              + sioobe);
      throw new ProcessException(new Exception(sioobe));
    } catch (Exception e) {
      logger.error("Problem occurred creating inpatient claim record." + e);
      throw new ProcessException(new Exception(e));
    }
    logger.debug("Calling createInpClaim() ended.");
    return claim;
  }

  // *===========================================================================*/
  // * Name : createMailingRpts */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 09 ,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Given the reports generated by the import, this process generates mailing reports. The reports
   * must be sent out to the treating province (the province that sent the import file in the first
   * place) and the receiving province(s). The reports will be duplicated for each province they are
   * to be sent to. The mailbox id of each province will be prefixed to the name of the reports the
   * province is to reveive. This method will then return a list of all the mailing reports it
   * generated.
   *
   * @param curProv The treating province (the one that submitted the import file).
   * @param imports Contains import objects. Each object contains the name of an import file, the
   *     report created for it, and a flag indicating whether or not the import failed.
   * @param fh FileHelper object to help make copies of the reports.
   * @return ArrayList Same arraylist of import objects that was passed in only the outgoing list
   *     contains a list of mailing reports for each import file. the report created for it, and a
   *     flag indicating whether or not the import failed.
   * @throws IOException
   */
  private ArrayList createMailingRpts(Province curProv, ArrayList imports, FileHelper fh)
      throws ProcessException {
    logger.debug("Calling createMailingRpts() started.");

    ArrayList mailingRptList = null;

    if ((imports != null) && (imports.size() != 0)) {
      int i = 0;
      try {
        while (i < imports.size()) {
          mailingRptList = new ArrayList();
          SubmissionDetails sd = (SubmissionDetails) imports.get(i);

          File rptFile = sd.getImportRpt();
          java.io.File f1 = null;
          String fname1;

          if (rptFile != null) {
            fname1 =
                mbxCmd
                    + curProv.getProvDetails().getSubmitIdentifier().trim()
                    + "."
                    + rptFile.getName();
            f1 = fh.createFile(fname1, rptFile.getParent());
            rptFile.renameTo(f1);
            mailingRptList.add(f1);
          }

          int j = 0;

          while (j < rpList.size()) {
            if (f1 != null) {
              String fname2 =
                  mbxCmd
                      + ((ProvinceDetails) rpList.get(j)).getSubmitIdentifier()
                      + "."
                      + rptFile.getName();
              java.io.File f2 = fh.createFile(fname2, rptFile.getParent());
              fh.copyFile(f1, f2);
              mailingRptList.add(f2);
              f2 = null;
              fname2 = null;
            }

            File rptFileR = sd.getRejectReport();
            java.io.File f1R = null;
            String fname1R;

            if (rptFileR != null) {
              fname1R =
                  mbxCmd
                      + ((ProvinceDetails) rpList.get(j)).getSubmitIdentifier()
                      + ".ER"
                      + rptFileR.getName();
              f1R = fh.createFile(fname1R, rptFileR.getParent());
              rptFileR.renameTo(f1R);
              mailingRptList.add(f1R);
            }

            j++;
          }
          sd.setMailingRpts(mailingRptList);
          imports.set(i, sd);
          mailingRptList = null;
          sd = null;
          f1 = null;
          fname1 = null;
          i++;
        }
      } catch (Exception e) {
        throw new ProcessException(
            new Exception("Problem occurred during creation of mailing reports " + e));
      }
    }
    logger.debug("Calling createMailingRpts() ended.");
    return imports;
  }
  // *===========================================================================*/
  // * Name : ftpMailingRpts */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 09, 2005 Initial Spec */
  // * DC Bartlett April 27,2005 Disallow ftp if flag is set. This way */
  // * can test process by simpy dropping file */
  // * to be processed into the applications */
  // * input directory instead of into a */
  // * mailbox on some server the process needs*/
  // * to ftp to and the reports will also not */
  // * needt to be ftped and instead can be */
  // * viewed in the apps trash or error dir. */
  // *===========================================================================*/

  /**
   * FTP's a given list of files to the appropriate mailboxes
   *
   * @param curProv A province object for the current object being processed.
   * @param imports Contains import objects. Each object contains the name of an import file, a list
   *     of reports created for it, and a flag indicating whether or not the import failed.
   * @throws IOException, ProcessException
   */
  private void ftpMailingRpts(Province curProv, ArrayList imports)
      throws IOException, ProcessException {
    logger.debug("Calling ftpMailingRpts() started.");

    if (!ftpAllowed.equals("Y")) {
      logger.info("FTP disabled in property file.");
    } else {
      int i = 0;
      while (i < imports.size()) {
        // ImportFileDetails idf = (ImportFileDetails)imports.get(i);
        SubmissionDetails idf = (SubmissionDetails) imports.get(i);
        ArrayList rpts = idf.getMailingRpts();
        if ((rpts == null) || (rpts.size() == 0)) {
          logger.info(
              "No FTPable reports found for province/import file: " + curProv.getProvince());
        } else {
          // *********************
          // Connect to FTP Server
          // *********************
          int j = 0;

          Sftp sftp =
              ftpUseKey
                  ? SFTPHelper.connectUsingKeys(
                      ftpHostName, ftpUserName, ftpPrivateKeyPath, ftpKnownHostsPath)
                  : SFTPHelper.connectUsingPassword(
                      ftpHostName, ftpUserName, ftpPswd, ftpKnownHostsPath);
          try {
            if (sftp == null || !sftp.isConnected()) {
              throw new ProcessException(new Exception("Could not connect to FTP Server"));
            }

            // *************************************************
            // If remote directory provided then change to it
            // otherwise stay in directory automatically placed
            // in when ftp connection is made
            // *************************************************
            if ((ftpOutDir.length() != 0) && (ftpOutDir != null)) {
              int retval = SFTPHelper.setRemoteDir(ftpOutDir, sftp);
              if (retval != Sftp.SUCCESS) {
                throw new ProcessException(
                    new Exception("Problems occurred changing to remote dir: " + ftpOutDir));
              }
            }
            // ************************
            // FTP all mailing reports
            // ************************
            while (j < rpts.size()) {
              File rptFile = (File) rpts.get(j);
              int retval =
                  SFTPHelper.sendSFTPFile(
                      rptFile.getParent(), rptFile.getName(), rptFile.getName(), sftp);
              if (retval != Sftp.SUCCESS) {
                throw new ProcessException(
                    new Exception("Problems occurred Ftping file: " + rptFile.getName()));
              }
              j++;
            }
          } finally {
            if (sftp != null) {
              sftp.disconnect();
            }
          }
        }
        idf = null;
        rpts = null;
        i++;
      }
    }
    logger.debug("Calling ftpMailingRpts() ended.");
  }

  // *===========================================================================*/
  // * Name : cleanupReports */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett Match 09, 2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Moves a given list of reports from the output directory to either the error or trash directory
   * depending on whether or not the import file they are tied to was successfully loaded.
   *
   * @param curProv A province object for the current object being processed.
   * @param imports Contains import objects. Each object contains the name of an import file, a list
   *     of reports created for it, and a flag indicating whether or not the import failed.
   * @param fh FileHelper object to help move files
   * @throws ProcessException
   */
  public void cleanupReports(Province curProv, ArrayList imports, FileHelper fh)
      throws ProcessException {
    logger.debug("Calling cleanupReports() started.");

    File processFile = null;
    File errorFile = null;
    File trashFile = null;
    File rejectReport = null;
    SubmissionDetails idf = null;
    ArrayList rpts = null;

    int idx2 = 0;
    while ((idx2 < imports.size())) {
      try {
        idf = (SubmissionDetails) imports.get(idx2);
        rpts = idf.getMailingRpts();
        int j = 0;
        while (j < rpts.size()) { // ************
          // Move reports
          // ************
          rejectReport = (File) rpts.get(j);
          if (idf.getImportError()) { // ************************************************
            // If there were errors during the import then move
            // reports to the error directory
            // ************************************************
            errorFile = new File(errorDir, rejectReport.getName());
            if (errorFile.exists()) {
              errorFile = fh.updateFileName(rejectReport.getName(), errorDir.getPath());
            }
            rejectReport.renameTo(errorFile);

            if ((rejectReport.exists()) || (!(errorFile.exists()))) {
              emailMessage =
                  emailMessage
                      + "Problem occurred moving file "
                      + rejectReport.getName()
                      + " from output dir to error dir for province "
                      + curProv.getProvince()
                      + "\r\n";
              logger.error(
                  "Problem occurred moving file "
                      + rejectReport.getName()
                      + " from output dir to error dir for province "
                      + curProv.getProvince());
              logger.error(
                  "File either still exists in output dir or does not exist in error dir.");
              logger.error(
                  "A move may fail if a file of the same name already exists in the error dir.");
              curProv.setProvError(true);
            }
          } else { // ************************************************
            // If there were no errors during the import then move
            // reports to the trash directory
            // ************************************************
            trashFile = new File(trashDir, rejectReport.getName());
            if (trashFile.exists()) {
              trashFile = fh.updateFileName(rejectReport.getName(), trashDir.getPath());
            }
            rejectReport.renameTo(trashFile);

            if ((rejectReport.exists()) || (!(trashFile.exists()))) {
              emailMessage =
                  emailMessage
                      + "\r\n"
                      + "Problem occurred moving file "
                      + rejectReport.getName()
                      + " from output dir to trash dir for province "
                      + curProv.getProvince()
                      + "\r\n";
              logger.error(
                  "Problem occurred moving file "
                      + rejectReport.getName()
                      + " from output dir to trash dir for province "
                      + curProv.getProvince());
              logger.error(
                  "File either still exists in output dir or does not exist in trash dir.");
              logger.error(
                  "A move may fail if a file of the same name already exists in the trash dir.");
              curProv.setProvError(true);
            }
          }
          j++;
          rejectReport = null;
          trashFile = null;
          errorFile = null;
        }
      } catch (Exception e) {
        throw new ProcessException(
            new Exception(
                "Problem occurred moving reports from output dir to error or trash dir" + e));
      } finally {
        idf = null;
        rpts = null;
      }
      idx2++;
    }

    logger.debug("Calling cleanupReports() ended.");
  }
  // *===========================================================================*/
  // * Name : purgeTrash */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 10,2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Looks for files in the trash directory that are older than some retention period and deletes
   * them if they are
   *
   * @throws ProcessException
   */
  private void purgeTrash() throws ProcessException {
    logger.debug("Calling purgeTrash() started.");

    if (retention != ApplicationConstants.DEFAULT_RETENTION) {
      File[] list = trashDir.listFiles();
      File trashFile = null;
      Date trashDate = null;
      Date curDate = null;

      try {
        int i = 0;
        while ((i < list.length)) {
          try { // ********************************
            // Move import file to process dir
            // ********************************
            trashFile = new File(trashDir, ((File) list[i]).getName());
            trashDate = new Date(trashFile.lastModified());

            Calendar cal = new GregorianCalendar();
            cal.add(Calendar.DAY_OF_YEAR, retention * -1);

            curDate = cal.getTime();
            if (curDate.after(trashDate)) {
              trashFile.delete();
            }
          } finally {
            trashFile = null;
            trashDate = null;
            curDate = null;
          }
          i++;
        }
      } catch (Exception e) {
        logger.error("Problems occurred while trying to purge files from trash directory." + e);
        emailMessage =
            emailMessage
                + "Problems occurred while trying to purge files from trash directory."
                + e
                + "\r\n";
        throw new ProcessException(new Exception(e));
      } finally {
        list = null;
      }
    }
    logger.debug("Calling purgeTrash() ended.");
  }

  // *===========================================================================*/
  // * Name : convertToDate */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 07,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Takes a date string in the YYYYMMDD format and changes it to a date
   *
   * @param dateStr Date value as a string type. If the string is empty a null is returned
   * @return java.util.Date Passed in string convereted to a date.
   * @throws ProcessException
   */
  private static java.util.Date convertToDate(String dateStr, String dateFormat, String dateName)
      throws ProcessException {
    logger.debug("Calling convertToDate() started.");
    if (dateStr == null || dateStr.equals("")) {
      return null;
    }

    String year, month, day;

    if (dateFormat.equals(ApplicationConstants.DEFAULT_DATE_FORMAT1)) {
      if (dateStr.matches("^[0-9]{4}[-/]?[0-9]{2}[-/]?[0-9]{2}$")) {
        dateStr = dateStr.replaceAll("[-/]", "");
        year = dateStr.substring(0, 4);
        month = dateStr.substring(4, 6);
        day = dateStr.substring(6, 8);
      } else {
        throw new ProcessException(
            new Exception(("Invalid date \"" + dateStr + "\"" + "for field" + dateName)));
      }
    } else if (dateFormat.equals(ApplicationConstants.DEFAULT_DATE_FORMAT2)) {
      if (dateStr.matches("^[0-9]{4}[-/]?[0-9]{2}$")) {
        dateStr = dateStr.replaceAll("[-/]", "");
        year = dateStr.substring(0, 4);
        month = dateStr.substring(4, 6);
        day = "1";
      } else {
        throw new ProcessException(
            new Exception("Invalid date \"" + dateStr + "\"" + "for field" + dateName));
      }
    } else {
      throw new ProcessException(
          new Exception("Invalid date \"" + dateStr + "\"" + "for field" + dateName));
    }

    logger.debug("Calling convertToDate() ended.");
    return Helper.getDate(year, month, day);
  }

  // *===========================================================================*/
  // * Name : convertToInteger */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 07,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Takes a date string and changes it to an Integer object
   *
   * @param s Integer value as a string type. If the string is empty a null is returned
   * @return Integer Passed in string convereted to an Integer.
   */
  private static Integer convertToInteger(String s) {

    logger.debug("Calling convertToInteger() started.");

    if (s == null || s.equals("")) {
      return null;
    }

    logger.debug("Calling convertToInteger() ended.");

    return new Integer(s);
  }

  // *===========================================================================*/
  // * Name : convertToDouble */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 07,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Takes a date string and changes it to a Double object
   *
   * @param s Double value as a string type. If the string is empty a null is returned
   * @return Double Passed in string convereted to a Double type.
   * @throws ProcessException
   */
  private static Double convertToDouble(String s) {

    logger.debug("Calling convertToDouble() started.");

    if (s == null || s.equals("")) {
      return null;
    }

    logger.debug("Calling convertToDouble() ended.");

    return new Double(s);
  }

  // *===========================================================================*/
  // * Name : convertToString */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 07,2005 Initial Spec */
  // *===========================================================================*/
  /**
   * Ensures any null string is changed to ""
   *
   * @param s String value. If the string is null then "" is returend.
   * @return String Passed in string passed back unless is null in which case "" is passed back
   * @throws ProcessException
   */
  private static String convertToString(String s) {

    logger.debug("Calling convertToString() started.");

    if (s == null) {
      return "";
    }

    logger.debug("Calling convertToString() ended.");

    return s;
  }
  // *===========================================================================*/
  // * Name : round */
  // * History: */
  // * Developer Date Description */
  // * --------- ------------ ----------------------------------------*/
  // * DC Bartlett March 14,2005 Initial Spec */
  // *===========================================================================*/

  /**
   * Round a double value to a specified number of decimal places.
   *
   * @param val the value to be rounded.
   * @param places the number of decimal places to round to.
   * @return val rounded to places decimal places.
   */
  public static double round(double val, int places) {
    long factor = (long) Math.pow(10, places);

    // Shift the decimal the correct number of places
    // to the right.
    val = val * factor;

    // Round to the nearest integer.
    long tmp = Math.round(val);

    // Shift the decimal the correct number of places
    // back to the left.
    return (double) tmp / factor;
  }
}
