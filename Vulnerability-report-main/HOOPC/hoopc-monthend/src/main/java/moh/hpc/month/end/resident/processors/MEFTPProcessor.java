/**
 * ****************************************************************************** Licensed Materials
 * - Property of IBM * Copyright IBM Canada Ltd 2005 All Rights Reserved * Created on Jan 14, 2005 *
 * ****************************************************************************** Please do not
 * makes any changes to this file without first * updating the revision history below, under
 * description * please include Harvest Change Request or PSO Tools CR that * caused the change. *
 * ****************************************************************************** Revision History:
 * * * Date Name Description * ---------- ----------------
 * --------------------------------------------- * 01-15-2005 David Bartlett Initial Spec *
 * ******************************************************************************
 */
package moh.hpc.month.end.resident.processors;

import com.ibm.network.sftp.Sftp;
import jakarta.enterprise.context.Dependent;
import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Properties;
import moh.broker.utils.PasswordUtility;
import moh.hpc.month.end.FileHelper;
import moh.hpc.month.end.SFTPHelper;
import moh.hpc.month.end.constants.PropertyFileKeys;
import moh.hpc.month.end.exceptions.ProcessException;
import moh.hpc.month.end.services.MEDataService;
import moh.hpc.month.end.support.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Dependent
public class MEFTPProcessor extends MonthEndResProcessor {

  private Properties prp = null;
  private MEDataService ds = null;
  private Hashtable provStatList = null;
  private String processMonth = null;
  private String startingStatus = null;
  private String nextStatus = null;
  private String successTrans = null;
  private String statusKey = null;
  private String ftpStatusStep = null;
  private String defaultStep = null;
  private String ftpAllowed = null;
  private String ftpHostName = null;
  private String ftpUserName = null;
  private boolean ftpUseKey;
  private String ftpPrivateKeyPath = null;
  private String ftpKnownHostsPath = null;
  private String ftpPswd = null;
  private String ftpInDir = null;
  private String ftpOutDir = null;
  private String provRpts = null;
  private String sourceDir = null;
  private String ext = null;
  private String mbxCmd = null;
  private String reportFormat = null;
  private static Logger logger = LoggerFactory.getLogger("MEFTPProcessor");

  // *===========================================================================*/
  // * Name    : constructor                                                     */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 12 2005   Initial Spec                            */
  // *===========================================================================*/
  public MEFTPProcessor() {
    super();
  }

  // *===========================================================================*/
  // * Name    : initialize                                                      */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 14 2005   Initial Spec                            */
  // *===========================================================================*/
  /**
   * Sets up class objects (properties, dataservice, province status list) and other variables to be
   * used in the process().
   *
   * @throws ProcessException
   */
  public void initialize() throws ProcessException {
    logger.debug("Calling initialize() started.");
    prp = getProperties();
    ds = getDataService();
    provStatList = getProvStatList();
    processMonth = getProcessMonth();

    startingStatus = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_STAT_FTPPEND);

    successTrans = prp.getProperty(PropertyFileKeys.PRP_PROV_TRANS_CAUSE_SUCCESS);

    ftpStatusStep = prp.getProperty(PropertyFileKeys.PRP_RES_FTP_STEP);
    defaultStep = prp.getProperty(PropertyFileKeys.PRP_RES_STEP_DEF);

    reportFormat = prp.getProperty(PropertyFileKeys.PRP_RPT_PDF_FORMAT);
    sourceDir = prp.getProperty(PropertyFileKeys.PRP_RPT_DIR);
    ext = prp.getProperty(PropertyFileKeys.PRP_RPT_PDF_EXT);
    mbxCmd = prp.getProperty(PropertyFileKeys.PRP_MAILBOX_CMD);
    ftpAllowed = prp.getProperty(PropertyFileKeys.PRP_RES_FTP_FLAG);
    ftpHostName = prp.getProperty(PropertyFileKeys.PRP_FTP_SRVR);
    ftpUserName = prp.getProperty(PropertyFileKeys.PRP_FTP_USER);
    ftpUseKey = Boolean.parseBoolean(prp.getProperty(PropertyFileKeys.PRP_FTP_USE_KEY));
    ftpKnownHostsPath = prp.getProperty(PropertyFileKeys.PRP_FTP_KNOWN_HOSTS_PATH);

    if (ftpUseKey) {
      ftpPrivateKeyPath = prp.getProperty(PropertyFileKeys.PRP_FTP_PRIVATE_KEY_PATH);
    } else {
      ftpPswd = prp.getProperty(PropertyFileKeys.PRP_FTP_PWD);
    }
    ftpInDir = prp.getProperty(PropertyFileKeys.PRP_FTP_INDIR);
    ftpOutDir = prp.getProperty(PropertyFileKeys.PRP_FTP_OUTDIR);
    provRpts = prp.getProperty(PropertyFileKeys.PRP_RES_PROV_RPTS);

    try {
      if ((startingStatus.trim().length() == 0)
          || (successTrans.trim().length() == 0)
          || (reportFormat.trim().length() == 0)
          || (ftpStatusStep.trim().length() == 0)
          || (ftpAllowed.trim().length() == 0)
          || (defaultStep.trim().length() == 0)
          || (provRpts.trim().length() == 0)
          || (ftpHostName.trim().length() == 0)
          || (ftpUserName.trim().length() == 0)
          || (ftpUseKey && ftpPrivateKeyPath.trim().isEmpty())
          || (!ftpUseKey && ftpPswd.trim().isEmpty())) {
        logger.error("Some properties for the ftp processor are null when they cannot be");
        logger.error("FTP Starting Status:      " + startingStatus);
        logger.error("Success Transition Code:  " + successTrans);
        logger.error("Report Format:            " + reportFormat);
        logger.error("Report List:              " + provRpts);
        logger.error("FTP Step Code:            " + ftpStatusStep);
        logger.error("FTP Allowed:              " + ftpAllowed);
        logger.error("Default Step Code:        " + defaultStep);
        logger.error("FTP Host Name:            " + ftpHostName);
        logger.error("FTP User Name:            " + ftpUserName);
        logger.error("FTP Use Private Key:                    " + ftpUseKey);
        logger.error("FTP Private Key File Path:              " + ftpPrivateKeyPath);
        logger.error("FTP Password:                           " + ftpPswd);
        throw new ProcessException(new Exception("Config File Parameter error"));
      }
    } catch (NullPointerException npe) {
      logger.error("Missing properties in the config file " + npe);
      throw new ProcessException(npe);
    }
    // *********************************************
    // Determine next status
    // *********************************************
    try {
      statusKey = startingStatus.trim() + ":" + successTrans.trim();
      nextStatus = ((ProvTransitionsStats) (provStatList.get(statusKey))).getEndStatus();
    } catch (NullPointerException npe) {
      logger.error("Next status not found in transition status list using " + nextStatus);
      throw new ProcessException(npe);
    }
    // *********************************************
    // Decode FTP Password
    // *********************************************
    try {

      try {
        // Attemp decoding only if using pasword
        if (!ftpUseKey) {
          ftpPswd = PasswordUtility.simpleDecoder(ftpPswd);
        }
      } catch (NullPointerException npe) {
        logger.error("FTP Server password can not be decoded " + npe);
        throw new ProcessException(npe);
      }
    } catch (NullPointerException npe) {
      logger.error("FTP Server password can not be decoded " + npe);
      throw new ProcessException(npe);
    }

    logger.debug("Calling initialize() finished.");
  }
  // *===========================================================================*/
  // * Name    : process                                                         */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 12 2005   Initial Spec                            */
  // *===========================================================================*/

  /**
   * Retrieves all reports that were processed for a particular province in the given processing
   * month but only if they have been tagged as being ftpable. If so then once they are retrieved
   * they are FTPed to the appropriate mailboxes
   *
   * @param curProv A province object for the current object being processed.
   * @param stepCode Code indicating whether or not this step of the month end should be executed It
   *     will usually be defaulted to 'ALL'
   * @throws SQLException, IOException, ProcessException
   */
  public void process(Province curProv, String stepCode)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling process() started.");
    logger.info("");
    logger.info(
        "Starting FTP step for Province/Status: "
            + curProv.getProvince()
            + "/"
            + curProv.getCurStatus());
    logger.info("Processor Starting Status: " + startingStatus);
    logger.info("Processor Step Code:       " + stepCode);

    String sessionId = "ME: " + this.getClass().getName() + logger.getName();
    curProv.setProvError(false);

    // ***********************************************
    // Ensure that the next and current status
    // fields are not null
    // ***********************************************
    if ((nextStatus == null)
        || (nextStatus.trim().length() == 0)
        || (curProv.getCurStatus() == null)
        || (curProv.getCurStatus().trim().length() == 0)) {
      logger.error(
          "One or more of the status fields are null for province: " + curProv.getProvince());
      logger.error("Current Status: " + curProv.getCurStatus());
      logger.error("Next Status:    " + nextStatus);
      throw new ProcessException(new Exception("Province is in error: " + curProv.getProvince()));
    }

    // *************************************************************
    // Only process the province if it is at the correct status,
    // there was no overriding step command and it is valid to run
    // the province at its current status at the current time
    // *************************************************************
    if (!(ftpAllowed.equals("Y"))) {
      logger.info("Flag has been set to dissallow FTP");
    } else {
      if ((curProv.getCurStatus().equals(startingStatus))
          && ((stepCode.equals(defaultStep)) || (stepCode.equals(ftpStatusStep)))) {
        if (!validateTime(curProv.getCurStatus(), statusKey, provStatList)) {
          logger.info(
              "The current Province is not allowed to run at this time at its current status");
          logger.info("Province/Status: " + curProv.getProvince() + "/" + curProv.getCurStatus());
          curProv.setProvError(true);
        } else {
          logger.info("FTP reports for province: " + curProv.getProvince());
          ArrayList rptRequests = null;
          try {
            rptRequests = getProvinceRpts(curProv, sessionId);
            ftpProvinceRpts(curProv, rptRequests, sessionId);
          } finally {
            cleanupProvinceRpts(curProv, rptRequests, sessionId);
          }

          logger.info("Reports FTPed for Province: " + curProv.getProvince());
          curProv.setProvError(false);
          ds.advanceProvStat(
              curProv.getProvince(),
              curProv.getProvDetails().getResidencyType(),
              sessionId,
              curProv.getCurStatus(),
              successTrans);
          curProv.setCurStatus(nextStatus);
        }
      }
    }
    logger.debug("Calling process() finished.");
  }
  // *===========================================================================*/
  // * Name    : getProvinceRpts                                                 */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 20 2005   Initial Spec                            */
  // *===========================================================================*/

  /**
   * Retrieves all reports that were processed for a particular province in the given processing
   * month but only if they have been tagged as being ftpable.
   *
   * @param curProv A province object for the current object being processed.
   * @param sessionId Object that called this method
   * @throws SQLException, IOException, ProcessException
   */
  private ArrayList getProvinceRpts(Province curProv, String sessionId)
      throws SQLException, IOException, ProcessException {
    logger.debug("Calling getProvinceRpts() started.");

    ArrayList rptRequest = new ArrayList();
    rptRequest =
        ds.getProvinceRptRequests(
            curProv.getProvince(),
            curProv.getProvDetails().getResidencyType(),
            processMonth,
            provRpts,
            sessionId);

    if (rptRequest.size() != 0) {
      int i = 0;
      FileHelper fh = new FileHelper();
      try {
        while (i < rptRequest.size()) {
          Reports tmpRpt = (Reports) rptRequest.get(i);
          byte[] rptBytes =
              ds.executeRetrieveReport(tmpRpt.getRptRequestId(), tmpRpt.getDataFormat(), sessionId);

          if (rptBytes.length != 0) {

            String tmpDEI =
                curProv.getProvDetails().getSubmitIdentifier().trim() == null
                    ? ""
                    : curProv.getProvDetails().getSubmitIdentifier().trim();
            String tmpSFP =
                tmpRpt.getServerFilePrefix() == null ? "" : tmpRpt.getServerFilePrefix();
            
            //BCMOHAM-21683 add "Res" to file name
            
            //String fname = mbxCmd + tmpDEI + "." + curProv.getProvince().trim() + tmpSFP;
            
            String fname = mbxCmd + tmpDEI + "." + curProv.getProvince().trim() + tmpSFP + " RES";

            java.io.File f = fh.createFile(fname, sourceDir, ext);
            fh.writeFile(rptBytes, f.getAbsolutePath());
            tmpRpt.setFileName(f.getName());
            tmpRpt.setFilePath(f.getAbsolutePath());
            rptRequest.set(i, tmpRpt);
            logger.info("File created: " + f.getAbsolutePath());
            f = null;
            i += 1;
          } else {
            rptRequest.remove(i);
          }
          tmpRpt = null;
          rptBytes = null;
        }
        if (rptRequest.size() == 0) {
          logger.info(
              "No reports found for selected request ids for province: " + curProv.getProvince());
        }
      } finally {
        if (fh != null) {
          fh = null;
        }
      }
    }

    logger.debug("Calling getProvinceRpts() ended.");
    return rptRequest;
  }
  // *===========================================================================*/
  // * Name    : ftpProvinceRpts                                                 */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 20 2005   Initial Spec                            */
  // *===========================================================================*/

  /**
   * FTP's a given list of files to the appropriate mailboxes
   *
   * @param curProv A province object for the current object being processed.
   * @param rptRequests List of reports for the province that need to be FTPed
   * @param sessionId Object that called this method
   * @throws SQLException, IOException, ProcessException
   */
  private void ftpProvinceRpts(Province curProv, ArrayList rptRequests, String sessionId)
      throws IOException, ProcessException {
    logger.debug("Calling ftpProvinceRpts() started.");

    if ((rptRequests == null) || (rptRequests.size() == 0)) {
      logger.info("No FTPable reports found for province: " + curProv.getProvince());
    } else {
      // *********************
      // Connect to FTP Server
      // *********************
      int j = 0;
      Sftp sftp =
          ftpUseKey
              ? SFTPHelper.connectUsingKeys(
                  ftpHostName, ftpUserName, ftpPrivateKeyPath, ftpKnownHostsPath)
              : SFTPHelper.connectUsingPassword(
                  ftpHostName, ftpUserName, ftpPswd, ftpKnownHostsPath);
      try {
        if (sftp == null || !sftp.isConnected()) {
          throw new ProcessException(new Exception("Could not connect to FTP Server"));
        }

        // *************************************************
        // If remote directory provided then change to it
        // otherwise stay in directory automatically placed
        // in when ftp connection is made
        // *************************************************
        if ((ftpOutDir.length() != 0) && (ftpOutDir != null)) {
          int retval = SFTPHelper.setRemoteDir(ftpOutDir, sftp);
          if (retval != Sftp.SUCCESS) {
            throw new ProcessException(
                new Exception("Problems occurred changing to remote dir: " + ftpOutDir));
          }
        }
        // **********************************
        // FTP all reports for the province
        // **********************************
        while (j < rptRequests.size()) {
          Reports ftpRpt = (Reports) rptRequests.get(j);
          int retval =
              SFTPHelper.sendSFTPFile(sourceDir, ftpRpt.getFileName(), ftpRpt.getFileName(), sftp);

          if (retval != Sftp.SUCCESS) {
            throw new ProcessException(
                new Exception("Problems occurred Ftping file: " + ftpRpt.getFileName()));
          }
          j += 1;
        }
      } finally {
        if (sftp != null) {
          sftp.disconnect();
        }
      }
    }
    logger.debug("Calling ftpProvinceRpts() ended.");
  }
  // *===========================================================================*/
  // * Name    : cleanupProvinceRpts                                             */
  // * History:                                                                  */
  // *   Developer     Date              Description                             */
  // *   ---------     ------------      ----------------------------------------*/
  // *   DC Bartlett   January 20 2005   Initial Spec                            */
  // *===========================================================================*/

  /**
   * Removes a given list of files from the source directory
   *
   * @param curProv A province object for the current object being processed.
   * @param rptRequests List of reports for the province that need to be deleted
   * @param sessionId Object that called this method
   * @throws SQLException, IOException, ProcessException
   */
  private void cleanupProvinceRpts(Province curProv, ArrayList rptRequests, String sessionId)
      throws ProcessException {
    logger.debug("Calling cleanupProvinceRpts() started.");

    if ((rptRequests != null) && (rptRequests.size() != 0)) {
      int j = 0;
      FileHelper fh = new FileHelper();
      Reports tmpRpt = null;
      try {
        while (j < rptRequests.size()) {
          tmpRpt = (Reports) rptRequests.get(j);
          if ((tmpRpt.getFilePath().trim().length() != 0)
              && (!(tmpRpt.getFilePath().equals(null)))) {
            logger.info("Deleting file from source directory: " + tmpRpt.getFilePath());
            fh.deleteFile(tmpRpt.getFilePath());
          }
          j += 1;
          tmpRpt = null;
        }
        rptRequests = null;
      } catch (IOException ie) {
        logger.error("Problems occurred trying to delete file: " + tmpRpt.getFilePath());
        throw new ProcessException(ie);
      } finally {
        if (fh != null) {
          fh = null;
        }
        if (tmpRpt != null) {
          tmpRpt = null;
        }
      }
    }
    logger.debug("Calling cleanupProvinceRpts() ended.");
  }
}
