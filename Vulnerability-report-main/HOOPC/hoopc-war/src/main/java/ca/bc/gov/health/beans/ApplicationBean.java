/*
 * To change this license header, choose License Headers in Project Properties. To change this
 * template file, choose Tools | Templates and open the template in the editor.
 */
package ca.bc.gov.health.beans;

import ca.bc.gov.health.constants.GlobalConstants;
import static ca.bc.gov.health.constants.GlobalConstants.CLAIM_ADJ_DEC_TYPE;
import static ca.bc.gov.health.constants.GlobalConstants.CLAIM_ADJ_REQ_TYPE;
import ca.bc.gov.health.database.ejb.AdjustmentCodesFacadeLocal;
import ca.bc.gov.health.database.ejb.ClaimTypesFacade;
import ca.bc.gov.health.database.ejb.ResidencyTypesFacadeLocal;
import ca.bc.gov.health.database.entity.AdjustmentCodes;
import ca.bc.gov.health.database.entity.AppUserAuthorizations;
import ca.bc.gov.health.database.entity.ApplicationUsers;
import ca.bc.gov.health.database.entity.ClaimStatusCodes;
import ca.bc.gov.health.database.entity.ClaimTypes;
import ca.bc.gov.health.database.entity.Hospitals;
import ca.bc.gov.health.database.entity.ResidencyTypes;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.HoopcSessionBean;
import ca.bc.gov.health.validation.claim.ClaimValidatorHelper;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.Resource;
import jakarta.ejb.EJB;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.faces.component.UIComponent;
import jakarta.faces.context.FacesContext;
import jakarta.faces.model.SelectItem;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The Class ApplicationBean.
 *
 * @author trevor.schiavone
 */
@ApplicationScoped
@Named("ApplicationBean")
public class ApplicationBean implements Serializable {

  private static final long serialVersionUID = 1L;

  private static final Logger LOG = LoggerFactory.getLogger(ApplicationBean.class.getName());

  @Inject private HoopcAppService appService;

  @Inject private HoopcSessionBean session;

  @EJB private ClaimTypesFacade claimTypesFacade;
  @EJB private ResidencyTypesFacadeLocal residencyTypesFacade;
  @EJB private AdjustmentCodesFacadeLocal adjustmentCodesFacade;

  @Resource(lookup = "java:app/hpc/application_properties")
  private Properties applicationProperties;

  // TODO: Only used by converter. May be replaced like statusCodes later
  private List<AdjustmentCodes> adjustmentCodesReqList;
  private List<AdjustmentCodes> adjustmentCodesDecisionList;

  private List<ClaimStatusCodes> allStatusCodeList;
  private List<ClaimTypes> claimTypeList;
  private List<ResidencyTypes> residencyTypesList;

  /** Inits the static structures. */
  @PostConstruct
  public void init() {
    setupClaimTypes();
    setupResidencyTypes();
    setupAdjustmentCodesRequest();
    setupAdjustmentCodesDecision();
  }

  /**
   * Hospital autocomplete with only the hospital number in the value, and with the number and name
   * in the label.
   *
   * @param query the query
   * @return the list
   */
  public List<String> hospitalAutoComplete(String query) {
    return hospitalAutoComplete(query, false, false);
  }

  /**
   * Hospital auto complete with province in string.
   *
   * @param query the query
   * @return the list
   */
  public List<String> hospitalAutoCompleteWithProvinceInString(String query) {
    return hospitalAutoComplete(query, true, false);
  }

  /**
   * Hospital auto complete with province in string.
   *
   * @param query the query
   * @return the list
   */
  public List<String> hospitalAutoCompleteAllOption(String query) {
    return hospitalAutoComplete(query, false, true);
  }

  /**
   * Hospital auto complete with province in string.
   *
   * @param query the query
   * @return the list
   */
  public List<String> hospitalAutoCompleteWithProvinceInStringAllOption(String query) {
    return hospitalAutoComplete(query, true, true);
  }

  /**
   * Hospital auto complete. If treating province is selected, lists hospital code-name in this
   * province. If no treating province is selected, lists all hospitals.
   *
   * @param query the query
   * @param concatenateProvince the concatenate province
   * @param allOption will add a "ALL" option when filter is empty
   * @return the list
   */
  public List<String> hospitalAutoComplete(
      String query, boolean concatenateProvince, boolean allOption) {
    // Fetching province and health authority from the UI
    String province =
        (String)
            UIComponent.getCurrentComponent(FacesContext.getCurrentInstance())
                .getAttributes()
                .get("treatingProvince");
    String healthAuthority =
        (String)
            UIComponent.getCurrentComponent(FacesContext.getCurrentInstance())
                .getAttributes()
                .get("healthAuthority");
    ApplicationUsers appUser = session.getCurrentUser();
    List<Hospitals> hospitalList = appService.getHospitals(province, healthAuthority);

    List<String> hspList = new ArrayList<>();
    if (StringUtils.isBlank(query) && allOption) {
      hspList.add("ALL");
    }
    if (concatenateProvince) {
      hspList.addAll(filterHospitalsWithProvinceInString(query, appUser, hospitalList));
    } else {
      hspList.addAll(filterHospitals(query, appUser, hospitalList));
    }

    return hspList;
  }

  /**
   * Returning hospital's number and name in the Strings.
   *
   * @param query the query
   * @param appUser the app user
   * @param hospitalsList the hospitals list
   * @return the list
   */
  public List<String> filterHospitals(
      String query, ApplicationUsers appUser, List<Hospitals> hospitalsList) {
    return hospitalsList.stream()
        // sorted by number
        .sorted(
            (h1, h2) ->
                Integer.valueOf(h1.getHospitalNumber())
                    .compareTo(Integer.valueOf(h2.getHospitalNumber())))
        // Filter for user
        .filter(h -> isUserAuthorized(appUser, h))
        // Convert to code-descr label
        .map(item -> item.getHospitalNumber() + "-" + item.getName())
        // Filter given query
        .filter(item -> StringUtils.containsIgnoreCase(item, query))
        // toList
        .collect(Collectors.toList());
  }

  /**
   * Returning hospital's province, number, name in the Strings.
   *
   * @param query the query
   * @param appUser the app user
   * @param hospitalsList the hospitals list
   * @return the list
   */
  public List<String> filterHospitalsWithProvinceInString(
      String query, ApplicationUsers appUser, List<Hospitals> hospitalsList) {
    return hospitalsList.stream()
        // sorted by number
        .sorted(
            (h1, h2) ->
                Integer.valueOf(h1.getHospitalNumber())
                    .compareTo(Integer.valueOf(h2.getHospitalNumber())))
        // Filter for user
        .filter(h -> isUserAuthorized(appUser, h))
        // Convert to code-descr label
        .map(
            item ->
                "("
                    + item.getPteId().getProvinceCode()
                    + ") "
                    + item.getHospitalNumber()
                    + "-"
                    + item.getName())
        // Filter given query
        .filter(item -> StringUtils.containsIgnoreCase(item, query))
        // toList
        .collect(Collectors.toList());
  }

  /**
   * Claim diagnostic codes auto complete.
   *
   * @param query the query
   * @return the list
   */
  public List<String> claimDiagnosticCodesAutoComplete(String query) {

    List<String> filtered =
        appService
            .getDiagnosticCodes()
            .parallelStream()
            // Convert to code-descr label
            .map(c -> c.getCodeValue() + "-" + c.getShortDescription())
            // Filter given query
            .filter(c -> StringUtils.containsIgnoreCase(c, query))
            // Sort by label
            .sorted()
            .collect(Collectors.toList());
    return filtered;
  }

  /**
   * Claim procedure codes auto complete.
   *
   * @param query the query
   * @return the list
   */
  public List<String> claimProcedureCodesAutoComplete(String query) {

    List<String> filtered =
        appService
            .getProcedureCodes()
            .parallelStream()
            // Convert to code-descr label
            .map(c -> c.getCodeValue() + "-" + c.getShortDescription())
            // Filter given query
            .filter(c -> StringUtils.containsIgnoreCase(c, query))
            // Sort by label
            .sorted()
            .collect(Collectors.toList());
    return filtered;
  }

  /**
   * Claim Status Codes Auto complete
   *
   * @param query the query
   * @return the list
   */
  public List<String> claimStatusCodesAutoComplete(String query) {

    FacesContext context = FacesContext.getCurrentInstance();
    ResidencyTypes residencyType =
        context
            .getApplication()
            .evaluateExpressionGet(context, "#{claim.residencyType}", ResidencyTypes.class);

    // Different status codes apply to different residency types
    List<ClaimStatusCodes> statusCodes = getResidencySpecificStatusCodes(residencyType);

    List<String> filtered =
        statusCodes
            .parallelStream()
            // Convert to code-descr label
            .map(c -> c.getStatusCode())
            // Filter given query
            .filter(c -> StringUtils.containsIgnoreCase(c, query))
            // Sort by label
            .sorted()
            .collect(Collectors.toList());
    return filtered;
  }

  private List<ClaimStatusCodes> getResidencySpecificStatusCodes(ResidencyTypes residencyType) {

    List<ClaimStatusCodes> statusCodes;
    switch (residencyType.getTypeCode()) {
      case GlobalConstants.NRES_RESIDENCY_TYPE:
        statusCodes = appService.getNonResidentStatusCodes();
        break;
      case GlobalConstants.RES_RESIDENCY_TYPE:
        statusCodes = appService.getResidentStatusCodes();
        break;
      default:
        statusCodes = appService.getResidentStatusCodes();
        break;
    }
    return statusCodes;
  }

  /**
   * Claim service codes auto complete.
   *
   * @param query the query
   * @return the list
   */
  public List<String> claimServiceCodesAutoComplete(String query) {

    List<String> filtered =
        appService
            .getServiceCodes()
            .parallelStream()
            // Convert to code-descr label
            .map(c -> c.getCodeValue() + "-" + c.getShortDescription())
            // Filter given query
            .filter(c -> StringUtils.containsIgnoreCase(c, query))
            // Sort by label
            .sorted()
            .collect(Collectors.toList());
    return filtered;
  }

  /**
   * Claim highcost codes auto complete.
   *
   * @param query the query
   * @return the list
   */
  public List<String> claimHighcostCodesAutoComplete(String query) {

    List<String> filtered =
        appService
            .getHighcostCodes()
            .parallelStream()
            // sorted by number
            .sorted(
                (h1, h2) -> h1.getHighCostProcedureCode().compareTo(h2.getHighCostProcedureCode()))
            // Convert to code-descr label
            .map(c -> c.getHighCostProcedureCode() + "-" + c.getDescription())
            // Filter given query
            .filter(c -> StringUtils.containsIgnoreCase(c, query))
            // to List
            .collect(Collectors.toList());
    return filtered;
  }

  private void setupClaimTypes() {
    try {
      claimTypeList = this.claimTypesFacade.findAll();

    } catch (HoopcException e) {
      LOG.error(e.getMessage());
    }
  }

  private void setupResidencyTypes() {
    try {
      residencyTypesList = this.residencyTypesFacade.findAll();
    } catch (HoopcException e) {
      LOG.error(e.getMessage());
    }
  }

  private void setupAdjustmentCodesRequest() {
    try {
      adjustmentCodesReqList = this.adjustmentCodesFacade.findByType(CLAIM_ADJ_REQ_TYPE);

    } catch (Exception e) {
      LOG.error(e.getMessage());
    }
  }

  private void setupAdjustmentCodesDecision() {
    try {
      adjustmentCodesDecisionList = this.adjustmentCodesFacade.findByType(CLAIM_ADJ_DEC_TYPE);

    } catch (Exception e) {
      LOG.error(e.getMessage());
    }
  }

  // Allow UI access to Hospitals list from the app service
  public List<Hospitals> getHospitalsListBC() {
    String province = "BC";
    ApplicationUsers appUser = session.getCurrentUser();

    List<Hospitals> hospitals =
        appService.getHospitals(province, null).stream()
            // sorted by number
            .sorted(
                (h1, h2) ->
                    Integer.valueOf(h1.getHospitalNumber())
                        .compareTo(Integer.valueOf(h2.getHospitalNumber())))
            // fliter users
            .filter(h -> isUserAuthorized(appUser, h))
            // toList
            .collect(Collectors.toList());

    return hospitals;
  }

  public List<SelectItem> provincesAbreviationList(String residencyType) {
    if ("NRES".equals(residencyType)) {
      return appService.getNresProvincesAbreviationList();
    } else {
      return appService.getProvincesAbreviationList();
    }
  }

  public List<AdjustmentCodes> getAdjustmentCodesReqList() {
    return adjustmentCodesReqList;
  }

  public List<AdjustmentCodes> getAdjustmentCodesDecisionList() {
    return adjustmentCodesDecisionList;
  }

  public List<ClaimStatusCodes> getAllStatusCodeList() {
    return allStatusCodeList;
  }

  public List<ClaimTypes> getClaimTypeList() {
    return claimTypeList;
  }

  public List<ResidencyTypes> getResidencyTypesList() {
    return residencyTypesList;
  }

  public List<SelectItem> getProvincesList() {
    return appService.getProvincesList();
  }

  public List<SelectItem> getResidentProvincesList() {
    return appService.getResidentProvincesList();
  }

  public List<SelectItem> getProvincesAbreviationList() {
    return appService.getProvincesAbreviationList();
  }

  public List<SelectItem> getNresProvincesAbreviationList() {
    return appService.getNresProvincesAbreviationList();
  }

  public List<SelectItem> getReasonInBcList() {
    return appService.getReasonInBcList();
  }

  public List<SelectItem> getHealthAuthoritiesList() {
    return appService.getHealthAuthoritiesList();
  }

  /**
   * Return if current user is allowed to see a given hospital. Users with MINISTRY role can access
   * all hospitals. Users with MINISTRY role can only access hospitals defined in {@link
   * AppUserAuthorizations}.
   *
   * @param province the province
   * @param hospitalNumber the hospital number
   * @return true, if is user authorized
   */
  public boolean isUserAuthorized(String province, String hospitalNumber) {

    ApplicationUsers applicationUser = session.getCurrentUser();
    Hospitals hospital = appService.getHospital(province, hospitalNumber);
    if (hospital == null) {
      // for invalid hospital numbers, let it pass
      return true;
    }
    return isUserAuthorized(applicationUser, hospital);
  }

  /**
   * Checks if is user authorized.
   *
   * @param appUser the app user
   * @param hospital the hospital
   * @return true, if is user authorized
   */
  public boolean isUserAuthorized(ApplicationUsers appUser, Hospitals hospital) {
    // TODO: Crappy shortcut to reuse ClaimValidator rule.
    ClaimValidatorHelper helper = new ClaimValidatorHelper();
    return helper.isUserAuthorized(appUser, hospital);
  }

  /**
   * Get the runtime environment for JNDI. Values for runtimes are (not exclusively) "D" (dev), "T"
   * (test), "S" (staging), "P" (prod).
   *
   * <p>Define this in server domain config: <br>
   * <custom-resource factory-class="org.glassfish.resources.custom.factory.PropertiesFactory"
   * res-type="java.util.Properties" jndi-name="hpc/application_properties"><br>
   * <property name="env_name" value="D"> </property><br>
   * </custom-resource>
   *
   * @return Value of env_name property
   */
  public String getAppEnv() {
    if (applicationProperties != null) {
      String appEnvName = (String) applicationProperties.get("env_name");
      if (appEnvName != null) {
        return appEnvName;
      }
    }
    // default is PROD
    return "P";
  }
}
