package ca.bc.gov.health.monthend;

import ca.bc.gov.health.beans.BaseBean;
import ca.bc.gov.health.constants.GlobalConstants;
import ca.bc.gov.health.database.entity.ProvinceMonthendStatus;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.MonthEndReportService;
import ca.bc.gov.health.service.MonthEndService;
import ca.bc.gov.health.validation.ValidationError;
import jakarta.faces.application.FacesMessage;
import jakarta.inject.Inject;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.Serializable;
import java.text.MessageFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.primefaces.model.DefaultStreamedContent;

public class ReportMonthEndBaseBean extends BaseBean implements Serializable {

  private static final long serialVersionUID = -7739888232116256099L;

  @Inject HoopcAppService appService;
  @Inject protected MonthEndService meService;
  @Inject MonthEndReportService meReportService;

  private static final Map<String, String> ACTION_MESSAGES = new HashMap<>();

  static {
    ACTION_MESSAGES.put("SCHEDULED", "scheduled");
    ACTION_MESSAGES.put("NOTSTARTED", "cancelled");
    ACTION_MESSAGES.put("APPROVED", "approved");
    ACTION_MESSAGES.put("DISTPENDNG", "distributed");
  }

  protected List<String> selectedProvinces = new ArrayList<>();
  protected boolean selectAllProvinces;
  final Map<String, String> monthEndStatuses = new HashMap<>();
  protected byte[] monthEndReports;
  protected static final String REPORT_NOT_FOUND = "Report not found";

  public void scheduleMonthend(String resType) {
    try {
      changeMonthEndStatus("SCHEDULED", resType);
    } catch (Exception e) {
      addErrorMessage(e.getMessage());
    }
  }

  public void cancelMonthend(String resType) {
    try {
      changeMonthEndStatus("NOTSTARTED", resType);
    } catch (Exception e) {
      addErrorMessage(e.getMessage());
    }
  }

  /**
   * Prepare to change the monthend status and refresh province status after.
   *
   * @param targetStatus
   * @param resType
   */
  void changeMonthEndStatus(String targetStatus, String resType) throws HoopcException {
    List<ValidationError> errors =
        meService.validateAndChangeProvinceStatus(targetStatus, selectedProvinces, resType);
    refreshMonthEndStatuses(resType);
    if (!errors.isEmpty()) {
      throw new HoopcException(
          errors.stream().map(e -> e.getMessage()).collect(Collectors.joining("<BR/>")));
    }
    addInfoMessage(
        MessageFormat.format(
            GlobalConstants.MONTHEND_ACTION_MESSAGE,
            ACTION_MESSAGES.getOrDefault(targetStatus, targetStatus.toLowerCase()),
            targetStatus.equals("DISTPENDNG") ? "all provinces" : selectedProvincesMessage()));
  }

  void changeMonthEndStatusNonRes(String targetStatus, String resType) throws HoopcException {
    List<ValidationError> errors =
        meService.validateAndChangeProvinceStatus(targetStatus, getAllProvinces(), resType);
    refreshMonthEndStatuses(resType);
    if (!errors.isEmpty()) {
      throw new HoopcException(
          errors.stream().map(e -> e.getMessage()).collect(Collectors.joining("<BR/>")));
    }
    addInfoMessage(
        MessageFormat.format(
            GlobalConstants.MONTHEND_ACTION_MESSAGE,
            ACTION_MESSAGES.getOrDefault(targetStatus, targetStatus.toLowerCase()),
            targetStatus.equals("DISTPENDNG") ? "all provinces" : selectedProvincesMessage()));
  }

  private String selectedProvincesMessage() {
    return selectedProvinces.stream().collect(Collectors.joining(", "));
  }

  List<String> getAllProvinces() {
    return monthEndStatuses.entrySet().stream().map(m -> m.getKey()).collect(Collectors.toList());
  }

  void refreshMonthEndStatuses(String resType) {
    List<ProvinceMonthendStatus> statuses = meService.getMonthEndStatuses(resType);
    for (ProvinceMonthendStatus status : statuses) {
      monthEndStatuses.put(status.getPteId().getProvinceCode(), status.getMesId().getStatusCode());
    }
  }

  public String getProcessingMonth(String resType) throws HoopcException {
    try {
      String period = meService.getProcessingMonth(resType);
      if (period == null && StringUtils.isBlank(period)) {
        period = "N/A";
      } else {
        LocalDate processingMonth =
            LocalDate.of(
                Integer.valueOf(period.substring(0, 4)), Integer.valueOf(period.substring(4)), 1);
        period = processingMonth.format(DateTimeFormatter.ofPattern("MMMM, yyyy"));
      }
      return period;
    } catch (HoopcException e) {
      // TODO make this appear to the screen
      addMessage(FacesMessage.SEVERITY_ERROR, e.getMessage(), false);
    }
    return null;
  }

  public DefaultStreamedContent showReports(String reportName) {
    InputStream is = new ByteArrayInputStream(monthEndReports);
    return DefaultStreamedContent.builder().contentType("application/pdf").name(reportName).stream(() -> is).build();
  }

  public Map<String, String> getMonthEndStatuses() {
    return monthEndStatuses;
  }

  public List<String> getSelectedProvinces() {
    return selectedProvinces;
  }

  public void setSelectedProvinces(List<String> selectedProvinces) {
    this.selectedProvinces = selectedProvinces;
  }

  public boolean getSelectAllProvinces() {
    return selectAllProvinces;
  }

  public void setSelectAllProvinces(boolean selectAllProvinces) {
    this.selectAllProvinces = selectAllProvinces;
  }
}
