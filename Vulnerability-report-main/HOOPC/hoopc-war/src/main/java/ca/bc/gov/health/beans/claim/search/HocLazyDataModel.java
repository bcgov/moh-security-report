package ca.bc.gov.health.beans.claim.search;

import ca.bc.gov.health.database.entity.HospitalOopClaims;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.service.ClaimServiceLocal;
import ca.bc.gov.health.service.HoopcSessionBean;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import jakarta.annotation.PostConstruct;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.context.FacesContext;
import java.text.MessageFormat;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.primefaces.model.FilterMeta;
import org.primefaces.model.LazyDataModel;
import org.primefaces.model.SortMeta;
import org.primefaces.model.SortOrder;

public class HocLazyDataModel extends LazyDataModel<HospitalOopClaims> {
  private static final long serialVersionUID = -6318587154155829859L;

  private ClaimServiceLocal claimService;
  private ClaimViewModel claim;
  private List<HospitalOopClaims> datasource;
  private Long totalRowCount;

  protected HoopcSessionBean session;

  // Constructor
  public HocLazyDataModel() {}

  @PostConstruct
  public void init() {
    totalRowCount = 0L;
  }

  @Override
  public HospitalOopClaims getRowData(String rowKey) {
    for (HospitalOopClaims hoc : datasource) {
      if (hoc.getId().equals(rowKey)) {
        return hoc;
      }
    }
    return null;
  }

  @Override
  public String getRowKey(HospitalOopClaims hoc) {
    return hoc.getId().toString();
  }

  @Override
  public List<HospitalOopClaims> load(int first, int pageSize, Map<String, SortMeta> sortBy, Map<String, FilterMeta> filterBy) {
    String sortField = null;
    SortMeta sortMeta = null;
    SortOrder orderBy = SortOrder.ASCENDING;
    if (!sortBy.isEmpty()) {
      sortMeta = (SortMeta) sortBy.values().toArray()[0];
      sortField = sortMeta.getField();
      // Hack fix for bug introduced from PrimeFaces 12 upgrade where sortBy is defined by a list reference like `<p:column ... sortBy="#{result.admissionsList[0].admissionDate}">`
      if (sortField == null && sortMeta.getSortBy() != null) {
        sortField = sortMeta.getSortBy().getExpressionString().replaceAll("^#\\{result\\.", "").replaceAll("\\}$", "");
      }
      orderBy = sortMeta.getOrder();
    }
    if (this.claim == null) {
      return null;
    }

    try {
      // sorting parameter
      String sortOrder = null;
      if (orderBy == SortOrder.ASCENDING) {
        sortOrder = "ASCENDING";
      } else if (orderBy == SortOrder.DESCENDING) {
        sortOrder = "DESCENDING";
      }
      // main query
      datasource = claimService.searchByCriteria(claim, first, pageSize, sortField, sortOrder);

      List<Long> ls = datasource.stream().map(c -> c.getId()).collect(Collectors.toList());

      session.setLastSearchResult(ls);

    } catch (HoopcException e) {
      addMessage(e);
    } catch (Exception ex) {
      addMessage(new FacesMessage(FacesMessage.SEVERITY_ERROR, ex.getMessage(), ex.getMessage()));
    }

    return datasource;
  }

  /**
   * Adds the message.
   *
   * @param faceMsg the face msg
   */
  public void addMessage(FacesMessage faceMsg) {
    FacesContext.getCurrentInstance().getExternalContext().getFlash().setKeepMessages(true);
    FacesContext.getCurrentInstance().addMessage(null, faceMsg);
  }

  @Override
  public int count(Map<String, FilterMeta> filters) {
    if (this.claim == null) {
        return 0;
    }

    try {
        Long count = claimService.selectCountByCriteria(claim);
        return count != null ? count.intValue() : 0;
    } catch (HoopcException e) {
        addMessage(e);
    } catch (Exception ex) {
        addMessage(new FacesMessage(FacesMessage.SEVERITY_ERROR, ex.getMessage(), ex.getMessage()));
    }

    return 0;
  }
  /**
   * Adds the message.
   *
   * @param severity the severity
   * @param message the message
   * @param isFlash the is flash
   */
  public void addMessage(FacesMessage.Severity severity, String message, boolean isFlash) {
    FacesContext.getCurrentInstance().getExternalContext().getFlash().setKeepMessages(isFlash);
    FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(severity, message, null));
  }

  /**
   * Adds the message.
   *
   * @param e the e
   */
  public void addMessage(HoopcException e) {
    addMessage(FacesMessage.SEVERITY_ERROR, formatMessage(e), true);
  }

  /**
   * Format message.
   *
   * @param e the e
   * @return the string
   */
  public String formatMessage(HoopcException e) {
    return MessageFormat.format(
        "Fatal error: ref={0}<br/>{1}", e.getCorrelationId(), e.getMessage());
  }

  public ClaimViewModel getClaim() {
    return claim;
  }

  public void setClaim(ClaimViewModel claim) {
    this.claim = claim;
  }

  public ClaimServiceLocal getClaimService() {
    return claimService;
  }

  public void setClaimService(ClaimServiceLocal claimService) {
    this.claimService = claimService;
  }

  public Long getTotalRowCount() {
    return totalRowCount;
  }

  public void setTotalRowCount(Long totalRowCount) {
    this.totalRowCount = totalRowCount;
  }

  public HoopcSessionBean getSession() {
    return session;
  }

  public void setSession(HoopcSessionBean session) {
    this.session = session;
  }
}
