package ca.bc.gov.health.helper;

import ca.bc.gov.health.database.entity.InvoiceDetails;
import ca.bc.gov.health.database.entity.PeriodEndInvoices;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.time.chrono.ChronoLocalDate;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;

/** The Class InvoiceHelper. */
public class InvoiceHelper {

  private static final String INVOICE_TOTAL = "invoiceTotal";
  private static final String OUTPAT_TOTAL = "outpatTotal";
  private static final String INPAT_TOTAL = "inpatTotal";

  private InvoiceHelper() {
    throw new IllegalStateException("Utility class");
  }

  /**
   * Formulate invoice type.
   *
   * @param invoiceDetailsList the invoice details list
   * @return the string
   */
  public static String formulateInvoiceType(List<InvoiceDetails> invoiceDetailsList) {
    String value = "";
    if (invoiceDetailsList != null) {
      for (InvoiceDetails i : invoiceDetailsList) {
        if (!value.contains(i.getCtsId().getClaimType())
            && (i.getInvoiceAmount().compareTo(BigDecimal.ZERO) != 0
                || i.getReductionAmount().compareTo(BigDecimal.ZERO) != 0
                || i.getInvoiceQuantity().compareTo(BigInteger.ZERO) != 0)) {
          if (!value.isEmpty()) {
            value += "/";
          }
          value += i.getCtsId().getClaimType();
        }
      }
    }
    return value;
  }

  /**
   * Calculate invoice sub total and total amounts. <br>
   * Invoice Total = (inpatTotal-inpatReduction) + (outpatTotal-outpatReduction) <br>
   * <br>
   * Returns:<br>
   * Map<String, BigDecimal> totalAmounts = new HashMap<>()<br>
   * <br>
   * Inpatient subtotal: totalAmounts.get("inpatTotal")<br>
   * Outpatient subtotal: totalAmounts.get("outpatTotal")<br>
   * Invoice total: totalAmounts.get("invoiceTotal")<br>
   *
   * @param entity the entity
   * @return the map
   */
  public static Map<String, BigDecimal> calculateTotalAmounts(PeriodEndInvoices entity) {
    Map<String, BigDecimal> totalAmounts = new HashMap<>();
    totalAmounts.put(INPAT_TOTAL, new BigDecimal("0"));
    totalAmounts.put(OUTPAT_TOTAL, new BigDecimal("0"));
    totalAmounts.put(INVOICE_TOTAL, new BigDecimal("0"));

    if (entity == null || entity.getInvoiceDetailsList() == null) {
      return totalAmounts;
    }

    for (InvoiceDetails d : entity.getInvoiceDetailsList()) {

      // Making sure that mandatory properties are not null
      if (d.getCtsId() != null
          && d.getCtsId().getClaimType() != null
          && d.getInvoiceAmount() != null
          && d.getReductionAmount() != null) {

        // Setting the inpatient total
        if (d.getCtsId().getClaimType().equals("INPATIENT")) {
          BigDecimal inpatTotal =
              d.getInvoiceAmount()
                  .subtract(d.getReductionAmount())
                  .setScale(2, RoundingMode.HALF_EVEN);
          totalAmounts.replace(INPAT_TOTAL, inpatTotal);

          // Calculate outpatient total
        } else if (d.getCtsId().getClaimType().equals("OUTPATIENT")) {
          BigDecimal outpatTotal =
              d.getInvoiceAmount()
                  .subtract(d.getReductionAmount())
                  .setScale(2, RoundingMode.HALF_EVEN);
          totalAmounts.replace(OUTPAT_TOTAL, outpatTotal);
        }
      }
    }

    // Invoice Total
    BigDecimal invoiceTotal = new BigDecimal("0");
    invoiceTotal =
        invoiceTotal
            .add(totalAmounts.get(INPAT_TOTAL))
            .add(totalAmounts.get(OUTPAT_TOTAL))
            .setScale(2, RoundingMode.HALF_EVEN);
    totalAmounts.replace(INVOICE_TOTAL, invoiceTotal);

    return totalAmounts;
  }

  /**
   * Format date.
   *
   * @param format the format
   * @param date the date
   * @return the string
   */
  public static String formatDate(String format, ChronoLocalDate date) {
    if (date != null) {
      DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format, Locale.ENGLISH);
      return formatter.format(date);
    } else return "";
  }

  /**
   * Calculate province invoice total.
   *
   * @param invoiceList the invoice list
   * @return the big decimal
   */
  public static BigDecimal calculateProvinceInvoiceTotal(List<PeriodEndInvoices> invoiceList) {
    BigDecimal total = new BigDecimal(0).setScale(2, RoundingMode.HALF_EVEN);
    if (invoiceList != null) {
      for (PeriodEndInvoices invoice : invoiceList) {
        total = total.add(calculateTotalAmounts(invoice).get(INVOICE_TOTAL));
      }
    }
    return total;
  }

  /**
   * Checks if is negative province invoice total.
   *
   * @param invoiceList the invoice list
   * @param invoice the invoice
   * @return true, if is negative province invoice total
   */
  public static boolean isNegativeProvinceInvoiceTotal(
      List<PeriodEndInvoices> invoiceList, PeriodEndInvoices invoice) {

    // Nothing to compare with
    if (invoiceList == null) {
      return false;
    }

    invoiceList =
        invoiceList.stream()
            .filter(i -> !i.getId().equals(invoice.getId()))
            .collect(Collectors.toList());
    // No error if no other invoice for same province
    if (invoiceList.size() == 0) {
      return false;
    }
    invoiceList.add(invoice);

    BigDecimal invoiceTotal = InvoiceHelper.calculateProvinceInvoiceTotal(invoiceList);

    if (invoiceTotal.compareTo(new BigDecimal(0)) == -1) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Checks if is total different with calculated total.
   *
   * @param invoice the invoice
   * @param invoiceTotal the invoice total
   * @return true, if is total different with calculated total
   */
  public static boolean isTotalDifferentWithCalculatedTotal(
      PeriodEndInvoices invoice, BigDecimal invoiceTotal) {

    BigDecimal calculatedTotal = InvoiceHelper.calculateTotalAmounts(invoice).get(INVOICE_TOTAL);

    if (calculatedTotal.compareTo(invoiceTotal) != 0) {
      return true;
    } else {
      return false;
    }
  }
}
