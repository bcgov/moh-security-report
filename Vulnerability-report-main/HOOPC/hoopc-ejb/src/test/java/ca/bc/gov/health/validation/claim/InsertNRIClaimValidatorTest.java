package ca.bc.gov.health.validation.claim;

import ca.bc.gov.health.constants.ClaimDetailCodePurpose;
import ca.bc.gov.health.constants.OverrideStatus;
import ca.bc.gov.health.database.entity.ApplicationUsers;
import ca.bc.gov.health.database.entity.ClaimDetailCodes;
import ca.bc.gov.health.database.entity.Hospitals;
import ca.bc.gov.health.database.entity.ProvincesTerritories;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.HoopcSessionBean;
import ca.bc.gov.health.service.viewmodel.AdmissionsViewModel;
import ca.bc.gov.health.service.viewmodel.ClaimOverridesViewModel;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.HighcostViewModel;
import ca.bc.gov.health.service.viewmodel.PatientsViewModel;
import ca.bc.gov.health.util.RateRange;
import ca.bc.gov.health.util.RateRange.RateType;
import ca.bc.gov.health.validation.ValidationError;
import ca.bc.gov.health.validation.rule.ValidationRuleType;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.mockito.ArgumentMatchers.any;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import static org.mockito.Mockito.times;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Test Validation rules for INSERTNONRESINPATCLAIMINFO in
 * InsertNRIClaimValidator.insertNRIClaimRules()
 */
public class InsertNRIClaimValidatorTest {

  // TODO: Setup debug logger
  private static Logger log = LoggerFactory.getLogger(InsertNRIClaimValidatorTest.class);

  @InjectMocks private InsertNRIClaimValidator validator;

  @InjectMocks private ClaimValidatorComplexRules complexRules;

  @Mock private HoopcAppService appService;

  @Mock private HoopcSessionBean session;

  @Mock private ClaimValidatorHelper helper;

  @BeforeEach
  public void initMocks() {
    MockitoAnnotations.initMocks(this);
    validator.setComplexRules(complexRules);
  }

  private ClaimViewModel emptyClaim() {
    ClaimViewModel claim = new ClaimViewModel();
    claim.setPatient(new PatientsViewModel());
    claim.setAdmission(new AdmissionsViewModel());
    claim.setDiagnosisCodes(new String[] {"", "", ""});
    HighcostViewModel highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("123");
    claim.setHighCostProcedures(
        new HighcostViewModel[] {highCostViewModel, highCostViewModel, highCostViewModel});
    claim.setClaimOverride(new ClaimOverridesViewModel());
    return claim;
  }

  @Test
  public void ReceivingProvince_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setReceivingProvince(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Receiving Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setReceivingProvince("NU");
    Mockito.when(appService.getProvince("NU")).thenReturn(new ProvincesTerritories());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Receiving Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);
    Mockito.verify(appService).getProvince("NU");
  }

  @Test
  public void ReceivingProvince_Lookup() {
    ClaimViewModel claim = emptyClaim();

    // lookup test
    claim.setReceivingProvince("BB");
    Mockito.when(appService.getProvince("BB")).thenReturn(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one lookup error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Receiving Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.LOOKUP_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService).getProvince("BB");

    // Positive test
    claim.setReceivingProvince("NU");
    Mockito.when(appService.getProvince("NU")).thenReturn(new ProvincesTerritories());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Receiving Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);
    Mockito.verify(appService).getProvince("NU");
  }

  @Test
  public void ReceivingProvince_NotInSet() {
    ClaimViewModel claim = emptyClaim();

    // NotInSet test
    claim.setReceivingProvince("BC");
    Mockito.when(appService.getProvince("BC")).thenReturn(new ProvincesTerritories());
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one NotInSet error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Receiving Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.NOT_IN_SET))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService).getProvince("BC");

    // Positive test
    claim.setReceivingProvince("NU");
    Mockito.when(appService.getProvince("NU")).thenReturn(new ProvincesTerritories());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Receiving Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);
    Mockito.verify(appService).getProvince("NU");
  }

  @Test
  public void hospitalNumber_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setHospitalNumberAndName(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Hospital Number & Name"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setHospitalNumberAndName("123");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Hospital Number & Name"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void hospitalNumber_checkValidHospital() {
    ClaimViewModel claim = emptyClaim();

    // checkValidHospital test
    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    Mockito.when(appService.checkValidHospital("BC", "001", "InvalidHospital")).thenReturn(null);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    Mockito.verify(appService).checkValidHospital("BC", "001", "InvalidHospital");

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Hospital Name"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    log.info(error.getMessage());

    // Positive test
    claim.setReceivingProvince("BC");
    claim.setHospitalNumberAndName("001-TestHospital");
    Mockito.when(appService.checkValidHospital("BC", "001", "TestHospital"))
        .thenReturn(new Hospitals());

    errors = validator.validate(claim);

    assertNotNull(errors);
    Mockito.verify(appService).checkValidHospital("BC", "001", "TestHospital");

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Hospital Name"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    // Note: commented because setting province code calls appService too
    // Mockito.verifyZeroInteractions(appService);
  }

  @Test
  public void hospitalNumber_checkHospitalAuthorized() {
    ClaimViewModel claim = emptyClaim();

    // Check Hospital Authorized test with MINISTRY role
    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("001-TestHospital");
    Hospitals hospital =
        new Hospitals() {
          {
            setProvince("BC");
            setHospitalNumber("001");
          }
        };
    ApplicationUsers appUser =
        new ApplicationUsers() {
          {
            setApplicationUserid("User1");
          }
        };
    Mockito.when(appService.getHospital("BC", "001")).thenReturn(hospital);
    Mockito.when(session.getCurrentUser()).thenReturn(appUser);
    Mockito.when(helper.isUserAuthorized(appUser, hospital)).thenReturn(false);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Hospital Authorized"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    log.info(error.getMessage());

    // Positive test
    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("002-TestHospital");
    Hospitals hospital2 =
        new Hospitals() {
          {
            setProvince("BC");
            setHospitalNumber("002");
          }
        };
    Mockito.when(appService.getHospital("BC", "002")).thenReturn(hospital2);
    Mockito.when(session.getCurrentUser()).thenReturn(appUser);
    Mockito.when(helper.isUserAuthorized(appUser, hospital2)).thenReturn(true);

    errors = validator.validate(claim);

    assertNotNull(errors);

    Mockito.verify(helper, times(2))
        .isUserAuthorized(any(ApplicationUsers.class), any(Hospitals.class));

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Hospital Authorized"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    // Note: commented because setting province code calls appService too
    // Mockito.verifyZeroInteractions(appService);
  }

  @Test
  public void hospitalNumber_checkHospitalActiveRange() {
    ClaimViewModel claim = emptyClaim();

    LocalDate admDate = LocalDate.now();
    LocalDate disDate = LocalDate.now().plusDays(2);

    // checkValidHospital test
    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getAdmission().setAdmissionDate(admDate);
    claim.getAdmission().setDischargeDate(disDate);

    Mockito.when(appService.getPerDiemRate("BC", "001", admDate)).thenReturn(null);
    Mockito.when(appService.getPerDiemRate("BC", "001", disDate)).thenReturn(BigDecimal.valueOf(2));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Mockito.verify(appService).getPerDiemRate("BC", "001", admDate);
    // Mockito.verify(appService).getPerDiemRate("BC", "001", disDate);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Hospital Active"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    log.info(error.getMessage());

    // Positive test
    claim.setReceivingProvince("BC");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getAdmission().setAdmissionDate(admDate);
    claim.getAdmission().setDischargeDate(disDate);

    // Verifiy for two tests
    Mockito.when(appService.getPerDiemRate("BC", "001", admDate)).thenReturn(BigDecimal.valueOf(1));
    Mockito.when(appService.getPerDiemRate("BC", "001", disDate)).thenReturn(BigDecimal.valueOf(2));

    errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Hospital Active"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(appService, Mockito.times(2)).getPerDiemRate("BC", "001", admDate);
    Mockito.verify(appService, Mockito.times(2)).getPerDiemRate("BC", "001", disDate);

    // Note: commented because setting province code calls appService too
    // Mockito.verifyZeroInteractions(appService);
  }

  @Test
  public void hospitalNumber_checkPerDiemRate_notChildbirth() throws HoopcException {
    ClaimViewModel claim = emptyClaim();

    // checkPerDiemRate test (not child birth)
    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("001-TestHospital");
    claim.getAdmission().setDischargeDate(LocalDate.now());
    claim.getDiagnosisCodes()[0] = "NotChildBirth";
    claim.getAdmission().setWardRate(2);
    Mockito.when(helper.getRateRange(claim)).thenReturn(new ArrayList<>());
    Mockito.when(helper.isNewborn("NotChildBirth")).thenReturn(false);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Perdiem Rate"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    log.info(error.getMessage());

    // Positive test
    claim.setReceivingProvince("BC");
    claim.setHospitalNumberAndName("002-TestHospital");
    claim.getAdmission().setDischargeDate(LocalDate.now());
    claim.getDiagnosisCodes()[0] = "NotChildBirth";

    claim.getAdmission().setWardRate(2);
    Mockito.when(helper.getRateRange(claim))
        .thenReturn(
            new ArrayList<RateRange>() {
              {
                add(
                    new RateRange(
                        LocalDate.MIN, LocalDate.MAX, BigDecimal.valueOf(2.0), RateType.HOSPITAL));
              }
            });
    Mockito.when(helper.isNewborn("NotChildBirth")).thenReturn(false);

    errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Perdiem Rate"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(helper, times(2)).getRateRange(claim);
    // Note: commented because setting province code calls appService too
    // Mockito.verifyZeroInteractions(appService);
  }

  @Test
  public void hospitalNumber_checkPerDiemRate_childbirth() throws HoopcException {
    ClaimViewModel claim = emptyClaim();

    // checkPerDiemRate test (not child birth)
    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("001-TestHospital");
    claim.getAdmission().setDischargeDate(LocalDate.now());
    claim.getDiagnosisCodes()[0] = "ChildBirth";
    claim.getAdmission().setWardRate(2);
    Mockito.when(helper.getRateRange(claim)).thenReturn(new ArrayList<>());
    Mockito.when(helper.isNewborn("ChildBirth")).thenReturn(true);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Perdiem Rate"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    log.info(error.getMessage());

    // Positive test
    claim.setReceivingProvince("BC");
    claim.setHospitalNumberAndName("002-TestHospital");
    claim.getAdmission().setDischargeDate(LocalDate.now());
    claim.getDiagnosisCodes()[0] = "ChildBirth";
    claim.getAdmission().setWardRate(2);
    Mockito.when(helper.getRateRange(claim))
        .thenReturn(
            new ArrayList<RateRange>() {
              {
                add(
                    new RateRange(
                        LocalDate.MIN, LocalDate.MAX, BigDecimal.valueOf(2.0), RateType.SERVICE));
              }
            });
    Mockito.when(helper.isNewborn("ChildBirth")).thenReturn(true);

    errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Perdiem Rate"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    // Note: commented because setting province code calls appService too
    // Mockito.verifyZeroInteractions(appService);
    Mockito.verify(helper, times(2)).getRateRange(claim);
  }

  @Test
  public void totalAmountClaimed_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setTotalAmountClaimed(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Total Amount Claimed"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setTotalAmountClaimed(new BigDecimal(1.0));
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Total Amount Claimed"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  // CHECKINPATIENTTOTALAMT
  @Test
  public void totalAmountClaimed_checkTotalAmout() {
    ClaimViewModel claim = emptyClaim();

    LocalDate admission = LocalDate.of(2019, 01, 01);
    LocalDate discharge = LocalDate.of(2019, 01, 02);

    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("001");
    claim.getAdmission().setAdmissionDate(admission);
    claim.getAdmission().setDischargeDate(discharge);
    claim.getDiagnosisCodes()[0] = "NotChildBirth";
    claim.setTotalAmountClaimed(BigDecimal.valueOf(0.0));

    Mockito.when(helper.calculateTotalAmout(claim)).thenReturn(BigDecimal.ONE, BigDecimal.TEN);

    List<ValidationError> errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect one error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Total Amout"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    claim.setTotalAmountClaimed(BigDecimal.valueOf(10.0));

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Total Amout"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(helper, times(2)).calculateTotalAmout(claim);
  }

  @Test
  public void CodingScheme_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setIcdCodingScheme(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Coding Scheme"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setIcdCodingScheme("ICD10");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Coding Scheme"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void CodingScheme_InSet() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In Set test
    // Province must be BC
    claim.setIcdCodingScheme("ICD09");
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Coding Scheme"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_SET))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setIcdCodingScheme("ICD10");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Coding Scheme"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void AccidentCode_Lookup() {
    ClaimViewModel claim = emptyClaim();

    // lookup test
    claim.setAccidentCode("12");
    Mockito.when(appService.getClaimDetailCodes("12", ClaimDetailCodePurpose.DIAGNOSTIC))
        .thenReturn(new ArrayList<ClaimDetailCodes>());
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one lookup error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Accident Code"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.LOOKUP_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService).getDiagnosticCode("12");

    // Positive test
    claim.setAccidentCode("111");
    Mockito.when(appService.getDiagnosticCode("111"))
        .thenReturn(
            new ClaimDetailCodes() {
              {
                setCodeValue("111");
                setCodePurpose("PROCEDURE");
              }
            });
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Accident Code"))
            .findFirst()
            .orElse(null);
    assertNull(error);
    Mockito.verify(appService).getDiagnosticCode("111");
  }

  @Test
  public void AccidentInd_checkIncidentCodeIndicator() {
    ClaimViewModel claim = emptyClaim();

    // test case 1
    claim.setAccidentCode("12");
    claim.setAccidentIndicator("N");

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Accident Indicator"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // test case 2
    claim.setAccidentCode(null);
    claim.setAccidentIndicator("Y");

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Accident Indicator"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test 1
    claim.setAccidentCode("123");
    claim.setAccidentIndicator("Y");

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Accident Indicator"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    // Positive test 2
    claim.setAccidentCode("");
    claim.setAccidentIndicator(null);

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Accident Indicator"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void submissionDate_InDateRage() {
    ClaimViewModel claim = emptyClaim();

    // Failed InRageTest
    claim.setSubmissionDate(LocalDate.now());
    claim.getAdmission().setDischargeDate(LocalDate.now().plusDays(1));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Discharge Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_RANGE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setSubmissionDate(LocalDate.now());
    claim.getAdmission().setDischargeDate(LocalDate.now());

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Submission Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void ReaonInBc_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setReasonInBC(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Reason In BC"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setReasonInBC("Reason");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Reason In BC"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void submissionDate_checkYearOldClaim() {
    ClaimViewModel claim = emptyClaim();

    // Failed Test
    claim.setSubmissionDate(LocalDate.of(2020, 04, 10));
    claim.getAdmission().setDischargeDate(LocalDate.of(2019, 04, 30));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Submission Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setSubmissionDate(LocalDate.of(2020, 04, 10));
    claim.getAdmission().setDischargeDate(LocalDate.of(2019, 05, 01));

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Submission Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void override_checkOverrideRequestReason() {
    ClaimViewModel claim = emptyClaim();

    // Failed Test
    claim.getClaimOverride().setOverrideRequest(true);
    claim.getClaimOverride().setOverrideRequestReason("");

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Override Request Reason"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test 1
    claim.getClaimOverride().setOverrideRequest(true);
    claim.getClaimOverride().setOverrideRequestReason("Reason");

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Override Request Reason"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    // Positive test 2
    claim.getClaimOverride().setOverrideRequest(false);
    claim.getClaimOverride().setOverrideRequestReason("Reason");

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Override Request Reason"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void OverrideStatus_InSet() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In Set test
    claim.getClaimOverride().setOverrideStatus("NOTVALID");

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Override Status"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_SET))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getClaimOverride().setOverrideStatus("REQUESTED");

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Override Status"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void override_checkOverrideStatusReason() {
    ClaimViewModel claim = emptyClaim();

    // Failed Test
    claim.getClaimOverride().setOverrideStatus(OverrideStatus.APPROVED.toString());
    claim.getClaimOverride().setOverrideStatusReason("");

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Override Status Reason"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test 1
    claim.getClaimOverride().setOverrideStatus(OverrideStatus.REQUESTED.toString());
    claim.getClaimOverride().setOverrideStatusReason("");

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Override Status Reason"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    // Positive test 2
    claim.getClaimOverride().setOverrideStatus(OverrideStatus.APPROVED.toString());
    claim.getClaimOverride().setOverrideStatusReason("Reason");

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Override Status Reason"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }
}
