package ca.bc.gov.health.validation.claim;

import ca.bc.gov.health.constants.ClaimType;
import ca.bc.gov.health.database.entity.Admissions;
import ca.bc.gov.health.database.entity.AppUserAuthorizations;
import ca.bc.gov.health.database.entity.ApplicationUsers;
import ca.bc.gov.health.database.entity.ClaimContents;
import ca.bc.gov.health.database.entity.ClaimDetailCodes;
import ca.bc.gov.health.database.entity.ClaimTypes;
import ca.bc.gov.health.database.entity.HospitalOopClaims;
import ca.bc.gov.health.database.entity.HospitalPerDiemRates;
import ca.bc.gov.health.database.entity.Hospitals;
import ca.bc.gov.health.database.entity.Patients;
import ca.bc.gov.health.database.entity.ProvincesTerritories;
import ca.bc.gov.health.database.entity.ServiceRates;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.viewmodel.AdmissionsViewModel;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.PatientsViewModel;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.mockito.ArgumentMatchers.any;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

public class ClaimValidatorHelperTest {

  @InjectMocks private ClaimValidatorHelper helper;

  @Mock private HoopcAppService appService;

  private static String PROVINCE_TEST = "BC";
  private static String HOSPITAL_TEST_1 = "001";
  private static String HOSPITAL_TEST_2 = "002";

  @BeforeEach
  public void initMocks() {
    MockitoAnnotations.initMocks(this);
  }

  @Test
  public void calculateTotalAmout_sameDay() {

    ClaimViewModel claim = createRITestClaim(LocalDate.of(2000, 1, 1), LocalDate.of(2000, 1, 1));
    Mockito.when(appService.getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1))
        .thenReturn(createTestRates());

    BigDecimal total = helper.calculateTotalAmout(claim);

    assertNotNull(total);
    assertEquals(BigDecimal.valueOf(10), total);

    Mockito.verify(appService).getNewbornCode(any(String.class));
    Mockito.verify(appService).getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1);
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void calculateTotalAmout_oneDay() {

    ClaimViewModel claim = createRITestClaim(LocalDate.of(2000, 1, 1), LocalDate.of(2000, 1, 2));

    Mockito.when(appService.getNewbornCode(any(String.class))).thenReturn(null);
    Mockito.when(appService.getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1))
        .thenReturn(createTestRates());

    BigDecimal total = helper.calculateTotalAmout(claim);

    assertNotNull(total);
    assertEquals(BigDecimal.valueOf(10), total);

    Mockito.verify(appService).getNewbornCode(any(String.class));
    Mockito.verify(appService).getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1);
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void calculateTotalAmout_oneRange() {

    ClaimViewModel claim = createRITestClaim(LocalDate.of(2000, 1, 1), LocalDate.of(2000, 1, 3));

    Mockito.when(appService.getNewbornCode(any(String.class))).thenReturn(null);
    Mockito.when(appService.getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1))
        .thenReturn(createTestRates());

    BigDecimal total = helper.calculateTotalAmout(claim);

    assertNotNull(total);
    assertEquals(BigDecimal.valueOf(20), total);

    Mockito.verify(appService).getNewbornCode(any(String.class));
    Mockito.verify(appService).getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1);
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void calculateTotalAmout_twoRange() {

    ClaimViewModel claim = createRITestClaim(LocalDate.of(2000, 1, 1), LocalDate.of(2000, 1, 12));

    Mockito.when(appService.getNewbornCode(any(String.class))).thenReturn(null);
    Mockito.when(appService.getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1))
        .thenReturn(createTestRates());

    BigDecimal total = helper.calculateTotalAmout(claim);

    assertNotNull(total);
    // 10 days at 10 + 1 day at 15 = 105
    assertEquals(BigDecimal.valueOf(115), total);

    Mockito.verify(appService).getNewbornCode(any(String.class));
    Mockito.verify(appService).getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1);
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void calculateTotalAmout_twoRange_special() {
    // If discharge date = start of second range, do not count discharge date
    ClaimViewModel claim = createRITestClaim(LocalDate.of(2000, 1, 1), LocalDate.of(2000, 1, 11));

    Mockito.when(appService.getNewbornCode(any(String.class))).thenReturn(null);
    Mockito.when(appService.getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1))
        .thenReturn(createTestRates());

    BigDecimal total = helper.calculateTotalAmout(claim);

    assertNotNull(total);
    // 10 days at 10
    assertEquals(BigDecimal.valueOf(100), total);

    Mockito.verify(appService).getNewbornCode(any(String.class));
    Mockito.verify(appService).getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1);
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void calculateTotalAmout_threeRange() {
    // If discharge date = start of second range, do not count discharge date
    ClaimViewModel claim = createRITestClaim(LocalDate.of(2000, 1, 1), LocalDate.of(2000, 1, 22));

    Mockito.when(appService.getNewbornCode(any(String.class))).thenReturn(null);
    Mockito.when(appService.getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1))
        .thenReturn(createTestRates());

    BigDecimal total = helper.calculateTotalAmout(claim);

    assertNotNull(total);
    // 10 days at 10 + 10 days at 15 + 1 day at 20 = 270
    assertEquals(BigDecimal.valueOf(270), total);

    Mockito.verify(appService).getNewbornCode(any(String.class));
    Mockito.verify(appService).getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1);
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void calculateTotalAmout_withHighCost() {

    ClaimViewModel claim = createRITestClaim(LocalDate.of(2000, 1, 1), LocalDate.of(2000, 1, 3));
    claim.getHighCostProcedures()[0].setProcedureCost(BigDecimal.valueOf(1.1));
    claim.getHighCostProcedures()[1].setProcedureCost(BigDecimal.valueOf(2.2));
    claim.getHighCostProcedures()[2].setProcedureCost(BigDecimal.valueOf(3.3));

    Mockito.when(appService.getNewbornCode(any(String.class))).thenReturn(null);
    Mockito.when(appService.getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1))
        .thenReturn(createTestRates());

    BigDecimal total = helper.calculateTotalAmout(claim);

    assertNotNull(total);
    // 2 days at 10 + 1.1 + 2.2 + 3.3 = 26.6
    assertEquals(BigDecimal.valueOf(26.6), total);

    Mockito.verify(appService).getNewbornCode(any(String.class));
    Mockito.verify(appService).getHospitalRates(PROVINCE_TEST, HOSPITAL_TEST_1);
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void calculateTotalAmout_childbirth() throws HoopcException {

    ClaimViewModel claim = createRITestClaim(LocalDate.of(2000, 1, 1), LocalDate.of(2000, 1, 3));
    claim.getDiagnosisCodes()[0] = "CHILD";

    Mockito.when(appService.getNewbornCode(any(String.class))).thenReturn(new ClaimDetailCodes(1L));
    Mockito.when(appService.getServiceRates(1l)).thenReturn(createServiceRates());

    BigDecimal total = helper.calculateTotalAmout(claim);

    assertNotNull(total);

    // 2 days at 10 = 20.0
    assertEquals(BigDecimal.valueOf(20.0), total);

    Mockito.verify(appService).getNewbornCode(any(String.class));
    Mockito.verify(appService).getServiceRates(1l);
    Mockito.verifyNoMoreInteractions(appService);
  }

  private List<ServiceRates> createServiceRates() {
    return new ArrayList<ServiceRates>() {
      {
        add(
            new ServiceRates() {
              {
                setEffectiveDate(LocalDate.MIN);
                setEndDate(null);
                setRateAmount(BigDecimal.valueOf(10.0));
              }
            });
      }
    };
  }

  private ClaimViewModel createRITestClaim(LocalDate admission, LocalDate discharge) {
    ClaimViewModel ret =
        new ClaimViewModel() {
          {
            // Mandatory values for calculateTotalAmout
            setTreatingProvince(PROVINCE_TEST);
            setHospitalNumberAndName(HOSPITAL_TEST_1);
            setPatient(
                new PatientsViewModel() {
                  {
                    setInsuranceCardNumber("card no");
                    setProvince(PROVINCE_TEST);
                    setBirthDate(LocalDate.now());
                  }
                });
            setClaimType(
                new ClaimTypes() {
                  {
                    setId(10l);
                    setClaimType("INPATIENT");
                  }
                });
            setAdmission(
                new AdmissionsViewModel() {
                  {
                    setAdmissionDate(admission);
                    setDischargeDate(discharge);
                  }
                });
            getDiagnosisCodes()[0] = "NotChildBirth";
          }
        };
    return ret;
  }

  private ClaimViewModel createROTestClaim(LocalDate serviceDate) {
    ClaimViewModel ret =
        new ClaimViewModel() {
          {
            // Mandatory values for calculateTotalAmout
            setTreatingProvince(PROVINCE_TEST);
            setHospitalNumberAndName(HOSPITAL_TEST_1);
            setPatient(
                new PatientsViewModel() {
                  {
                    setInsuranceCardNumber("card no");
                    setProvince(PROVINCE_TEST);
                    setBirthDate(LocalDate.now());
                  }
                });
            setClaimType(
                new ClaimTypes() {
                  {
                    setId(20l);
                    setClaimType("OUTPATIENT");
                  }
                });
            setServiceDate(serviceDate);
            setServiceCodeValue("12");
          }
        };
    return ret;
  }

  private List<HospitalPerDiemRates> createTestRates() {
    return new ArrayList<HospitalPerDiemRates>() {
      {
        add(
            new HospitalPerDiemRates() {
              {
                setEffectiveDate(LocalDate.of(2000, 1, 1));
                setEndDate(LocalDate.of(2000, 1, 10));
                setPerDiemRate(BigDecimal.valueOf(10));
              }
            });
        add(
            new HospitalPerDiemRates() {
              {
                setEffectiveDate(LocalDate.of(2000, 1, 11));
                setEndDate(LocalDate.of(2000, 1, 20));
                setPerDiemRate(BigDecimal.valueOf(15));
              }
            });
        add(
            new HospitalPerDiemRates() {
              {
                setEffectiveDate(LocalDate.of(2000, 1, 21));
                setEndDate(null);
                setPerDiemRate(BigDecimal.valueOf(20));
              }
            });
      }
    };
  }

  @Test
  public void isConflictOutpatient() {

    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    assertTrue(helper.isConflictOutpatient(admissionDate, dischargeDate, admissionDate.plusDays(1)));
    assertTrue(helper.isConflictOutpatient(admissionDate, dischargeDate, dischargeDate.minusDays(1)));
    assertFalse(helper.isConflictOutpatient(admissionDate, dischargeDate, admissionDate));
    assertFalse(helper.isConflictOutpatient(admissionDate, dischargeDate, dischargeDate));
    assertFalse(helper.isConflictOutpatient(admissionDate, dischargeDate, admissionDate.minusDays(1)));
    assertFalse(helper.isConflictOutpatient(admissionDate, dischargeDate, dischargeDate.plusDays(1)));
  }

  @Test
  public void isConflictInpatient() {

    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);
    
    /* Conflict = c2.admission < c1.admission && c2.discharge > c1.discharge */
    assertTrue(helper.isConflictInpatient(
            admissionDate, dischargeDate,
            admissionDate.minusDays(1), dischargeDate.plusDays(1),
            "", ""   // hospital numbers don't matter here
    ));
    
    /* Conflict = c2.admission > c1.admission && c2.discharge >= c1.discharge && c2.discharge < c1.admission */
    assertTrue(helper.isConflictInpatient(
            admissionDate, dischargeDate,
            admissionDate.plusDays(1), dischargeDate.plusDays(1),
            "", ""   // hospital numbers don't matter here
    ));
    
    /* Conflict = c2.admission <= c1.admission && c2.admission > c1.discharge && c2.discharge < c1.discharge */
    assertTrue(helper.isConflictInpatient(
            admissionDate, dischargeDate,
            admissionDate.minusDays(1), dischargeDate.minusDays(1),
            "", ""   // hospital numbers don't matter here
    ));
    
    /* Conflict = c2.admission > c1.admission && c2.discharge < c1.discharge */
    assertTrue(helper.isConflictInpatient(
        admissionDate, dischargeDate,
        admissionDate.plusDays(1), dischargeDate.minusDays(1),
        "", ""   // hospital numbers don't matter here
    ));
    
    /* Conflict = c2.admission = c1.admission && c2.discharge = c1.discharge && hospitalNumber1 != hospitalNumber2 */
    assertTrue(helper.isConflictInpatient(
            admissionDate, dischargeDate,
            admissionDate, dischargeDate,
            HOSPITAL_TEST_1,
            HOSPITAL_TEST_2
    ));

    /* No Conflict = c2.admission > c1.discharge (c2 happens after c1) */
    assertFalse(helper.isConflictInpatient(
            admissionDate, dischargeDate,
            dischargeDate.plusDays(1), dischargeDate.plusDays(5),
            "", ""   // hospital numbers don't matter here
    ));

    /* No Conflict: c2.discharge < c1.admission (c2 happens before c1) */
    assertFalse(helper.isConflictInpatient(
            admissionDate, dischargeDate,
            admissionDate.minusDays(10), admissionDate.minusDays(1),
            "", ""   // hospital numbers don't matter here
    ));
  }

  @Test
  public void findInpatConflictingClaims_NoConflict() {
    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    ClaimViewModel claim = createRITestClaim(admissionDate, dischargeDate);

    // No matching claims found
    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(new ArrayList<HospitalOopClaims>());

    List<HospitalOopClaims> conflict = helper.findInpatConflictingClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findInpatConflictingClaims_NoConflict_Inpatient() {
    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    ClaimViewModel claim = createRITestClaim(admissionDate, dischargeDate);

    // finds an inpatient claim with admission overlapping
    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                HospitalOopClaims nonConflictClaim = createInPatClaim(admissionDate.minusDays(1), admissionDate);
                nonConflictClaim.setHspId(new Hospitals(Long.valueOf(HOSPITAL_TEST_1)));
                add(nonConflictClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findInpatConflictingClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findInpatConflictingClaims_Conflict_Inpatient() {
    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    ClaimViewModel claim = createRITestClaim(admissionDate, dischargeDate);

    // finds an inpatient claim with serviceDate conflicting
    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                HospitalOopClaims conflictClaim = createInPatClaim(admissionDate.plusDays(1), dischargeDate.plusDays(1));
                conflictClaim.setHspId(new Hospitals(Long.valueOf(HOSPITAL_TEST_1)));
                add(conflictClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findInpatConflictingClaims(claim);

    assertNotNull(conflict);
    assertFalse(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findInpatConflictingClaims_NoConflict_Outpatient() {
    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    ClaimViewModel claim = createRITestClaim(admissionDate, dischargeDate);

    // finds an inpatient claim with admission not overlapping
    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(createOutPatClaim(admissionDate));
              }
            });

    List<HospitalOopClaims> conflict = helper.findInpatConflictingClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findInpatConflictingClaims_Conflict_Outpatient() {
    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    ClaimViewModel claim = createRITestClaim(admissionDate, dischargeDate);

    // finds an outpatient claim with serviceDate conflicting
    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                HospitalOopClaims conflictClaim = createOutPatClaim(admissionDate.plusDays(1));
                conflictClaim.setHspId(new Hospitals(Long.valueOf(HOSPITAL_TEST_1), HOSPITAL_TEST_1, "", LocalDate.now(), ""));
                add(conflictClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findInpatConflictingClaims(claim);

    assertNotNull(conflict);
    assertFalse(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  private HospitalOopClaims createInPatClaim(LocalDate admissionDate, LocalDate dischargeDate) {

    return new HospitalOopClaims() {
      {
        setId(666L);
        setCtsId(
            new ClaimTypes() {
              {
                setId(10l);
                setClaimType("INPATIENT");
              }
            });
        setAdmissionsList(
            new ArrayList<Admissions>() {
              {
                add(
                    new Admissions() {
                      {
                        setAdmissionDate(admissionDate);
                        setDischargeDate(dischargeDate);
                      }
                    });
              }
            });
      }
    };
  }

  private HospitalOopClaims createOutPatClaim(LocalDate serviceDate) {
    return new HospitalOopClaims() {
      {
        setId(666L);
        setCtsId(
            new ClaimTypes() {
              {
                setId(20l);
                setClaimType("OUTPATIENT");
              }
            });
        setServiceDate(serviceDate);
      }
    };
  }

  @Test
  public void findInpatDuplicateClaims_Duplicate() {
    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    ClaimViewModel claim = createRITestClaim(admissionDate, dischargeDate);
    HospitalOopClaims matchClaim = createMatchingClaim(claim);

    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(matchClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findInpatDuplicateClaims(claim);

    assertNotNull(conflict);
    assertFalse(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findInpatDuplicateClaims_Duplicate_treatingProvince() {
    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    ClaimViewModel claim = createRITestClaim(admissionDate, dischargeDate);
    HospitalOopClaims matchClaim = createMatchingClaim(claim);

    // Change the treating province
    claim.setTreatingProvince("BOB");

    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(matchClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findInpatDuplicateClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findInpatDuplicateClaims_Duplicate_hospital() {
    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    ClaimViewModel claim = createRITestClaim(admissionDate, dischargeDate);
    HospitalOopClaims matchClaim = createMatchingClaim(claim);

    // Change the hospital
    claim.setHospitalNumberAndName("BOB");

    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(matchClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findInpatDuplicateClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findInpatDuplicateClaims_Duplicate_admissionDate() {
    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    ClaimViewModel claim = createRITestClaim(admissionDate, dischargeDate);
    HospitalOopClaims matchClaim = createMatchingClaim(claim);

    // Change the hospital
    claim.getAdmission().setAdmissionDate(dischargeDate);

    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(matchClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findInpatDuplicateClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findInpatDuplicateClaims_Duplicate_claimType() {
    LocalDate admissionDate = LocalDate.of(2019, 5, 1);
    LocalDate dischargeDate = LocalDate.of(2019, 5, 10);

    ClaimViewModel claim = createRITestClaim(admissionDate, dischargeDate);
    HospitalOopClaims matchClaim = createMatchingClaim(claim);

    // Change claimtype
    claim.setClaimType(
        new ClaimTypes() {
          {
            setId(99L);
          }
        });

    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(matchClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findInpatDuplicateClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findOutpatDuplicateClaims_Duplicate() {
    LocalDate serviceDate = LocalDate.of(2019, 5, 1);
    ClaimViewModel claim = createROTestClaim(serviceDate);
    HospitalOopClaims matchClaim = createMatchingClaim(claim);

    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(matchClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findOutpatDuplicateClaims(claim);

    assertNotNull(conflict);
    assertFalse(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findOutpatDuplicateClaims_Duplicate_treatingProvince() {
    LocalDate serviceDate = LocalDate.of(2019, 5, 1);
    ClaimViewModel claim = createROTestClaim(serviceDate);
    HospitalOopClaims matchClaim = createMatchingClaim(claim);

    // Change the treating province
    claim.setTreatingProvince("BOB");

    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(matchClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findOutpatDuplicateClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findOutpatDuplicateClaims_Duplicate_hospital() {
    LocalDate serviceDate = LocalDate.of(2019, 5, 1);
    ClaimViewModel claim = createROTestClaim(serviceDate);
    HospitalOopClaims matchClaim = createMatchingClaim(claim);

    // Change the hospital
    claim.setHospitalNumberAndName("BOB");

    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(matchClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findOutpatDuplicateClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findOutpatDuplicateClaims_Duplicate_admissionDate() {
    LocalDate serviceDate = LocalDate.of(2019, 5, 1);
    ClaimViewModel claim = createROTestClaim(serviceDate);
    HospitalOopClaims matchClaim = createMatchingClaim(claim);

    // Change the service
    claim.setServiceDate(serviceDate.plusDays(1));

    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(matchClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findOutpatDuplicateClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findOutpatDuplicateClaims_Duplicate_claimType() {
    LocalDate serviceDate = LocalDate.of(2019, 5, 1);
    ClaimViewModel claim = createROTestClaim(serviceDate);
    HospitalOopClaims matchClaim = createMatchingClaim(claim);

    // Change claimtype
    claim.setClaimType(
        new ClaimTypes() {
          {
            setId(99L);
          }
        });

    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(matchClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findOutpatDuplicateClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  private HospitalOopClaims createMatchingClaim(ClaimViewModel claim) {
    return new HospitalOopClaims() {
      {
        // same treating province
        setTreatingPteId(
            new ProvincesTerritories() {
              {
                setProvinceCode(claim.getTreatingProvince());
              }
            });
        // same hospital
        setHspId(
            new Hospitals() {
              {
                setHospitalNumber(claim.getHospitalNumber());
              }
            });
        // Different ID
        setId(666L);
        // SameType
        setCtsId(claim.getClaimType());
        // Same service date
        if (claim.getClaimType().getClaimType().equals(ClaimType.INPATIENT.toString())) {
          setServiceDate(claim.getAdmission().getAdmissionDate());
        } else {
          setServiceDate(claim.getServiceDate());
        }
        // Same patient
        setPatId(
            new Patients() {
              {
                setBirthDate(claim.getPatient().getBirthDate());
                setProvince(claim.getPatient().getProvince());
                setInsuranceCardNumber(claim.getPatient().getInsuranceCardNumber());
              }
            });
        setClaimContentsList(
            new ArrayList<ClaimContents>() {
              {
                // Same diagnostic code
                add(
                    new ClaimContents() {
                      {
                        setCdcId(
                            new ClaimDetailCodes() {
                              {
                                setId(1l);
                                setCodeValue(claim.getMainDiagnosisCode());
                              }
                            });
                      }
                    });

                if (claim.getClaimType().getClaimType().equals(ClaimType.OUTPATIENT.toString())) {
                  // Same service code
                  add(
                      new ClaimContents() {
                        {
                          setCdcId(
                              new ClaimDetailCodes() {
                                {
                                  setId(1l);
                                  setCodeValue(claim.getServiceCodeValue());
                                  setCodeType("SERVICE");
                                }
                              });
                        }
                      });
                }
              }
            });
        if (claim.getAdmission() != null) {
          setAdmissionsList(
              new ArrayList<Admissions>() {
                {
                  add(
                      new Admissions() {
                        {
                          setAdmissionDate(claim.getAdmission().getAdmissionDate());
                          setDischargeDate(claim.getAdmission().getDischargeDate());
                        }
                      });
                }
              });
        }
      }
    };
  }

  @Test
  public void findOutpatConflictingClaims_NoConflict() {
    LocalDate serviceDate = LocalDate.of(2019, 5, 1);
    ClaimViewModel claim = createROTestClaim(serviceDate);

    // No matching claims found
    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(new ArrayList<HospitalOopClaims>());

    List<HospitalOopClaims> conflict = helper.findOutpatConflictingClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findOutpatConflictingClaims_Conflict_Inpatient() {
    LocalDate serviceDate = LocalDate.of(2019, 5, 1);
    ClaimViewModel claim = createROTestClaim(serviceDate);

    // finds an inpatient claim with admission overlapping
    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                HospitalOopClaims conflictClaim = createInPatClaim(serviceDate.minusDays(1), serviceDate.plusDays(1));
                conflictClaim.setHspId(new Hospitals(Long.valueOf(HOSPITAL_TEST_1), HOSPITAL_TEST_1, "", LocalDate.now(), ""));
                add(conflictClaim);
              }
            });

    List<HospitalOopClaims> conflict = helper.findOutpatConflictingClaims(claim);

    assertNotNull(conflict);
    assertFalse(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void findOutpatConflictingClaims_NoConflict_Inpatient() {
    LocalDate serviceDate = LocalDate.of(2019, 5, 1);
    ClaimViewModel claim = createROTestClaim(serviceDate);

    // finds an inpatient claim with admission overlapping
    Mockito.when(
            appService.findClaimsForPatient(
                any(String.class), any(String.class), any(LocalDate.class)))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(createInPatClaim(serviceDate.plusDays(1), serviceDate.plusDays(2)));
              }
            });

    List<HospitalOopClaims> conflict = helper.findOutpatConflictingClaims(claim);

    assertNotNull(conflict);
    assertTrue(conflict.isEmpty());

    Mockito.verify(appService)
        .findClaimsForPatient(any(String.class), any(String.class), any(LocalDate.class));
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void isUserAutorized_user_inactive() {
    Hospitals hospital =
        new Hospitals() {
          {
            setId(1l);
            setProvince(PROVINCE_TEST);
            setHospitalNumber(HOSPITAL_TEST_1);
          }
        };
    // create an inactive user
    ApplicationUsers appUser =
        new ApplicationUsers() {
          {
            setApplicationRole("MINISTRY");
            setApplicationUserid("User");
            setAccessEffectiveDate(LocalDate.now().minusDays(2));
            setAccessEndDate(LocalDate.now().minusDays(1));
          }
        };

    boolean ret = helper.isUserAuthorized(appUser, hospital);

    assertFalse(ret);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void isUserAutorized_MINISTRY() {
    Hospitals hospital =
        new Hospitals() {
          {
            setId(1l);
            setProvince(PROVINCE_TEST);
            setHospitalNumber(HOSPITAL_TEST_1);
          }
        };
    // create an active MINISTRY user
    ApplicationUsers appUser =
        new ApplicationUsers() {
          {
            setApplicationRole("MINISTRY");
            setApplicationUserid("User");
            setAccessEffectiveDate(LocalDate.now());
            setAccessEndDate(null);
          }
        };

    boolean ret = helper.isUserAuthorized(appUser, hospital);

    assertTrue(ret);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void isUserAutorized_HOSPITAL() {
    Hospitals hospital =
        new Hospitals() {
          {
            setId(1l);
            setProvince(PROVINCE_TEST);
            setHospitalNumber(HOSPITAL_TEST_1);
          }
        };
    // create an active AppUserAuthorizations
    AppUserAuthorizations appUserAuth =
        new AppUserAuthorizations() {
          {
            setHspId(hospital);
            setEffectiveDate(LocalDate.now());
            setEndDate(null);
          }
        };
    // create an active HOSPITAL user
    ApplicationUsers appUser =
        new ApplicationUsers() {
          {
            setAppUserAuthorizationsList(
                new ArrayList<AppUserAuthorizations>() {
                  {
                    add(appUserAuth);
                  }
                });
            setApplicationRole("HOSPITAL");
            setApplicationUserid("User");
            setAccessEffectiveDate(LocalDate.now());
            setAccessEndDate(null);
          }
        };

    boolean ret = helper.isUserAuthorized(appUser, hospital);

    assertTrue(ret);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void isUserAutorized_HOSPITAL_inactive() {
    Hospitals hospital =
        new Hospitals() {
          {
            setId(1l);
            setProvince(PROVINCE_TEST);
            setHospitalNumber(HOSPITAL_TEST_1);
          }
        };
    // create an inactive AppUserAuthorizations
    AppUserAuthorizations appUserAuth =
        new AppUserAuthorizations() {
          {
            setHspId(hospital);
            setEffectiveDate(LocalDate.now().minusDays(2));
            setEndDate(LocalDate.now().minusDays(1));
          }
        };
    // create an active HOSPITAL user
    ApplicationUsers appUser =
        new ApplicationUsers() {
          {
            setAppUserAuthorizationsList(
                new ArrayList<AppUserAuthorizations>() {
                  {
                    add(appUserAuth);
                  }
                });
            setApplicationRole("HOSPITAL");
            setApplicationUserid("User");
            setAccessEffectiveDate(LocalDate.now());
            setAccessEndDate(null);
          }
        };

    boolean ret = helper.isUserAuthorized(appUser, hospital);

    assertFalse(ret);

    Mockito.verifyNoMoreInteractions(appService);
  }
}
