package ca.bc.gov.health.validation.claim;

import ca.bc.gov.health.database.entity.ProvincesTerritories;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.PatientsViewModel;
import ca.bc.gov.health.validation.ValidationError;
import ca.bc.gov.health.validation.rule.ValidationRuleType;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import static org.mockito.Mockito.atLeast;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Test Validation rules for INSERTNONRESINPATPATIENTINFO in
 * InsertNROClaimValidator.insertNROPatientRules()
 */
public class InsertNROPatientValidatorTest {

  // TODO: Setup debug logger
  private static Logger log = LoggerFactory.getLogger(InsertNROPatientValidatorTest.class);

  @InjectMocks private InsertNROClaimValidator validator;

  @InjectMocks private ClaimValidatorComplexRules complexRules;

  @Mock private HoopcAppService appService;

  @Mock private ClaimValidatorHelper helper;

  @BeforeEach
  public void initMocks() {
    MockitoAnnotations.initMocks(this);
    validator.setComplexRules(complexRules);
  }

  private ClaimViewModel emptyClaim() {
    ClaimViewModel claim = new ClaimViewModel();
    claim.setPatient(new PatientsViewModel());
    claim.setDiagnosisCodes(new String[] {"", "", ""});
    return claim;
  }

  // ===========================================================================================
  // Patient rules
  // ===========================================================================================
  @Test
  public void insuranceCardNumber_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setInsuranceCardNumber(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Insurance Number"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setInsuranceCardNumber("123");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Insurance Number"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void lastName_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setLastName(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Last Name"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setLastName("Kirk");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Last Name"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void firstName_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setFirstName(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("First Name"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setFirstName("James");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("First Name"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void province_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setProvince(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setProvince("AB");
    Mockito.when(appService.getProvince("AB")).thenReturn(new ProvincesTerritories());

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(appService).getProvince("AB");
  }

  @Test
  public void province_InSet() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In Set test
    // Province must be BC
    claim.getPatient().setProvince("BC");
    Mockito.when(appService.getProvince("BC")).thenReturn(new ProvincesTerritories());
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.NOT_IN_SET))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService).getProvince("BC");

    // Positive test
    claim.getPatient().setProvince("AB");
    Mockito.when(appService.getProvince("AB")).thenReturn(new ProvincesTerritories());

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(appService).getProvince("AB");
  }

  @Test
  public void postalCode_Format() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Format test
    claim.getPatient().setPostalCode("123456");
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one format error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("checkPostalCodeFormat"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setPostalCode("X0X0X0");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("checkPostalCodeFormat"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void postalCode_Prefix() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Prefix test
    claim.getPatient().setPostalCode("X0X0X0");
    claim.getPatient().setProvince("AB");
    Mockito.when(appService.getProvince("AB"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setProvinceCode("AB");
                setPostalCodePrefix("T");
              }
            });
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one complex error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("checkPostalCodePrefix"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService, atLeast(1)).getProvince("AB");

    // Positive test
    claim.getPatient().setPostalCode("X0X0X0");
    claim.getPatient().setProvince("NU");
    Mockito.when(appService.getProvince("NU"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setProvinceCode("NU");
                setPostalCodePrefix("X");
              }
            });
    errors = validator.validate(claim);
    assertNotNull(errors);
    Mockito.verify(appService, atLeast(1)).getProvince("NU");

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Postal Code"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void birthDate_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setBirthDate(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setBirthDate(LocalDate.now());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void birthDate_InRange() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In_Range test
    // birthDate <= serviceDate
    claim.getPatient().setBirthDate(LocalDate.now());
    claim.setServiceDate(LocalDate.now().minusDays(1));
    
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one in range error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_RANGE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setBirthDate(LocalDate.now());
    claim.setServiceDate(LocalDate.now());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void sex_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.getPatient().setSexCode(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Sex"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setSexCode("M");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Sex"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void insuranceExpiry_inRange() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In_Range test
    // expiryDate <= dischageDate
    claim.getPatient().setCardExpiryDate(LocalDate.now());
    claim.setServiceDate(LocalDate.now().plusDays(1));
    
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one in range error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Insurance Card Expiry Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_RANGE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setCardExpiryDate(LocalDate.now());
    claim.setServiceDate(LocalDate.now());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Insurance Card Expiry Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  /** Test with province with no expiry */
  @Test
  public void insuranceExpiry_Mandatory_noExpiry() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    claim.getPatient().setCardExpiryDate(null);
    claim.getPatient().setProvince("ON");
    claim.setServiceDate(LocalDate.now());
    
    Mockito.when(appService.getProvince("ON"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setInsuranceExpiresInd("N");
              }
            });
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Insurance Expiry"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(appService, atLeast(1)).getProvince("ON");
  }

  /** Test with province with expiry, but with treatment date before expiry implementation */
  @Test
  public void insuranceExpiry_Mandatory_beforeExpiry() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    claim.getPatient().setCardExpiryDate(null);
    claim.getPatient().setProvince("ON");
    claim.setServiceDate(LocalDate.now().minusDays(1));
    
    Mockito.when(appService.getProvince("ON"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setInsuranceExpiresInd("Y");
                setInsuranceExpiryImpltnDate(LocalDate.now());
              }
            });
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Insurance Expiry"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(appService, atLeast(1)).getProvince("ON");
  }

  /** Test with province with expiry, but with treatment date before expiry implementation */
  @Test
  public void insuranceExpiry_Mandatory_afterExpiry() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    claim.getPatient().setCardExpiryDate(null);
    claim.getPatient().setProvince("ON");
    claim.setServiceDate(LocalDate.now());
    
    Mockito.when(appService.getProvince("ON"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setInsuranceExpiresInd("Y");
                setInsuranceExpiryImpltnDate(LocalDate.now());
              }
            });
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Insurance Expiry"))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    Mockito.verify(appService, atLeast(1)).getProvince("ON");
  }
}
