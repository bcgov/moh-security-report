package ca.bc.gov.health.service;

import ca.bc.gov.health.constants.ClaimStatus;
import ca.bc.gov.health.constants.ClaimType;
import ca.bc.gov.health.constants.GlobalConstants;
import static ca.bc.gov.health.constants.GlobalConstants.CLAIM_ADJ_DEC_TYPE;
import static ca.bc.gov.health.constants.GlobalConstants.CLAIM_ADJ_REQ_TYPE;
import ca.bc.gov.health.constants.ResidencyType;
import ca.bc.gov.health.database.entity.ClaimAdjustments;
import ca.bc.gov.health.database.entity.ClaimErrors;
import ca.bc.gov.health.database.entity.ClaimOverrides;
import ca.bc.gov.health.database.entity.ClaimStatusCodes;
import ca.bc.gov.health.database.entity.HospitalOopClaims;
import ca.bc.gov.health.database.entity.ResidencyTypes;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.transformer.ClaimModelTransformer;
import ca.bc.gov.health.transformer.ClaimModelTransformerTestHelper;
import ca.bc.gov.health.validation.ValidationError;
import ca.bc.gov.health.validation.claim.ClaimValidatorFactory;
import ca.bc.gov.health.validation.claim.InsertRIClaimValidator;
import ca.bc.gov.health.validation.rule.MandatoryRule;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.mockito.ArgumentMatchers.any;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

public class ClaimServiceTest {

  @InjectMocks private ClaimService claimService;

  @Mock private HoopcAppService appService;

  @Mock private ClaimModelTransformer claimModelTransformer;

  @Spy private ClaimSearchBuilder searchBuilder;

  @Mock private ClaimValidatorFactory validatorFactory;

  @Mock private InsertRIClaimValidator riValidator;

  @Mock private ClaimEligibilityService eligibilityService;

  @Mock private ClaimPreProcessor preProcessor;

  @Mock private ClaimServiceDao serviceDao;

  @BeforeEach
  public void initMocks() {
    MockitoAnnotations.initMocks(this);
  }

  @Test
  public void loadClaim_RI_Exceptions() throws HoopcException {
    // GIVEN
    Long claimId = 123L;

    doNothing().when(serviceDao).flushCache();
    when(serviceDao.findByClaimId(claimId)).thenThrow(RuntimeException.class);

    // WHEN
    assertThrows(HoopcException.class, () -> claimService.loadClaim(claimId));

    // THEN
    verify(serviceDao).flushCache();
    verify(serviceDao).findByClaimId(claimId);

    verifyNoMoreInteractions(serviceDao, claimModelTransformer);
  }

  @Test
  public void loadClaim_found() throws HoopcException {
    // GIVEN
    Long claimId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims(123L);

    doNothing().when(serviceDao).flushCache();
    when(serviceDao.findByClaimId(claimId)).thenReturn(foundClaim);
    when(claimModelTransformer.claimEntityToView(foundClaim)).thenReturn(new ClaimViewModel());

    // WHEN
    ClaimViewModel claimView = claimService.loadClaim(claimId);

    // THEN
    assertNotNull(claimView);

    verify(serviceDao).flushCache();
    verify(serviceDao).findByClaimId(claimId);
    verify(claimModelTransformer).claimEntityToView(foundClaim);

    verifyNoMoreInteractions(serviceDao, claimModelTransformer);
  }

  @Test
  public void loadClaim_notfound() throws HoopcException {
    // GIVEN
    Long claimId = 123L;

    doNothing().when(serviceDao).flushCache();
    when(serviceDao.findByClaimId(claimId)).thenReturn(null);

    // WHEN
    ClaimViewModel claimView = claimService.loadClaim(claimId);

    // THEN
    assertNull(claimView);

    verify(serviceDao).flushCache();
    verify(serviceDao).findByClaimId(claimId);

    verifyNoMoreInteractions(serviceDao, claimModelTransformer);
  }

  @Test
  public void deleteClaim() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);
    doNothing().when(serviceDao).remove(foundClaim);

    // WHEN
    claimService.deleteClaim(testId);

    // THEN
    verify(serviceDao).findByClaimId(123L);
    verify(serviceDao).remove(foundClaim);

    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void deleteClaim_NotFound() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    when(serviceDao.findByClaimId(testId)).thenReturn(null);

    // WHEN
    claimService.deleteClaim(testId);

    // THEN
    verify(serviceDao).findByClaimId(123L);

    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void deleteClaim_Exceptions() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);
    doThrow(RuntimeException.class).when(serviceDao).remove(foundClaim);

    // WHEN
    assertThrows(HoopcException.class, () -> claimService.deleteClaim(testId));

    // THEN
    verify(serviceDao).findByClaimId(123L);
    verify(serviceDao).remove(foundClaim);

    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void createClaim_RI_Exceptions() throws HoopcException {
    // GIVEN
    ClaimViewModel claimView = createTestClaim(null);

    doNothing().when(claimModelTransformer).claimViewToEntity(any(), any());
    when(serviceDao.addClaim(any())).thenThrow(RuntimeException.class);

    // WHEN
    assertThrows(HoopcException.class, () -> claimService.createClaim(claimView));

    // THEN
    verify(claimModelTransformer).claimViewToEntity(any(), any());
    verify(serviceDao).addClaim(any());

    verifyNoMoreInteractions(serviceDao, claimModelTransformer);
  }

  @Test
  public void createClaim_RI_NoError() throws HoopcException {
    // GIVEN
    ClaimViewModel claimView = createTestClaim(null);
    Long testId = 123L;

    when(serviceDao.addClaim(any())).thenReturn(testId);
    doNothing().when(claimModelTransformer).claimViewToEntity(any(), any());
    when(validatorFactory.createInsertValidator(
            ClaimType.INPATIENT.toString(), ResidencyType.RES.toString()))
        .thenReturn(riValidator);
    when(riValidator.validate(claimView)).thenReturn(new ArrayList<>());
    when(eligibilityService.validateClaimEligiblityAndDemographics(claimView))
        .thenReturn(new ArrayList<>());

    // WHEN
    Long claimId = claimService.createClaim(claimView);

    // THEN
    assertNotNull(claimId);
    assertEquals(testId, claimId);

    verify(serviceDao).addClaim(any());
    verify(claimModelTransformer).claimViewToEntity(any(), any());
    verify(validatorFactory).createInsertValidator(any(), any());

    // verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void createClaim_RI_WithErrors() throws HoopcException {
    // GIVEN
    ClaimViewModel claimView = createTestClaim(null);
    Long testId = 123L;

    when(serviceDao.addClaim(any())).thenReturn(testId);
    doNothing().when(claimModelTransformer).claimViewToEntity(any(), any());
    when(validatorFactory.createInsertValidator(
            ClaimType.INPATIENT.toString(), ResidencyType.RES.toString()))
        .thenReturn(riValidator);
    when(riValidator.validate(claimView))
        .thenReturn(
            new ArrayList<ValidationError>() {
              {
                add(
                    new ValidationError(
                        new MandatoryRule<ClaimViewModel, String>("test", null),
                        "TestMessage",
                        null));
              }
            });
    when(eligibilityService.validateClaimEligiblityAndDemographics(claimView))
        .thenReturn(new ArrayList<>());
    doNothing().when(serviceDao).add(any(ClaimErrors.class));

    // WHEN
    Long claimId = claimService.createClaim(claimView);

    // THEN
    assertNotNull(claimId);
    assertEquals(testId, claimId);

    verify(serviceDao).addClaim(any());
    verify(claimModelTransformer).claimViewToEntity(any(), any());
    verify(validatorFactory).createInsertValidator(any(), any());
    verify(serviceDao).add(any(ClaimErrors.class));

    // verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void saveClaim_RI_Exceptions() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    ClaimViewModel claimView = createTestClaim(testId);
    HospitalOopClaims foundClaim = new HospitalOopClaims(testId);
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    doThrow(RuntimeException.class)
        .when(claimModelTransformer)
        .claimViewToEntity(claimView, foundClaim);

    // WHEN
    assertThrows(HoopcException.class, () -> claimService.saveClaim(claimView));

    // THEN
    verify(serviceDao).findByClaimId(testId);
    verify(claimModelTransformer).claimViewToEntity(claimView, foundClaim);

    verifyNoMoreInteractions(serviceDao, claimModelTransformer);
  }

  @Test
  public void saveClaim_RI_NoError() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    ClaimViewModel claimView = createTestClaim(testId);
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    doNothing().when(claimModelTransformer).claimViewToEntity(any(), any());
    when(validatorFactory.createEditValidator(
            ClaimType.INPATIENT.toString(), ResidencyType.RES.toString()))
        .thenReturn(riValidator);
    when(riValidator.validate(claimView)).thenReturn(new ArrayList<>());
    when(eligibilityService.validateClaimEligiblityAndDemographics(claimView))
        .thenReturn(new ArrayList<>());

    // WHEN
    claimService.saveClaim(claimView);

    // THEN
    verify(serviceDao).findByClaimId(testId);
    verify(claimModelTransformer).claimViewToEntity(claimView, foundClaim);
    verify(validatorFactory).createEditValidator(any(), any());
    verify(serviceDao).save(foundClaim);

    verifyNoMoreInteractions(serviceDao, claimModelTransformer);
  }

  @Test
  public void saveClaim_RI_WithErrors() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    ClaimViewModel claimView = createTestClaim(testId);
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    doNothing().when(claimModelTransformer).claimViewToEntity(any(), any());
    when(validatorFactory.createEditValidator(
            ClaimType.INPATIENT.toString(), ResidencyType.RES.toString()))
        .thenReturn(riValidator);
    when(riValidator.validate(claimView))
        .thenReturn(
            new ArrayList<ValidationError>() {
              {
                add(
                    new ValidationError(
                        new MandatoryRule<ClaimViewModel, String>("test", null),
                        "TestMessage",
                        null));
              }
            });
    when(eligibilityService.validateClaimEligiblityAndDemographics(claimView))
        .thenReturn(new ArrayList<>());
    doNothing().when(serviceDao).add(any(ClaimErrors.class));

    // WHEN
    claimService.saveClaim(claimView);

    // THEN
    verify(serviceDao).findByClaimId(testId);
    verify(claimModelTransformer).claimViewToEntity(claimView, foundClaim);
    verify(validatorFactory).createEditValidator(any(), any());
    verify(serviceDao).add(any(ClaimErrors.class));
    verify(serviceDao).save(foundClaim);

    verifyNoMoreInteractions(serviceDao, claimModelTransformer);
  }

  private ClaimViewModel createTestClaim(Long testId) {
    ClaimViewModel claim = ClaimModelTransformerTestHelper.createViewModel();
    claim.setClaimId(testId);
    return claim;
  }

  private static String OLD_REQ_STATUS = "PENDING";
  private static String NEW_REQ_STATUS = "APPROVED";
  private static String ADJ_REQ_STATUS = "REQUIRED";
  private static LocalDate OLD_REQ_DATE = LocalDate.now();
  private static LocalDate NEW_REQ_DATE = LocalDate.now().plusDays(1);
  private static BigDecimal OLD_REQ_AMOUNT = BigDecimal.ONE;
  private static BigDecimal NEW_REQ_AMOUNT = BigDecimal.TEN;
  private static String OLD_REQ_SOURCE = "MANUAL";
  private static String NEW_REQ_SOURCE = "MOH";

  @Test
  public void saveClaimRequest_NoRequests_defaultStatus() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    ClaimViewModel claimView = createTestClaim(testId);
    claimView.setClaimAdjustmentsRequest(
        new ClaimAdjustments() {
          {
            setAdjustmentDate(NEW_REQ_DATE);
            setAdjustmentStatus(null);
            setAdjustmentType(CLAIM_ADJ_REQ_TYPE);
            setAmount(NEW_REQ_AMOUNT);
            setSource(NEW_REQ_SOURCE);
          }
        });
    // when no existing request
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    foundClaim.setRtsId(new ResidencyTypes(null, "RES", null, null));
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    claimService.saveClaimRequest(claimView);

    // THEN
    verify(serviceDao).findByClaimId(testId);
    // Will create one
    verify(serviceDao).add(any(ClaimAdjustments.class));
    verifyNoMoreInteractions(serviceDao);

    assertNotNull(foundClaim.getClaimAdjustmentsList());
    assertEquals(1, foundClaim.getClaimAdjustmentsList().size());
    ClaimAdjustments newAdjustment = foundClaim.getClaimAdjustmentsList().get(0);
    assertEquals(NEW_REQ_DATE, newAdjustment.getAdjustmentDate());
    assertEquals(ADJ_REQ_STATUS, newAdjustment.getAdjustmentStatus());
    assertEquals(CLAIM_ADJ_REQ_TYPE, newAdjustment.getAdjustmentType());
    assertEquals(NEW_REQ_AMOUNT, newAdjustment.getAmount());
    assertEquals(NEW_REQ_SOURCE, newAdjustment.getSource());
  }

  @Test
  public void saveClaimRequest_NoRequests_status() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    ClaimViewModel claimView = createTestClaim(testId);
    claimView.setClaimAdjustmentsRequest(
        new ClaimAdjustments() {
          {
            setAdjustmentDate(NEW_REQ_DATE);
            setAdjustmentStatus(NEW_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_REQ_TYPE);
            setAmount(NEW_REQ_AMOUNT);
            setSource(NEW_REQ_SOURCE);
          }
        });
    // when no existing request
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    foundClaim.setRtsId(new ResidencyTypes(null, "RES", null, null));
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    claimService.saveClaimRequest(claimView);

    // THEN
    verify(serviceDao).findByClaimId(testId);
    // Will create one
    verify(serviceDao).add(any(ClaimAdjustments.class));
    verifyNoMoreInteractions(serviceDao);

    assertNotNull(foundClaim.getClaimAdjustmentsList());
    assertEquals(1, foundClaim.getClaimAdjustmentsList().size());
    ClaimAdjustments newAdjustment = foundClaim.getClaimAdjustmentsList().get(0);
    assertEquals(NEW_REQ_DATE, newAdjustment.getAdjustmentDate());
    assertEquals(NEW_REQ_STATUS, newAdjustment.getAdjustmentStatus());
    assertEquals(CLAIM_ADJ_REQ_TYPE, newAdjustment.getAdjustmentType());
    assertEquals(NEW_REQ_AMOUNT, newAdjustment.getAmount());
    assertEquals(NEW_REQ_SOURCE, newAdjustment.getSource());
  }

  @Test
  public void saveClaimRequest_existing() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    ClaimViewModel claimView = createTestClaim(testId);
    claimView.setClaimAdjustmentsRequest(
        new ClaimAdjustments() {
          {
            setAdjustmentDate(NEW_REQ_DATE);
            setAdjustmentStatus(NEW_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_REQ_TYPE);
            setAmount(NEW_REQ_AMOUNT);
            setSource(NEW_REQ_SOURCE);
          }
        });
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    foundClaim.setClaimAdjustmentsList(
        new ArrayList<ClaimAdjustments>() {
          {
            add(
                new ClaimAdjustments() {
                  {
                    setAdjustmentDate(OLD_REQ_DATE);
                    setAdjustmentStatus(OLD_REQ_STATUS);
                    setAdjustmentType(CLAIM_ADJ_REQ_TYPE);
                    setAmount(OLD_REQ_AMOUNT);
                    setSource(OLD_REQ_SOURCE);
                  }
                });
          }
        });
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    claimService.saveClaimRequest(claimView);

    // THEN
    verify(serviceDao).findByClaimId(testId);
    // Will create one
    // verify(serviceDao).save(any(ClaimAdjustments.class));
    verifyNoMoreInteractions(serviceDao);

    assertNotNull(foundClaim.getClaimAdjustmentsList());
    assertEquals(1, foundClaim.getClaimAdjustmentsList().size());
    ClaimAdjustments newAdjustment = foundClaim.getClaimAdjustmentsList().get(0);
    // Only source, status and date can change
    assertEquals(NEW_REQ_DATE, newAdjustment.getAdjustmentDate());
    assertEquals(NEW_REQ_STATUS, newAdjustment.getAdjustmentStatus());
    assertEquals(CLAIM_ADJ_REQ_TYPE, newAdjustment.getAdjustmentType());
    assertEquals(OLD_REQ_AMOUNT, newAdjustment.getAmount());
    assertEquals(NEW_REQ_SOURCE, newAdjustment.getSource());
  }

  @Test
  public void deleteClaimRequest() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    foundClaim.setRtsId(new ResidencyTypes(null, "RES", null, null));
    ClaimAdjustments newRequest =
        new ClaimAdjustments() {
          {
            setAdjustmentDate(OLD_REQ_DATE);
            setAdjustmentStatus(OLD_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_REQ_TYPE);
            setAmount(OLD_REQ_AMOUNT);
            setSource(OLD_REQ_SOURCE);
          }
        };
    ClaimAdjustments newDecision =
        new ClaimAdjustments() {
          {
            setAdjustmentDate(OLD_REQ_DATE);
            setAdjustmentStatus(OLD_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_DEC_TYPE);
            setAmount(OLD_REQ_AMOUNT);
            setSource(OLD_REQ_SOURCE);
          }
        };
    foundClaim.setClaimAdjustmentsList(
        new ArrayList<ClaimAdjustments>() {
          {
            add(newRequest);
            add(newDecision);
          }
        });
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    claimService.deleteClaimRequest(testId);

    // THEN
    verify(serviceDao).findByClaimId(testId);
    verify(serviceDao).remove(newRequest);
    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void claimHasRequest_NoRequest() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    ClaimAdjustments newDecision =
        new ClaimAdjustments() {
          {
            setAdjustmentDate(OLD_REQ_DATE);
            setAdjustmentStatus(OLD_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_DEC_TYPE);
            setAmount(OLD_REQ_AMOUNT);
            setSource(OLD_REQ_SOURCE);
          }
        };
    foundClaim.setClaimAdjustmentsList(
        new ArrayList<ClaimAdjustments>() {
          {
            add(newDecision);
          }
        });
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    boolean ret = claimService.claimHasRequest(testId);

    // THEN
    assertFalse(ret);

    verify(serviceDao).findByClaimId(testId);
    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void claimHasRequest_Request() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    ClaimAdjustments newRequest =
        new ClaimAdjustments() {
          {
            setAdjustmentDate(OLD_REQ_DATE);
            setAdjustmentStatus(OLD_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_REQ_TYPE);
            setAmount(OLD_REQ_AMOUNT);
            setSource(OLD_REQ_SOURCE);
          }
        };
    foundClaim.setClaimAdjustmentsList(
        new ArrayList<ClaimAdjustments>() {
          {
            add(newRequest);
          }
        });
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    boolean ret = claimService.claimHasRequest(testId);

    // THEN
    assertTrue(ret);

    verify(serviceDao).findByClaimId(testId);
    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void saveClaimDecision_NoDecisions() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    ClaimViewModel claimView = createTestClaim(testId);
    claimView.setClaimAdjustmentsDecision(
        new ClaimAdjustments() {
          {
            setAdjustmentDate(NEW_REQ_DATE);
            setAdjustmentStatus(NEW_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_DEC_TYPE);
            setAmount(NEW_REQ_AMOUNT);
            setSource(NEW_REQ_SOURCE);
          }
        });
    // when no existing Decision
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    foundClaim.setRtsId(new ResidencyTypes(null, "RES", null, null));
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    claimService.saveClaimDecision(claimView);

    // THEN
    verify(serviceDao).findByClaimId(testId);
    // Will create one
    verify(serviceDao).add(any(ClaimAdjustments.class));
    verifyNoMoreInteractions(serviceDao);

    assertNotNull(foundClaim.getClaimAdjustmentsList());
    assertEquals(1, foundClaim.getClaimAdjustmentsList().size());
    ClaimAdjustments newAdjustment = foundClaim.getClaimAdjustmentsList().get(0);
    assertEquals(NEW_REQ_DATE, newAdjustment.getAdjustmentDate());
    assertEquals(NEW_REQ_STATUS, newAdjustment.getAdjustmentStatus());
    assertEquals(CLAIM_ADJ_DEC_TYPE, newAdjustment.getAdjustmentType());
    assertEquals(NEW_REQ_AMOUNT, newAdjustment.getAmount());
    assertEquals(NEW_REQ_SOURCE, newAdjustment.getSource());
  }

  @Test
  public void saveClaimDecision_existing() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    ClaimViewModel claimView = createTestClaim(testId);
    claimView.setClaimAdjustmentsDecision(
        new ClaimAdjustments() {
          {
            setAdjustmentDate(NEW_REQ_DATE);
            setAdjustmentStatus(NEW_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_DEC_TYPE);
            setAmount(NEW_REQ_AMOUNT);
            setSource(NEW_REQ_SOURCE);
          }
        });
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    foundClaim.setClaimAdjustmentsList(
        new ArrayList<ClaimAdjustments>() {
          {
            add(
                new ClaimAdjustments() {
                  {
                    setAdjustmentDate(OLD_REQ_DATE);
                    setAdjustmentStatus(OLD_REQ_STATUS);
                    setAdjustmentType(CLAIM_ADJ_DEC_TYPE);
                    setAmount(OLD_REQ_AMOUNT);
                    setSource(OLD_REQ_SOURCE);
                  }
                });
          }
        });
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    claimService.saveClaimDecision(claimView);

    // THEN
    verify(serviceDao).findByClaimId(testId);
    // Will create one
    // verify(serviceDao).save(any(ClaimAdjustments.class));
    verifyNoMoreInteractions(serviceDao);

    assertNotNull(foundClaim.getClaimAdjustmentsList());
    assertEquals(1, foundClaim.getClaimAdjustmentsList().size());
    ClaimAdjustments newAdjustment = foundClaim.getClaimAdjustmentsList().get(0);
    // Only source, status and date can change
    assertEquals(NEW_REQ_DATE, newAdjustment.getAdjustmentDate());
    assertEquals(NEW_REQ_STATUS, newAdjustment.getAdjustmentStatus());
    assertEquals(CLAIM_ADJ_DEC_TYPE, newAdjustment.getAdjustmentType());
    assertEquals(OLD_REQ_AMOUNT, newAdjustment.getAmount());
    assertEquals(NEW_REQ_SOURCE, newAdjustment.getSource());
  }

  @Test
  public void deleteClaimDecision() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    foundClaim.setRtsId(new ResidencyTypes(null, "RES", null, null));
    ClaimAdjustments newRequest =
        new ClaimAdjustments() {
          {
            setAdjustmentDate(OLD_REQ_DATE);
            setAdjustmentStatus(OLD_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_REQ_TYPE);
            setAmount(OLD_REQ_AMOUNT);
            setSource(OLD_REQ_SOURCE);
          }
        };
    ClaimAdjustments newDecision =
        new ClaimAdjustments() {
          {
            setAdjustmentDate(OLD_REQ_DATE);
            setAdjustmentStatus(OLD_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_DEC_TYPE);
            setAmount(OLD_REQ_AMOUNT);
            setSource(OLD_REQ_SOURCE);
          }
        };
    foundClaim.setClaimAdjustmentsList(
        new ArrayList<ClaimAdjustments>() {
          {
            add(newRequest);
            add(newDecision);
          }
        });
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    claimService.deleteClaimDecision(testId);

    // THEN
    verify(serviceDao).findByClaimId(testId);
    verify(serviceDao).remove(newDecision);
    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void claimHasDecision_NoDecision() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    ClaimAdjustments newRequest =
        new ClaimAdjustments() {
          {
            setAdjustmentDate(OLD_REQ_DATE);
            setAdjustmentStatus(OLD_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_REQ_TYPE);
            setAmount(OLD_REQ_AMOUNT);
            setSource(OLD_REQ_SOURCE);
          }
        };
    foundClaim.setClaimAdjustmentsList(
        new ArrayList<ClaimAdjustments>() {
          {
            add(newRequest);
          }
        });
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    boolean ret = claimService.claimHasDecision(testId);

    // THEN
    assertFalse(ret);

    verify(serviceDao).findByClaimId(testId);
    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void claimHasDecision_Decision() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    ClaimAdjustments newDecision =
        new ClaimAdjustments() {
          {
            setAdjustmentDate(OLD_REQ_DATE);
            setAdjustmentStatus(OLD_REQ_STATUS);
            setAdjustmentType(CLAIM_ADJ_DEC_TYPE);
            setAmount(OLD_REQ_AMOUNT);
            setSource(OLD_REQ_SOURCE);
          }
        };
    foundClaim.setClaimAdjustmentsList(
        new ArrayList<ClaimAdjustments>() {
          {
            add(newDecision);
          }
        });
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    boolean ret = claimService.claimHasDecision(testId);

    // THEN
    assertTrue(ret);

    verify(serviceDao).findByClaimId(testId);
    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void claimIsEditable_True() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    foundClaim.setCsId(
        new ClaimStatusCodes() {
          {
            setStatusCode(ClaimStatus.PENDING.toString());
          }
        });
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    boolean ret = claimService.claimIsEditable(testId);

    // THEN
    assertTrue(ret);

    verify(serviceDao).findByClaimId(testId);
    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void claimIsEditable_False() throws HoopcException {
    // GIVEN
    Long testId = 123L;
    HospitalOopClaims foundClaim = new HospitalOopClaims();
    foundClaim.setCsId(
        new ClaimStatusCodes() {
          {
            setStatusCode(ClaimStatus.PROCESSED.toString());
          }
        });
    when(serviceDao.findByClaimId(testId)).thenReturn(foundClaim);

    // WHEN
    boolean ret = claimService.claimIsEditable(testId);

    // THEN
    assertFalse(ret);

    verify(serviceDao).findByClaimId(testId);
    verifyNoMoreInteractions(serviceDao);
  }

  @Test
  public void nonResidentHasErrorsButOverridenClaimStatusTest() {
    // GIVEN
    HospitalOopClaims claim = new HospitalOopClaims();
    claim.setRtsId(new ResidencyTypes());
    claim.getRtsId().setTypeCode(GlobalConstants.NRES_RESIDENCY_TYPE);
    claim.getClaimErrorsList().add(new ClaimErrors());
    claim.setClaimOverrides(new ClaimOverrides());
    claim.getClaimOverrides().setOverrideRequest("Y");
    claim.getClaimOverrides().setOverrideStatus("APPROVED");
    claim.getClaimOverrides().setOverrideStatusReason("Reason");

    ClaimStatusCodes csId = new ClaimStatusCodes();
    csId.setStatusCode(GlobalConstants.CLAIM_VALID);
    when(appService.getByStatusCode(GlobalConstants.CLAIM_VALID)).thenReturn(csId);

    // WHEN
    claimService.setStatusValidInvalid(claim);

    // THEN
    assertNotNull(claim.getCsId());
    assertEquals(GlobalConstants.CLAIM_VALID, claim.getCsId().getStatusCode());

    verify(appService).getByStatusCode(GlobalConstants.CLAIM_VALID);
    verifyNoMoreInteractions(appService);
  }

  @Test
  public void nonResidentHasErrorsButNotOverridenClaimStatusTest() {
    // GIVEN
    HospitalOopClaims claim = new HospitalOopClaims();
    claim.setRtsId(new ResidencyTypes());
    claim.getRtsId().setTypeCode(GlobalConstants.NRES_RESIDENCY_TYPE);
    claim.getClaimErrorsList().add(new ClaimErrors());

    ClaimStatusCodes csId = new ClaimStatusCodes();
    csId.setStatusCode(GlobalConstants.CLAIM_INVALID);
    when(appService.getByStatusCode(GlobalConstants.CLAIM_INVALID)).thenReturn(csId);

    // WHEN
    claimService.setStatusValidInvalid(claim);

    // THEN
    assertNotNull(claim.getCsId());
    assertEquals(GlobalConstants.CLAIM_INVALID, claim.getCsId().getStatusCode());

    verify(appService).getByStatusCode(GlobalConstants.CLAIM_INVALID);
    verifyNoMoreInteractions(appService);
  }

  @Test
  public void nonResidentNoErrorClaimStatusTest() {
    // GIVEN
    HospitalOopClaims claim = new HospitalOopClaims();
    claim.setRtsId(new ResidencyTypes());
    claim.getRtsId().setTypeCode(GlobalConstants.NRES_RESIDENCY_TYPE);
    claim.getClaimErrorsList().clear();

    ClaimStatusCodes csId = new ClaimStatusCodes();
    csId.setStatusCode(GlobalConstants.CLAIM_VALID);
    when(appService.getByStatusCode(GlobalConstants.CLAIM_VALID)).thenReturn(csId);

    // WHEN
    claimService.setStatusValidInvalid(claim);

    // THEN
    assertNotNull(claim.getCsId());
    assertEquals(GlobalConstants.CLAIM_VALID, claim.getCsId().getStatusCode());

    verify(appService).getByStatusCode(GlobalConstants.CLAIM_VALID);
    verifyNoMoreInteractions(appService);
  }

  @Test
  public void residentSetReviewIndicator_True() {
    // GIVEN
    HospitalOopClaims claim = new HospitalOopClaims();
    claim.setRtsId(new ResidencyTypes());
    claim.getRtsId().setTypeCode(GlobalConstants.RES_RESIDENCY_TYPE);
    claim.getClaimErrorsList().add(new ClaimErrors());

    // WHEN
    claimService.setReviewClaim(claim);

    // THEN
    assertEquals("Y", claim.getClaimToBeReviewedInd());
  }

  @Test
  public void residentSetReviewIndicator_False() {
    // GIVEN
    HospitalOopClaims claim = new HospitalOopClaims();
    claim.setRtsId(new ResidencyTypes());
    claim.getRtsId().setTypeCode(GlobalConstants.RES_RESIDENCY_TYPE);
    claim.getClaimErrorsList().clear();

    // WHEN
    claimService.setReviewClaim(claim);

    // THEN
    assertEquals("N", claim.getClaimToBeReviewedInd());
  }
}
