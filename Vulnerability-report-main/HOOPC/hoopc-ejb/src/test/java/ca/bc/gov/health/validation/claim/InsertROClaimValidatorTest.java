package ca.bc.gov.health.validation.claim;

import ca.bc.gov.health.constants.ClaimContentContext;
import ca.bc.gov.health.database.entity.ClaimDetailCodes;
import ca.bc.gov.health.database.entity.Hospitals;
import ca.bc.gov.health.database.entity.ProvincesTerritories;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.viewmodel.AdmissionsViewModel;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.PatientsViewModel;
import ca.bc.gov.health.validation.ValidationError;
import ca.bc.gov.health.validation.rule.ValidationRuleType;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Test Validation rules for INSERTRESOUTPATCLAIMINFO in InsertROClaimValidator.insertROClaimRules()
 */
public class InsertROClaimValidatorTest {

  // TODO: Setup debug logger
  private static Logger log = LoggerFactory.getLogger(InsertROClaimValidatorTest.class);

  @InjectMocks private InsertROClaimValidator validator;

  @InjectMocks private ClaimValidatorComplexRules complexRules;

  @Mock private HoopcAppService appService;

  @Mock private ClaimValidatorHelper helper;

  @BeforeEach
  public void initMocks() {
    MockitoAnnotations.initMocks(this);
    validator.setComplexRules(complexRules);
  }

  private ClaimViewModel emptyClaim() {
    ClaimViewModel claim = new ClaimViewModel();
    claim.setPatient(new PatientsViewModel());
    claim.setAdmission(new AdmissionsViewModel());
    claim.setDiagnosisCodes(new String[] {"", "", ""});
    return claim;
  }

  @Test
  public void treatingProvince_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setTreatingProvince(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Treating Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setTreatingProvince("NU");
    Mockito.when(appService.getProvince("NU")).thenReturn(new ProvincesTerritories());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Treating Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);
    Mockito.verify(appService).getProvince("NU");
  }

  @Test
  public void treatingProvince_Lookup() {
    ClaimViewModel claim = emptyClaim();

    // lookup test
    claim.setTreatingProvince("BB");
    Mockito.when(appService.getProvince("BB")).thenReturn(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one lookup error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Treating Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.LOOKUP_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService).getProvince("BB");

    // Positive test
    claim.setTreatingProvince("NU");
    Mockito.when(appService.getProvince("NU")).thenReturn(new ProvincesTerritories());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Treating Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);
    Mockito.verify(appService).getProvince("NU");
  }

  @Test
  public void treatingProvince_NotInSet() {
    ClaimViewModel claim = emptyClaim();

    // NotInSet test
    claim.setTreatingProvince("BC");
    Mockito.when(appService.getProvince("BC")).thenReturn(new ProvincesTerritories());
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one NotInSet error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Treating Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.NOT_IN_SET))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService).getProvince("BC");

    // Positive test
    claim.setTreatingProvince("NU");
    Mockito.when(appService.getProvince("NU")).thenReturn(new ProvincesTerritories());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Treating Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);
    Mockito.verify(appService).getProvince("NU");
  }

  @Test
  public void hospitalNumber_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setHospitalNumberAndName(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Hospital Number & Name"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setHospitalNumberAndName("123");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Hospital Number & Name"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void hospitalNumber_checkValidHospital() {
    ClaimViewModel claim = emptyClaim();

    // checkValidHospital test
    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    Mockito.when(appService.checkValidHospital("BC", "001", "InvalidHospital")).thenReturn(null);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    Mockito.verify(appService).checkValidHospital("BC", "001", "InvalidHospital");

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Hospital Name"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    log.info(error.getMessage());

    // Positive test
    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("001-TestHospital");
    Mockito.when(appService.checkValidHospital("BC", "001", "TestHospital"))
        .thenReturn(new Hospitals());

    errors = validator.validate(claim);

    assertNotNull(errors);
    Mockito.verify(appService).checkValidHospital("BC", "001", "TestHospital");

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Hospital Name"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    // Note: commented because setting province code calls appService too
    // Mockito.verifyZeroInteractions(appService);
  }

  @Test
  public void hospitalNumber_checkHospitalActiveDate() {
    ClaimViewModel claim = emptyClaim();

    LocalDate serviceDate = LocalDate.now();

    // checkValidHospital test
    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.setServiceDate(serviceDate);

    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));
    Mockito.when(appService.getPerDiemRate("BC", "001", serviceDate)).thenReturn(null);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Hospital Active"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    log.info(error.getMessage());

    // Positive test
    claim.setTreatingProvince("BC");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.setServiceDate(serviceDate);

    // Verifiy for two tests
    Mockito.when(appService.getPerDiemRate("BC", "001", serviceDate)).thenReturn(BigDecimal.TEN);

    errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Hospital Active"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(appService, Mockito.times(2)).getPerDiemRate("BC", "001", serviceDate);

    // Note: commented because setting province code calls appService too
    // Mockito.verifyZeroInteractions(appService);
  }

  @Test
  public void totalAmountClaimed_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setTotalAmountClaimed(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Total Amount Claimed"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setTotalAmountClaimed(new BigDecimal(1.0));
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Total Amount Claimed"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  // CHECKOUTPATIENTTOTALAMT
  @Test
  public void totalAmountClaimed_checkTotalAmout() {
    ClaimViewModel claim = emptyClaim();

    LocalDate serviceDate = LocalDate.now();
    claim.setServiceCodeValue("12");
    claim.setServiceDate(LocalDate.now());
    claim.setTotalAmountClaimed(BigDecimal.valueOf(0.0));

    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));
    Mockito.when(appService.getServiceRate("12", serviceDate)).thenReturn(BigDecimal.TEN);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Total Amout"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    claim.setTotalAmountClaimed(BigDecimal.valueOf(10.0));

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Total Amout"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void ClaimSource_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setClaimSource("");
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Claim Source"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setClaimSource("MANUAL");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Claim Source"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void ClaimSource_InSet() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In Set test
    // Province must be BC
    claim.setClaimSource("Source");
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Claim Source"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_SET))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setClaimSource("MANUAL");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Claim Source"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void CodingScheme_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setIcdCodingScheme(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Coding Scheme"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setIcdCodingScheme("ICD10");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Coding Scheme"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void CodingScheme_InSet() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In Set test
    // Province must be BC
    claim.setIcdCodingScheme("ICD09");
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Coding Scheme"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_SET))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setIcdCodingScheme("ICD10");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Coding Scheme"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void serviceCode_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setServiceCodeValue(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Service Code"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setServiceCodeValue("14");
    Mockito.when(appService.getServiceCode("14")).thenReturn(new ClaimDetailCodes());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Service Code"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void serviceCode_Loockup() {
    ClaimViewModel claim = emptyClaim();

    // lookup test
    claim.setServiceCodeValue("12");
    Mockito.when(appService.getClaimDetailCode("12", ClaimContentContext.SERVICE)).thenReturn(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one lookup error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Service Code"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.LOOKUP_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService).getServiceCode("12");

    // Positive test
    claim.setServiceCodeValue("14");
    Mockito.when(appService.getServiceCode("14")).thenReturn(new ClaimDetailCodes());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Service Code"))
            .findFirst()
            .orElse(null);
    assertNull(error);
    Mockito.verify(appService).getServiceCode("14");
  }

  @Test
  public void serviceCode_checkServiceCodeActive() {
    ClaimViewModel claim = emptyClaim();

    LocalDate serviceDate = LocalDate.now();

    claim.setServiceDate(serviceDate);
    claim.setServiceCodeValue("12");
    Mockito.when(appService.getServiceRate("12", serviceDate)).thenReturn(null);
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    Mockito.verify(appService).getServiceRate("12", serviceDate);

    // Expect one complex error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Service Code Active"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    log.info(error.getMessage());

    // Positive test
    claim.setServiceDate(serviceDate);
    claim.setServiceCodeValue("14");
    Mockito.when(appService.getServiceRate("14", serviceDate)).thenReturn(BigDecimal.ZERO);

    errors = validator.validate(claim);

    Mockito.verify(appService).getServiceRate("14", serviceDate);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Service Code Active"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void serviceCode_checkProcedureCodeOutpatient() {
    ClaimViewModel claim = emptyClaim();

    claim.setServiceDate(LocalDate.now());
    claim.setServiceCodeValue("02");
    claim.getProcedureCodes()[0] = null;
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one complex error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Procedure Code Outpatient"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    log.info(error.getMessage());

    // Positive test
    claim.setServiceCodeValue("14");
    claim.getProcedureCodes()[0] = null;

    errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Procedure Code Outpatient"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    // Positive test
    claim.setServiceCodeValue("02");
    claim.getProcedureCodes()[0] = "XXX";

    errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Procedure Code Outpatient"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void serviceCode_checkDiagnosticCodeOutpatient() {
    ClaimViewModel claim = emptyClaim();

    claim.setServiceDate(LocalDate.now());
    claim.setServiceCodeValue("02");
    claim.getDiagnosisCodes()[0] = null;
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one complex error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Diagnostic Code Outpatient"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    log.info(error.getMessage());

    // Positive test
    claim.setServiceCodeValue("14");
    claim.getDiagnosisCodes()[0] = null;

    errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Diagnostic Code Outpatient"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    // Positive test
    claim.setServiceCodeValue("02");
    claim.getDiagnosisCodes()[0] = "XXX";

    errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Diagnostic Code Outpatient"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void serviceDate_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.setServiceDate(null);
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Service Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setServiceDate(LocalDate.now());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Service Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void submissionDate_InDateRage() {
    ClaimViewModel claim = emptyClaim();

    // Failed InRageTest
    claim.setSubmissionDate(LocalDate.now());
    claim.setServiceDate(LocalDate.now().plusDays(1));
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Service Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_RANGE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setSubmissionDate(LocalDate.now());
    claim.setServiceDate(LocalDate.now());

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Service Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void submissionDate_checkYearOldClaim() {
    ClaimViewModel claim = emptyClaim();

    // Failed Test
    claim.setSubmissionDate(LocalDate.of(2020, 04, 10));
    claim.setServiceDate(LocalDate.of(2019, 04, 30));
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Submission Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.setSubmissionDate(LocalDate.of(2020, 04, 10));
    claim.setServiceDate(LocalDate.of(2019, 05, 01));

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Submission Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }
}
