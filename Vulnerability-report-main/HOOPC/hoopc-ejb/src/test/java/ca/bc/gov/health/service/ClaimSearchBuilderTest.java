package ca.bc.gov.health.service;

import ca.bc.gov.health.database.entity.HospitalOopClaims;
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.Persistence;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.Root;
import java.util.Properties;
import org.eclipse.persistence.config.PersistenceUnitProperties;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Disabled
public class ClaimSearchBuilderTest {
  private static final Logger log = LoggerFactory.getLogger(ClaimSearchBuilderTest.class);

  @InjectMocks private ClaimSearchBuilder builder;

  @Mock CriteriaBuilder mockBuilder;

  @Mock HoopcAppService appService;

  Root<HospitalOopClaims> root;

  @BeforeEach
  public void initMocks() {
    MockitoAnnotations.initMocks(this);

    log.info("creating entity manager factory");

    Properties pros = new Properties();
    pros.setProperty(
        PersistenceUnitProperties.ECLIPSELINK_PERSISTENCE_XML, "META-INF/persistence-test.xml");

    EntityManagerFactory emf = Persistence.createEntityManagerFactory("hoopc-junit", pros);
    EntityManager testEm = emf.createEntityManager();
    CriteriaBuilder critBuilder = testEm.getCriteriaBuilder();
    root = critBuilder.createQuery().from(HospitalOopClaims.class);
  }

  // @Test
  // public void emptySearch() {
  // ClaimViewModel claim = createMinimalClaim(ClaimType.INPATIENT, ResidencyType.RES);
  //
  // mockEqualCriteria("ctsId", claim.getClaimType());
  // mockEqualCriteria("rtsId", claim.getResidencyType());
  //
  // List<Predicate> predicates = builder.buildPredicates(claim, mockBuilder, root);
  //
  // assertNotNull(predicates);
  // assertEquals(2, predicates.size());
  //
  // assertEqualCriteria(predicates, "ctsId", claim.getClaimType());
  // assertEqualCriteria(predicates, "rtsId", claim.getResidencyType());
  //
  // Mockito.verifyNoMoreInteractions(mockBuilder, appService);
  // }
  //
  // @Test
  // @SuppressWarnings("serial")
  // public void treatingProvince() {
  // ClaimViewModel claim = createMinimalClaim(ClaimType.INPATIENT, ResidencyType.RES);
  // claim.setTreatingProvince("NU");
  //
  // ProvincesTerritories testProvince = new ProvincesTerritories() {
  // {
  // setId(12L);
  // setProvinceCode("NU");
  // }
  // };
  // mockEqualCriteria("ctsId", claim.getClaimType());
  // mockEqualCriteria("rtsId", claim.getResidencyType());
  // mockEqualCriteria("treatingPteId", testProvince);
  // Mockito.when(appService.getProvince("NU")).thenReturn(testProvince);
  //
  // List<Predicate> predicates = builder.buildPredicates(claim, mockBuilder, root);
  //
  // assertNotNull(predicates);
  // assertEquals(3, predicates.size());
  //
  // assertEqualCriteria(predicates, "ctsId", claim.getClaimType());
  // assertEqualCriteria(predicates, "rtsId", claim.getResidencyType());
  // assertEqualCriteria(predicates, "treatingPteId", testProvince);
  //
  // Mockito.verify(appService).getProvince("NU");
  //
  // Mockito.verifyNoMoreInteractions(mockBuilder, appService);
  // }
  //
  //
  // /**
  // * For non-resident, province is BC. Full number AND name must match ???
  // */
  // @Test
  // @SuppressWarnings("serial")
  // public void hospitalNumberNonResident() {
  // ClaimViewModel claim = createMinimalClaim(ClaimType.INPATIENT, ResidencyType.NRES);
  // claim.setTreatingProvince("BC");
  // claim.setHospitalNumberAndName("003");
  //
  // ProvincesTerritories testProvince = new ProvincesTerritories() {
  // {
  // setId(1L);
  // setProvinceCode("BC");
  // }
  // };
  // Hospitals testHospital = new Hospitals() {
  // {
  // setId(12L);
  // setProvince("BC");
  // setHospitalNumber("003");
  // setName("Test Hospital");
  // }
  // };
  // mockEqualCriteria("ctsId", claim.getClaimType());
  // mockEqualCriteria("rtsId", claim.getResidencyType());
  // mockEqualCriteria("treatingPteId", testProvince);
  // mockEqualCriteria("hspId", testHospital);
  // Mockito.when(appService.getProvince("BC")).thenReturn(testProvince);
  // Mockito.when(appService.getHospital("BC", "003")).thenReturn(testHospital);
  //
  // List<Predicate> predicates = builder.buildPredicates(claim, mockBuilder, root);
  //
  // assertNotNull(predicates);
  // assertEquals(4, predicates.size());
  //
  // assertEqualCriteria(predicates, "ctsId", claim.getClaimType());
  // assertEqualCriteria(predicates, "rtsId", claim.getResidencyType());
  // assertEqualCriteria(predicates, "treatingPteId", testProvince);
  // assertEqualCriteria(predicates, "hspId", testHospital);
  //
  // Mockito.verify(appService).getProvince("BC");
  // Mockito.verify(appService).getHospital("BC", "003");
  //
  // Mockito.verifyNoMoreInteractions(mockBuilder, appService);
  // }
  //
  // /**
  // */
  // @Test
  // @Disabled
  // public void hospitalNumberResident_NoTreatingProvince() {
  // // TODO
  // }
  //
  //
  // /**
  // * If Both, no criteria
  // */
  // @Test
  // public void codingScheme_Both() {
  // ClaimViewModel claim = createMinimalClaim(ClaimType.INPATIENT, ResidencyType.NRES);
  // claim.setIcdCodingScheme("Both");
  //
  // mockEqualCriteria("ctsId", claim.getClaimType());
  // mockEqualCriteria("rtsId", claim.getResidencyType());
  //
  // List<Predicate> predicates = builder.buildPredicates(claim, mockBuilder, root);
  //
  // assertNotNull(predicates);
  // assertEquals(2, predicates.size());
  //
  // assertEqualCriteria(predicates, "ctsId", claim.getClaimType());
  // assertEqualCriteria(predicates, "rtsId", claim.getResidencyType());
  //
  // Mockito.verifyNoMoreInteractions(mockBuilder, appService);
  // }
  //
  // /**
  // * If Both, no criteria
  // */
  // @Test
  // public void codingScheme_ICD10() {
  // ClaimViewModel claim = createMinimalClaim(ClaimType.INPATIENT, ResidencyType.NRES);
  // claim.setIcdCodingScheme("ICD-10");
  //
  // mockEqualCriteria("ctsId", claim.getClaimType());
  // mockEqualCriteria("rtsId", claim.getResidencyType());
  // mockEqualCriteria("icdCodingScheme", claim.getIcdCodingScheme());
  //
  // List<Predicate> predicates = builder.buildPredicates(claim, mockBuilder, root);
  //
  // assertNotNull(predicates);
  // assertEquals(3, predicates.size());
  //
  // assertEqualCriteria(predicates, "ctsId", claim.getClaimType());
  // assertEqualCriteria(predicates, "rtsId", claim.getResidencyType());
  // assertEqualCriteria(predicates, "icdCodingScheme", claim.getIcdCodingScheme());
  //
  // Mockito.verifyNoMoreInteractions(mockBuilder, appService);
  // }
  //
  // @Test
  // public void statusCode() {
  // ClaimViewModel claim = createMinimalClaim(ClaimType.INPATIENT, ResidencyType.RES);
  // claim.setStatusCode("PENDING");
  //
  // mockEqualCriteria("ctsId", claim.getClaimType());
  // mockEqualCriteria("rtsId", claim.getResidencyType());
  // mockEqualCriteria("csId/code", "PENDING");
  //
  // List<Predicate> predicates = builder.buildPredicates(claim, mockBuilder, root);
  //
  // assertNotNull(predicates);
  // assertEquals(3, predicates.size());
  //
  // assertEqualCriteria(predicates, "ctsId", claim.getClaimType());
  // assertEqualCriteria(predicates, "rtsId", claim.getResidencyType());
  // assertEqualCriteria(predicates, "csId/code", "PENDING");
  //
  // Mockito.verifyNoMoreInteractions(mockBuilder, appService);
  // }
  //
  //
  // /**
  // * ------------------------------------------------------------------------------------------
  // */
  // @Test
  // @Disabled
  // public void insuranceCardNumber() {
  // ClaimViewModel claim = createMinimalClaim(ClaimType.INPATIENT, ResidencyType.NRES);
  // claim.getPatient().setInsuranceCardNumber("a123");
  //
  // mockEqualCriteria("ctsId", claim.getClaimType());
  // mockEqualCriteria("rtsId", claim.getResidencyType());
  // mockEqualCriteria("patId/insuranceCardNumber", "a123");
  //
  // List<Predicate> predicates = builder.buildPredicates(claim, mockBuilder, root);
  //
  // assertNotNull(predicates);
  // assertEquals(3, predicates.size());
  //
  // assertEqualCriteria(predicates, "ctsId", claim.getClaimType());
  // assertEqualCriteria(predicates, "rtsId", claim.getResidencyType());
  // assertEqualCriteria(predicates, "patId/insuranceCardNumber", "a123");
  //
  // Mockito.verifyNoMoreInteractions(mockBuilder, appService);
  // }
  //
  //
  //
  // /**
  // * ------------------------------------------------------------------------------------------
  // */
  //
  // /**
  // * Creates a Minimal claim. Just sets claim type and residency type;
  // *
  // * @return
  // */
  // @SuppressWarnings("serial")
  // public static ClaimViewModel createMinimalClaim(ClaimType type, ResidencyType res) {
  // ClaimViewModel claimView = new ClaimViewModel() {
  // {
  // setClaimType(new ClaimTypes() {
  // {
  // setId(1L);
  // setClaimType(type.toString());
  // }
  // });
  // setResidencyType(new ResidencyTypes() {
  // {
  // setId(2L);
  // setTypeCode(res.toString());
  // }
  // });
  // setPatient(new PatientsViewModel());
  // }
  // };
  // return claimView;
  // }
  //
  // private <T> void mockEqualCriteria(String path, T value) {
  // // Mockito.when(root.get(path)).thenReturn(new FakePath(path));
  //
  // // TODO: Does not work with embeded expression like eq(lower(..))
  // Mockito.when(mockBuilder.equal(any(Expression.class), eq(value)))
  // .thenReturn(new FakePredicate(path, value));
  // Mockito.when(mockBuilder.lower(any(Expression.class)))
  // .thenReturn(new FakePredicate(path, value));
  // }
  //
  // private void assertEqualCriteria(List<Predicate> predicates, String path, Object value) {
  // // TODO: make sure only one?
  // FakePredicate predicate = predicates.stream().filter(p -> p != null).map(p -> (FakePredicate)
  // p)
  // .filter(p -> p.getFieldName().equals(path)).findFirst().orElse(null);
  // assertNotNull(predicate, "No criteria found for " + path);
  // assertEquals(path, predicate.getFieldName());
  // assertEquals(value, predicate.getValue());
  // Mockito.verify(mockBuilder).equal(any(Expression.class), eq(value));
  // // Mockito.verify(root).get(path);
  // }
  //
  // private class FakePredicate implements Predicate {
  // protected String fieldName;
  // protected Object value;
  //
  // public FakePredicate(String fieldName, Object value) {
  // this.fieldName = fieldName;
  // this.value = value;
  // }
  //
  // @Override
  // public String toString() {
  // return "FakePredicate [fieldName=" + fieldName + ", value=" + value + "]";
  // }
  //
  // protected String getFieldName() {
  // return fieldName;
  // }
  //
  // protected Object getValue() {
  // return value;
  // }
  //
  // @Override
  // public Predicate isNull() {
  // return null;
  // }
  //
  // @Override
  // public Predicate isNotNull() {
  // return null;
  // }
  //
  // @Override
  // public Predicate in(Object... values) {
  // return null;
  // }
  //
  // @Override
  // public Predicate in(Expression<?>... values) {
  // return null;
  // }
  //
  // @Override
  // public Predicate in(Collection<?> values) {
  // return null;
  // }
  //
  // @Override
  // public Predicate in(Expression<Collection<?>> values) {
  // return null;
  // }
  //
  // @Override
  // public <X> Expression<X> as(Class<X> type) {
  // return null;
  // }
  //
  // @Override
  // public Selection<Boolean> alias(String name) {
  // return null;
  // }
  //
  // @Override
  // public boolean isCompoundSelection() {
  // return false;
  // }
  //
  // @Override
  // public List<Selection<?>> getCompoundSelectionItems() {
  // return null;
  // }
  //
  // @Override
  // public Class<? extends Boolean> getJavaType() {
  // return null;
  // }
  //
  // @Override
  // public String getAlias() {
  // return null;
  // }
  //
  // @Override
  // public BooleanOperator getOperator() {
  // return null;
  // }
  //
  // @Override
  // public boolean isNegated() {
  // return false;
  // }
  //
  // @Override
  // public List<Expression<Boolean>> getExpressions() {
  // return null;
  // }
  //
  // @Override
  // public Predicate not() {
  // return null;
  // }
  // }

}
