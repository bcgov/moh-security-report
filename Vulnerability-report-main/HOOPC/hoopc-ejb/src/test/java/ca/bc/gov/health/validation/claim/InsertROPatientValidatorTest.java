package ca.bc.gov.health.validation.claim;

import ca.bc.gov.health.database.entity.ClaimDetailCodes;
import ca.bc.gov.health.database.entity.HospitalOopClaims;
import ca.bc.gov.health.database.entity.ProvincesTerritories;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.PatientsViewModel;
import ca.bc.gov.health.validation.ValidationError;
import ca.bc.gov.health.validation.rule.ValidationRuleType;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.mockito.ArgumentMatchers.any;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import static org.mockito.Mockito.times;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Test Validation rules for INSERTRESOUTPATPATIENTINFO in
 * InsertRIClaimValidator.insertROPatientRules()
 */
public class InsertROPatientValidatorTest {

  // TODO: Setup debug logger
  private static Logger log = LoggerFactory.getLogger(InsertROPatientValidatorTest.class);

  @InjectMocks private InsertROClaimValidator validator;

  @InjectMocks private ClaimValidatorComplexRules complexRules;

  @Mock private HoopcAppService appService;

  @Mock private ClaimValidatorHelper helper;

  @BeforeEach
  public void initMocks() {
    MockitoAnnotations.initMocks(this);
    validator.setComplexRules(complexRules);
  }

  private ClaimViewModel emptyClaim() {
    ClaimViewModel claim = new ClaimViewModel();
    claim.setPatient(new PatientsViewModel());
    claim.setDiagnosisCodes(new String[] {"", "", ""});
    claim.setProcedureCodes(new String[] {"", "", ""});
    return claim;
  }

  // ===========================================================================================
  // Patient rules
  // ===========================================================================================
  @Test
  public void insuranceCardNumber_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setInsuranceCardNumber(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Insurance Number"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setInsuranceCardNumber("123");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Insurance Number"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void lastName_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setLastName(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Last Name"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setLastName("Kirk");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Last Name"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void firstName_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setFirstName(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("First Name"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setFirstName("James");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("First Name"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void province_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setProvince(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setProvince("BC");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void province_InSet() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In Set test
    // Province must be BC
    claim.getPatient().setProvince("AB");
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_SET))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setProvince("BC");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void postalCode_Format() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Format test
    claim.getPatient().setPostalCode("123456");
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one format error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("checkPostalCodeFormat"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setPostalCode("X0X0X0");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("checkPostalCodeFormat"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void postalCode_Prefix() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Prefix test
    claim.getPatient().setPostalCode("X0X0X0");
    claim.getPatient().setProvince("AB");
    Mockito.when(appService.getProvince("AB"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setProvinceCode("AB");
                setPostalCodePrefix("T");
              }
            });
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one complex error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("checkPostalCodePrefix"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService).getProvince("AB");

    // Positive test
    claim.getPatient().setPostalCode("X0X0X0");
    claim.getPatient().setProvince("NU");
    Mockito.when(appService.getProvince("NU"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setProvinceCode("NU");
                setPostalCodePrefix("X");
              }
            });
    errors = validator.validate(claim);
    assertNotNull(errors);
    Mockito.verify(appService).getProvince("NU");

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Postal Code"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void birthDate_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setBirthDate(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setBirthDate(LocalDate.now());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void birthDate_InRange() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In_Range test
    // birthDate <= serviceDate
    claim.getPatient().setBirthDate(LocalDate.now());
    claim.setServiceDate(LocalDate.now().minusDays(1));
    
    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one in range error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_RANGE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setBirthDate(LocalDate.now());
    claim.setServiceDate(LocalDate.now());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void sex_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.getPatient().setSexCode(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Sex"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setSexCode("M");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Sex"))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void insuranceNumber_checkPatientDuplicate_Simple() {
    ClaimViewModel claim = emptyClaim();

    // Simple Conflict Error Test
    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.setServiceDate(LocalDate.of(2019, 12, 25));
    claim.setServiceCodeValue("12");

    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));
    // One duplicate
    Mockito.when(helper.findOutpatDuplicateClaims(claim))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(
                    new HospitalOopClaims() {
                      {
                        setProvincialClaimId("999");
                      }
                    });
              }
            });
    // Same code (not duplicate allowed)
    Mockito.when(helper.getServiceCode(any(HospitalOopClaims.class)))
        .thenReturn(
            new ClaimDetailCodes() {
              {
                setCodeValue(claim.getServiceCodeValue());
                setDuplicateAllowedInd("N");
              }
            });

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Duplicate"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    Mockito.verify(helper).findOutpatDuplicateClaims(any(ClaimViewModel.class));
    Mockito.verify(helper).getServiceCode(any(HospitalOopClaims.class));
  }

  @Test
  public void insuranceNumber_checkPatientDuplicate_DuplicateAllowed() {
    ClaimViewModel claim = emptyClaim();

    // DuplicateAllowed Error Test
    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.setServiceDate(LocalDate.of(2019, 12, 25));
    claim.setServiceCodeValue("12");

    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));
    // Returns two conflicting claims
    Mockito.when(helper.findOutpatDuplicateClaims(claim))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(new HospitalOopClaims());
                add(new HospitalOopClaims());
              }
            });
    // Same code (duplicate allowed)
    Mockito.when(helper.getServiceCode(any(HospitalOopClaims.class)))
        .thenReturn(
            new ClaimDetailCodes() {
              {
                setCodeValue(claim.getServiceCodeValue());
                setDuplicateAllowedInd("Y");
              }
            });

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Duplicate"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(helper).findOutpatDuplicateClaims(any(ClaimViewModel.class));
    Mockito.verify(helper, times(2)).getServiceCode(any(HospitalOopClaims.class));
  }
  
  @Test
  public void insuranceNumber_checkOutpatientConflict_simple() {
    ClaimViewModel claim = emptyClaim();

    // DuplicateAllowed Error Test
    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.setServiceDate(LocalDate.of(2019, 12, 25));

    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));
    // Returns no conflicting claims
    Mockito.when(helper.findOutpatConflictingClaims(claim))
        .thenReturn(new ArrayList<HospitalOopClaims>());

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Conflict"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(helper).findOutpatConflictingClaims(any(ClaimViewModel.class));
  }

  @Test
  public void insuranceNumber_checkOutpatientConflict_conflictIn() {
    ClaimViewModel claim = emptyClaim();

    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.setServiceDate(LocalDate.of(2019, 12, 25));

    Mockito.when(appService.getCutOffDateNewCodes()).thenReturn(LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd")));
    Mockito.when(helper.findOutpatConflictingClaims(claim))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(
                    new HospitalOopClaims() {
                      {
                        setProvincialClaimId("999");
                      }
                   });
              }
            });

    List<ValidationError> errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect one errors
    ValidationError error =
        errors.stream()
           .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Conflict"))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    Mockito.verify(helper).findOutpatConflictingClaims(any(ClaimViewModel.class));
  }
}
