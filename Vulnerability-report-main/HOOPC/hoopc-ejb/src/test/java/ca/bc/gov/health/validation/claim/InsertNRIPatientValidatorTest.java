package ca.bc.gov.health.validation.claim;

import ca.bc.gov.health.database.entity.ClaimDetailCodes;
import ca.bc.gov.health.database.entity.HospitalOopClaims;
import ca.bc.gov.health.database.entity.ProvincesTerritories;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.HoopcSessionBean;
import ca.bc.gov.health.service.viewmodel.AdmissionsViewModel;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.PatientsViewModel;
import ca.bc.gov.health.validation.ValidationError;
import ca.bc.gov.health.validation.rule.ValidationRuleType;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.mockito.ArgumentMatchers.any;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import static org.mockito.Mockito.atLeast;
import static org.mockito.Mockito.times;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Test Validation rules for INSERTNONRESINPATPATIENTINFO in
 * InsertNRIClaimValidator.insertNRIPatientRules()
 */
public class InsertNRIPatientValidatorTest {

  // TODO: Setup debug logger
  private static Logger log = LoggerFactory.getLogger(InsertNRIPatientValidatorTest.class);

  @InjectMocks private InsertNRIClaimValidator validator;

  @InjectMocks private ClaimValidatorComplexRules complexRules;

  @Mock private HoopcAppService appService;

  @Mock private HoopcSessionBean session;

  @Mock private ClaimValidatorHelper helper;

  @Mock private PHNHelper phnHelper;

  @BeforeEach
  public void initMocks() {
    MockitoAnnotations.initMocks(this);
    validator.setComplexRules(complexRules);
  }

  private ClaimViewModel emptyClaim() {
    ClaimViewModel claim = new ClaimViewModel();
    claim.setPatient(new PatientsViewModel());
    claim.setAdmission(new AdmissionsViewModel());
    claim.setDiagnosisCodes(new String[] {"", "", ""});
    return claim;
  }

  // ===========================================================================================
  // Patient rules
  // ===========================================================================================
  @Test
  public void insuranceCardNumber_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setInsuranceCardNumber(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Insurance Number"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setInsuranceCardNumber("123");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Insurance Number"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void lastName_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setLastName(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Last Name"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setLastName("Kirk");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Last Name"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void firstName_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setFirstName(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("First Name"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setFirstName("James");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("First Name"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void address_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setAddress1(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Address Line 1"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setAddress1("24-593 Federation Drive");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Address Line 1"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void city_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setCity(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("City"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setCity("San Francisco");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("City"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void province_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setProvince(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setProvince("AB");
    Mockito.when(appService.getProvince("AB")).thenReturn(new ProvincesTerritories());

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(appService).getProvince("AB");
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void province_InSet() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In Set test
    // Province must be BC
    claim.getPatient().setProvince("BC");
    Mockito.when(appService.getProvince("BC")).thenReturn(new ProvincesTerritories());
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.NOT_IN_SET))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService).getProvince("BC");

    // Positive test
    claim.getPatient().setProvince("AB");
    Mockito.when(appService.getProvince("AB")).thenReturn(new ProvincesTerritories());

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Province"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(appService).getProvince("AB");
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void postalCode_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setPostalCode(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Postal Code"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setPostalCode("X0X0X0");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Postal Code"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void postalCode_Format() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Format test
    claim.getPatient().setPostalCode("123456");
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one format error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("checkPostalCodeFormat"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setPostalCode("X0X0X0");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("checkPostalCodeFormat"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void postalCode_Prefix() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Prefix test
    claim.getPatient().setPostalCode("X0X0X0");
    claim.getPatient().setProvince("AB");
    Mockito.when(appService.getProvince("AB"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setProvinceCode("AB");
                setPostalCodePrefix("T");
              }
            });
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one complex error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("checkPostalCodePrefix"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());
    Mockito.verify(appService, atLeast(1)).getProvince("AB");

    // Positive test
    claim.getPatient().setPostalCode("X0X0X0");
    claim.getPatient().setProvince("NU");
    Mockito.when(appService.getProvince("NU"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setProvinceCode("NU");
                setPostalCodePrefix("X");
              }
            });
    errors = validator.validate(claim);
    assertNotNull(errors);
    Mockito.verify(appService, atLeast(1)).getProvince("NU");

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Postal Code"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void birthDate_Mandatory() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // Mandatory test
    claim.getPatient().setBirthDate(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setBirthDate(LocalDate.now());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void birthDate_InRange() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In_Range test
    // birthDate <= admissionDate
    claim.getPatient().setBirthDate(LocalDate.now());
    claim.getAdmission().setAdmissionDate(LocalDate.now().minusDays(1));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one in range error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_RANGE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setBirthDate(LocalDate.now());
    claim.getAdmission().setAdmissionDate(LocalDate.now());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Birth Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void sex_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.getPatient().setSexCode(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Sex"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setSexCode("M");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Sex"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void deceasedFlag_Mandatory() {
    ClaimViewModel claim = emptyClaim();

    // Mandatory test
    claim.getPatient().setDeceasedFlag(null);
    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one mandatory error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Deceased Flag"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.MANDATORY_VALUE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setDeceasedFlag("N");
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Deceased Flag"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void insuranceNumber_checkPatientDuplicate_Simple() {
    ClaimViewModel claim = emptyClaim();

    // Simple Conflict Error Test
    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.getAdmission().setAdmissionDate(LocalDate.of(2019, 12, 25));
    claim.getDiagnosisCodes()[0] = "NotChildBirth";

    // Not MultipleBirth
    Mockito.when(helper.isMultipleBirth(claim.getMainDiagnosisCode())).thenReturn(false);
    // One duplicate
    Mockito.when(helper.findInpatDuplicateClaims(claim))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(
                    new HospitalOopClaims() {
                      {
                        setProvincialClaimId("999");
                      }
                    });
              }
            });
    // Same code (not duplicate allowed)
    Mockito.when(helper.getMainDiagnostic(any(HospitalOopClaims.class)))
        .thenReturn(
            new ClaimDetailCodes() {
              {
                setCodeValue(claim.getMainDiagnosisCode());
              }
            });

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Duplicate"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    Mockito.verify(helper).isMultipleBirth(any(String.class));
    Mockito.verify(helper).findInpatDuplicateClaims(any(ClaimViewModel.class));
    Mockito.verify(helper).getMainDiagnostic(any(HospitalOopClaims.class));
  }

  @Test
  public void insuranceNumber_checkPatientDuplicate_MultipleBirth() {
    ClaimViewModel claim = emptyClaim();

    // Simple Conflict Error Test
    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.getAdmission().setAdmissionDate(LocalDate.of(2019, 12, 25));
    claim.getDiagnosisCodes()[0] = "NEWBORN";

    Mockito.when(helper.isMultipleBirth("NEWBORN")).thenReturn(true);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Duplicate"))
            .findFirst()
            .orElse(null);
    assertNull(error);
    Mockito.verify(helper).isMultipleBirth("NEWBORN");
    Mockito.verify(helper, times(0)).findInpatDuplicateClaims(any(ClaimViewModel.class));
  }

  @Test
  public void insuranceNumber_checkPatientDuplicate_DuplicateAllowed() {
    ClaimViewModel claim = emptyClaim();

    // DuplicateAllowed Error Test
    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.getAdmission().setAdmissionDate(LocalDate.of(2019, 12, 25));
    claim.getDiagnosisCodes()[0] = "NotChildBirth";

    // Returns two conflicting claims
    Mockito.when(helper.isMultipleBirth(claim.getMainDiagnosisCode())).thenReturn(false);
    Mockito.when(helper.findInpatDuplicateClaims(claim))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(new HospitalOopClaims());
                add(new HospitalOopClaims());
              }
            });
    Mockito.when(helper.getMainDiagnostic(any(HospitalOopClaims.class)))
        .thenReturn(
            new ClaimDetailCodes() {
              {
                setId(1L);
                setCodeValue(claim.getMainDiagnosisCode());
                setDuplicateAllowedInd("Y");
              }
            });

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Duplicate"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(helper).isMultipleBirth(any(String.class));
    Mockito.verify(helper).findInpatDuplicateClaims(any(ClaimViewModel.class));
    Mockito.verify(helper, times(2)).getMainDiagnostic(any(HospitalOopClaims.class));
  }

  @Test
  public void insuranceNumber_checkPatientConflict_simple() {
    ClaimViewModel claim = emptyClaim();

    // DuplicateAllowed Error Test
    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.getAdmission().setAdmissionDate(LocalDate.of(2019, 12, 25));
    claim.getAdmission().setDischargeDate(LocalDate.of(2019, 12, 25));
    claim.getDiagnosisCodes()[0] = "NotChildBirth";

    // Returns no conflicting claims
    Mockito.when(helper.findInpatConflictingClaims(claim))
        .thenReturn(new ArrayList<HospitalOopClaims>());

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Conflict"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(helper).findInpatConflictingClaims(any(ClaimViewModel.class));
  }

  @Test
  public void insuranceNumber_checkPatientConflict_conflictIn() {
    ClaimViewModel claim = emptyClaim();

    // DuplicateAllowed Error Test
    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.getAdmission().setAdmissionDate(LocalDate.of(2019, 12, 25));
    claim.getAdmission().setDischargeDate(LocalDate.of(2019, 12, 25));
    claim.getDiagnosisCodes()[0] = "NotChildBirth";

    Mockito.when(helper.isMultipleBirth(any(String.class))).thenReturn(false);
    // Returns one claims
    Mockito.when(helper.findInpatConflictingClaims(claim))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(
                    new HospitalOopClaims() {
                      {
                        setProvincialClaimId("999");
                      }
                    });
              }
            });
    Mockito.when(helper.isInpatient(any(HospitalOopClaims.class))).thenReturn(true);

    List<ValidationError> errors = validator.validate(claim);

    assertNotNull(errors);

    // Expect one errors
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Conflict"))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    Mockito.verify(helper).findInpatConflictingClaims(any(ClaimViewModel.class));
  }

  @Test
  public void insuranceNumber_checkPatientConflict_conflictOut() {
    ClaimViewModel claim = emptyClaim();

    // DuplicateAllowed Error Test
    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.getAdmission().setAdmissionDate(LocalDate.of(2019, 12, 25));
    claim.getAdmission().setDischargeDate(LocalDate.of(2019, 12, 25));
    claim.getDiagnosisCodes()[0] = "NotChildBirth";

    Mockito.when(helper.isMultipleBirth(any(String.class))).thenReturn(false);
    // Returns one claims
    Mockito.when(helper.findInpatConflictingClaims(claim))
        .thenReturn(
            new ArrayList<HospitalOopClaims>() {
              {
                add(
                    new HospitalOopClaims() {
                      {
                        setProvincialClaimId("999");
                      }
                    });
              }
            });
    Mockito.when(helper.isInpatient(any(HospitalOopClaims.class))).thenReturn(false);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one errors
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Conflict"))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    Mockito.verify(helper).findInpatConflictingClaims(any(ClaimViewModel.class));
  }

  @Test
  public void insuranceNumber_checkPatientConflict_childbirth() {
    ClaimViewModel claim = emptyClaim();

    // DuplicateAllowed Error Test
    claim.setTreatingProvince("AB");
    claim.setHospitalNumberAndName("001-InvalidHospital");
    claim.getPatient().setProvince("BC");
    claim.getPatient().setInsuranceCardNumber("1234");
    claim.getPatient().setBirthDate(LocalDate.of(2000, 12, 25));
    claim.getAdmission().setAdmissionDate(LocalDate.of(2019, 12, 25));
    claim.getAdmission().setDischargeDate(LocalDate.of(2019, 12, 25));
    claim.getDiagnosisCodes()[0] = "NEWBORN";

    Mockito.when(helper.isMultipleBirth("NEWBORN")).thenReturn(true);
    // // Returns one claims
    // Mockito.when(helper.findConflictingClaims(claim))
    // .thenReturn(new ArrayList<HospitalOopClaims>() {
    // {
    // add(new HospitalOopClaims());
    // }
    // });

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no errors
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Patient Conflict"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(helper, times(0)).findInpatConflictingClaims(any(ClaimViewModel.class));
  }

  @Test
  public void insuranceExpiry_inRange() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    // In_Range test
    // expiryDate <= dischageDate
    claim.getPatient().setCardExpiryDate(LocalDate.now());
    claim.getAdmission().setDischargeDate(LocalDate.now().plusDays(1));

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one in range error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Insurance Card Expiry Date"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_RANGE))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    log.info(error.getMessage());

    // Positive test
    claim.getPatient().setCardExpiryDate(LocalDate.now());
    claim.getAdmission().setDischargeDate(LocalDate.now());
    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Insurance Card Expiry Date"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verifyNoMoreInteractions(appService);
  }

  /** Test with province with no expiry */
  @Test
  public void insuranceExpiry_Mandatory_noExpiry() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    claim.getPatient().setCardExpiryDate(null);
    claim.getPatient().setProvince("ON");
    claim.setServiceDate(LocalDate.now());
    Mockito.when(appService.getProvince("ON"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setInsuranceExpiresInd("N");
              }
            });

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Insurance Expiry"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(appService, atLeast(1)).getProvince("ON");
    Mockito.verifyNoMoreInteractions(appService);
  }

  /** Test with province with expiry, but with treatment date before expiry implementation */
  @Test
  public void insuranceExpiry_Mandatory_beforeExpiry() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    claim.getPatient().setCardExpiryDate(null);
    claim.getPatient().setProvince("ON");
    claim.setServiceDate(LocalDate.now().minusDays(1));
    Mockito.when(appService.getProvince("ON"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setInsuranceExpiresInd("Y");
                setInsuranceExpiryImpltnDate(LocalDate.now());
              }
            });

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Insurance Expiry"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    Mockito.verify(appService, atLeast(1)).getProvince("ON");
    Mockito.verifyNoMoreInteractions(appService);
  }

  /** Test with province with expiry, but with treatment date before expiry implementation */
  @Test
  public void insuranceExpiry_Mandatory_afterExpiry() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    claim.getPatient().setCardExpiryDate(null);
    claim.getPatient().setProvince("ON");
    claim.setServiceDate(LocalDate.now());
    Mockito.when(appService.getProvince("ON"))
        .thenReturn(
            new ProvincesTerritories() {
              {
                setInsuranceExpiresInd("Y");
                setInsuranceExpiryImpltnDate(LocalDate.now());
              }
            });

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check Insurance Expiry"))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    Mockito.verify(appService, atLeast(1)).getProvince("ON");
    Mockito.verifyNoMoreInteractions(appService);
  }

  @Test
  public void insuranceNumber_phn() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    claim.getPatient().setProvince("AB");
    claim.getPatient().setInsuranceCardNumber("123456789");

    Mockito.when(phnHelper.checkPHN("AB", "123456789")).thenReturn(PHNHelper.PHN_ERROR_NONE);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check PHN Format"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    claim.getPatient().setProvince("AB");
    claim.getPatient().setInsuranceCardNumber("12345678");
    Mockito.when(phnHelper.checkPHN("AB", "12345678")).thenReturn(PHNHelper.PHN_ERROR_FORMAT);

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check PHN Format"))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    claim.getPatient().setProvince("AB");
    claim.getPatient().setInsuranceCardNumber("abc");
    Mockito.when(phnHelper.checkPHN("AB", "abc")).thenReturn(PHNHelper.PHN_ERROR_CHECKSUM);

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check PHN Format"))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    Mockito.verify(phnHelper).checkPHN("AB", "123456789");
    Mockito.verify(phnHelper).checkPHN("AB", "12345678");
    Mockito.verify(phnHelper).checkPHN("AB", "abc");
    Mockito.verifyNoMoreInteractions(phnHelper);
  }

  @Test
  public void insuranceNumber_phnQC() {
    ClaimViewModel claim = emptyClaim();
    claim.setPatient(new PatientsViewModel());

    claim.getPatient().setProvince("QC");
    claim.getPatient().setInsuranceCardNumber("123456789");
    claim.getPatient().setSexCode("M");

    Mockito.when(phnHelper.checkPHN("QC", "123456789", "M")).thenReturn(PHNHelper.PHN_ERROR_NONE);

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect no error
    ValidationError error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check PHN Format"))
            .findFirst()
            .orElse(null);
    assertNull(error);

    claim.getPatient().setProvince("QC");
    claim.getPatient().setInsuranceCardNumber("12345678");
    claim.getPatient().setSexCode("F");
    Mockito.when(phnHelper.checkPHN("QC", "12345678", "F")).thenReturn(PHNHelper.PHN_ERROR_FORMAT);

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check PHN Format"))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    claim.getPatient().setProvince("QC");
    claim.getPatient().setInsuranceCardNumber("abc");
    claim.getPatient().setSexCode("M");
    Mockito.when(phnHelper.checkPHN("QC", "abc", "M")).thenReturn(PHNHelper.PHN_ERROR_CHECKSUM);

    errors = validator.validate(claim);
    assertNotNull(errors);

    // Expect one error
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("Check PHN Format"))
            .findFirst()
            .orElse(null);
    assertNotNull(error);

    Mockito.verify(phnHelper).checkPHN("QC", "123456789", "M");
    Mockito.verify(phnHelper).checkPHN("QC", "12345678", "F");
    Mockito.verify(phnHelper).checkPHN("QC", "abc", "M");
    Mockito.verifyNoMoreInteractions(phnHelper);
  }
}
