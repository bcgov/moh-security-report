package ca.bc.gov.health.validation.claim;

import ca.bc.gov.health.database.entity.HighcostProcedureCodes;
import ca.bc.gov.health.database.entity.HighcostProcedureRate;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.viewmodel.AdmissionsViewModel;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.HighcostViewModel;
import ca.bc.gov.health.service.viewmodel.PatientsViewModel;
import ca.bc.gov.health.validation.ValidationError;
import ca.bc.gov.health.validation.rule.ValidationRuleType;
import java.math.BigDecimal;
import java.text.MessageFormat;
import java.text.NumberFormat;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Assertions;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentMatchers;
import static org.mockito.ArgumentMatchers.any;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

/**
 * Test Validation rules for EDITHIGHCOSTPROCEDUREINFO in
 * InsertRIClaimValidator.editHighCostProcedureRules()
 */
public class EditHighCostValidatorTest {

  @InjectMocks private InsertRIClaimValidator validator;

  @InjectMocks private ClaimValidatorComplexRules complexRules;

  @Mock private HoopcAppService appService;

  @Mock private ClaimValidatorHelper helper;

  @BeforeEach
  public void initMocks() {
    MockitoAnnotations.initMocks(this);
    Mockito.when(appService.findHighcostProcedureByCode(any(Short.class))).thenReturn(null);
    validator.setComplexRules(complexRules);
  }

  private ClaimViewModel emptyClaim() {
    ClaimViewModel claim = new ClaimViewModel();
    claim.setPatient(new PatientsViewModel());
    claim.setAdmission(new AdmissionsViewModel());
    claim.setDiagnosisCodes(new String[] {"", "", ""});
    HighcostViewModel highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("123");
    claim.setHighCostProcedures(
        new HighcostViewModel[] {highCostViewModel, highCostViewModel, highCostViewModel});
    return claim;
  }

  @Test
  public void mandatoryHighCostProcedure_allEmptyFields() {
    ClaimViewModel claim = emptyClaim();
    claim.setHighCostProcedures(
        new HighcostViewModel[] {
          new HighcostViewModel(), new HighcostViewModel(), new HighcostViewModel()
        });

    List<ValidationError> errors = validator.validate(claim);

    ValidationError error;
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("HighCostProcedureCode Mandatory"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNull(error);

    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("HighCostProcedureDate Mandatory"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNull(error);

    error =
        errors.stream()
            .filter(
                e -> e.getRule().getRuleIdentifier().equals("HighCostProcedureAmount Mandatory"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNull(error);
  }

  @Test
  public void missingMandatoryHighCostProcedureFields() {
    ClaimViewModel claim = emptyClaim();
    HighcostViewModel highCostViewModel;

    // Missing code
    highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue(null);
    highCostViewModel.setProcedureDate(LocalDate.of(2019, 1, 1));
    highCostViewModel.setProcedureCost(new BigDecimal("123"));
    claim.getHighCostProcedures()[0] = highCostViewModel;

    // Missing amount
    highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("123");
    highCostViewModel.setProcedureDate(LocalDate.of(2019, 1, 1));
    highCostViewModel.setProcedureCost(null);
    claim.getHighCostProcedures()[1] = highCostViewModel;

    // Missing date
    highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("123");
    highCostViewModel.setProcedureDate(null);
    highCostViewModel.setProcedureCost(new BigDecimal("123"));
    claim.getHighCostProcedures()[2] = highCostViewModel;

    List<ValidationError> errors = validator.validate(claim);
    assertNotNull(errors);

    ValidationError error;
    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("HighCostProcedureCode Mandatory"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    Assertions.assertEquals("Missing High Cost #1 Procedure Code", error.getMessage());

    error =
        errors.stream()
            .filter(e -> e.getRule().getRuleIdentifier().equals("HighCostProcedureDate Mandatory"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    Assertions.assertEquals("Missing High Cost #3 Procedure Date", error.getMessage());

    error =
        errors.stream()
            .filter(
                e -> e.getRule().getRuleIdentifier().equals("HighCostProcedureAmount Mandatory"))
            .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
            .findFirst()
            .orElse(null);
    assertNotNull(error);
    Assertions.assertEquals("Missing High Cost #2 Procedure Amount", error.getMessage());
  }

  @Test
  public void highCostProcedureLookUp() {
    ClaimViewModel claim = emptyClaim();
    HighcostViewModel highCostViewModel;

    highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("123");
    claim.getHighCostProcedures()[0] = highCostViewModel;
    claim.getHighCostProcedures()[1] = highCostViewModel;
    claim.getHighCostProcedures()[2] = highCostViewModel;

    List<ValidationError> errors = new ArrayList<ValidationError>();
    ValidationError error;

    /*
     * Expect errors
     */
    errors = validator.validate(claim);

    for (int index = 1; index <= 3; index++) {
      int i = index;
      String fieldName = "High Cost #" + i + " Code";
      error =
          errors.stream()
              .filter(e -> e.getRule().getRuleIdentifier().equals(fieldName))
              .filter(e -> e.getRule().getType().equals(ValidationRuleType.LOOKUP_VALUE))
              .findFirst()
              .orElse(null);
      assertNotNull(error);
      Assertions.assertEquals("Invalid code 123 for " + fieldName, error.getMessage());
    }

    /*
     * Expect no error
     */

    Mockito.when(appService.findHighcostProcedureByCode(any(Short.class)))
        .thenReturn(new HighcostProcedureCodes());
    errors = validator.validate(claim);

    for (int index = 1; index <= 3; index++) {
      int i = index;
      error =
          errors.stream()
              .filter(e -> e.getRule().getRuleIdentifier().equals("HighCostProcedureCode#" + i))
              .filter(e -> e.getRule().getType().equals(ValidationRuleType.LOOKUP_VALUE))
              .findFirst()
              .orElse(null);
      assertNull(error);
    }
  }

  @Test
  public void highCostProcedureInDateRange() {
    List<ValidationError> errors;
    ValidationError error;
    ClaimViewModel claim = emptyClaim();

    HighcostViewModel highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("123");
    highCostViewModel.setProcedureDate(LocalDate.now());
    claim.getHighCostProcedures()[0] = highCostViewModel;
    claim.getHighCostProcedures()[1] = highCostViewModel;
    claim.getHighCostProcedures()[2] = highCostViewModel;

    /*
     * Not between admission and discharge date then error expected
     */

    claim.getAdmission().setAdmissionDate(LocalDate.now().plusDays(1));
    claim.getAdmission().setDischargeDate(LocalDate.now().plusDays(2));
    errors = validator.validate(claim);

    for (int index = 1; index <= 3; index++) {
      int i = index;
      String fieldName = "High Cost #" + i + " Date";
      error =
          errors.stream()
              .filter(e -> e.getRule().getRuleIdentifier().equals(fieldName))
              .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_RANGE))
              .findFirst()
              .orElse(null);
      assertNotNull(error);
    }

    /*
     * Inside admission and discharge date then no error expected
     */

    claim.getAdmission().setAdmissionDate(LocalDate.now().minusDays(1));
    claim.getAdmission().setDischargeDate(LocalDate.now().plusDays(1));
    errors = validator.validate(claim);

    for (int index = 1; index <= 3; index++) {
      int i = index;
      error =
          errors.stream()
              .filter(e -> e.getRule().getRuleIdentifier().equals("HighCostProcedureDate#" + i))
              .filter(e -> e.getRule().getType().equals(ValidationRuleType.IN_RANGE))
              .findFirst()
              .orElse(null);
      assertNull(error);
    }
  }

  @Test
  public void noHighCostRateFound() {
    ValidationError error;
    ClaimViewModel claim = emptyClaim();

    HighcostViewModel highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("12345");
    highCostViewModel.setProcedureCost(BigDecimal.ZERO);
    claim.getHighCostProcedures()[0] = highCostViewModel;
    claim.getHighCostProcedures()[1] = highCostViewModel;
    claim.getHighCostProcedures()[2] = highCostViewModel;

    List<ValidationError> errors = validator.validate(claim);

    String noRateFound = "No high cost procedure found for high cost procedure code {0}";
    noRateFound = MessageFormat.format(noRateFound, highCostViewModel.getCodeValue());

    for (int index = 1; index <= 3; index++) {
      int i = index;
      String fieldName = "High Cost #" + i + " Amount";
      error =
          errors.stream()
              .filter(e -> e.getRule().getRuleIdentifier().contains(fieldName))
              .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
              .findFirst()
              .orElse(null);
      assertNotNull(error);
      Assertions.assertEquals(noRateFound, error.getMessage());
    }
  }

  @Test
  public void highCostRateNoMatch() {
    ValidationError error;
    ClaimViewModel claim = emptyClaim();

    List<HighcostProcedureRate> rates = new ArrayList<>();
    HighcostProcedureRate rate = new HighcostProcedureRate();
    rate.setEffectiveDate(LocalDate.now().minusDays(1));
    rate.setEndDate(LocalDate.now().plusDays(1));
    rate.setBasicBlockRateAmount(new BigDecimal("123"));
    rates.add(rate);
    Mockito.when(helper.getHighCostCodeRates(any(Short.class))).thenReturn(rates);
    Mockito.when(
            helper.filterHighCostCodeRatesOnDate(ArgumentMatchers.anyList(), any(LocalDate.class)))
        .thenReturn(rates);

    HighcostViewModel highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("12345");
    highCostViewModel.setProcedureCost(new BigDecimal("321"));
    highCostViewModel.setProcedureDate(LocalDate.now());

    claim.getHighCostProcedures()[0] = highCostViewModel;
    claim.getHighCostProcedures()[1] = highCostViewModel;
    claim.getHighCostProcedures()[2] = highCostViewModel;

    List<ValidationError> errors = validator.validate(claim);

    String rateDoNotMatch =
        "The high cost procedure rate entered ({0}) does not match the "
            + "rate in effect for high cost procedure code {1} on procedure date {2}";
    rateDoNotMatch =
        MessageFormat.format(
            rateDoNotMatch,
            NumberFormat.getCurrencyInstance().format(highCostViewModel.getProcedureCost()),
            highCostViewModel.getCodeValue(),
            highCostViewModel.getProcedureDate());

    for (int index = 1; index <= 3; index++) {
      int i = index;
      String fieldName = "High Cost #" + i + " Amount";
      error =
          errors.stream()
              .filter(e -> e.getRule().getRuleIdentifier().equals(fieldName))
              .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
              .findFirst()
              .orElse(null);
      assertNotNull(error);
      Assertions.assertEquals(rateDoNotMatch, error.getMessage());
    }
  }

  @Test
  public void noHighCostRateNotInRange() {
    ValidationError error;
    ClaimViewModel claim = emptyClaim();

    List<HighcostProcedureRate> rates = new ArrayList<>();
    HighcostProcedureRate rate = new HighcostProcedureRate();
    rate.setEffectiveDate(LocalDate.now().plusDays(1));
    rate.setEndDate(LocalDate.now().plusDays(2));
    rates.add(rate);
    Mockito.when(helper.getHighCostCodeRates(any(Short.class))).thenReturn(rates);

    HighcostViewModel highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("12345");
    highCostViewModel.setProcedureDate(LocalDate.now());
    highCostViewModel.setProcedureCost(BigDecimal.ZERO);

    claim.getHighCostProcedures()[0] = highCostViewModel;
    claim.getHighCostProcedures()[1] = highCostViewModel;
    claim.getHighCostProcedures()[2] = highCostViewModel;

    List<ValidationError> errors = validator.validate(claim);

    String noEffectiveRate =
        "No high cost procedure rate is effective for high cost procedure code"
            + " {0} on procedure date {1}";
    noEffectiveRate =
        MessageFormat.format(
            noEffectiveRate,
            highCostViewModel.getCodeValue(),
            highCostViewModel.getProcedureDate());

    for (int index = 1; index <= 3; index++) {
      int i = index;
      String fieldName = "High Cost #" + i + " Amount";
      error =
          errors.stream()
              .filter(e -> e.getRule().getRuleIdentifier().equals(fieldName))
              .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
              .findFirst()
              .orElse(null);
      assertNotNull(error);
      Assertions.assertEquals(noEffectiveRate, error.getMessage());
    }
  }

  @Test
  public void highCostRate_ZERO() {
    ValidationError error;
    ClaimViewModel claim = emptyClaim();

    List<HighcostProcedureRate> rates = new ArrayList<>();
    HighcostProcedureRate rate = new HighcostProcedureRate();
    rate.setEffectiveDate(LocalDate.now().minusDays(1));
    rate.setEndDate(LocalDate.now().plusDays(1));
    rate.setBasicBlockRateAmount(new BigDecimal("0"));
    rates.add(rate);
    Mockito.when(helper.getHighCostCodeRates(any(Short.class))).thenReturn(rates);
    Mockito.when(
            helper.filterHighCostCodeRatesOnDate(ArgumentMatchers.anyList(), any(LocalDate.class)))
        .thenReturn(rates);

    HighcostViewModel highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("12345");
    highCostViewModel.setProcedureCost(new BigDecimal("123"));
    highCostViewModel.setProcedureDate(LocalDate.now());

    claim.getHighCostProcedures()[0] = highCostViewModel;
    claim.getHighCostProcedures()[1] = highCostViewModel;
    claim.getHighCostProcedures()[2] = highCostViewModel;

    List<ValidationError> errors = validator.validate(claim);

    for (int index = 1; index <= 3; index++) {
      int i = index;
      error =
          errors.stream()
              .filter(e -> e.getRule().getRuleIdentifier().equals("HighCostProcedureAmount#" + i))
              .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
              .findFirst()
              .orElse(null);
      assertNull(error);
    }
  }

  @Test
  public void highCostRate_OK() {
    ValidationError error;
    ClaimViewModel claim = emptyClaim();

    List<HighcostProcedureRate> rates = new ArrayList<>();
    HighcostProcedureRate rate = new HighcostProcedureRate();
    rate.setEffectiveDate(LocalDate.now().minusDays(1));
    rate.setEndDate(LocalDate.now().plusDays(1));
    rate.setBasicBlockRateAmount(new BigDecimal("123"));
    rates.add(rate);
    Mockito.when(helper.getHighCostCodeRates(any(Short.class))).thenReturn(rates);
    Mockito.when(
            helper.filterHighCostCodeRatesOnDate(ArgumentMatchers.anyList(), any(LocalDate.class)))
        .thenReturn(rates);

    HighcostViewModel highCostViewModel = new HighcostViewModel();
    highCostViewModel.setCodeValue("12345");
    highCostViewModel.setProcedureCost(new BigDecimal("123"));
    highCostViewModel.setProcedureDate(LocalDate.now());

    claim.getHighCostProcedures()[0] = highCostViewModel;
    claim.getHighCostProcedures()[1] = highCostViewModel;
    claim.getHighCostProcedures()[2] = highCostViewModel;

    List<ValidationError> errors = validator.validate(claim);

    for (int index = 1; index <= 3; index++) {
      int i = index;
      error =
          errors.stream()
              .filter(e -> e.getRule().getRuleIdentifier().equals("HighCostProcedureAmount#" + i))
              .filter(e -> e.getRule().getType().equals(ValidationRuleType.COMPLEX))
              .findFirst()
              .orElse(null);
      assertNull(error);
    }
  }
}
