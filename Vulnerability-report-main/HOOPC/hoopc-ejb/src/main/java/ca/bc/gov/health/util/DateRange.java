package ca.bc.gov.health.util;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.Iterator;
import java.util.Objects;
import java.util.stream.Stream;

/**
 * Utility class to work with date ranges (ie PerDiemRates, ...). A DateRange is inclusive
 * [startDate, endDate].
 */
public class DateRange implements Iterable<LocalDate> {
  protected final LocalDate startDate;
  protected final LocalDate endDate;

  /**
   * Create a new Date Range.
   *
   * @param startDate If null, will be LocalDate.MIN
   * @param endDate If null, will be LocalDate.MAX
   */
  public DateRange(LocalDate startDate, LocalDate endDate) {
    super();

    this.startDate = (startDate != null) ? startDate : LocalDate.MIN;
    this.endDate = (endDate != null) ? endDate : LocalDate.MAX;

    if (this.endDate.isBefore(this.startDate))
      throw new IllegalArgumentException("endDate must not be before startDate");
  }

  /**
   * Returns an iterator for each day (inclusive) between startDate and endDate.
   *
   * @return the iterator
   */
  @Override
  public Iterator<LocalDate> iterator() {
    return stream().iterator();
  }

  /**
   * Returns a stream for each day (inclusive) between startDate and endDate.
   *
   * @return the stream
   */
  public Stream<LocalDate> stream() {
    return Stream.iterate(startDate, d -> d.plusDays(1))
        .limit(ChronoUnit.DAYS.between(startDate, endDate) + 1);
  }

  /**
   * Returns true is given date is include in the range (inclusive).
   *
   * @param date the date
   * @return true, if successful
   */
  public boolean contains(LocalDate date) {
    if (date == null) return false;
    return (!date.isBefore(this.startDate) && !date.isAfter(this.endDate));
  }

  /**
   * Returns true is given range is entirely include inside this. subset.startDate >= this.startDate
   * && subset.endDate <= this.endDate.
   *
   * @param subset the subset
   * @return true, if successful
   */
  public boolean contains(DateRange subset) {
    return (contains(subset.startDate) && contains(subset.endDate));
  }

  /**
   * Number of days.
   *
   * @return the long
   */
  public long numberOfDays() {
    return ChronoUnit.DAYS.between(startDate, endDate) + 1;
  }

  /**
   * Returns a DateRange composed of the intersection between this and provided range. Null if
   * ranges do not overlap.
   *
   * @param other the other
   * @return the date range
   */
  public DateRange intersection(DateRange other) {
    LocalDate start = max(this.startDate, other.startDate);
    LocalDate end = min(this.endDate, other.endDate);
    if (!start.isAfter(end)) {
      return new DateRange(start, end);
    }
    return null;
  }

  /**
   * Min.
   *
   * @param date1 the date 1
   * @param date2 the date 2
   * @return the local date
   */
  protected LocalDate min(LocalDate date1, LocalDate date2) {
    return date1.isBefore(date2) ? date1 : date2;
  }

  /**
   * Max.
   *
   * @param date1 the date 1
   * @param date2 the date 2
   * @return the local date
   */
  protected LocalDate max(LocalDate date1, LocalDate date2) {
    return date1.isAfter(date2) ? date1 : date2;
  }

  public LocalDate getStartDate() {
    return startDate;
  }

  public LocalDate getEndDate() {
    return endDate;
  }

  /* (non-Javadoc)
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode() {
    return Objects.hash(endDate, startDate);
  }

  /* (non-Javadoc)
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null) return false;
    if (!(obj instanceof DateRange)) return false;
    DateRange other = (DateRange) obj;
    return Objects.equals(endDate, other.endDate) && Objects.equals(startDate, other.startDate);
  }

  /* (non-Javadoc)
   * @see java.lang.Object#toString()
   */
  @Override
  public String toString() {
    return "DateRange [startDate=" + startDate + ", endDate=" + endDate + "]";
  }
}
