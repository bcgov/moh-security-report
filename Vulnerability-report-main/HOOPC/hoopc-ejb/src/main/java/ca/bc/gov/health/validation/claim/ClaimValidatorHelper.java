package ca.bc.gov.health.validation.claim;

import ca.bc.gov.health.constants.ClaimContentContext;
import ca.bc.gov.health.constants.GlobalConstants;
import static ca.bc.gov.health.constants.GlobalConstants.ROLE_MINISTRY;
import ca.bc.gov.health.database.entity.AppUserAuthorizations;
import ca.bc.gov.health.database.entity.ApplicationUsers;
import ca.bc.gov.health.database.entity.ClaimDetailCodes;
import ca.bc.gov.health.database.entity.HighcostProcedureCodes;
import ca.bc.gov.health.database.entity.HighcostProcedureRate;
import ca.bc.gov.health.database.entity.HospitalOopClaims;
import ca.bc.gov.health.database.entity.HospitalPerDiemRates;
import ca.bc.gov.health.database.entity.Hospitals;
import ca.bc.gov.health.database.entity.ServiceRates;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.HighcostViewModel;
import ca.bc.gov.health.util.DateRange;
import ca.bc.gov.health.util.RateRange;
import ca.bc.gov.health.util.RateRange.RateType;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.lang3.Range;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Class ClaimValidatorHelper. */
@ApplicationScoped
public class ClaimValidatorHelper {
  private static Logger log = LoggerFactory.getLogger(ClaimValidatorHelper.class);

  @Inject private HoopcAppService appService;

  /**
   * Calculate the total amount of the claim.
   *
   * @param c the c
   * @return the big decimal
   */
  protected BigDecimal calculateTotalAmout(ClaimViewModel c) {

    try {
      BigDecimal rateCumul =
          cumulRate(
              c.getAdmission().getAdmissionDate(),
              c.getAdmission().getDischargeDate(),
              getRateRange(c));

      // Add all highcost procedure if present
      BigDecimal highCostCumul = BigDecimal.ZERO;
      for (HighcostViewModel cost : c.getHighCostProcedures()) {
        if (cost.getProcedureCost() != null) {
          highCostCumul = highCostCumul.add(cost.getProcedureCost());
        }
      }

      BigDecimal total = rateCumul.add(highCostCumul);
      return total;
    } catch (HoopcException e) {
      log.error("Error in calculateTotalAmout", e);
      return null;
    }
  }

  /**
   * Return the rates to used for the given rule. Uses the hospital perdiem rates except, if
   * diagnostic code is of type NEWBORN uses service rates.
   *
   * @param c the c
   * @return the rate range
   * @throws HoopcException the hoopc exception
   */
  public List<RateRange> getRateRange(ClaimViewModel c) throws HoopcException {
    ClaimDetailCodes cdc = appService.getNewbornCode(c.getMainDiagnosisCode());
    if (cdc != null) {
      // If NEWBORN than use Service Rates
      List<ServiceRates> rates = appService.getServiceRates(cdc.getId());
      return toRateRangeService(rates);
    } else {
      // Else return hospital perdiem rates
      List<HospitalPerDiemRates> rates =
          appService.getHospitalRates(c.getTreatingProvince(), c.getHospitalNumber());
      return toRateRangeHospital(rates);
    }
  }

  private BigDecimal cumulRate(
      LocalDate admissionDate, LocalDate dischargeDate, List<RateRange> ranges) {

    // exclude discharge date from the calculation
    final DateRange period;
    if (admissionDate.isEqual(dischargeDate)) {
      period = new DateRange(admissionDate, dischargeDate);
    } else if (admissionDate.isBefore(dischargeDate)) {
      period = new DateRange(admissionDate, dischargeDate.minusDays(1));
    } else {
      return BigDecimal.ZERO;
    }

    // for each rate range:
    BigDecimal total =
        ranges.stream()
            // If intersection with period
            .filter(r -> r.intersection(period) != null)
            // rate for range = rate * number of intersection days
            .map(
                r ->
                    r.getRate().multiply(BigDecimal.valueOf(r.intersection(period).numberOfDays())))
            // increment total
            .reduce(BigDecimal.ZERO, BigDecimal::add);

    return total;
  }

  private List<RateRange> toRateRangeHospital(List<HospitalPerDiemRates> rates) {
    Stream<RateRange> ret =
        rates.stream()
            .map(
                r ->
                    new RateRange(
                        r.getEffectiveDate(),
                        r.getEndDate(),
                        r.getPerDiemRate(),
                        RateType.HOSPITAL));
    return ret.collect(Collectors.toList());
  }

  private List<RateRange> toRateRangeService(List<ServiceRates> rates) {
    Stream<RateRange> ret =
        rates.stream()
            .map(
                r ->
                    new RateRange(
                        r.getEffectiveDate(), r.getEndDate(), r.getRateAmount(), RateType.SERVICE));
    return ret.collect(Collectors.toList());
  }

  /**
   * Find duplicate claims for an INPATIENT claim. A Duplicate is:
   * <li>same Patient (same insurance number, province and birth date)
   * <li>same Claim Type (i.e: INPATIENT)
   * <li>same Treating Province
   * <li>same Hospital
   * <li>same Admission Date
   *
   * @param claim the claim
   * @return the list
   */
  public List<HospitalOopClaims> findInpatDuplicateClaims(ClaimViewModel claim) {
    // Get all claims for patient
    List<HospitalOopClaims> claimsForPatient =
        appService.findClaimsForPatient(
            claim.getPatient().getInsuranceCardNumber(),
            claim.getPatient().getProvince(),
            claim.getPatient().getBirthDate());

    // Filter out Self
    claimsForPatient.removeIf(c -> c.getId().equals(claim.getClaimId()));

    // Filter out different claim types
    claimsForPatient.removeIf(c -> !(c.getCtsId().getId().equals(claim.getClaimType().getId())));

    // Filter out different treating province
    claimsForPatient.removeIf(
        c -> !c.getTreatingPteId().getProvinceCode().equals(claim.getTreatingProvince()));

    // Filter out different hospital
    claimsForPatient.removeIf(
        c ->
            c.getHspId() == null
                || !c.getHspId().getHospitalNumber().equals(claim.getHospitalNumber()));

    // Filter out different service_date
    // NOTE: The old app checks for oldclaim.service_date = newclaim.admission.admission_date
    // looks like it sets service_date = admission_date somewhere. We do it in
    // ClaimModelTransformer.
    claimsForPatient.removeIf(
        c -> !c.getServiceDate().equals(claim.getAdmission().getAdmissionDate()));
    //BCMOHAD-10314-8Mar22: Defining duplicate scenario for Inpatient-Inpatient
    claimsForPatient.removeIf(
        c -> !checkInpatDuplicate(claim.getAdmission().getAdmissionDate(),
                                  claim.getAdmission().getDischargeDate(),
                                  c.getAdmissionsList().get(0).getAdmissionDate(),
                                  c.getAdmissionsList().get(0).getDischargeDate()));

    return claimsForPatient;
  }

  /**
   * Determine if a potentially duplicating claim (c2) admission-discharge dates falls on same day.
   *
   * BCMOHAD-10314-08/03/22: New conflicting cases have been introduced.
   * <p>Duplicate = c2.admission = c1.admission && c2.discharge = c1.discharge
   * @param admission1 tested claim admission date
   * @param discharge1 tested claim discharge date
   * @param admission2 potentially conflicting claim admission date
   * @param discharge2 potentially conflicting claim discharge date
   * @return true if duplicate claim
   */
  protected boolean checkInpatDuplicate(
      LocalDate admission1, LocalDate discharge1, LocalDate admission2, LocalDate discharge2) 
      {
        if (admission2.isEqual(admission1) && discharge2.isEqual(discharge1))
          return true;
        else
          return false;
      }
  /**
   * Find duplicate claims for an OUTPATIENT claim. A Duplicate is:
   * <li>same Patient (same insurance number, province and birth date)
   * <li>same Claim Type (i.e: OUTPATIENT)
   * <li>same Treating Province
   * <li>same Hospital
   * <li>same Service Date
   *
   * @param claim the claim
   * @return the list
   */
  public List<HospitalOopClaims> findOutpatDuplicateClaims(ClaimViewModel claim) {
    // Get all claims for patient
    List<HospitalOopClaims> claimsForPatient =
        appService.findClaimsForPatient(
            claim.getPatient().getInsuranceCardNumber(),
            claim.getPatient().getProvince(),
            claim.getPatient().getBirthDate());

    // Filter out Self
    claimsForPatient.removeIf(c -> c.getId().equals(claim.getClaimId()));

    // Filter out different claim types
    claimsForPatient.removeIf(c -> !(c.getCtsId().getId().equals(claim.getClaimType().getId())));

    // Filter out different treating province
    claimsForPatient.removeIf(
        c -> !c.getTreatingPteId().getProvinceCode().equals(claim.getTreatingProvince()));

    // Filter out different hospital
    claimsForPatient.removeIf(
        c ->
            c.getHspId() == null
                || !c.getHspId().getHospitalNumber().equals(claim.getHospitalNumber()));

    // Filter out different service_date
    claimsForPatient.removeIf(c -> !c.getServiceDate().equals(claim.getServiceDate()));

    return claimsForPatient;
  }

  /**
   * Find Conflicting claims for an INPATIENT claim. A Conflicting claim is:
   * <li>same Patient (same insurance number, province and birth date)
   * <li>If other claim is INPATIENT: admission-discharge overlaps
   * <li>If other claim is OUTPATIENT: service date between admission-discharge (exclusive)
   *
   * @param claim the claim
   * @return the list
   */
  public List<HospitalOopClaims> findInpatConflictingClaims(ClaimViewModel claim) {
    // Get all claims for patient
    List<HospitalOopClaims> claimsForPatient =
        appService.findClaimsForPatient(
            claim.getPatient().getInsuranceCardNumber(),
            claim.getPatient().getProvince(),
            claim.getPatient().getBirthDate());

    // Filter out Self
    claimsForPatient.removeIf(c -> c.getId().equals(claim.getClaimId()));

    //BCMOHAD-9594-31/01/2022: Filter out different hospitals outpatient claims
    claimsForPatient.removeIf(
        c ->
            (GlobalConstants.OUTPATIENT_CLAIM_TYPE.equals(c.getCtsId().getClaimType())
               && (c.getHspId() == null
                   || !c.getHspId().getHospitalNumber().equals(claim.getHospitalNumber()))));
    

    // IF Outpatient claim, remove if service date not in admission-discharge (exclusive)
    claimsForPatient.removeIf(
        c ->
            (GlobalConstants.OUTPATIENT_CLAIM_TYPE.equals(c.getCtsId().getClaimType())
                // Check for conflict
                && !isConflictOutpatient(
                    claim.getAdmission().getAdmissionDate(),
                    claim.getAdmission().getDischargeDate(),
                    c.getServiceDate())));

    // IF Inpatient claim, remove if service date not in admission-discharge (exclusive)
    //BCMOHAD-9594-14Feb22: Checking for different hospitals when dates overlaps.
    claimsForPatient.removeIf(
        c ->
            (GlobalConstants.INPATIENT_CLAIM_TYPE.equals(c.getCtsId().getClaimType())
                // Prevent null pointer
                && (c.getAdmissionsList() != null && !c.getAdmissionsList().isEmpty())
                // Check for conflict
                && !isConflictInpatient(
                    claim.getAdmission().getAdmissionDate(),
                    claim.getAdmission().getDischargeDate(),
                    c.getAdmissionsList().get(0).getAdmissionDate(),
                    c.getAdmissionsList().get(0).getDischargeDate(),
                    c.getHspId().getHospitalNumber(),
                    claim.getHospitalNumber())));

    return claimsForPatient;
  }

  /**
   * Determine if a potentially conflicting claim (c2) serviceDate is between tested claim (c1)
   * admission-discharge range (NOTE: exclusively).
   *
   * <p>Conflict = c1.admission < c2.serviceDate < c1.discharge
   *
   * @param admission tested claim admission date
   * @param discharge tested claim discharge date
   * @param serviceDate potentially conflicting claim serviceDate
   * @return true if conflicting claim
   */
  protected boolean isConflictOutpatient(
      LocalDate admission, LocalDate discharge, LocalDate serviceDate) {
    return serviceDate.isAfter(admission) && serviceDate.isBefore(discharge);
  }

  /**
   * Determine if a potentially conflicting claim (c2) admission-discharge range is between tested
   * claim (c1) admission-discharge range.
   *
   * BCMOHAD-9594-24/01/22: New conflicting cases have been introduced.
   * <p>Conflict = c2.admission < c1.admission && c2.discharge > c1.discharge
   * <p>Conflict = c2.admission > c1.admission && c2.discharge >= c1.discharge && c2.discharge < c1.admission
   * <p>Conflict = c2.admission <= c1.admission && c2.admission > c1.discharge && c2.discharge < c1.discharge
   * <p>Conflict = c2.admission > c1.admission && c2.discharge < c1.discharge
   * <p>Conflict = c2.admission = c1.admission && c2.discharge = c1.discharge && hospitalNumber1 != hospitalNumber2
   *
   * @param admission1 tested claim admission date
   * @param discharge1 tested claim discharge date
   * @param admission2 potentially conflicting claim admission date
   * @param discharge2 potentially conflicting claim discharge date
   * @return true if conflicting claim
   */
  protected boolean isConflictInpatient(
      LocalDate admission1, LocalDate discharge1, LocalDate admission2, LocalDate discharge2, 
      String hospitalNumber1 , String hospitalNumber2) {

        if (admission2.isAfter(admission1) && discharge2.isBefore(discharge1)
              || admission2.isBefore(admission1) && (discharge2.isBefore(discharge1) || discharge2.isEqual(discharge1)) && discharge2.isAfter(admission1)
              || (admission2.isAfter(admission1) || admission2.isEqual(admission1))  && admission2.isBefore(discharge1) && discharge2.isAfter(discharge1)
              || admission2.isBefore(admission1) && discharge2.isAfter(discharge1)
              || admission2.isEqual(admission1) && discharge2.isEqual(discharge1) && !hospitalNumber1.equals(hospitalNumber2))
          return true;
      else
          return false;
  }

  /**
   * Find Conflicting claims for an OUTPATIENT claim. A Conflicting claim is:
   * <li>same Patient (same insurance number, province and birth date)
   * <li>other claim is INPATIENT with service date between admission-discharge
   *
   * @param claim the claim
   * @return the list
   */
  public List<HospitalOopClaims> findOutpatConflictingClaims(ClaimViewModel claim) {
    // Get all claims for patient
    List<HospitalOopClaims> claimsForPatient =
        appService.findClaimsForPatient(
            claim.getPatient().getInsuranceCardNumber(),
            claim.getPatient().getProvince(),
            claim.getPatient().getBirthDate());

    // Filter out Self
    claimsForPatient.removeIf(c -> c.getId().equals(claim.getClaimId()));

    // Filter out same claim types
    claimsForPatient.removeIf(c -> c.getCtsId().getId().equals(claim.getClaimType().getId()));
    
    // BCMOHAD-9594-22/01/31: Filter out different hospitals
    claimsForPatient.removeIf(
        c ->
            c.getHspId() == null
                || !c.getHspId().getHospitalNumber().equals(claim.getHospitalNumber()));

    // remove if service date not in admission-discharge (exclusive)
    claimsForPatient.removeIf(
        c ->
            !(isConflictOutpatient(
                c.getAdmissionsList().get(0).getAdmissionDate(),
                c.getAdmissionsList().get(0).getDischargeDate(),
                claim.getServiceDate())));

    return claimsForPatient;
  }

  /**
   * Returns true if diagnostic is for multiple birth.
   *
   * @param codeValue the code value
   * @return true, if is newborn
   */
  public boolean isNewborn(String codeValue) {
    ClaimDetailCodes newbornCode = appService.getNewbornCode(codeValue);
    return newbornCode != null;
  }

  /**
   * Returns true if diagnostic is for multiple birth.
   *
   * @param codeValue the code value
   * @return true, if is multiple birth
   */
  public boolean isMultipleBirth(String codeValue) {
    ClaimDetailCodes newbornCode = appService.getNewbornCode(codeValue);
    if (newbornCode != null) {
      return "Y".equals(newbornCode.getDuplicateAllowedInd());
    }
    return false;
  }

  /**
   * Get the main diagnostic (#1) from a given claim.
   *
   * @param claim the claim
   * @return the main diagnostic
   */
  public ClaimDetailCodes getMainDiagnostic(HospitalOopClaims claim) {
    return claim.getClaimContentsList().stream()
        .filter(c -> c.getContext().equals(ClaimContentContext.DIAGNOSTIC.toString()))
        .sorted((c1, c2) -> c1.getSequenceNum().compareTo(c2.getSequenceNum()))
        .map(c -> c.getCdcId())
        .findFirst()
        .orElse(null);
  }

  /**
   * Get the service code from a given claim.
   *
   * @param claim the claim
   * @return the service code
   */
  public ClaimDetailCodes getServiceCode(HospitalOopClaims claim) {
    return claim.getClaimContentsList().stream()
        .filter(c -> c.getContext().equals(ClaimContentContext.SERVICE.toString()))
        .map(c -> c.getCdcId())
        .findFirst()
        .orElse(null);
  }

  /**
   * Get the High Cost Procedure rates based on high cost code value.
   *
   * @param highCostCode the high cost code
   * @return the high cost code rates
   */
  public List<HighcostProcedureRate> getHighCostCodeRates(Short highCostCode) {
    try {
      HighcostProcedureCodes highcostProcedure =
          appService.findHighcostProcedureByCode(highCostCode);
      if (highcostProcedure != null) {
        return highcostProcedure.getHighcostProcedureRateList();
      }
    } catch (Exception ex) {
      log.error("Error in ClaimValidatorHelper.getHighCostCodeRates", ex);
      return new ArrayList<>();
    }
    return new ArrayList<>();
  }

  /**
   * Filter high cost code rates on date.
   *
   * @param rates the rates
   * @param highCostDate the high cost date
   * @return the list
   */
  public List<HighcostProcedureRate> filterHighCostCodeRatesOnDate(
      List<HighcostProcedureRate> rates, LocalDate highCostDate) {
    List<HighcostProcedureRate> filteredRates = new ArrayList<>();
    for (HighcostProcedureRate rate : rates) {
      // Verify if highCostDate is inside the rate range
      // Two possible ranges in the condition : effectiveDate and over && between effectiveDate and
      // endDate.
      if (rate.getEffectiveDate() != null
          && ((rate.getEndDate() == null && !highCostDate.isBefore(rate.getEffectiveDate()))
              || (rate.getEndDate() != null
                  && Range.between(rate.getEffectiveDate(), rate.getEndDate())
                      .contains(highCostDate)))) {
        filteredRates.add(rate);
      }
    }
    return filteredRates;
  }

  /**
   * Returns if a claim type is INPATIENT.
   *
   * @param claim the claim
   * @return true, if is inpatient
   */
  public boolean isInpatient(HospitalOopClaims claim) {
    return GlobalConstants.INPATIENT_CLAIM_TYPE.equals(claim.getCtsId().getClaimType());
  }

  /**
   * Return if appUser has access to given hospital.
   *
   * @param appUser the app user
   * @param hospital the hospital
   * @return true, if is user authorized
   */
  public boolean isUserAuthorized(ApplicationUsers appUser, Hospitals hospital) {
    LocalDate today = LocalDate.now();

    // Check if user is active
    if (!isBetween(today, appUser.getAccessEffectiveDate(), appUser.getAccessEndDate())) {
      return false;
    }

    // For MINISTRY users, all hospitals are valid
    if (StringUtils.equalsIgnoreCase(appUser.getApplicationRole(), ROLE_MINISTRY)) {
      return true;
    } else {
      // get all hospitals for user
      AppUserAuthorizations auth =
          appUser.getAppUserAuthorizationsList().stream()
              .filter(a -> hospital.getId().equals(a.getHspId().getId()))
              .findFirst()
              .orElse(null);

      // Check if user auth is active
      if (auth != null && isBetween(today, auth.getEffectiveDate(), auth.getEndDate())) {
        return true;
      }
    }

    return false;
  }

  /**
   * True if date is between min and max dates. if max is null: infinite.
   *
   * @param date Not Null
   * @param min Not Null
   * @param max if Null
   * @return true, if is between
   */
  public boolean isBetween(LocalDate date, LocalDate min, LocalDate max) {
    if (date == null || min == null) {
      throw new IllegalArgumentException("date or min cannot be null");
    }
    if (date.isBefore(min)) {
      return false;
    }
    if (max != null && date.isAfter(max)) {
      return false;
    }
    return true;
  }
}
