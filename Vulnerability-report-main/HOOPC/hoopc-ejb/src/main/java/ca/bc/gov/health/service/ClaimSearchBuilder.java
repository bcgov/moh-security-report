package ca.bc.gov.health.service;

import ca.bc.gov.health.constants.ClaimContentContext;
import static ca.bc.gov.health.constants.GlobalConstants.INPATIENT_NB_CODING;
import static ca.bc.gov.health.constants.GlobalConstants.ROLE_MINISTRY;
import ca.bc.gov.health.database.entity.ApplicationUsers;
import ca.bc.gov.health.database.entity.ClaimContents;
import ca.bc.gov.health.database.entity.HighcostProcedurePerformed;
import ca.bc.gov.health.database.entity.HospitalOopClaims;
import ca.bc.gov.health.service.viewmodel.AdmissionsViewModel;
import ca.bc.gov.health.service.viewmodel.ClaimOverridesViewModel;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.HighcostViewModel;
import ca.bc.gov.health.service.viewmodel.PatientsViewModel;
import jakarta.ejb.Singleton;
import jakarta.inject.Inject;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Path;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Root;
import jakarta.persistence.criteria.Subquery;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Class ClaimSearchBuilder. */
@Singleton
public class ClaimSearchBuilder {

  private static final String HOC_ID_CONST = "hocId";

  private static final String CONTEXT_CONST = "context";

  private static final String CODE_VALUE_CONST = "codeValue";

  private static final String CDC_ID_CONST = "cdcId";

  private static Logger log = LoggerFactory.getLogger(ClaimSearchBuilder.class);

  @Inject private HoopcSessionBean session;

  @Inject private HoopcAppService appService;

  @Inject private CriteriaBuilderWrapper cb;

  /** Instantiates a new claim search builder. */
  public ClaimSearchBuilder() {
    // No initialization needed, just instance
  }

  /**
   * Builds the search query.
   *
   * @param claimCriteria the claim criteria
   * @param sortField
   * @param sortOrder
   * @return the criteria query
   */
  public CriteriaQuery<HospitalOopClaims> buildSearchQuery(
      ClaimViewModel claimCriteria, String sortField, String sortOrder) {
    log.info("Building Search Query");

    CriteriaQuery<HospitalOopClaims> query = cb.createQuery(HospitalOopClaims.class);
    Root<HospitalOopClaims> claim = query.from(HospitalOopClaims.class);
    query.select(claim);
    query.where(buildPredicates(claimCriteria, query, claim).toArray(new Predicate[] {}));
    if (sortField != null) {
      Path<Object> path = null;
      if (sortField.matches(".*\\..*")) {
        path =
            claim
                .get(sortField.replaceFirst("(\\..*)|(\\[0\\]\\..*)", ""))
                .get(sortField.replaceFirst(".*\\.", ""));
      } else {
        path = claim.get(sortField);
      }
      if (sortOrder.equals("ASCENDING")) {
        query.orderBy(cb.getCriteriaBuilder().asc(path));
      } else if (sortOrder.equals("DESCENDING")) {
        query.orderBy(cb.getCriteriaBuilder().desc(path));
      }
    }
    return query;
  }

  public CriteriaQuery<Long> buildCountSearchQuery(ClaimViewModel claimCriteria) {
    CriteriaBuilder qb = cb.getCriteriaBuilder();
    CriteriaQuery<Long> cq = qb.createQuery(Long.class);
    Root<HospitalOopClaims> claim = cq.from(HospitalOopClaims.class);
    cq.select(cb.getCriteriaBuilder().count(claim));
    cq.where(buildPredicatesCountQuery(claimCriteria, cq, claim).toArray(new Predicate[] {}));
    return cq;
  }

  /**
   * Builds the predicates.
   *
   * @param claimCriteria the claim criteria
   * @param query the query
   * @param claim the claim
   * @return the list
   */
  protected List<Predicate> buildPredicates(
      ClaimViewModel claimCriteria,
      CriteriaQuery<HospitalOopClaims> query,
      Root<HospitalOopClaims> claim) {
    List<Predicate> queryPredicates = new ArrayList<>();

    Predicate userFilter = createUserFilter(claimCriteria, query, claim);
    if (userFilter != null) {
      queryPredicates.add(userFilter);
    }

    queryPredicates.addAll(buildClaimCriteria(claimCriteria, claim));

    queryPredicates.addAll(buildAdmissionClaimCriteria(claimCriteria, claim));

    queryPredicates.addAll(buildPatientPredicate(claimCriteria, claim));

    queryPredicates.addAll(buildClaimContentPredicate(claimCriteria, query, claim));

    queryPredicates.addAll(buildClaimOverrideStatusPredicate(claimCriteria, claim));

    queryPredicates.addAll(buildHighCostCodesPredicate(claimCriteria, query, claim));

    return queryPredicates;
  }

  /**
   * Builds the predicates.
   *
   * @param claimCriteria the claim criteria
   * @param query the query
   * @param claim the claim
   * @return the list
   */
  protected List<Predicate> buildPredicatesCountQuery(
      ClaimViewModel claimCriteria, CriteriaQuery<Long> query, Root<HospitalOopClaims> claim) {
    List<Predicate> queryPredicates = new ArrayList<>();

    Predicate userFilter = createUserFilterCountQuery(claimCriteria, query, claim);
    if (userFilter != null) {
      queryPredicates.add(userFilter);
    }

    queryPredicates.addAll(buildClaimCriteria(claimCriteria, claim));

    queryPredicates.addAll(buildAdmissionClaimCriteria(claimCriteria, claim));

    queryPredicates.addAll(buildPatientPredicate(claimCriteria, claim));

    queryPredicates.addAll(buildClaimContentPredicateCountQuery(claimCriteria, query, claim));

    queryPredicates.addAll(buildClaimOverrideStatusPredicate(claimCriteria, claim));

    queryPredicates.addAll(buildHighCostCodesPredicateCountQuery(claimCriteria, query, claim));

    return queryPredicates;
  }

  /**
   * Adds a filter to return only authorized hospitals if the logged on user is not of MINISTRY
   * role.
   *
   * @param claimCriteria the claim criteria
   * @param query the query
   * @param claim the claim
   * @return the predicate
   */
  protected Predicate createUserFilter(
      ClaimViewModel claimCriteria,
      CriteriaQuery<HospitalOopClaims> query,
      Root<HospitalOopClaims> claim) {
    ApplicationUsers user = session.getCurrentUser();

    // TODO: user null????
    // Ministry users have no restrictions
    if (ROLE_MINISTRY.equals(user.getApplicationRole())) {
      return null;
    }

    // TODO: Move to appservice?
    List<Long> listHsp =
        user.getAppUserAuthorizationsList().stream()
            .map(a -> a.getHspId().getId())
            .collect(Collectors.toList());

    // Add an IN filter like hspId.id IN (x, y, z, ...)
    return claim.get("hspId").get("id").in(listHsp);
  }

  /**
   * Adds a filter to return only authorized hospitals if the logged on user is not of MINISTRY
   * role.
   *
   * @param claimCriteria the claim criteria
   * @param query the query
   * @param claim the claim
   * @return the predicate
   */
  protected Predicate createUserFilterCountQuery(
      ClaimViewModel claimCriteria, CriteriaQuery<Long> query, Root<HospitalOopClaims> claim) {
    ApplicationUsers user = session.getCurrentUser();

    // TODO: user null????
    // Ministry users have no restrictions
    if (ROLE_MINISTRY.equals(user.getApplicationRole())) {
      return null;
    }

    // TODO: Move to appservice?
    List<Long> listHsp =
        user.getAppUserAuthorizationsList().stream()
            .map(a -> a.getHspId().getId())
            .collect(Collectors.toList());

    // Add an IN filter like hspId.id IN (x, y, z, ...)
    return claim.get("hspId").get("id").in(listHsp);
  }

  /**
   * Builds the claim criteria.
   *
   * @param claimCriteria the claim criteria
   * @param claim the claim
   * @return the list
   */
  @SuppressWarnings("squid:S3776")
  protected List<Predicate> buildClaimCriteria(
      ClaimViewModel claimCriteria, Root<HospitalOopClaims> claim) {
    List<Predicate> queryPredicates = new ArrayList<>();

    if (claimCriteria.getClaimId() != null) {
      queryPredicates.add(cb.equal(claim.get("id"), claimCriteria.getClaimId()));
    }

    if (claimCriteria.getClaimType() != null) {
      queryPredicates.add(cb.equal(claim.get("ctsId"), claimCriteria.getClaimType()));
    }

    if (claimCriteria.getResidencyType() != null) {
      queryPredicates.add(cb.equal(claim.get("rtsId"), claimCriteria.getResidencyType()));
    }

    if (claimCriteria.getTreatingProvince() != null) {
      queryPredicates.add(
          cb.equal(
              claim.get("treatingPteId"),
              appService.getProvince(claimCriteria.getTreatingProvince())));
    }

    if (claimCriteria.getHospitalNumberAndName() != null) {
      queryPredicates.add(
          cb.equal(claim.get("hspId").get("hospitalNumber"), claimCriteria.getHospitalNumber()));
    }

    if (!StringUtils.isEmpty(claimCriteria.getIcdCodingScheme())
        && !claimCriteria.getIcdCodingScheme().equalsIgnoreCase("Both")) {
      queryPredicates.add(
          cb.equal(claim.get("icdCodingScheme"), claimCriteria.getIcdCodingScheme()));
    }

    if (!StringUtils.isEmpty(claimCriteria.getHospitalNotes())) {
      queryPredicates.add(
          cb.containsIgnoreCase(claim.get("hospitalNotes"), claimCriteria.getHospitalNotes()));
    }

    if (!StringUtils.isEmpty(claimCriteria.getReviewNotes())) {
      queryPredicates.add(
          cb.containsIgnoreCase(claim.get("reviewNotes"), claimCriteria.getReviewNotes()));
    }

    if (!StringUtils.isEmpty(claimCriteria.getProvincialClaimId())) {
      queryPredicates.add(
          cb.equalIgnoreCase(claim.get("provincialClaimId"), claimCriteria.getProvincialClaimId()));
    }

    if (!StringUtils.isEmpty(claimCriteria.getHospitalClaimNumber())) {
      queryPredicates.add(
          cb.equalIgnoreCase(
              claim.get("hospitalClaimNumber"), claimCriteria.getHospitalClaimNumber()));
    }

    if (!StringUtils.isBlank(claimCriteria.getStatusCode())) {
      queryPredicates.add(
          cb.equal(claim.get("csId").get("statusCode"), claimCriteria.getStatusCode()));
    }

    if (claimCriteria.getSubmissionDateFrom() != null) {
      queryPredicates.add(
          cb.greaterThanOrEqualTo(
              claim.get("submissionDate"), claimCriteria.getSubmissionDateFrom()));
    }
    if (claimCriteria.getSubmissionDateTo() != null) {
      queryPredicates.add(
          cb.lessThanOrEqualTo(claim.get("submissionDate"), claimCriteria.getSubmissionDateTo()));
    }

    if (claimCriteria.getProcessedDateFrom() != null) {
      queryPredicates.add(
          cb.greaterThanOrEqualTo(
              claim.get("processedDate"), claimCriteria.getProcessedDateFrom()));
    }
    if (claimCriteria.getProcessedDateTo() != null) {
      queryPredicates.add(
          cb.lessThanOrEqualTo(claim.get("processedDate"), claimCriteria.getProcessedDateTo()));
    }

    // NOTE: For accident Code, see ClaimContent section

    if (!StringUtils.isBlank(claimCriteria.getAccidentIndicator())) {
      queryPredicates.add(
          cb.equal(claim.get("accidentIndicator"), claimCriteria.getAccidentIndicator()));
    }

    if (claimCriteria.getServiceDate() != null) {
      queryPredicates.add(cb.equal(claim.get("serviceDate"), claimCriteria.getServiceDate()));
    }

    if (claimCriteria.getTotalAmountClaimed() != null) {
      queryPredicates.add(
          cb.equal(claim.get("totalAmountClaimed"), claimCriteria.getTotalAmountClaimed()));
    }

    if (!StringUtils.isBlank(claimCriteria.getReasonInBC())) {
      queryPredicates.add(
          cb.equal(claim.get("ripId").get("reasonCode"), claimCriteria.getReasonInBC()));
    }

    return queryPredicates;
  }

  /**
   * Builds the admission claim criteria.
   *
   * @param claimCriteria the claim criteria
   * @param claim the claim
   * @return the list
   */
  protected List<Predicate> buildAdmissionClaimCriteria(
      ClaimViewModel claimCriteria, Root<HospitalOopClaims> claim) {
    List<Predicate> queryPredicates = new ArrayList<>();

    if (claimCriteria.getAdmission() != null) {
      AdmissionsViewModel admission = claimCriteria.getAdmission();

      Path<Object> admPath = claim.get("admissionsList");

      if (!StringUtils.isBlank(admission.getAdmissionNumber())) {
        queryPredicates.add(
            cb.equalIgnoreCase(admPath.get("admissionNumber"), admission.getAdmissionNumber()));
      }
      if (admission.getAdmissionDate() != null) {
        queryPredicates.add(cb.equal(admPath.get("admissionDate"), admission.getAdmissionDate()));
      }

      if (admission.getDischargeDate() != null) {
        queryPredicates.add(cb.equal(admPath.get("dischargeDate"), admission.getDischargeDate()));
      }

      if (admission.getTotalDaysStay() != null) {
        queryPredicates.add(cb.equal(admPath.get("totalDaysStay"), admission.getTotalDaysStay()));
      }

      if (admission.getWardRate() != null) {
        queryPredicates.add(cb.equal(admPath.get("wardRate"), admission.getWardRate()));
      }

      if (!StringUtils.isBlank(admission.getLongTermStayInd())) {
        queryPredicates.add(
            cb.equal(admPath.get("longTermStayInd"), admission.getLongTermStayInd()));
      }
    }

    return queryPredicates;
  }

  /**
   * Builds the patient predicate.
   *
   * @param claimCriteria the claim criteria
   * @param claim the claim
   * @return the list
   */
  @SuppressWarnings("squid:S3776")
  protected List<Predicate> buildPatientPredicate(
      ClaimViewModel claimCriteria, Root<HospitalOopClaims> claim) {
    List<Predicate> queryPredicates = new ArrayList<>();

    if (claimCriteria.getPatient() != null) {
      Path<Object> patientPath = claim.get("patId");
      PatientsViewModel patient = claimCriteria.getPatient();

      if (!StringUtils.isEmpty(patient.getInsuranceCardNumber())) {
        queryPredicates.add(
            cb.equalIgnoreCase(
                patientPath.get("insuranceCardNumber"),
                claimCriteria.getPatient().getInsuranceCardNumber()));
      }

      if (!StringUtils.isEmpty(patient.getFirstName())) {
        queryPredicates.add(
            cb.equalIgnoreCase(patientPath.get("firstName"), patient.getFirstName()));
      }

      if (!StringUtils.isEmpty(patient.getLastName())) {
        queryPredicates.add(cb.equalIgnoreCase(patientPath.get("lastName"), patient.getLastName()));
      }

      if (!StringUtils.isEmpty(patient.getAddress1())) {
        queryPredicates.add(
            cb.containsIgnoreCase(patientPath.get("address1"), patient.getAddress1()));
      }

      if (!StringUtils.isEmpty(patient.getAddress2())) {
        queryPredicates.add(
            cb.containsIgnoreCase(patientPath.get("address2"), patient.getAddress2()));
      }

      if (!StringUtils.isEmpty(patient.getCity())) {
        queryPredicates.add(cb.equalIgnoreCase(patientPath.get("city"), patient.getCity()));
      }

      if (!StringUtils.isEmpty(patient.getProvince())) {
        queryPredicates.add(cb.equal(patientPath.get("province"), patient.getProvince()));
      }

      if (!StringUtils.isEmpty(patient.getPostalCode())) {
        String code = patient.getPostalCode().toUpperCase().replace(" ", "");
        queryPredicates.add(cb.equalIgnoreCase(patientPath.get("postalCode"), code));
      }

      if (patient.getCardExpiryDate() != null) {
        queryPredicates.add(
            cb.equal(patientPath.get("cardExpiryDate"), patient.getCardExpiryDate()));
      }

      if (patient.getBirthDate() != null) {
        queryPredicates.add(cb.equal(patientPath.get("birthDate"), patient.getBirthDate()));
      }

      if (!StringUtils.isEmpty(patient.getSexCode())) {
        queryPredicates.add(cb.equal(patientPath.get("sexCode"), patient.getSexCode()));
      }

      if (!StringUtils.isEmpty(patient.getDeceasedFlag())) {
        queryPredicates.add(cb.equal(patientPath.get("deceasedFlag"), patient.getDeceasedFlag()));
      }
    }
    return queryPredicates;
  }

  /**
   * Builds the claim override status predicate.
   *
   * @param claimCriteria the claim criteria
   * @param claim the claim
   * @return the list
   */
  protected List<Predicate> buildClaimOverrideStatusPredicate(
      ClaimViewModel claimCriteria, Root<HospitalOopClaims> claim) {
    List<Predicate> queryPredicates = new ArrayList<>();

    if (claimCriteria.getClaimOverride() != null) {
      Path<Object> overridePath = claim.get("claimOverrides");
      ClaimOverridesViewModel override = claimCriteria.getClaimOverride();

      if (override.isOverrideRequest()) {
        queryPredicates.add(cb.equal(overridePath.get("overrideRequest"), "Y"));
      }

      if (!StringUtils.isBlank(override.getOverrideRequestReason())) {
        queryPredicates.add(
            cb.containsIgnoreCase(
                overridePath.get("overrideRequestReason"), override.getOverrideRequestReason()));
      }

      if (!StringUtils.isBlank(override.getOverrideStatus())) {
        queryPredicates.add(
            cb.containsIgnoreCase(
                overridePath.get("overrideStatus"), override.getOverrideStatus()));
      }

      if (!StringUtils.isBlank(override.getOverrideStatusReason())) {
        queryPredicates.add(
            cb.containsIgnoreCase(
                overridePath.get("overrideStatusReason"), override.getOverrideStatusReason()));
      }
    }

    return queryPredicates;
  }

  /**
   * Builds the claim content predicate.
   *
   * @param claimCriteria the claim criteria
   * @param query the query
   * @param claim the claim
   * @return the list
   */
  protected List<Predicate> buildClaimContentPredicate(
      ClaimViewModel claimCriteria,
      CriteriaQuery<HospitalOopClaims> query,
      Root<HospitalOopClaims> claim) {
    List<Predicate> queryPredicates = new ArrayList<>();
    Path<Object> contentPath = claim.get("claimContentsList");

    // Service Code
    if (!StringUtils.isBlank(claimCriteria.getServiceCodeValue())) {
      queryPredicates.add(
          cb.and(
              cb.equal(contentPath.get(CONTEXT_CONST), ClaimContentContext.SERVICE.toString()),
              cb.equal(
                  contentPath.get(CDC_ID_CONST).get(CODE_VALUE_CONST),
                  claimCriteria.getServiceCodeValue())));
    }

    // Accident Code
    if (!StringUtils.isBlank(claimCriteria.getAccidentCode())) {
      queryPredicates.add(
          cb.and(
              cb.equal(contentPath.get(CONTEXT_CONST), ClaimContentContext.ACCIDENT.toString()),
              cb.equal(
                  contentPath.get(CDC_ID_CONST).get(CODE_VALUE_CONST),
                  claimCriteria.getAccidentCode())));
    }

    // For diagnostic and procedure codes, generate a subquery to fetch all codes for a claim than
    // use IN operator to filter. Example:
    //
    // 'CODE_TO_SEARCH' IN (
    // SELECT cdc.CODE_VALUE
    // FROM
    // HOSPITAL_OOP_CLAIMS hoc1,
    // CLAIM_CONTENTS cc,
    // CLAIM_DETAIL_CODES cdc
    // WHERE
    // (((hoc.ID = hoc1.ID)
    // AND (cc.CONTEXT = 'DIAGNOSTIC'))
    // AND ((hoc.ID = cc.HOC_ID)
    // AND (cdc.ID = cc.CDC_ID)))))
    // NOTE1: We don't filter for a specific coding scheme. So it should work to find ICD09 codes
    // (not tested).
    // NOTE2: This subquery is repeated for each code entered in search form. This may lead to
    // performance issues. Will rework later if necessary.

    for (int i = 0; i < INPATIENT_NB_CODING; i++) {
      // Diagnostic Codes
      if (!StringUtils.isBlank(claimCriteria.getDiagnosisCodes()[i])) {

        Subquery<String> subQuery = query.subquery(String.class);
        Root<ClaimContents> subRoot = subQuery.from(ClaimContents.class);
        subQuery.select(subRoot.get(CDC_ID_CONST).get(CODE_VALUE_CONST));
        subQuery.where(
            cb.and(
                cb.equal(claim.get("id"), subRoot.get(HOC_ID_CONST).get("id")),
                cb.equal(subRoot.get(CONTEXT_CONST), "DIAGNOSTIC")));

        queryPredicates.add(cb.literal(claimCriteria.getDiagnosisCodes()[i]).in(subQuery));
      }

      // Procedure Codes
      if (!StringUtils.isBlank(claimCriteria.getProcedureCodes()[i])) {

        Subquery<String> subQuery = query.subquery(String.class);
        Root<ClaimContents> subRoot = subQuery.from(ClaimContents.class);
        subQuery.select(subRoot.get(CDC_ID_CONST).get(CODE_VALUE_CONST));
        subQuery.where(
            cb.and(
                cb.equal(claim.get("id"), subRoot.get(HOC_ID_CONST).get("id")),
                cb.equal(subRoot.get(CONTEXT_CONST), "PROCEDURE")));

        queryPredicates.add(cb.literal(claimCriteria.getProcedureCodes()[i]).in(subQuery));
      }
    }

    return queryPredicates;
  }

  /**
   * Builds the claim content predicate.
   *
   * @param claimCriteria the claim criteria
   * @param query the query
   * @param claim the claim
   * @return the list
   */
  protected List<Predicate> buildClaimContentPredicateCountQuery(
      ClaimViewModel claimCriteria, CriteriaQuery<Long> query, Root<HospitalOopClaims> claim) {
    List<Predicate> queryPredicates = new ArrayList<>();
    Path<Object> contentPath = claim.get("claimContentsList");

    // Service Code
    if (!StringUtils.isBlank(claimCriteria.getServiceCodeValue())) {
      queryPredicates.add(
          cb.and(
              cb.equal(contentPath.get(CONTEXT_CONST), ClaimContentContext.SERVICE.toString()),
              cb.equal(
                  contentPath.get(CDC_ID_CONST).get(CODE_VALUE_CONST),
                  claimCriteria.getServiceCodeValue())));
    }

    // Accident Code
    if (!StringUtils.isBlank(claimCriteria.getAccidentCode())) {
      queryPredicates.add(
          cb.and(
              cb.equal(contentPath.get(CONTEXT_CONST), ClaimContentContext.ACCIDENT.toString()),
              cb.equal(
                  contentPath.get(CDC_ID_CONST).get(CODE_VALUE_CONST),
                  claimCriteria.getAccidentCode())));
    }

    // For diagnostic and procedure codes, generate a subquery to fetch all codes for a claim than
    // use IN operator to filter. Example:
    //
    // 'CODE_TO_SEARCH' IN (
    // SELECT cdc.CODE_VALUE
    // FROM
    // HOSPITAL_OOP_CLAIMS hoc1,
    // CLAIM_CONTENTS cc,
    // CLAIM_DETAIL_CODES cdc
    // WHERE
    // (((hoc.ID = hoc1.ID)
    // AND (cc.CONTEXT = 'DIAGNOSTIC'))
    // AND ((hoc.ID = cc.HOC_ID)
    // AND (cdc.ID = cc.CDC_ID)))))
    // NOTE1: We don't filter for a specific coding scheme. So it should work to find ICD09 codes
    // (not tested).
    // NOTE2: This subquery is repeated for each code entered in search form. This may lead to
    // performance issues. Will rework later if necessary.

    for (int i = 0; i < INPATIENT_NB_CODING; i++) {
      // Diagnostic Codes
      if (!StringUtils.isBlank(claimCriteria.getDiagnosisCodes()[i])) {

        Subquery<String> subQuery = query.subquery(String.class);
        Root<ClaimContents> subRoot = subQuery.from(ClaimContents.class);
        subQuery.select(subRoot.get(CDC_ID_CONST).get(CODE_VALUE_CONST));
        subQuery.where(
            cb.and(
                cb.equal(claim.get("id"), subRoot.get(HOC_ID_CONST).get("id")),
                cb.equal(subRoot.get(CONTEXT_CONST), "DIAGNOSTIC")));

        queryPredicates.add(cb.literal(claimCriteria.getDiagnosisCodes()[i]).in(subQuery));
      }

      // Procedure Codes
      if (!StringUtils.isBlank(claimCriteria.getProcedureCodes()[i])) {

        Subquery<String> subQuery = query.subquery(String.class);
        Root<ClaimContents> subRoot = subQuery.from(ClaimContents.class);
        subQuery.select(subRoot.get(CDC_ID_CONST).get(CODE_VALUE_CONST));
        subQuery.where(
            cb.and(
                cb.equal(claim.get("id"), subRoot.get(HOC_ID_CONST).get("id")),
                cb.equal(subRoot.get(CONTEXT_CONST), "PROCEDURE")));

        queryPredicates.add(cb.literal(claimCriteria.getProcedureCodes()[i]).in(subQuery));
      }
    }

    return queryPredicates;
  }

  /**
   * Builds the high cost codes predicate.
   *
   * @param claimCriteria the claim criteria
   * @param query the query
   * @param claim the claim
   * @return the list
   */
  protected List<Predicate> buildHighCostCodesPredicate(
      ClaimViewModel claimCriteria,
      CriteriaQuery<HospitalOopClaims> query,
      Root<HospitalOopClaims> claim) {
    List<Predicate> queryPredicates = new ArrayList<>();

    for (int i = 0; i < INPATIENT_NB_CODING; i++) {
      HighcostViewModel highcost = claimCriteria.getHighCostProcedures()[i];

      // Add this subquery condition like this:
      // ... AND EXISTS (SELECT 1
      // FROM
      // HIGHCOST_PROCEDURE_CODES hcp,
      // HIGHCOST_PROCEDURE_PERFORMED hcpp,
      // HOSPITAL_OOP_CLAIMS hoc1
      // WHERE
      // hoc.ID = hoc1.ID
      // AND hcp.HIGH_COST_PROCEDURE_CODE = 12
      // AND hcpp.PROCEDURE_DATE = '20190402'
      // AND hcpp.PROCEDURE_COST = 123
      // AND hoc1.ID = hcpp.HOC_ID
      // AND hcp.ID = hcpp.HCPP_ID)

      // TODO: seems like a better solution that the one implemented for procedure/diagnostic codes.
      // Could retrofit to the same strategy later.

      if (!StringUtils.isBlank(highcost.getCodeValue())
          || highcost.getProcedureDate() != null
          || highcost.getProcedureCost() != null) {
        // if one of the 3 values present, build the subquery
        Subquery<Long> subQuery = query.subquery(Long.class);
        Root<HighcostProcedurePerformed> subRoot = subQuery.from(HighcostProcedurePerformed.class);
        subQuery.select(cb.literal(1l));
        List<Predicate> subPredicate = new ArrayList<>();
        // Link claim and highcost
        subPredicate.add(cb.equal(claim.get("id"), subRoot.get(HOC_ID_CONST).get("id")));
        if (!StringUtils.isBlank(highcost.getCodeValue())) {
          subPredicate.add(
              cb.equal(
                  subRoot.get("hcppId").get("highCostProcedureCode"),
                  Long.valueOf(highcost.getCodeValue())));
        }
        if (highcost.getProcedureDate() != null) {
          subPredicate.add(cb.equal(subRoot.get("procedureDate"), highcost.getProcedureDate()));
        }
        if (highcost.getProcedureCost() != null) {
          subPredicate.add(cb.equal(subRoot.get("procedureCost"), highcost.getProcedureCost()));
        }
        subQuery.where(subPredicate.toArray(new Predicate[] {}));

        queryPredicates.add(cb.exists(subQuery));
      }
    }

    return queryPredicates;
  }

  /**
   * Builds the high cost codes predicate.
   *
   * @param claimCriteria the claim criteria
   * @param query the query
   * @param claim the claim
   * @return the list
   */
  protected List<Predicate> buildHighCostCodesPredicateCountQuery(
      ClaimViewModel claimCriteria, CriteriaQuery<Long> query, Root<HospitalOopClaims> claim) {
    List<Predicate> queryPredicates = new ArrayList<>();

    for (int i = 0; i < INPATIENT_NB_CODING; i++) {
      HighcostViewModel highcost = claimCriteria.getHighCostProcedures()[i];

      // Add this subquery condition like this:
      // ... AND EXISTS (SELECT 1
      // FROM
      // HIGHCOST_PROCEDURE_CODES hcp,
      // HIGHCOST_PROCEDURE_PERFORMED hcpp,
      // HOSPITAL_OOP_CLAIMS hoc1
      // WHERE
      // hoc.ID = hoc1.ID
      // AND hcp.HIGH_COST_PROCEDURE_CODE = 12
      // AND hcpp.PROCEDURE_DATE = '20190402'
      // AND hcpp.PROCEDURE_COST = 123
      // AND hoc1.ID = hcpp.HOC_ID
      // AND hcp.ID = hcpp.HCPP_ID)

      // TODO: seems like a better solution that the one implemented for procedure/diagnostic codes.
      // Could retrofit to the same strategy later.

      if (!StringUtils.isBlank(highcost.getCodeValue())
          || highcost.getProcedureDate() != null
          || highcost.getProcedureCost() != null) {
        // if one of the 3 values present, build the subquery
        Subquery<Long> subQuery = query.subquery(Long.class);
        Root<HighcostProcedurePerformed> subRoot = subQuery.from(HighcostProcedurePerformed.class);
        subQuery.select(cb.literal(1l));
        List<Predicate> subPredicate = new ArrayList<>();
        // Link claim and highcost
        subPredicate.add(cb.equal(claim.get("id"), subRoot.get(HOC_ID_CONST).get("id")));
        if (!StringUtils.isBlank(highcost.getCodeValue())) {
          subPredicate.add(
              cb.equal(
                  subRoot.get("hcppId").get("highCostProcedureCode"),
                  Long.valueOf(highcost.getCodeValue())));
        }
        if (highcost.getProcedureDate() != null) {
          subPredicate.add(cb.equal(subRoot.get("procedureDate"), highcost.getProcedureDate()));
        }
        if (highcost.getProcedureCost() != null) {
          subPredicate.add(cb.equal(subRoot.get("procedureCost"), highcost.getProcedureCost()));
        }
        subQuery.where(subPredicate.toArray(new Predicate[] {}));

        queryPredicates.add(cb.exists(subQuery));
      }
    }

    return queryPredicates;
  }
}
