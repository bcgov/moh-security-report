/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.service;

import ca.bc.gov.health.constants.GlobalConstants;
import ca.bc.gov.health.registry.service.HealthRegistry;
import ca.bc.gov.health.registry.service.HealthRegistryException;
import ca.bc.gov.health.registry.service.MessageMetaData;
import ca.bc.gov.health.registry.v2.model.E45Query;
import ca.bc.gov.health.registry.v2.model.E45Response;
import ca.bc.gov.health.registry.v3.model.Address;
import ca.bc.gov.health.registry.v3.model.GetDemographicsQuery;
import ca.bc.gov.health.registry.v3.model.Name;
import ca.bc.gov.health.registry.v3.model.Person;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.PatientsViewModel;
import ca.bc.gov.health.validation.ValidationError;
import jakarta.annotation.Resource;
import jakarta.ejb.SessionContext;
import jakarta.ejb.Stateless;
import jakarta.inject.Inject;
import java.text.MessageFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author trevor.schiavone
 */
@Stateless
public class ClaimEligibilityService {

  @Inject
  private HealthRegistry healthRegistry;

  @Resource
  private SessionContext context;

  private static Logger log = LoggerFactory.getLogger(ClaimEligibilityService.class);

  protected static final DateTimeFormatter DT_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd");

  /**
   * @param claimView
   * @return
   */
  public List<ValidationError> validateClaimEligiblityAndDemographics(ClaimViewModel claimView) {

    List<ValidationError> validationErrors = new ArrayList<>();
    PatientsViewModel patient = claimView.getPatient();
    // INITIAL PHN VALIDATION
    if (patient.getBirthDate() == null
            || patient.getInsuranceCardNumber() == null
            || !HealthRegistry.isValidPHN(patient.getInsuranceCardNumber())) {

      // Null values or invalid PHN: "Insurance number" + insuranceCardNumber + "is not eligible for
      // treatement"
      validationErrors.add(
              new ValidationError(
                      MessageFormat.format(
                              GlobalConstants.NOT_ELIGIBLE_MESSAGE, patient.getInsuranceCardNumber())));
      log.info("Insurance number " + patient.getInsuranceCardNumber() + " PHN not valid.");
      return validationErrors;
    }
    
    // E45 PART
    if (claimView.getServiceDate() == null) {
      claimView.setServiceDate(LocalDate.now());
    }

    E45Query e45Query
            = new E45Query(
                    patient.getInsuranceCardNumber(),
                    patient.getBirthDate().format(DT_FORMATTER),
                    claimView.getServiceDate().format(DT_FORMATTER),
                    context.getCallerPrincipal().getName(),
                    getE45Env());

    try {
      E45Response e45Resp = healthRegistry.getEligibility(e45Query);
      String e45ResponseMsg = e45Resp.getResponseMesssage().toUpperCase();
      // Reference : https://hl7-definition.caristix.com/v2/HL7v2.8/Segments
      // Reference : https://hl7-definition.caristix.com/v2/HL7v2.8/Segments/IN1
      // Reference : https://hl7-definition.caristix.com/v2/HL7v2.8/Segments/ADJ
      boolean isBirthDateDoNotMatch
              = e45ResponseMsg.contains(GlobalConstants.BIRTHDATES_DO_NOT_MATCH_CODE);
      boolean isADJPresent = e45ResponseMsg.contains(GlobalConstants.ADJ_CODE);
      boolean isEndReasonPresent = e45ResponseMsg.contains(GlobalConstants.ENDRSN_CODE);
      boolean isIN1Present = e45ResponseMsg.contains(GlobalConstants.IN1_CODE);
      boolean isNoErrorValidating = e45ResponseMsg.contains(GlobalConstants.E45_NOERROR_CODE);
      boolean checkDischargeDate = false;
//new validations oct 2020
      boolean isPHNNotExist = e45ResponseMsg.contains(GlobalConstants.PHN_NOT_EXIST_ERROR);
      boolean isOver18Months =  e45ResponseMsg.contains(GlobalConstants.PASSED_18MONTHS_LIMIT_ERROR);
      boolean isMerged = e45ResponseMsg.contains(GlobalConstants.MERGED_PHN_ERROR);
//-----------------------------      
      log.info(
              "First check-up...Insurance number "
              + patient.getInsuranceCardNumber()
              + " isBirthDateDoNotMatch="
              + isBirthDateDoNotMatch
              + " isADJPresent="
              + isADJPresent
              + " isEndReasonPresent="
              + isEndReasonPresent
              + " isIN1Present="
              + isIN1Present
              + " isNoErrorValidating="
              + isNoErrorValidating);

      if (isPHNNotExist) { //Validation if the phn exist
          validationErrors.add(
                new ValidationError(GlobalConstants.PHN_NOT_EXIST));
          return validationErrors;
      } else if (isADJPresent && isEndReasonPresent) {
        log.info("Inside condition : isADJPresent=true && isEndReasonPresent=true");
        validationErrors.add(
                new ValidationError(
                        MessageFormat.format(
                                GlobalConstants.NOT_ELIGIBLE_ON_DATE_MESSAGE,
                                patient.getInsuranceCardNumber(),
                                claimView.getServiceDate())));
      } else if (isIN1Present && isNoErrorValidating) { // Verification of eligibility flag fields 25 in IN1
        int intOffsetIN1Start = e45ResponseMsg.indexOf(GlobalConstants.IN1_CODE);
        String[] splitStrIN1
                = e45ResponseMsg
                        .substring(intOffsetIN1Start)
                        .replace(GlobalConstants.IN1_CODE, "")
                        .split("\\|");

        log.info("intOffsetIN1Start = " + intOffsetIN1Start);
        log.info(
                "IN1 string = "
                + e45ResponseMsg
                        .substring(intOffsetIN1Start)
                        .replace(GlobalConstants.IN1_CODE, ""));
        log.info("splitStrIN1.length=" + splitStrIN1.length);

        String isEligible = "N";
        if (splitStrIN1.length >= 24 && splitStrIN1[24].length() > 0) {
          isEligible = splitStrIN1[24].substring(0, 1).toUpperCase();
          log.info("Found eligible flag=" + isEligible);
          log.info("splitStrIN1[24]=" + splitStrIN1[24]);
        }

        if (isEligible.equals("Y")) {
          log.info("Inside isEligible=y condition");
          // For inpatient verify if covered until discharge date (see below the condition)
          if (claimView
                  .getClaimType()
                  .getClaimType()
                  .equals(GlobalConstants.INPATIENT_CLAIM_TYPE)) {
            checkDischargeDate = true;
            log.info("checkDischargeDate=" + checkDischargeDate);
          }
        } else {
          log.info("Entered else condition for e45 check-up inside isEligible=y condition");
          validationErrors.add(
                  new ValidationError(
                          MessageFormat.format(
                                  GlobalConstants.NOT_ELIGIBLE_ON_DATE_MESSAGE,
                                  patient.getInsuranceCardNumber(),
                                  claimView.getServiceDate())));
        }
        if (isBirthDateDoNotMatch) {
          validationErrors.add(
                  new ValidationError(
                          MessageFormat.format(
                                  GlobalConstants.BIRTHDATE_MISMATCH_MESSAGE, patient.getBirthDate())));
        }

      } else {
        log.info("Entered else condition for e45 check-up outside isEligible=y condition");
        validationErrors.add(
                new ValidationError(
                        MessageFormat.format(
                                GlobalConstants.NOT_ELIGIBLE_ON_DATE_MESSAGE,
                                patient.getInsuranceCardNumber(),
                                claimView.getServiceDate())));
      }

      // Inpatient && no error during service date check then redo the validation with the discharge
      // date
      log.info(
              "validationErrors.size()="
              + validationErrors.size()
              + " and checkDischargeDate="
              + checkDischargeDate);
      if (validationErrors.isEmpty() && checkDischargeDate) {

        e45Query.setServiceDate(claimView.getAdmission().getDischargeDate().format(DT_FORMATTER));
        e45Resp = healthRegistry.getEligibility(e45Query);
        e45ResponseMsg = e45Resp.getResponseMesssage().toUpperCase();
        
        isBirthDateDoNotMatch
                = e45ResponseMsg.contains(GlobalConstants.BIRTHDATES_DO_NOT_MATCH_CODE);
        isADJPresent = e45ResponseMsg.contains(GlobalConstants.ADJ_CODE);
        isEndReasonPresent = e45ResponseMsg.contains(GlobalConstants.ENDRSN_CODE);
        isIN1Present = e45ResponseMsg.contains(GlobalConstants.IN1_CODE);
        isNoErrorValidating = e45ResponseMsg.contains(GlobalConstants.E45_NOERROR_CODE);

        log.info(
                "Second check-up for inpatient...Insurance number "
                + patient.getInsuranceCardNumber()
                + " isBirthDateDoNotMatch="
                + isBirthDateDoNotMatch
                + " isADJPresent="
                + isADJPresent
                + " isEndReasonPresent="
                + isEndReasonPresent
                + " isIN1Present="
                + isIN1Present
                + " isNoErrorValidating="
                + isNoErrorValidating);

        if (isBirthDateDoNotMatch) {
          validationErrors.add(
                  new ValidationError(
                          MessageFormat.format(
                                  GlobalConstants.BIRTHDATE_MISMATCH_MESSAGE,
                                  patient.getInsuranceCardNumber())));

        } else if (isADJPresent && isEndReasonPresent) {
          log.info(
                  "Second check-up...Inside condition : isADJPresent=true && isEndReasonPresent=true");
          validationErrors.add(
                  new ValidationError(
                          MessageFormat.format(
                                  GlobalConstants.NOT_ELIGIBLE_ON_RANGE_MESSAGE,
                                  patient.getInsuranceCardNumber(),
                                  claimView.getServiceDate(),
                                  claimView.getAdmission().getAdmissionDate())));

        } else if (isIN1Present
                && isNoErrorValidating) { // Verification of eligibility flag fields 25 in IN1
          int intOffsetIN1Start = e45ResponseMsg.indexOf(GlobalConstants.IN1_CODE);
          String[] splitStrIN1
                  = e45ResponseMsg
                          .substring(intOffsetIN1Start)
                          .replace(GlobalConstants.IN1_CODE, "")
                          .split("\\|");

          log.info("Second check-up...intOffsetIN1Start = " + intOffsetIN1Start);
          log.info(
                  "Second check-up...IN1 string = "
                  + e45ResponseMsg
                          .substring(intOffsetIN1Start)
                          .replace(GlobalConstants.IN1_CODE, ""));
          log.info("Second check-up...splitStrIN1.length=" + splitStrIN1.length);

          String isEligible = "N";
          if (splitStrIN1.length >= 24 && splitStrIN1[24].length() > 0) {
            log.info("Second check-up...Found eligible flag=" + isEligible);
            log.info("Second check-up...splitStrIN1[24]=" + splitStrIN1[24]);
            isEligible = splitStrIN1[24].substring(0, 1).toUpperCase();
          }
          
          if (isEligible.equals("N")) {
            log.info("Second check-up...inside IN1 found condition with no error but not eligible");
            validationErrors.add(
                    new ValidationError(
                            MessageFormat.format(
                                    GlobalConstants.NOT_ELIGIBLE_ON_DATE_MESSAGE,
                                    patient.getInsuranceCardNumber(),
                                    claimView.getServiceDate())));
          }
        }
      } 
      
      log.info("Final validation pass.");
      if (isOver18Months) { //Validation if the date claimed is older than 18 months.
        validationErrors.add(
              new ValidationError(GlobalConstants.PASSED_18MONTHS_LIMIT));
        }

      if (isMerged) {//Validation of merged phn
          validationErrors.add(
                new ValidationError(MessageFormat.format(GlobalConstants.MERGED_PHN_MESSAGE, patient.getInsuranceCardNumber())));
      } 

    } catch (HealthRegistryException ex) { // Couldn't connect to JMB
      // Couldn't connect to JMB or HNS ESB
      validationErrors.add(new ValidationError(GlobalConstants.JMB_CONNECTION_ERROR_MESSAGE));
      log.info("Got and exception during e45 validation.");
      log.error(ex.getMessage(), ex);
      return validationErrors;
    }

    log.info(
            "Insurance number "
            + patient.getInsuranceCardNumber()
            + " has "
            + validationErrors.size()
            + " then if no error then he is eligible.");

    // GET DEMOGRAPHICS PART
    GetDemographicsQuery getDemoQuery = new GetDemographicsQuery();
    getDemoQuery.setPhn(patient.getInsuranceCardNumber());
    MessageMetaData mmd
            = new MessageMetaData(context.getCallerPrincipal().getName(), "BCHCIM", "HOOPC");

    try {
      Person getDemoResponsePerson = healthRegistry.getDemographics(getDemoQuery, mmd).getPerson();
      validationErrors.addAll(
              validateOrUpdateName(patient, getDemoResponsePerson.getDeclaredName()));
      validationErrors.addAll(
              validateOrUpdateAddress(patient, getDemoResponsePerson.getPhysicalAddress()));

    } catch (HealthRegistryException ex) {
      if (ex.getMessage() != null && ex.getMessage().equals(GlobalConstants.HCIM_USER_NOT_FOUND_ERROR))  {
        validationErrors.add(new ValidationError(GlobalConstants.HCIM_USER_NOT_FOUND_ERROR_MESSAGE));
      }
      else {  
        validationErrors.add(new ValidationError(GlobalConstants.HCIM_CONNECTION_ERROR_MESSAGE));
      }
      log.error(ex.getMessage(), ex);
      return validationErrors;
    }

    return validationErrors;
  }

  /**
   * Takes a patient from a claim and the address from the getDemo response and
   * updates the claim or creates an error
   *
   * @param patient
   * @param getDemoResponseAddress
   * @return
   */
  public List<ValidationError> validateOrUpdateAddress(
          PatientsViewModel patient, Address getDemoResponseAddress) {

    List<ValidationError> errors = new ArrayList<>();

    log.debug("GetDemo City: " + getDemoResponseAddress.getCity());
    log.debug("GetDemo Postal Code: " + getDemoResponseAddress.getPostalCode());

    if (StringUtils.isBlank(patient.getCity())) {
      patient.setCity(getDemoResponseAddress.getCity());

    } else if (!patient.getCity().equalsIgnoreCase(getDemoResponseAddress.getCity())) {
      errors.add(
              new ValidationError(
                      MessageFormat.format(
                              GlobalConstants.NO_MATCHING_VALUES_MESSAGE,
                              "city",
                              patient.getCity(),
                              getDemoResponseAddress.getCity())));
    }

    if (StringUtils.isBlank(patient.getPostalCode())) {
      patient.setPostalCode(getDemoResponseAddress.getPostalCode());

    } else if (!patient
            .getPostalCode()
            .replace(" ", "")
            .equalsIgnoreCase(getDemoResponseAddress.getPostalCode().replace(" ", ""))) {
      errors.add(
              
              
              new ValidationError(
                      MessageFormat.format(
                              GlobalConstants.NO_MATCHING_VALUES_MESSAGE,
                              "postal code",
                              patient.getPostalCode(),
                              getDemoResponseAddress.getPostalCode()))
      );
    }
    return errors;
  }

  /**
   * Takes a patient from a claim and the name from the getDemo response and
   * updates or creates an error
   *
   * @param patient
   * @param getDemoResponseName
   * @return
   */
  public List<ValidationError> validateOrUpdateName(
          PatientsViewModel patient, Name getDemoResponseName) {

    List<ValidationError> errors = new ArrayList<>();

    log.debug("GetDemo First Name: " + getDemoResponseName.getFirstGivenName());
    log.debug("GetDemo Last Name: " + getDemoResponseName.getSurname());

    // First Name validation/update - Update the name if empty else validate against HCIM
    if (StringUtils.isBlank(patient.getFirstName())) {
      patient.setFirstName(getDemoResponseName.getFirstGivenName());

    } else if (!getDemoResponseName.getFirstGivenName().equalsIgnoreCase(patient.getFirstName())) {
      // First Name Error: "The supplied first name" + claimFirstName + "does not match with the
      // inistry first name" + getDemoFirstName
      errors.add(
              new ValidationError(
                      MessageFormat.format(
                              GlobalConstants.NO_MATCHING_VALUES_MESSAGE,
                              "first name",
                              patient.getFirstName(),
                              getDemoResponseName.getFirstGivenName())));
    }

    // Last Name validation/update - Update the name if empty else validate against HCIM
    if (StringUtils.isBlank(patient.getLastName())) {
      patient.setLastName(getDemoResponseName.getSurname());

    } else if (!getDemoResponseName.getSurname().equalsIgnoreCase(patient.getLastName())) {
      // Last Name Error: "The supplied last name" + claimFirstName + "does not match with the
      // inistry last name" + getDemoFirstName
      errors.add(
              new ValidationError(
                      MessageFormat.format(
                              GlobalConstants.NO_MATCHING_VALUES_MESSAGE,
                              "last name",
                              patient.getLastName(),
                              getDemoResponseName.getSurname())));
    }

    return errors;
  }

  /**
   * Get the e45 runtime environment for JNDI. Values for runtimes are (not
   * exclusively) "D" (dev), "T" (test), "S" (staging), "P" (prod). E45
   * environment can be different from runtime environment.
   *
   * @return Value of e45_env_name property
   */
  //  public String getE45Env() {
  //    if (applicationProperties != null) {
  //      String e45EnvName = (String) applicationProperties.get("e45_env_name").getContent();
  //      if (e45EnvName != null) {
  //        return e45EnvName;
  //      }
  //    }
  //    // default is PROD
  //    return "P";
  //  }
  public String getE45Env() {
    Properties applicationProperties;
    String appEnvName = "D";
    try {
      applicationProperties
              = (Properties) new InitialContext().lookup("java:app/hpc/health_registry_properties");

      if (applicationProperties != null
              && applicationProperties.getProperty("e45_env_name") != null) {
        appEnvName = applicationProperties.getProperty("e45_env_name");
        log.info("Found e45_env_name in jndi. appEnvName=" + appEnvName);
      }
    } catch (NamingException ex) {
      log.error("Could not load application properties");
    }

    // default is PROD
    log.info("appEnvName=" + appEnvName);
    return appEnvName;
  }
}
