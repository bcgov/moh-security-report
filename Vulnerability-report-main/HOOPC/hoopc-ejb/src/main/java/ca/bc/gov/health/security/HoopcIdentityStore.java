package ca.bc.gov.health.security;

import static ca.bc.gov.health.constants.GlobalConstants.ROLE_UNAUTHORIZED;
import ca.bc.gov.health.database.ejb.ApplicationUsersFacadeLocal;
import ca.bc.gov.health.database.entity.ApplicationUsers;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.validation.claim.ClaimValidatorHelper;
import fish.payara.security.openid.OpenIdCredential;
import fish.payara.security.openid.OpenIdIdentityStore;
import jakarta.annotation.Priority;
import jakarta.ejb.EJB;
import jakarta.enterprise.inject.Alternative;
import jakarta.security.enterprise.CallerPrincipal;
import jakarta.security.enterprise.identitystore.CredentialValidationResult;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Customized HOOPC specific implementation of a JSR375 <code>IdentityStore</code> for database authorizations
 *
 * @see <a href="https://javaee.github.io/security-spec/">JSR 375</a>
 * @author CGI Information Management Consultants Inc.
 */
@Alternative
@Priority(Integer.MAX_VALUE)
public class HoopcIdentityStore extends OpenIdIdentityStore {

    private static final Logger LOG = LoggerFactory.getLogger(HoopcIdentityStore.class.getName());

    private static final int PRIORITY = 80;

    @EJB
    private ApplicationUsersFacadeLocal applicationUsersFacade;

    /**
     * Override IdentityStore priority()
     *
     * @return
     */
    @Override
    public int priority() {
        return PRIORITY;
    }

    /**
     * Override OpenIdIdentityStore validate() to further validate OpenIdCredential against the database
     *
     * @param credential - JSR375 object holding the access token
     * @see <a href="https://javaee.github.io/security-spec/">JSR 375</a>
     * @return CredentialValidationResult - JSR375 object holding the AuthenticationStatus
     */
    @Override
    public CredentialValidationResult validate(OpenIdCredential credential) {
        
        /* Validate against Keycloak */
        CredentialValidationResult credentialValidationResult = super.validate(credential);

        return new CredentialValidationResult(
            credentialValidationResult.getCallerPrincipal(),
            getUserRole(credentialValidationResult.getCallerPrincipal())
        );
    }

    /**
     * Return the role stored in the database
     *
     * @param callerPrincipal
     * @return the role associated with the caller from the identity store
     */
    private Set<String> getUserRole(CallerPrincipal callerPrincipal) {

        Set<String> groups = new HashSet<>();
        Map<String, Object> criteria = new HashMap<>();
        ClaimValidatorHelper validator = new ClaimValidatorHelper();

        criteria.put("applicationUserid", callerPrincipal.getName());
        try {
            List<ApplicationUsers> users
                    = applicationUsersFacade.findByNamedQuery("ApplicationUsers.findByUserId", criteria);

            if (!users.isEmpty()) {
                /* No more than one ApplicationUsers record per applicationUserid */
                ApplicationUsers user = users.get(0);
                if (validator.isBetween(LocalDate.now(), user.getAccessEffectiveDate(), user.getAccessEndDate())) {
                    groups.add(user.getApplicationRole());
                }
            }
        } catch (HoopcException e) {
            LOG.error(e.getMessage(), e);
        }

        if (groups.isEmpty()) {
            groups.add(ROLE_UNAUTHORIZED);
        }

        return groups;
    }
}
