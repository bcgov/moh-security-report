package ca.bc.gov.health.importfile;

import ca.bc.gov.health.database.entity.ClaimDetailCodes;
import ca.bc.gov.health.database.entity.ProvincesTerritories;
import ca.bc.gov.health.service.HoopcAppService;
import jakarta.inject.Inject;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import moh.common.business.services.utils.CommonValidator;
import moh.common.business.services.utils.Helper;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Validates Claims in the flat file format.
 *
 * <p>After validation, errors are accessible via the {@link #getErrors()} method. Class is not
 * thread-safe. Most of the code in this class was copied from the original HOOPC2 application.
 */
public class HospitalClaimValidator {

  
  private final FileErrors errors = new FileErrors();

  private String importMessage = "";

  private final List<String> unAuthHosps = new ArrayList<>();
  private final List<String> hospList;
  private final List<String> provList;

  private static final String IMPORT_MSG_1 =
      "The import was aborted because file was named incorrectly. Must begin with xxx for inpatient imports or xxx for outpatient imports.";
  private static final String IMPORT_MSG_3 =
      "The import was aborted because data type mis-match(s) at the xxx field on line xxx.";
  private static final String REPLACE_STR = "xxx";

  private static final Logger LOGGER = LoggerFactory.getLogger(HospitalClaimValidator.class);

  @Inject
  public HospitalClaimValidator(
      List<ProvincesTerritories> provinces, @AllowedHospitalNumbers List<String> hospList) {
    this.provList = provinces.stream().map((t) -> t.getProvinceCode()).collect(Collectors.toList());
    this.hospList = hospList;
  }

  @Inject HoopcAppService appService;
  
  public FileErrors getErrors() {
    return errors;
  }

  /**
   * Validates all claims in the flat file format.
   *
   * <p>After validation, errors are accessible via the {@link #getErrors()} method.
   *
   * @param fileName the name of the file, used to distinguish Inpatient and Outpatient claims.
   * @param lines the claims, one claim per line, in the flat file format.
   * @return {@link HOOPC2Properties#SUCCESS} or {@link HOOPC2Properties#FAILURE}.
   * @throws java.lang.Exception
   */
  public int validateImportFile(String fileName, List<String> lines) throws Exception {
    int retval = HOOPC2Properties.SUCCESS;
    int lineCnt = 1;

    String fileType = null;

    // ****************************************************
    // Check what type of file is being processed and raise
    // error if not appropriately named.
    // ****************************************************
    if ((fileName.substring(HICOutp.fnStrt, HICOutp.fnEnd + 1))
        .equalsIgnoreCase(HICOutp.fnOutpCode)) {
      fileType = HICOutp.fnOutpCode.toUpperCase();
    } else if ((fileName.substring(HICInp.fnStrt, HICInp.fnEnd + 1))
        .equalsIgnoreCase(HICInp.fnInpCode)) {
      fileType = HICInp.fnInpCode.toUpperCase();
    } else {
      importMessage = IMPORT_MSG_1.replaceFirst(REPLACE_STR, HICInp.fnInpCode);
      importMessage = importMessage.replaceFirst(REPLACE_STR, HICOutp.fnOutpCode) + "<br>";
      retval = HOOPC2Properties.FAILURE;
      errors.add(importMessage);
    }

    if (retval == HOOPC2Properties.SUCCESS) {
      for (String line : lines) {
        if (HICInp.fnInpCode.equals(fileType)) {
          validateInpatientDetail(line, lineCnt);
        } else {
          validateOutpatientDetail(line, lineCnt);
        }
        lineCnt++;
      }
    }

    if (lines.isEmpty()) {
      errors.add("No claims were found in the file.");
    }

    // ******************************************************
    // * Finished checking the file so now look to see if the
    // * user tried so submit data for hospitals they were not
    // * authorized to. If so, add an error message listing
    // * the hospitals.
    // ******************************************************
    if (!unAuthHosps.isEmpty()) {
      errors.add(
          "Claims for unauthorized hospitals "
              + unAuthHosps.toString()
              + " were found in the file.");
    }

    if (errors.hasErrors()) {
      retval = HOOPC2Properties.FAILURE;
    }
    return retval;
  }

  /**
   * Validates the structure of an inpatient detail record.
   *
   * @param inputLine The record to be checked.
   * @param lineCnt Position in file the record the field belongs to
   * @return int Code indicating success or failure of test
   */
  private double validateInpatientDetail(String inputLine, int lineCnt) {
    int retval;
    int decAllowed = 4;
    int decAllowedPosOnly = 6;
    int noDecAllowedPosOnly = 2;
    double claimAmount = 0;
    String inputField1;
    String inputField2;
    String dateFormat;
    String admissionDate = null;

    // ************************
    // Ensure the line is the right length.
    // While we could defer returning if it is not the right length and
    // do as many validation as possible up to the end of the line, this
    // is not in the requirements. Something for late if desired.
    // ************************
    if (inputLine.length() != (HICInp.ColEnd_34 + 1)) {
      errors.add("line size", lineCnt);
      return claimAmount;
    }

    // ************************
    // Hospital (ensure user is authorized)
    // ************************
    inputField1 = inputLine.substring(HICInp.ColStrt_01, HICInp.ColEnd_01 + 1).trim();
    retval = checkHospital(inputField1);
    if (retval != HOOPC2Properties.SUCCESS) {
      // Track unauthorized hospitals user tried to import for
      if (!unAuthHosps.contains(inputField1)) {
        unAuthHosps.add(inputField1);
      }
    }

    // ************************
    // Province (Mandatory to get into the database)
    // ************************
    inputField1 = inputLine.substring(HICInp.ColStrt_08, HICInp.ColEnd_08 + 1).trim().toUpperCase();
    retval = checkProvince(inputField1);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Province Code", lineCnt);
    }

    // ********************
    // Insurance field Validation (add on May 28, 2021)
    // ********************
    String provinceCode = inputLine.substring(HICInp.ColStrt_08, HICInp.ColEnd_08 + 1).trim().toUpperCase();
    String insuranceNo = inputLine.substring(HICInp.ColStrt_10, HICInp.ColEnd_10 + 1).trim().toUpperCase();;
    String sex = inputLine.substring(HICInp.ColStrt_12, HICInp.ColEnd_12 + 1).trim();
    retval = checkInsuranceNo(provinceCode, insuranceNo, sex);
    if (retval != HOOPC2Properties.SUCCESS) {
      LOGGER.info("Insurance number error on line: ", lineCnt);
      //Altered to confirm with client request to create claim as invalid when PHN incorrect.
      //errors.add("Insurance No", lineCnt);
    }

    // ************************
    // Birth Date(Mandatory)
    // ************************
    inputField1 = inputLine.substring(HICInp.ColStrt_11, HICInp.ColEnd_11 + 1).trim();
    dateFormat = HICInp.BIRTH_DATE_FORMAT;
    retval = checkDate(inputField1, dateFormat, HICInp.ColName_11, lineCnt, null, false);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Birth Date", lineCnt);
    }

    // ********************
    // Sex field Validation (add on May 28, 2021)
    // ********************
    inputField1 = inputLine.substring(HICInp.ColStrt_12, HICInp.ColEnd_12 + 1).trim();
    retval = checkSex(inputField1);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Sex", lineCnt);
    }

    // *************************
    // Admission Date (Mandatory)
    // *************************
    inputField1 = inputLine.substring(HICInp.ColStrt_16, HICInp.ColEnd_16 + 1).trim();
    dateFormat = HICInp.ADMISSION_DATE_FORMAT;
    retval = checkDate(inputField1, dateFormat, HICInp.ColName_16, lineCnt, null, false);
    if (retval == HOOPC2Properties.SUCCESS) {
      admissionDate = inputField1;
    } else {
      errors.add("Admission Date", lineCnt);
    }

    // ****************
    // Discharge Date (Mandatory)
    // ****************
    inputField1 = inputLine.substring(HICInp.ColStrt_17, HICInp.ColEnd_17 + 1).trim();
    dateFormat = HICInp.DISCHARGE_DATE_FORMAT;
    retval = checkDate(inputField1, dateFormat, HICInp.ColName_17, lineCnt, null, false);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Discharge Date", lineCnt);
    }

    // *********************
    // Total Days (Mandatory)
    // *********************
    inputField1 = inputLine.substring(HICInp.ColStrt_18, HICInp.ColEnd_18 + 1).trim();
    retval = checkNumber(inputField1, HICInp.ColName_18, lineCnt, noDecAllowedPosOnly);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Total Days", lineCnt);
    }

    // ***********************
    // Per Diem Rate (Mandatory)
    // ***********************
    inputField1 = inputLine.substring(HICInp.ColStrt_19, HICInp.ColEnd_19 + 1).trim();
    retval = checkNumber(inputField1, HICInp.ColName_19, lineCnt, decAllowedPosOnly);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Per Diem Rate", lineCnt);
    }

    // ***************************
    // Total Amount Claimed (Mandatory)
    // ***************************
    inputField1 = inputLine.substring(HICInp.ColStrt_20, HICInp.ColEnd_20 + 1).trim();
    retval = checkNumber(inputField1, HICInp.ColName_20, lineCnt, decAllowed);
    if (retval == HOOPC2Properties.SUCCESS) {
      claimAmount =
          Double.parseDouble(inputLine.substring(HICInp.ColStrt_20, HICInp.ColEnd_20 + 1).trim());
    } else {
      errors.add("Total Claim Amount", lineCnt);
    }

    // ****************************
    // High Cost Procedure Date #1 (Mandatory if a HCP Code #1 is supplied)
    // ****************************
    dateFormat = HICInp.HIGH_COST_PROC_DATE_FORMAT1;
    inputField1 = inputLine.substring(HICInp.ColStrt_23, HICInp.ColEnd_23 + 1).trim();
    inputField2 = inputLine.substring(HICInp.ColStrt_24, HICInp.ColEnd_24 + 1).trim();

    if ((inputField1 != null) && (inputField1.trim().length() != 0)) {
      retval = checkNumber(inputField1, HICInp.ColName_23, lineCnt, noDecAllowedPosOnly);
      if (retval == HOOPC2Properties.SUCCESS) {
        retval =
            checkDate(inputField2, dateFormat, HICInp.ColName_24, lineCnt, admissionDate, true);
        if (retval != HOOPC2Properties.SUCCESS) {
          errors.add("High Cost Procedure Date #1", lineCnt);
        }
      } else {
        errors.add("High Cost Procedure #1", lineCnt);
      }
    } else if ((inputField2 != null) && (inputField2.trim().length() != 0)) {
      retval = checkDate(inputField2, dateFormat, HICInp.ColName_24, lineCnt, admissionDate, true);
      if (retval != HOOPC2Properties.SUCCESS) {
        errors.add("High Cost Procedure Date #1", lineCnt);
      }
    }

    // ****************************
    // High Cost Procedure Date #2 (Mandatory if a HCP Code #2 is supplied)
    // ****************************
    dateFormat = HICInp.HIGH_COST_PROC_DATE_FORMAT2;
    inputField1 = inputLine.substring(HICInp.ColStrt_25, HICInp.ColEnd_25 + 1).trim();
    inputField2 = inputLine.substring(HICInp.ColStrt_26, HICInp.ColEnd_26 + 1).trim();

    if ((inputField1 != null) && (inputField1.trim().length() != 0)) {
      retval = checkNumber(inputField1, HICInp.ColName_25, lineCnt, noDecAllowedPosOnly);
      if (retval == HOOPC2Properties.SUCCESS) {
        retval =
            checkDate(inputField2, dateFormat, HICInp.ColName_26, lineCnt, admissionDate, true);
        if (retval != HOOPC2Properties.SUCCESS) {
          errors.add("High Cost Procedure Date #2", lineCnt);
        }
      } else {
        errors.add("High Cost Procedure #2", lineCnt);
      }
    } else if ((inputField2 != null) && (inputField2.trim().length() != 0)) {
      retval = checkDate(inputField2, dateFormat, HICInp.ColName_26, lineCnt, admissionDate, true);
      if (retval != HOOPC2Properties.SUCCESS) {
        errors.add("High Cost Procedure Date #2", lineCnt);
      }
    }

    // ****************************
    // High Cost Procedure Date #3 (Mandatory if a HCP Code #3 is supplied)
    // ****************************
    dateFormat = HICInp.HIGH_COST_PROC_DATE_FORMAT3;
    inputField1 = inputLine.substring(HICInp.ColStrt_27, HICInp.ColEnd_27 + 1).trim();
    inputField2 = inputLine.substring(HICInp.ColStrt_28, HICInp.ColEnd_28 + 1).trim();

    if ((inputField1 != null) && (inputField1.trim().length() != 0)) {
      retval = checkNumber(inputField1, HICInp.ColName_27, lineCnt, noDecAllowedPosOnly);
      if (retval == HOOPC2Properties.SUCCESS) {
        retval =
            checkDate(inputField2, dateFormat, HICInp.ColName_28, lineCnt, admissionDate, true);
        if (retval != HOOPC2Properties.SUCCESS) {
          errors.add("High Cost Procedure Date #3", lineCnt);
        }
      } else {
        errors.add("High Cost Procedure #3", lineCnt);
      }
    } else if ((inputField2 != null) && (inputField2.trim().length() != 0)) {
      retval = checkDate(inputField2, dateFormat, HICInp.ColName_28, lineCnt, admissionDate, true);
      if (retval != HOOPC2Properties.SUCCESS) {
        errors.add("High Cost Procedure Date #3", lineCnt);
      }
    }

    // *******************************
    // PHN Expiry Date (Optional)
    // *******************************
    try {
      inputField1 = inputLine.substring(HICInp.ColStrt_34, HICInp.ColEnd_34 + 1).trim();

      if ((inputField1 != null) && (inputField1.trim().length() != 0)) {
        dateFormat = HICInp.PHN_EXPIRY_DATE_FORMAT;
        retval = checkDate(inputField1, dateFormat, HICInp.ColName_34, lineCnt, null, false);
        if (retval != HOOPC2Properties.SUCCESS) {
          errors.add("PHN Expiry Date", lineCnt);
        }
      }
    } catch (IndexOutOfBoundsException iobe) {
      LOGGER.info("PHN Expiry date is null.");
    }
    LOGGER.debug("Calling validateInpatientDetail() ended.");
    return claimAmount;
  }

  /**
   * Validates the structure of an outpatient detail record.
   *
   * @param inputLine The record to be checked.
   * @param lineCnt Position in file the record the field belongs to
   * @return int Code indicating success or failure of test
   */
  private double validateOutpatientDetail(String inputLine, int lineCnt) {
    LOGGER.debug("Calling validateOutpatientDetail() started.");
    int retval;
    int noDecAllowedPosOnly = 2;
    int decAllowed = 4;
    double claimAmount = 0;
    String inputField;
    String inputField2;
    String inputField3;
    String dateFormat;

    // ************************
    // Ensure the line is the right length.
    // While we could defer returning if it is not the right length and
    // do as many validation as possible up to the end of the line, this
    // is not in the requirements. Something for late if desired.
    // ************************
    if (inputLine.length() != (HICOutp.ColEnd_15 + 1)) {
      errors.add("line size", lineCnt);
      return claimAmount;
    }

    // ************************
    // Province (Mandatory to get into the database)
    // ************************
    inputField =
        inputLine.substring(HICOutp.ColStrt_02, HICOutp.ColEnd_02 + 1).trim().toUpperCase();
    retval = checkProvince(inputField);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Province Code", lineCnt);
    }

    // ************************
    // Hospital (ensure user is authorized)
    // ************************
    inputField = inputLine.substring(HICOutp.ColStrt_01, HICOutp.ColEnd_01 + 1).trim();
    retval = checkHospital(inputField);
    if (retval != HOOPC2Properties.SUCCESS) {
      // Track unauthorized hospitals user tried to import for
      if (!unAuthHosps.contains(inputField)) {
        unAuthHosps.add(inputField);
      }
    }

    // ********************
    // Insurance field Validation (add on May 28, 2021)
    // ********************
    String provinceCode = inputLine.substring(HICOutp.ColStrt_02, HICOutp.ColEnd_02 + 1).trim().toUpperCase();
    String insuranceNo = inputLine.substring(HICOutp.ColStrt_03, HICOutp.ColEnd_03 + 1).trim().toUpperCase();;
    String sex = inputLine.substring(HICOutp.ColStrt_07, HICOutp.ColEnd_07 + 1).trim();
    retval = checkInsuranceNo(provinceCode, insuranceNo, sex);

    if (retval != HOOPC2Properties.SUCCESS) {
      LOGGER.info("Insurance number error on line: ", lineCnt);
      //Altered to confirm with client request to create claim as invalid when PHN incorrect.
      //errors.add("Insurance No", lineCnt);
    }

    // ********************
    // Birth Date (Mandatory)
    // ********************
    inputField = inputLine.substring(HICOutp.ColStrt_06, HICOutp.ColEnd_06 + 1).trim();
    dateFormat = HICOutp.BIRTH_DATE_FORMAT;
    retval = checkDate(inputField, dateFormat, HICOutp.ColName_06, lineCnt, null, false);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Birth Date", lineCnt);
    }

    // ********************
    // Sex field Validation (add on May 28, 2021)
    // ********************
    inputField = inputLine.substring(HICOutp.ColStrt_07, HICOutp.ColEnd_07 + 1).trim();
    retval = checkSex(inputField);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Sex", lineCnt);
    }

    // **********************
    // Service Date (Mandatory)
    // **********************
    inputField = inputLine.substring(HICOutp.ColStrt_08, HICOutp.ColEnd_08 + 1).trim();
    dateFormat = HICOutp.SERVICE_DATE_FORMAT;
    retval = checkDate(inputField, dateFormat, HICOutp.ColName_08, lineCnt, null, false);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Service Date", lineCnt);
    }

    // ***********************
    // Validate Service Code (Mandatory)
    // ***********************
    inputField = inputLine.substring(HICOutp.ColStrt_09, HICOutp.ColEnd_09 + 1).trim();
    retval = checkNumber(inputField, HICOutp.ColName_09, lineCnt, noDecAllowedPosOnly);
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Service Code", lineCnt);
    }

    // ***********************
    // Total Amount Claimed (Mandatory)
    // ***********************
    inputField = inputLine.substring(HICOutp.ColStrt_10, HICOutp.ColEnd_10 + 1).trim();
    retval = checkNumber(inputField, HICOutp.ColName_10, lineCnt, decAllowed);
    if (retval == HOOPC2Properties.SUCCESS) {
      claimAmount =
          Double.parseDouble(inputLine.substring(HICOutp.ColStrt_10, HICOutp.ColEnd_10 + 1).trim());
    } else {
      errors.add("Total Claim Amount", lineCnt);
    }

    // *******************************
    // Validate PHN Expiry Date (Optional)
    // *******************************
    try {
      inputField = inputLine.substring(HICOutp.ColStrt_13, HICOutp.ColEnd_13 + 1).trim();
      if ((inputField != null) && (inputField.trim().length() != 0)) {
        dateFormat = HICOutp.PHN_EXPIRY_DATE_FORMAT;
        retval = checkDate(inputField, dateFormat, HICOutp.ColName_13, lineCnt, null, false);
        if (retval != HOOPC2Properties.SUCCESS) {
          errors.add("PHN Expiry Date", lineCnt);
        }
      }
    } catch (IndexOutOfBoundsException iobe) {
      LOGGER.info("Phn expiry date is null.");
    }

    // ***********************
    // Validate cutoff date (Optional)
    // ***********************
    inputField2 = inputLine.substring(HICOutp.ColStrt_09, HICOutp.ColEnd_09 + 1).trim();
    inputField3 = inputLine.substring(HICOutp.ColStrt_08, HICOutp.ColEnd_08 + 1).trim();
    
    retval = checkCutOffDate(inputField2, inputField3, HICOutp.ColName_09, lineCnt);
    
    if (retval != HOOPC2Properties.SUCCESS) {
      errors.add("Service code unavailable for service date", lineCnt);
      LOGGER.info("Service code unavailable for service date", lineCnt);
    }

    // ***********************
    // Validate Procedure Code (Optional)
    // ***********************
   inputField = inputLine.substring(HICOutp.ColStrt_15, HICOutp.ColEnd_15 + 1).trim();
   inputField2 = inputLine.substring(HICOutp.ColStrt_09, HICOutp.ColEnd_09 + 1).trim();
    
    retval = checkProcedure(inputField, inputField2, HICOutp.ColName_15, lineCnt);
    
    if (retval != HOOPC2Properties.SUCCESS) {
      LOGGER.info("Missing or unknown CCI Procedure Code", lineCnt);
    }
    
    // ***********************
    // Validate Procedure level (Optional)
    // ***********************
    inputField = inputLine.substring(HICOutp.ColStrt_15, HICOutp.ColEnd_15 + 1).trim();
    inputField2 = inputLine.substring(HICOutp.ColStrt_09, HICOutp.ColEnd_09 + 1).trim();
    inputField3 = inputLine.substring(HICOutp.ColStrt_08, HICOutp.ColEnd_08 + 1).trim();

    retval = checkProcedureLevel(inputField, inputField2, inputField3, HICOutp.ColName_15, lineCnt);
    
    if (retval != HOOPC2Properties.SUCCESS) {
      LOGGER.info("CCI Procedure Code invalid for the provided Service code", lineCnt);
    }

    // ***********************
    // Validate Diagnostic Code (Optional)
    // ***********************
   inputField = inputLine.substring(HICOutp.ColStrt_14, HICOutp.ColEnd_14 + 1).trim();
   inputField2 = inputLine.substring(HICOutp.ColStrt_09, HICOutp.ColEnd_09 + 1).trim();
    
    retval = checkDiagnostic(inputField, inputField2, HICOutp.ColName_14, lineCnt);
    
    if (retval != HOOPC2Properties.SUCCESS) {
      LOGGER.info("Missing or unknown ICD10 Diagnositic Code", lineCnt);
    }
    
    
    LOGGER.debug("Calling validateOutpatientDetail() ended.");

    return claimAmount;
  }

  private int checkHospital(String hospNumber) {
    if (hospList.contains(hospNumber)) {
      return HOOPC2Properties.SUCCESS;
    } else {
      return HOOPC2Properties.FAILURE;
    }
  }

  private int checkProvince(String provCode) {
    if (provList.contains(provCode)) {
      return HOOPC2Properties.SUCCESS;
    } else {
      return HOOPC2Properties.FAILURE;
    }
  }

  /**
   * create on May 28, 2021 for validating the Insurance No field.
   * @param insuranceNo
   * @return HOOPC2Properties.SUCCESS or HOOPC2Properties.FAILURE
   */
  private int checkInsuranceNo(String provinceCode, String insuranceNo, String sex) {
    if ((insuranceNo != null) && (insuranceNo.trim().length() != 0)) {
      try {
        int resp = appService.checkPHN(provinceCode, insuranceNo, sex);
        if (resp == 0) {
          return HOOPC2Properties.SUCCESS;
        }
      } catch (Exception e) {
        return HOOPC2Properties.FAILURE;
      }
    }
    return HOOPC2Properties.FAILURE;
  }

  private static double round(double val, int places) {
    long factor = (long) Math.pow(10, places);

    // Shift the decimal the correct number of places
    // to the right.
    val = val * factor;

    // Round to the nearest integer.
    long tmp = Math.round(val);

    // Shift the decimal the correct number of places
    // back to the left.
    return (double) tmp / factor;
  }

  /**
   * Checks to see if field passed in is a valid date
   *
   * @param dt The field to be checked.
   * @param dtFormat The format the field is be in.
   * @param fieldName The name of the field being checked.
   * @param linenum Position in file the record the field belongs to
   * @param baseDt For date comparison purchases. If a date with a mmdd format is passed this
   *     process will use the baseDt to determine a year for the mmdd date.
   * @param mustBeOlder Flag to be used with the baseDt. Determines whether a passed in date must be
   *     greater or less than the baseDt.
   * @return int Code indicating success or failure of test
   * @exception ProcessException
   */
  private int checkDate(
      String dt, String dtFormat, String dtName, int lineNum, String baseDt, boolean mustBeOlder) {
    int retval = HOOPC2Properties.SUCCESS;
    String invalid = "-/";
    String strDt1 = Helper.removeInvalidChars(dt, invalid);

    if (strDt1 == null) {
      retval = HOOPC2Properties.FAILURE;
    } else if (dtFormat.equals(HOOPC2Properties.DEFAULT_DATE_FORMAT1)) {
      if (strDt1.length() == 8) {
        String year = strDt1.substring(0, 4);
        String month = strDt1.substring(4, 6);
        String day = strDt1.substring(6, 8);

        if (CommonValidator.isValidDate(year, month, day) != CommonValidator.DATE_OK) {
          retval = HOOPC2Properties.FAILURE;
        }
      } else {
        retval = HOOPC2Properties.FAILURE;
      }
    } else if (dtFormat.equals(HOOPC2Properties.DEFAULT_DATE_FORMAT2)) {
      if (strDt1.length() == 6) {
        String year = strDt1.substring(0, 4);
        String month = strDt1.substring(4, 6);
        String day = "01";

        if (CommonValidator.isValidDate(year, month, day) != CommonValidator.DATE_OK) {
          retval = HOOPC2Properties.FAILURE;
        }
      } else {
        retval = HOOPC2Properties.FAILURE;
      }
    } else if (dtFormat.equals(HOOPC2Properties.DEFAULT_DATE_FORMAT3)) {
      if (strDt1.length() == 4) {
        try {
          String year = null;
          String month = strDt1.substring(0, 2);
          String day = strDt1.substring(2, 4);
          String strDt2 = Helper.removeInvalidChars(baseDt, invalid);
          String tmpDate = strDt2.substring(0, 4) + month + day;

          if (mustBeOlder) {
            if ((Integer.parseInt(tmpDate)) < (Integer.parseInt(strDt2))) {
              year = Integer.toString(Integer.parseInt(strDt2.substring(0, 4)) + 1);
            } else {
              year = strDt2.substring(0, 4);
            }
          }
          if (CommonValidator.isValidDate(year, month, day) != CommonValidator.DATE_OK) {
            retval = HOOPC2Properties.FAILURE;
          }
        } catch (NumberFormatException nfe) {
          retval = HOOPC2Properties.FAILURE;
        }
      } else {
        retval = HOOPC2Properties.FAILURE;
      }
    } else {
      LOGGER.error("Date Format not one recognized by Import Process.");
      retval = HOOPC2Properties.FAILURE;
    }
    if (retval == HOOPC2Properties.FAILURE) {
      importMessage = IMPORT_MSG_3.replaceFirst(REPLACE_STR, dtName);
      importMessage = importMessage.replaceFirst(REPLACE_STR, Integer.toString(lineNum)) + "<br>";
      LOGGER.error(importMessage);
      LOGGER.error(
          "Line: " + lineNum + ". Date or Date Format invalid. Field " + dtName + "=" + dt);
      LOGGER.error("Date Format: " + dtFormat);
      return HOOPC2Properties.FAILURE;
    }
    return HOOPC2Properties.SUCCESS;
  }

  /**
   * Check to see if String value passed in is a numeric value.
   *
   * @param num_in The field to be checked.
   * @param fieldName The name of the field being checked.
   * @param linenum Position in file the record the field belongs to
   * @param numTypeAllowed Indicates numeric type allowed for the passed in value: Decimal, No
   *     Decimal, Positive Only
   * @return int Code indicating success or failure of test
   * @exception ProcessException
   */
  private int checkNumber(String num_in, String fieldName, int lineNum, int numTypeAllowed) {
    int decAllowed = 4;
    int decAllowedPosOnly = 6;
    int noDecAllowedPosOnly = 2;
    int noDecAllowed = 0;
    int numResult = CommonValidator.isNumeric(num_in, numTypeAllowed);

    if (numResult != CommonValidator.NUMBER_OK) {
      importMessage = IMPORT_MSG_3.replaceFirst(REPLACE_STR, fieldName);
      importMessage = importMessage.replaceFirst(REPLACE_STR, Integer.toString(lineNum)) + "<br>";
      LOGGER.error(importMessage);
      LOGGER.error(
          "Line: " + lineNum + ". Numeric Field invalid. Field " + fieldName + "=" + num_in);

      if (numTypeAllowed == decAllowed) {
        LOGGER.error("Numeric field can be decimal, positive or negative.");
        importMessage =
            importMessage + " Numeric field can be decimal, positive or negative." + "<br>";
      }
      if (numTypeAllowed == decAllowedPosOnly) {
        LOGGER.error("Numeric field can be decimal and cannot be negative.");
        importMessage =
            importMessage + " Numeric field can be decimal and cannot be negative." + "<br>";
      }

      if (numTypeAllowed == noDecAllowedPosOnly) {
        LOGGER.error("Numeric field cannot be decimal and cannot be negative.");
        importMessage =
            importMessage + " Numeric field cannot be decimal and cannot be negative." + "<br>";
      }

      if (numTypeAllowed == noDecAllowed) {
        LOGGER.error("Numeric field cannot be decimal but can be negative or positive.");
        importMessage =
            importMessage
                + " Numeric field cannot be decimal but can be negative or positive."
                + "<br>";
      }
      return HOOPC2Properties.FAILURE;
    } else {
      return HOOPC2Properties.SUCCESS;
    }
  }

        
   /**
   * Check to see if String value passed in is a valid procedure code.
   *
   * @param procCode The field to be checked.
   * @param servCode The service code referenced.
   * @param fieldName The name of the field being checked.
   * @param linenum Position in file the record the field belongs to
   * @return int Code indicating success or failure of test
   * @exception ProcessException
   */
  private int checkCutOffDate(String servCode, String servDate, String fieldName, int lineNum) {
    LocalDate cutDate = appService.getCutOffDateNewCodes();
    try {
      LocalDate date1 = LocalDate.parse(fixDateCode(servDate), DateTimeFormatter.ofPattern("yyyyMMdd"));
      int sC = Integer.valueOf(servCode);
      if (servCode.trim().equals("") || servCode.isEmpty()) {
        return HOOPC2Properties.SUCCESS;
      }

      if (sC > 16  && !(date1.isAfter(cutDate))) {
        importMessage = IMPORT_MSG_3.replaceFirst(REPLACE_STR, fieldName);
        importMessage = importMessage.replaceFirst(REPLACE_STR, Integer.toString(lineNum)) + "<br>";
        LOGGER.error(importMessage);
        LOGGER.error(
                "Line: " + lineNum + ". Invalid service code " + fieldName + "=" + servCode + " for service date " + servDate);
        return HOOPC2Properties.FAILURE;
      }
      if (sC == 2 && (date1.isAfter(cutDate))) {
        importMessage = IMPORT_MSG_3.replaceFirst(REPLACE_STR, fieldName);
        importMessage = importMessage.replaceFirst(REPLACE_STR, Integer.toString(lineNum)) + "<br>";
        LOGGER.error(importMessage);
        LOGGER.error(
                "Line: " + lineNum + ". Service code inactive for " + fieldName + "=" + servCode + " for service date " + servDate);
        return HOOPC2Properties.FAILURE;
      }
    } catch (Exception e) {
        importMessage = IMPORT_MSG_3.replaceFirst(REPLACE_STR, fieldName);
        importMessage = importMessage.replaceFirst(REPLACE_STR, Integer.toString(lineNum)) + "<br>";
        LOGGER.error(importMessage);
        LOGGER.error(
                "Line: " + lineNum + ". Error validating service code " + fieldName + "=" + servCode + " for service date " + servDate);
        return HOOPC2Properties.FAILURE;
    }
    return HOOPC2Properties.SUCCESS;
  }

        
   /**
   * Check to see if String value passed in is a valid procedure code.
   *
   * @param procCode The field to be checked.
   * @param servCode The service code referenced.
   * @param fieldName The name of the field being checked.
   * @param linenum Position in file the record the field belongs to
   * @return int Code indicating success or failure of test
   * @exception ProcessException
   */
  private int checkProcedure(String procCode, String servCode, String fieldName, int lineNum) {
    List<String> mandatoryCodes = Arrays.asList(new String[]{"02", "13", "18", "19", "20", "63", "68", "69", "70"});
    if (procCode.trim().isEmpty()) {
      if (mandatoryCodes.contains(servCode)) {
        importMessage = IMPORT_MSG_3.replaceFirst(REPLACE_STR, fieldName);
        importMessage = importMessage.replaceFirst(REPLACE_STR, Integer.toString(lineNum)) + "<br>";
        LOGGER.error(importMessage);
        LOGGER.error(
                "Line: " + lineNum + ". Missing procedure code. Field " + fieldName + "=" + procCode);
        return HOOPC2Properties.FAILURE;
      }
    } else if (appService.getProcedureCode(procCode) == null) {
      importMessage = IMPORT_MSG_3.replaceFirst(REPLACE_STR, fieldName);
      importMessage = importMessage.replaceFirst(REPLACE_STR, Integer.toString(lineNum)) + "<br>";
      LOGGER.error(importMessage);
      LOGGER.error(
              "Line: " + lineNum + ". Unknown procedure code. Field " + fieldName + "=" + procCode);
      return HOOPC2Properties.FAILURE;
    }
    return HOOPC2Properties.SUCCESS;
  }

   /**
   * Check to see if String value passed in is a valid procedure code for the service code level.
   *
   * @param procCode The field to be checked.
   * @param servCode The service code referenced.
   * @param servDate The date of service referenced.
   * @param fieldName The name of the field being checked.
   * @param linenum Position in file the record the field belongs to
   * @return int Code indicating success or failure of test
   * @exception ProcessException
   */
  private int checkProcedureLevel(String procCode, String servCode, String servDate, String fieldName, int lineNum) {
    List<String> Level1 =  Arrays.asList(new String[]{"18", "68"});
    List<String> Level2 =  Arrays.asList(new String[]{"19", "69"});
    List<String> Level3 =  Arrays.asList(new String[]{"20", "70"});
    String Level = "";
    String sDate = fixDateCode(servDate);
    if (!sDate.trim().isEmpty()) {
        LocalDate date1 = LocalDate.parse(fixDateCode(servDate), DateTimeFormatter.ofPattern("yyyyMMdd"));
        if (date1.isAfter(appService.getCutOffDateNewCodes())) {
        if (!StringUtils.isBlank(servCode) && !StringUtils.isBlank(procCode)) {
          if (date1.isAfter(appService.getCutOffDateNewCodes()) && (Level1.contains(servCode) || Level2.contains(servCode) || Level3.contains(servCode))) {
            if (Level1.contains(servCode)) {
              Level = "01";
            } else if (Level2.contains(servCode)) {
              Level = "02";
            } else if (Level3.contains(servCode)) {
              Level = "03";
            }
            if (!appService.isValidProcedureForService(Level, procCode)) {
              if (date1.isAfter(appService.getCutOffDateNewCodes())) {
                importMessage = IMPORT_MSG_3.replaceFirst(REPLACE_STR, fieldName);
                importMessage = importMessage.replaceFirst(REPLACE_STR, Integer.toString(lineNum)) + "<br>";
                LOGGER.error(importMessage);
                LOGGER.error(
                        "Line: " + lineNum + ". error with procedure code. Field " + fieldName + "=" + procCode);
                LOGGER.error("Procedure code: " + procCode + " invalid for the provided Service code: " + servCode + ".");
                importMessage
                        = importMessage
                        + " Procedure code invalid for the provided Service code."
                        + "<br>";
                return HOOPC2Properties.FAILURE;
              }
            }
          }
        }
      }
    }
    return HOOPC2Properties.SUCCESS;
  }
 
   /**
   * Check to see if String value passed in is a valid diagnostic code.
   *
   * @param diagCode The field to be checked.
   * @param servCode The service code referenced.
   * @param fieldName The name of the field being checked.
   * @param linenum Position in file the record the field belongs to
   * @return int Code indicating success or failure of test
   * @exception ProcessException
   */
  private int checkDiagnostic(String diagCode, String servCode, String fieldName, int lineNum) {
    List<String> mandatoryCodes = Arrays.asList(new String[]{"02", "18", "19", "20", "68", "69", "70"});
    if (diagCode.trim().isEmpty()) {
      if (mandatoryCodes.contains(servCode)) {
        importMessage = IMPORT_MSG_3.replaceFirst(REPLACE_STR, fieldName);
        importMessage = importMessage.replaceFirst(REPLACE_STR, Integer.toString(lineNum)) + "<br>";
        LOGGER.error(importMessage);
        LOGGER.error(
                "Line: " + lineNum + ". Missing diagnostic code. Field " + fieldName + "=" + diagCode);
        return HOOPC2Properties.FAILURE;
      }
    } else {
      ClaimDetailCodes diagList = appService.getDiagnosticCode(diagCode);
      if (appService.getDiagnosticCode(diagCode) == null) {
        importMessage = IMPORT_MSG_3.replaceFirst(REPLACE_STR, fieldName);
        importMessage = importMessage.replaceFirst(REPLACE_STR, Integer.toString(lineNum)) + "<br>";
        LOGGER.error(importMessage);
        LOGGER.error(
                "Line: " + lineNum + ". Unknown diagnostic code. Field " + fieldName + "=" + diagCode);
        return HOOPC2Properties.FAILURE;
      }
    }
    return HOOPC2Properties.SUCCESS;
  }

  /**
   * create on May 28, 2021 for validating the sex field.
   * @param sex
   * @return
   */
  private int checkSex(String sex) {
    return (sex.equals("M") || sex.equals("F")) ? HOOPC2Properties.SUCCESS : HOOPC2Properties.FAILURE;
  }

   /**
   * Prepare the string date to a usable format
   *
   * @param servDate The string containing the date to format
   * @return String formatted date
   */
  private String fixDateCode(String servDate) {
    String invalid = "-/";
    String strDt1 = Helper.removeInvalidChars(servDate, invalid);
    String fixDate = "";
      if (strDt1.length() == 8) {
        String year = strDt1.substring(0, 4);
        String month = strDt1.substring(4, 6);
        String day = strDt1.substring(6, 8);
        if (CommonValidator.isValidDate(year, month, day) == CommonValidator.DATE_OK) {
          fixDate = strDt1;
        }
      } 
    return fixDate;
  }
}
