package ca.bc.gov.health.report;

import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.report.model.ClaimReportModel;
import ca.bc.gov.health.report.model.ClaimReportViewModel;
import ca.bc.gov.health.report.transformer.ClaimReportCsvTransformer;
import ca.bc.gov.health.report.transformer.ClaimReportJasperTransformer;
import jakarta.persistence.EntityManager;
import jakarta.persistence.ParameterMode;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;
import jakarta.persistence.StoredProcedureQuery;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.persistence.config.QueryHints;
import org.eclipse.persistence.config.ResultType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Class BaseReportProcessor. */
public abstract class BaseReportProcessor implements ReportProcessor {
  @PersistenceContext(unitName = "hoopc-ejb_pu")
  private EntityManager em;

  private static Logger log = LoggerFactory.getLogger(BaseReportProcessor.class);

  protected abstract String getPreprocessingSpName();

  protected abstract String getViewName();

  protected abstract Object getSortField();

  protected abstract List<String> getCsvFields();

  /**
   * Transform to store proc param.
   *
   * @param viewModel the view model
   * @return the list
   * @throws HoopcException the hoopc exception
   */
  protected abstract List<StoredProcQueryParams> transformToStoreProcParam(
      ClaimReportViewModel viewModel) throws HoopcException;

  /* (non-Javadoc)
   * @see ca.bc.gov.health.report.ReportProcessor#process(ca.bc.gov.health.report.model.ClaimReportViewModel)
   */
  @Override
  public List<ClaimReportModel> process(ClaimReportViewModel viewModel) throws HoopcException {
    List<StoredProcQueryParams> parameters = transformToStoreProcParam(viewModel);
    String reportReqID = preProcessing(getPreprocessingSpName(), parameters);

    List<ClaimReportModel> reportDataSource = loadData(reportReqID);
    if (reportDataSource.isEmpty()) {
      reportDataSource.add(new ClaimReportModel());
    }

    return removeNullValues(reportDataSource);
  }

  /* (non-Javadoc)
   * @see ca.bc.gov.health.report.ReportProcessor#processCSV(ca.bc.gov.health.report.model.ClaimReportViewModel)
   */
  @Override
  public List<String> processCSV(ClaimReportViewModel viewModel) throws HoopcException {
    List<StoredProcQueryParams> parameters = transformToStoreProcParam(viewModel);
    String reportReqID = preProcessing(getPreprocessingSpName(), parameters);

    List<String> reportDataSource = new ArrayList<>();
    String title = loadDataCSV(reportReqID, reportDataSource);
    int reportDataSourceSize = reportDataSource.size();
    reportDataSource.add(0, StringUtils.join(getCsvFields(), ","));
    reportDataSource.add("CS_CHECK,CS_REPORT_TYPE");
    reportDataSource.add(reportDataSourceSize + "," + title);

    return reportDataSource;
  }

  private String preProcessing(String procedureName, List<StoredProcQueryParams> parameters)
      throws HoopcException {

    // build name of StoredProc to call
    final String spName = MessageFormat.format("HOOPC2_Reports.{0}", procedureName);
    log.info("Calling {}", spName);

    try {
      // Creating the stored proc query object
      StoredProcedureQuery query = em.createStoredProcedureQuery(spName);

      // Adding the in/out parameters
      for (StoredProcQueryParams param : parameters) {
        query.registerStoredProcedureParameter(
            param.getParamName(), param.getParamClass(), param.getParamMode());
        if (param.getParamMode().equals(ParameterMode.IN)) {
          query.setParameter(param.getParamName(), param.getParamValue());
        }
      }

      // Execute the pl/sql procecure
      query.execute();

      // Get the return value
      String resultCode = (String) query.getOutputParameterValue("pn_resultCode");
      String reportReqID = (String) query.getOutputParameterValue("pv_reportReqID");
      String message = (String) query.getOutputParameterValue("pv_message");

      log.info(
          "{} returned resultCode {} and reportReqID {} and message {}",
          spName,
          resultCode,
          reportReqID,
          message);

      return reportReqID;

    } catch (Exception e) {
      String errMsg = MessageFormat.format("Oracle error in {0}", spName);
      throw new HoopcException(errMsg, e);
    }
  }

  private List<ClaimReportModel> loadData(String reportReqID) {
    List<ClaimReportModel> reportDataSource = new ArrayList<>();
    List<Map<Object, Object>> viewResult = executeQuery(reportReqID);

    if (viewResult != null && !viewResult.isEmpty()) {
      log.info("Service returned {} rows for SEQ_ID '{}'", viewResult.size(), reportReqID);
      for (Map<Object, Object> record : viewResult) {
        // TODO: EclipseLink implementation specific. Convert Map<DatabaseRecord, Object> to
        // Map<String, Object>
        Map<String, Object> map2 =
            record.entrySet().stream()
                .filter(r -> r.getValue() != null)
                .collect(Collectors.toMap(r -> r.getKey().toString(), r -> r.getValue()));

        ClaimReportModel row = ClaimReportJasperTransformer.transformToJasperModel(map2);
        reportDataSource.add(row);
      }
    } else {
      log.info("Service returned no data for reportReqID '{}'", reportReqID);
    }
    return reportDataSource;
  }

  private String loadDataCSV(String reportReqID, List<String> reportDataSource) {
    String title = "";
    List<Map<Object, Object>> viewResult = executeQuery(reportReqID);

    if (viewResult != null && !viewResult.isEmpty()) {
      log.info("Service returned {} rows for SEQ_ID '{}'", viewResult.size(), reportReqID);
      for (Map<Object, Object> record : viewResult) {
        // TODO: EclipseLink implementation specific. Convert Map<DatabaseRecord, Object> to
        // Map<String, Object>
        Map<String, Object> map2 =
            record.entrySet().stream()
                .filter(r -> r.getValue() != null)
                .collect(Collectors.toMap(r -> r.getKey().toString(), r -> r.getValue()));

        if (StringUtils.isBlank(title)) {
          title = extractTitle(title, map2);
        }

        String row = ClaimReportCsvTransformer.transform(map2, getCsvFields());
        reportDataSource.add(row);
      }
    } else {
      log.info("Service returned no data for reportReqID '{}'", reportReqID);
    }
    return title;
  }

  private String extractTitle(String title, Map<String, Object> map) {
    if (map.containsKey("REPORT_TYPE")) {
      title = (String) map.get("REPORT_TYPE");
    } else if (map.containsKey("REPORT_TITLE")) {
      title = (String) map.get("REPORT_TITLE");
    }
    return title;
  }

  private List<Map<Object, Object>> executeQuery(String reportReqID) {
    String q =
        MessageFormat.format(
            "SELECT * FROM {0} WHERE SEQ_ID = ? ORDER BY {1}", getViewName(), getSortField());
    Query query = em.createNativeQuery(q);
    query.setHint(QueryHints.RESULT_TYPE, ResultType.Map);
    query.setParameter(1, Long.valueOf(reportReqID));
    @SuppressWarnings("unchecked")
    List<Map<Object, Object>> viewResult = query.getResultList();
    return viewResult;
  }

  private List<ClaimReportModel> removeNullValues(List<ClaimReportModel> data)
      throws HoopcException {
    log.debug("Calling method removeNullValues");
    for (ClaimReportModel record : data) {
      for (final Method method : record.getClass().getDeclaredMethods()) {
        if (Modifier.isPublic(method.getModifiers())
            && (method.getReturnType() == String.class)
            && (method.getName().startsWith("get"))) {
          String property = method.getName().substring(3);
          try {
            // log.debug("Calling method " + method.getName());
            String value = (String) method.invoke(record);
            if (value == null) {
              Method setterMethod =
                  record.getClass().getDeclaredMethod("set" + property, String.class);
              setterMethod.invoke(record, "");
            }
          } catch (Throwable e) {
            throw new HoopcException(e);
          }
        }
      }
    }
    return data;
  }
}
