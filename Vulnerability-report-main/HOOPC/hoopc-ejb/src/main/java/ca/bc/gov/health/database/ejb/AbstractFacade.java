/*
 * To change this license header, choose License Headers in Project Properties. To change this
 * template file, choose Tools | Templates and open the template in the editor.
 */
package ca.bc.gov.health.database.ejb;

import ca.bc.gov.health.exception.HoopcException;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import jakarta.persistence.criteria.CriteriaQuery;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The Class AbstractFacade.
 *
 * @author je.tremblay
 * @param <T> the generic type
 */
public abstract class AbstractFacade<T> {

  private Class<T> entityClass;

  private static final Logger log = LoggerFactory.getLogger(AbstractFacade.class.getName());

  /**
   * Instantiates a new abstract facade.
   *
   * @param entityClass the entity class
   */
  public AbstractFacade(Class<T> entityClass) {
    this.entityClass = entityClass;
  }

  protected abstract EntityManager getEntityManager();

  /**
   * Creates the.
   *
   * @param entity the entity
   * @return the t
   * @throws HoopcException the hoopc exception
   */
  public T create(T entity) throws HoopcException {
    try {
      getEntityManager().persist(entity);
      getEntityManager().getEntityManagerFactory().getCache().evictAll();

    } catch (Exception e) {
      HoopcException exception = new HoopcException("Error in AbstractFacade.create()", e);
      log.error("Error in AbstractFacade.create({})", exception);
      throw exception;
    }
    return entity;
  }

  /**
   * Edits the.
   *
   * @param entity the entity
   * @throws HoopcException the hoopc exception
   */
  public void edit(T entity) throws HoopcException {
    try {
      getEntityManager().merge(entity);
      getEntityManager().getEntityManagerFactory().getCache().evictAll();
    } catch (Exception e) {
      HoopcException exception = new HoopcException("Error in AbstractFacade.edit()", e);
      log.error("Error in AbstractFacade.edit({})", exception);
      throw exception;
    }
  }

  /**
   * Removes the.
   *
   * @param entity the entity
   * @throws HoopcException the hoopc exception
   */
  public void remove(T entity) throws HoopcException {
    try {
      getEntityManager().remove(getEntityManager().merge(entity));
    } catch (Exception e) {
      HoopcException exception = new HoopcException("Error in AbstractFacade.remove()", e);
      log.error("Error in AbstractFacade.remove({})", exception);
      throw exception;
    }
  }

  /**
   * Find.
   *
   * @param id the id
   * @return the t
   * @throws HoopcException the hoopc exception
   */
  public T find(Object id) throws HoopcException {
    try {
      return getEntityManager().find(entityClass, id);
    } catch (Exception e) {
      HoopcException exception = new HoopcException("Error in AbstractFacade.find()", e);
      log.error("Error in AbstractFacade.find({})", exception);
      throw exception;
    }
  }

  /**
   * Find all.
   *
   * @return the list
   * @throws HoopcException the hoopc exception
   */
  @SuppressWarnings({"unchecked", "rawtypes"})
  public List<T> findAll() throws HoopcException {
    jakarta.persistence.criteria.CriteriaQuery cq;
    try {
      cq = getEntityManager().getCriteriaBuilder().createQuery();
      cq.select(cq.from(entityClass));
      return getEntityManager().createQuery(cq).getResultList();
    } catch (Exception e) {
      HoopcException exception = new HoopcException("Error in AbstractFacade.findAll()", e);
      log.error("Error in AbstractFacade.findAll({})", exception);
      throw exception;
    }
  }

  /**
   * Find range.
   *
   * @param range the range
   * @return the list
   */
  @SuppressWarnings({"rawtypes", "unchecked"})
  public List<T> findRange(int[] range) {
    jakarta.persistence.criteria.CriteriaQuery cq =
        getEntityManager().getCriteriaBuilder().createQuery();
    cq.select(cq.from(entityClass));
    jakarta.persistence.Query q = getEntityManager().createQuery(cq);
    q.setMaxResults(range[1] - range[0] + 1);
    q.setFirstResult(range[0]);
    return q.getResultList();
  }

  /**
   * Count.
   *
   * @return the int
   */
  public int count() {
    CriteriaQuery<Object> cq = getEntityManager().getCriteriaBuilder().createQuery();
    jakarta.persistence.criteria.Root<T> rt = cq.from(entityClass);
    cq.select(getEntityManager().getCriteriaBuilder().count(rt));
    jakarta.persistence.Query q = getEntityManager().createQuery(cq);
    return ((Long) q.getSingleResult()).intValue();
  }

  /**
   * Find by named query.
   *
   * @param namedQuery the named query
   * @param params the params
   * @return the list
   * @throws HoopcException the hoopc exception
   */
  @SuppressWarnings("unchecked")
  public List<T> findByNamedQuery(String namedQuery, Map<String, Object> params)
      throws HoopcException {
    try {
      Query query = getEntityManager().createNamedQuery(namedQuery);
      if (params != null) {
        for (Map.Entry<String, Object> entry : params.entrySet()) {
          query.setParameter(entry.getKey(), entry.getValue());
        }
      }
      return query.getResultList();
    } catch (RuntimeException e) {
      HoopcException exception =
          new HoopcException("Error in AbstractFacade.findByNamedQuery()", e);
      log.error("Error in AbstractFacade.findByNamedQuery({})", exception);
      throw exception;
    }
  }

  public Class<T> getEntityClass() {
    return entityClass;
  }

  public void setEntityClass(Class<T> entityClass) {
    this.entityClass = entityClass;
  }
}
