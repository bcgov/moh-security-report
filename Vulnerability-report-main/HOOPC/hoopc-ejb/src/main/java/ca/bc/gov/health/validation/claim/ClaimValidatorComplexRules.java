package ca.bc.gov.health.validation.claim;

import ca.bc.gov.health.constants.ClaimDetailCodePurpose;
import ca.bc.gov.health.constants.GlobalConstants;
import ca.bc.gov.health.constants.OverrideStatus;
import ca.bc.gov.health.database.entity.ApplicationUsers;
import ca.bc.gov.health.database.entity.ClaimDetailCodes;
import ca.bc.gov.health.database.entity.HighcostProcedureRate;
import ca.bc.gov.health.database.entity.HospitalOopClaims;
import ca.bc.gov.health.database.entity.Hospitals;
import ca.bc.gov.health.database.entity.ProvincesTerritories;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.service.HoopcAppService;
import ca.bc.gov.health.service.HoopcSessionBean;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.HighcostViewModel;
import ca.bc.gov.health.util.RateRange;
import ca.bc.gov.health.validation.ValidationError;
import ca.bc.gov.health.validation.rule.ValidationRule;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import jakarta.persistence.EntityManager;
import java.math.BigDecimal;
import java.text.MessageFormat;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.function.Function;
import org.apache.commons.lang3.StringUtils;

/** The Class ClaimValidatorComplexRules. */
@Named("ClaimValidatorComplexRules")
public class ClaimValidatorComplexRules {

  private static final String CLAIM_VALIDATION_CHECK_PATIENT_DUPLICATE =
      "claim.validation.checkPatientDuplicate";
  //BCMOHAD-9594-31/01/2022: Outpatient and Inpatient Conflict messages.
  private static final String CLAIM_VALIDATION_CHECK_PATIENT_CONFLICT2 = 
      "claim.validation.checkPatientConflict2";
  private static final String CLAIM_VALIDATION_CHECK_PATIENT_CONFLICT1 = 
      "claim.validation.checkPatientConflict1";
  private EntityManager em;
  // TODO: Inject this
  private static ResourceBundle bundle = ResourceBundle.getBundle("messages");

  @Inject private HoopcAppService appService;

  @Inject private HoopcSessionBean session;

  @Inject private ClaimValidatorHelper helper;

  @Inject private PHNHelper phnHelper;
  
  /**
   * CHECKPOSTALCODEPREFIX if the provided postal code begins with a letter that is a valid postal
   * code prefix for the provided province.
   *
   * @param claimView the claim view
   * @return the validation error
   */
  public ValidationError checkPostalCodeFormat(ClaimViewModel claimView) {
    String postalCode = claimView.getPatient().getPostalCode();

    // Mandatory values should be validated in other rules
    if (StringUtils.isBlank(postalCode)) return null;

    if (!postalCode.matches(bundle.getString("claim.validation.postalCodeRegex"))) {
      String errorMsg = bundle.getString("claim.validation.checkPostalCodeFormat");
      return new ValidationError(null, errorMsg, postalCode);
    }

    return null;
  }

  /**
   * CHECKPOSTALCODEPREFIX if the provided postal code begins with a letter that is a valid postal
   * code prefix for the provided province.
   *
   * @param claimView the claim view
   * @return the validation error
   */
  public ValidationError checkPostalCodePrefix(ClaimViewModel claimView) {
    String provinceCode = claimView.getPatient().getProvince();
    String postalCode = claimView.getPatient().getPostalCode();

    // Mandatory values should be validated in other rules
    if (StringUtils.isAnyBlank(provinceCode, postalCode)) return null;

    // Invalid codes should be validated in other rules
    ProvincesTerritories province = appService.getProvince(provinceCode);
    if (province == null) return null;

    // Valid if the first letter of postal code is in the province prefix list
    String prefix = postalCode.substring(0, 1);
    if (province.getPostalCodePrefix().contains(prefix)) {
      return null;
    }

    String errorMsg = bundle.getString("claim.validation.checkPostalCodePrefix");
    return new ValidationError(null, errorMsg, postalCode);
  }

  /**
   * CHECKVALIDHOSPITAL: if a hospital with the provided name and number exists in the provided
   * province.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkValidHospital(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isAnyBlank(claim.getTreatingProvince(), claim.getHospitalNumber())) {
      Hospitals hosp =
          appService.checkValidHospital(
              claim.getTreatingProvince(), claim.getHospitalNumber(), claim.getHospitalName());
      if (hosp == null) {
        String errorMsg = bundle.getString("claim.validation.checkValidHospital");
        return new ValidationError(null, errorMsg, claim.getHospitalNumber());
      }
    }
    return null;
  }

  /**
   * CHECKHOSPITALAUTH: if the user has authorization on the provided hospital.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError CheckHospitalAuth(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isAnyBlank(claim.getTreatingProvince(), claim.getHospitalNumber())) {
      ApplicationUsers applicationUser = session.getCurrentUser();
      Hospitals hospital =
          appService.getHospital(claim.getTreatingProvince(), claim.getHospitalNumber());
      if (applicationUser != null && hospital != null) {
        if (!helper.isUserAuthorized(applicationUser, hospital)) {
          String errorMsg =
              MessageFormat.format(
                  bundle.getString("claim.validation.checkHospitalAuth"),
                  applicationUser.getApplicationUserid(),
                  claim.getHospitalNumber());
          return new ValidationError(null, errorMsg, claim.getHospitalNumber());
        }
      }
    }
    return null;
  }

  /**
   * CHECKACCIDENTINDICATOR: if the provided accident indicator corresponds to the presence or
   * absence of a value for accident code.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkIncidentCodeIndicator(ClaimViewModel claim) {
    boolean indicator = "Y".equals(claim.getAccidentIndicator());
    if (indicator == StringUtils.isBlank(claim.getAccidentCode())) {
      String errMessage = null;
      if (indicator) {
        errMessage =
            MessageFormat.format(
                bundle.getString("claim.validation.checkIncidentCodeIndicator"), "N", "Y", "null");
      } else {
        errMessage =
            MessageFormat.format(
                bundle.getString("claim.validation.checkIncidentCodeIndicator"),
                "Y",
                "N",
                "not null");
      }
      return new ValidationError(null, errMessage, claim.getAccidentIndicator());
    }
    return null;
  }

  /**
   * CHECKHOSPITALACTIVERANGE if the hospital was active during the provided time period.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkHospitalActiveRange(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isAnyBlank(claim.getTreatingProvince(), claim.getHospitalNumber())
        && (claim.getAdmission() != null
            && claim.getAdmission().getAdmissionDate() != null
            && claim.getAdmission().getDischargeDate() != null)) {

      // TODO: May need to reuse this logic in other rules. Move to helper function?
      BigDecimal rateAdmission =
          appService.getPerDiemRate(
              claim.getTreatingProvince(),
              claim.getHospitalNumber(),
              claim.getAdmission().getAdmissionDate());
      BigDecimal rateDischarge =
          appService.getPerDiemRate(
              claim.getTreatingProvince(),
              claim.getHospitalNumber(),
              claim.getAdmission().getDischargeDate());
      // If rateAdmisson == null -> hospital not active for admissionDate
      // If rateDischarge == null -> hospital not active for dischargeDate
      if (rateAdmission == null || rateDischarge == null) {
        String errMessage = bundle.getString("claim.validation.checkHospitalActiveRange");
        return new ValidationError(null, errMessage, claim.getHospitalNumber());
      }
    }

    return null;
  }

  /**
   * CHECKHOSPITALACTIVEDATE if the hospital was active on the provided date.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkHospitalActiveDate(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isAnyBlank(claim.getTreatingProvince(), claim.getHospitalNumber())
        && claim.getServiceDate() != null) {

      // TODO: May need to reuse this logic in other rules. Move to helper function?
      BigDecimal rateService =
          appService.getPerDiemRate(
              claim.getTreatingProvince(), claim.getHospitalNumber(), claim.getServiceDate());
      // If rateAdmisson == null -> hospital not active for admissionDate
      // If rateDischarge == null -> hospital not active for dischargeDate
      if (rateService == null) {
        String errMessage = bundle.getString("claim.validation.checkHospitalActiveDate");
        return new ValidationError(null, errMessage, claim.getHospitalNumber());
      }
    }

    return null;
  }

  /**
   * CHECKINPATIENTTOTALAMT if the total claim amount is equal to the sum of the daily rate times
   * the number of days stay plus any high cost procedure amounts.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkInPatientTotalAmout(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isAnyBlank(claim.getTreatingProvince(), claim.getHospitalNumber())
        && claim.getTotalAmountClaimed() != null
        && (claim.getAdmission() != null
            && claim.getAdmission().getAdmissionDate() != null
            && claim.getAdmission().getDischargeDate() != null)) {

      BigDecimal calculated = helper.calculateTotalAmout(claim);
      if (claim.getTotalAmountClaimed().compareTo(calculated) != 0) {
        String errMessage =
            MessageFormat.format(bundle.getString("claim.validation.checkTotalAmout"), calculated);
        return new ValidationError(null, errMessage, claim.getTotalAmountClaimed());
      }
    }
    return null;
  }

  /**
   * CHECKPERDIEMRATE if the provided perdiem rate is equal to the hospital perdiem rate in effect
   * at time of treatment (i.e: dischargeDate</BR> or if the first diagnostic code is a newborn
   * code, the newborn rate in effect at time of treatment.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkPerDiemRate(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isAnyBlank(claim.getTreatingProvince(), claim.getHospitalNumber())
        && (claim.getAdmission() != null
            && claim.getAdmission().getDischargeDate() != null
            && claim.getAdmission().getWardRate() != null)
        && claim.getMainDiagnosisCode() != null) {

      BigDecimal rate = null;

      try {
        List<RateRange> rates = helper.getRateRange(claim);
        rate =
            rates.stream()
                .filter(r -> r.contains(claim.getAdmission().getDischargeDate()))
                .map(r -> r.getRate())
                .findFirst()
                .orElse(null);
      } catch (HoopcException e) {
        // error is logged in getWardRate or getServiceRate
        // will appear as invalid rate
      }

      // NOTE Compare BigDecimal to BigInteger (hope this works)
      if (rate == null || rate.compareTo(new BigDecimal(claim.getAdmission().getWardRate())) != 0) {
        String errMessage;
        if (helper.isNewborn(claim.getMainDiagnosisCode())) {
          errMessage = bundle.getString("claim.validation.checkPerDiemRate2");
        } else {
          errMessage = bundle.getString("claim.validation.checkPerDiemRate1");
        }
        return new ValidationError(null, errMessage, claim.getAdmission().getWardRate());
      }

      // No error if here
      return null;
    }

    return null;
  }

  /**
   * CHECKYEAROLDCLAIMS: if the submission month is less than 12 months after the discharge month.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkYearOldClaim(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (claim.getSubmissionDate() != null
        && (claim.getAdmission() != null && claim.getAdmission().getDischargeDate() != null)) {
      // Diff in mounths (rounded at first of month)
      long monthsBetween =
          ChronoUnit.MONTHS.between(
              claim.getAdmission().getDischargeDate().withDayOfMonth(1),
              claim.getSubmissionDate().withDayOfMonth(1));
      if (monthsBetween >= 12) {
        String errMessage = bundle.getString("claim.validation.checkYearOldClaim");
        return new ValidationError(null, errMessage, claim.getSubmissionDate());
      }
    }
    return null;
  }

  public ValidationError checkYearOldOutpatientClaim(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (claim.getSubmissionDate() != null && (claim.getServiceDate() != null)) {
      // Diff in mounths (rounded at first of month)
      long monthsBetween =
          ChronoUnit.MONTHS.between(
              claim.getServiceDate().withDayOfMonth(1),
              claim.getSubmissionDate().withDayOfMonth(1));
      if (monthsBetween >= 12) {
        String errMessage = bundle.getString("claim.validation.checkYearOldClaim");
        return new ValidationError(null, errMessage, claim.getSubmissionDate());
      }
    }
    return null;
  }

  /**
   * CHECKTOTALDAYSSTAY: if the provided total days stay matches the length of stay calculated from
   * admission and discharge dates.<br>
   * <EM>NOTE: if discharge==admission total days = 1</EM>
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkTotalDaysStay(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (claim.getAdmission() != null
        && claim.getAdmission().getAdmissionDate() != null
        && claim.getAdmission().getDischargeDate() != null
        && claim.getAdmission().getTotalDaysStay() != null) {

      // Calculate number of days
      long totalDays =
          ChronoUnit.DAYS.between(
              claim.getAdmission().getAdmissionDate(), claim.getAdmission().getDischargeDate());
      // If admission==discharge, total days is one also
      if (totalDays == 0) {
        totalDays = 1;
      }

      if (claim.getAdmission().getTotalDaysStay() != totalDays) {
        String errorMsg =
            MessageFormat.format(
                bundle.getString("claim.validation.checkTotalDaysStay"),
                claim.getAdmission().getTotalDaysStay(),
                claim.getAdmission().getAdmissionDate(),
                claim.getAdmission().getDischargeDate(),
                totalDays);
        return new ValidationError(null, errorMsg, claim.getAdmission().getTotalDaysStay());
      }
    }
    return null;
  }

  /**
   * CHECKLONGTERMINDICATOR: if the calculated length of stay is >= 30 days.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkLongTermIndicator(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (claim.getAdmission() != null
        && claim.getAdmission().getAdmissionDate() != null
        && claim.getAdmission().getDischargeDate() != null) {

      boolean indicator = "Y".equals(claim.getAdmission().getLongTermStayInd());

      // Calculate number of days
      long totalDays =
          ChronoUnit.DAYS.between(
              claim.getAdmission().getAdmissionDate(), claim.getAdmission().getDischargeDate());

      if ((totalDays >= GlobalConstants.LONG_TERM_STAY_NUMBER_OF_DAYS) != indicator) {
        String errMessage =
            MessageFormat.format(
                bundle.getString("claim.validation.checkLongTermIndicator"),
                (indicator == true ? "N" : "Y"),
                (indicator == true ? "Y" : "N"),
                totalDays);
        return new ValidationError(null, errMessage, claim.getAdmission().getLongTermStayInd());
      }
    }
    return null;
  }

  /**
   * CHECKINPATDUPLICATE if no duplicate claims are found in the database. NOTE: If multiple birth,
   * there is no validation of conflicting claims.
   *
   * <p>A Duplicate claim has
   * <li>different claim id
   * <li>same insurance number
   * <li>same birth name
   * <li>same resident province
   * <li>same treating province
   * <li>same hospital number
   * <li>same claim type
   * <li>same admission date <b>TODO: service date = admission_date???</b>
   * <li>same diagnosis code #1 (see exception for multiple birth)
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkInPatientDuplicate(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    // and check for Multiple birth (do not check duplicate)
    if (!StringUtils.isAnyBlank(claim.getTreatingProvince(), claim.getHospitalNumber())
        && (claim.getPatient() != null
            && !StringUtils.isAnyBlank(
                claim.getPatient().getProvince(), claim.getPatient().getInsuranceCardNumber())
            && claim.getPatient().getBirthDate() != null)
        && (claim.getAdmission() != null && claim.getAdmission().getAdmissionDate() != null)
        && claim.getMainDiagnosisCode() != null
        && !helper.isMultipleBirth(claim.getMainDiagnosisCode())) {

      // Fin all duplicate claims
      List<HospitalOopClaims> duplicateClaims = helper.findInpatDuplicateClaims(claim);
      for (HospitalOopClaims duplicateClaim : duplicateClaims) {

        // Get the first diag code from duplicate claim
        ClaimDetailCodes dupClaimCode = helper.getMainDiagnostic(duplicateClaim);

        // if diag code is different
        if ((dupClaimCode == null
                || !claim.getMainDiagnosisCode().equals(dupClaimCode.getCodeValue()))
            // OR same + does not allow duplicate
            || !"Y".equals(dupClaimCode.getDuplicateAllowedInd())) {
          String errMessage =
              MessageFormat.format(
                  bundle.getString(CLAIM_VALIDATION_CHECK_PATIENT_DUPLICATE),
                  duplicateClaim.getProvincialClaimId());
          return new ValidationError(null, errMessage, claim.getPatient().getInsuranceCardNumber());
        }
      }
    }
    return null;
  }

  /**
   * CHECKINPATDUPLICATE if no duplicate claims are found in the database. NOTE: If multiple birth,
   * there is no validation of conflicting claims.
   *
   * <p>A Duplicate claim has
   * <li>different claim id
   * <li>same insurance number
   * <li>same birth name
   * <li>same resident province
   * <li>same treating province
   * <li>same hospital number
   * <li>same claim type
   * <li>same admission date <b>TODO: service date = admission_date???</b>
   * <li>same diagnosis code #1 (see exception for multiple birth)
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkOutPatientDuplicate(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isAnyBlank(
            claim.getTreatingProvince(), claim.getHospitalNumber(), claim.getServiceCodeValue())
        && (claim.getPatient() != null
            && !StringUtils.isAnyBlank(
                claim.getPatient().getProvince(), claim.getPatient().getInsuranceCardNumber())
            && claim.getPatient().getBirthDate() != null)
        && claim.getServiceDate() != null) {

      // Fin all duplicate claims
      List<HospitalOopClaims> duplicateClaims = helper.findOutpatDuplicateClaims(claim);
      for (HospitalOopClaims duplicateClaim : duplicateClaims) {

        // Get the first diag code from duplicate claim
        ClaimDetailCodes dupClaimCode = helper.getServiceCode(duplicateClaim);

        // if service code is different
        if ((dupClaimCode == null
                || !claim.getServiceCodeValue().equals(dupClaimCode.getCodeValue()))
            // OR same + does not allow duplicate
            || !"Y".equals(dupClaimCode.getDuplicateAllowedInd())) {
          String errMessage =
              MessageFormat.format(
                  bundle.getString(CLAIM_VALIDATION_CHECK_PATIENT_DUPLICATE),
                  duplicateClaim.getProvincialClaimId());
          return new ValidationError(null, errMessage, claim.getPatient().getInsuranceCardNumber());
        }
      }
    }
    return null;
  }

  /**
   * CHECKINPATCONFLICT: if no conflicting claims are found in the database for the provided
   * inpatient claim data.
   *
   * <p>A Conflicting claim has
   * <li>different claim id
   * <li>same insurance number
   * <li>same birth name
   * <li>same resident province
   * <li>if other claim is INPATIENT: other.admission_date < me.discharge_date and
   *     other.discharge_date < me.admission_date
   * <li>if other claim is OUPATIENT: me.admission_date <= other.service_date <= me.discharge_date
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkInPatientConflict(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    // and check for Multiple birth (do not check duplicate)
    if (!StringUtils.isAnyBlank(claim.getTreatingProvince(), claim.getHospitalNumber())
        && (claim.getPatient() != null
            && !StringUtils.isAnyBlank(
                claim.getPatient().getProvince(), claim.getPatient().getInsuranceCardNumber())
            && claim.getPatient().getBirthDate() != null)
        && (claim.getAdmission() != null
            && claim.getAdmission().getAdmissionDate() != null
            && claim.getAdmission().getDischargeDate() != null)
        && !helper.isMultipleBirth(claim.getMainDiagnosisCode())) {

      //BCMOHAD-9594-31/01/2022: Find first conflicting claims
      List<HospitalOopClaims> conflictClaims = helper.findInpatConflictingClaims(claim);
      if (!conflictClaims.isEmpty()) {
        HospitalOopClaims conflictClaim = conflictClaims.get(0);
        String errMessage;
        if (helper.isInpatient(conflictClaim)) {
          errMessage =
              MessageFormat.format(
                  bundle.getString(CLAIM_VALIDATION_CHECK_PATIENT_CONFLICT1),
                  conflictClaim.getProvincialClaimId());
        } else {
          errMessage =
              MessageFormat.format(
                  bundle.getString(CLAIM_VALIDATION_CHECK_PATIENT_CONFLICT2),
                  conflictClaim.getProvincialClaimId());
        }
        return new ValidationError(null, errMessage, claim.getPatient().getInsuranceCardNumber());
      }
    }
    return null;
  }

  /**
   * CHECKOUTPATCONFLICT: if no conflicting claims are found in the database for the provided
   * outpatient claim data.
   *
   * <p>A Conflicting claim has
   * <li>different claim id
   * <li>same insurance number
   * <li>same birth name
   * <li>same resident province
   * <li>other claim is INPATIENT: other.admission_date <= me.service_date <= other.discharge_date
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkOutPatientConflict(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isAnyBlank(claim.getTreatingProvince(), claim.getHospitalNumber())
        && (claim.getPatient() != null
            && !StringUtils.isAnyBlank(
                claim.getPatient().getProvince(), claim.getPatient().getInsuranceCardNumber())
            && claim.getPatient().getBirthDate() != null)
        && (claim.getServiceDate() != null)) {
      //BCMOHAD-9594-If outpatient conflict occurs, it will throw conflict inpatient error message.
      List<HospitalOopClaims> conflictClaims = helper.findOutpatConflictingClaims(claim);
      if (!conflictClaims.isEmpty()) {
        HospitalOopClaims conflictClaim = conflictClaims.get(0);

        String errMessage =
            MessageFormat.format(
                bundle.getString(CLAIM_VALIDATION_CHECK_PATIENT_CONFLICT1),
                conflictClaim.getProvincialClaimId());
        return new ValidationError(null, errMessage, claim.getPatient().getInsuranceCardNumber());
      }
    }
    return null;
  }

  /**
   * CHECKCODINGSCHEME: if the provided value matches the coding scheme from the database NOTE:
   * Probably unnecessary because we can no longer create claims with ICD09.
   *
   * @param claim the claim
   * @param fieldName the field name
   * @param codePurpose the code purpose
   * @param getter to get the value to validate
   * @return the validation error
   */
  public ValidationError checkCodingScheme(
      ClaimViewModel claim,
      String fieldName,
      ClaimDetailCodePurpose codePurpose,
      Function<ClaimViewModel, String> getter) {
    // Get the value to test
    String codeValue = ValidationRule.getValue(getter, claim);
    // Get the claim coding scheme
    String claimCoding = claim.getIcdCodingScheme();

    // Mandatory values should be validated in other rules
    if (!StringUtils.isAnyBlank(codeValue, claimCoding)) {
      // Get the value coding scheme
      ClaimDetailCodes code = appService.getClaimDetailCodeAnyScheme(codeValue, codePurpose);

      if (code != null && !StringUtils.equalsIgnoreCase(code.getCodeType(), claimCoding)) {
        String errMessage =
            MessageFormat.format(
                bundle.getString("claim.validation.checkCodingScheme"),
                fieldName,
                codeValue,
                claimCoding);
        return new ValidationError(
            null, MessageFormat.format(errMessage, fieldName, codeValue, claimCoding), codeValue);
      }
    }
    return null;
  }

  /**
   * EDITHIGHCOSTPROCEDUREINFO : Compound mandatory rule for inpatient claim data.
   *
   * <p>If any of the following fields is not empty then all the following become mandatory if they
   * have the same row number (#1, #2 or #3)
   * <li>High Cost Code
   * <li>High Cost Date
   * <li>High Cost Amount <br>
   *
   * @param highcost the highcost
   * @param fieldValidated the field validated
   * @param index the index
   * @return ValidationError or null if no error
   */
  public ValidationError checkHighcostMandatory(
      HighcostViewModel highcost, String fieldValidated, int index) {
    Map<String, Boolean> missingField = new HashMap<>();
    missingField.put("Code", false);
    missingField.put("Date", false);
    missingField.put("Amount", false);

    if (highcost == null) {
      return null;
    }

    if (!StringUtils.isBlank(highcost.getCodeValue())
        || highcost.getProcedureDate() != null
        || highcost.getProcedureCost() != null) {
      if (StringUtils.isEmpty(highcost.getCodeValue())) {
        missingField.replace("Code", true);
      }
      if (highcost.getProcedureDate() == null) {
        missingField.replace("Date", true);
      }
      if (highcost.getProcedureCost() == null) {
        missingField.replace("Amount", true);
      }
    }

    if (missingField.get(fieldValidated)) {
      String errMessage =
          MessageFormat.format(
              bundle.getString("claim.validation.checkHighcostMandatory"), index, fieldValidated);
      return new ValidationError(null, errMessage, null);
    }
    return null;
  }

  /**
   * CHECKHIGHCOSTPROCAMOUNT: if the provided high cost amount is equal to the high cost procedure
   * rate in effect at time of treatment or if the rate in effect is 0.
   *
   * @param highCostViewModel the high cost view model
   * @return the validation error
   */
  public ValidationError checkHighCostProcAmount(HighcostViewModel highCostViewModel) {

    if (highCostViewModel == null
        || StringUtils.isBlank(highCostViewModel.getCodeValue())
        || highCostViewModel.getProcedureCost() == null) {
      return null;
    }

    List<HighcostProcedureRate> highCostRates =
        helper.getHighCostCodeRates(Short.valueOf(highCostViewModel.getCodeValue()));

    // Check if any rate with same High Cost Code
    if (highCostRates != null && !highCostRates.isEmpty()) {
      highCostRates =
          helper.filterHighCostCodeRatesOnDate(highCostRates, highCostViewModel.getProcedureDate());

      // No rate found according to the High Cost Code
    } else {
      String errMessage =
          MessageFormat.format(
              bundle.getString("claim.validation.checkHighCostProcAmount3"),
              highCostViewModel.getCodeValue());
      return new ValidationError(null, errMessage, null);
    }

    // Check if any rates that can contains the High Cost Date
    if (highCostRates != null && !highCostRates.isEmpty()) {

      HighcostProcedureRate rate = highCostRates.get(0);

      // If High Cost Rate Amount is different of 0 and the rate Amount found in database
      // BCMOHAD-10399-16Mar22: formatting the error message to display the amount with currency symbol
      if (rate.getBasicBlockRateAmount().compareTo(new BigDecimal("0")) != 0
          && rate.getBasicBlockRateAmount().compareTo(highCostViewModel.getProcedureCost()) != 0) {
        String errMessage =
            MessageFormat.format(
                bundle.getString("claim.validation.checkHighCostProcAmount2"),
                highCostViewModel.getProcedureCost(),
                highCostViewModel.getCodeValue(),
                highCostViewModel.getProcedureDate());
        return new ValidationError(null, errMessage, null);
      }

      // No rate found according to the High Cost Date
    } else {
      String errMessage =
          MessageFormat.format(
              bundle.getString("claim.validation.checkHighCostProcAmount1"),
              highCostViewModel.getCodeValue(),
              highCostViewModel.getProcedureDate());
      return new ValidationError(null, errMessage, null);
    }

    return null;
  }

  /**
   * CHECKOUTPATIENTTOTALAMT if the total claim amount is equal to the active service rate.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkOutPatientTotalAmout(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isBlank(claim.getServiceCodeValue())
        && claim.getServiceDate() != null
        && claim.getTotalAmountClaimed() != null) {
      BigDecimal activeRate =
          appService.getServiceRate(claim.getServiceCodeValue(), claim.getServiceDate());

      // Valid values should be validated in other rules (see checkServiceCodeActive)
      if (activeRate != null
          && activeRate != BigDecimal.ZERO
          && activeRate.compareTo(claim.getTotalAmountClaimed()) != 0) {
        String errMessage =
            MessageFormat.format(bundle.getString("claim.validation.checkTotalAmout"), activeRate);
        return new ValidationError(null, errMessage, claim.getTotalAmountClaimed());
      }
    }
    return null;
  }

  /**
   * CHECKSERVICECODEACTIVE if the service code was active on the provided date.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkServiceCodeActive(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isBlank(claim.getServiceCodeValue()) && claim.getServiceDate() != null) {

      BigDecimal activeRate =
          appService.getServiceRate(claim.getServiceCodeValue(), claim.getServiceDate());
      if (activeRate == null) {
        String errMessage =
            MessageFormat.format(
                bundle.getString("claim.validation.checkServiceCodeActive"),
                claim.getServiceCodeValue(),
                claim.getServiceDate());
        return new ValidationError(null, errMessage, claim.getServiceCodeValue());
      }
    }

    return null;
  }

  /* checkProcedureCodeOutpatient procedure code is mandatory for service codes 02, 13, 18, 19, 20, 63, 68, 69, 70.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkProcedureCodeOutpatient(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isBlank(claim.getServiceCodeValue())) {
      List<String> mandatoryCodes = Arrays.asList(new String[]{"02", "13", "18", "19", "20", "63", "68", "69", "70"});

      if (mandatoryCodes.contains(claim.getServiceCodeValue())) {
        if (StringUtils.isBlank(claim.getProcedureCodes()[0]) && StringUtils.isBlank(claim.getProcedureCodes()[1]) && StringUtils.isBlank(claim.getProcedureCodes()[2])) {
          String errMessage
                  = MessageFormat.format(bundle.getString("claim.validation.mandatory"), "Procedure Code");
          return new ValidationError(null, errMessage, claim.getHospitalNumber());
        }
      }
    }
    return null;
  }

  /**
   * checkDiagnosticCodeOutpatient diagnostic code is mandatory for service codes 02, 18, 19, 20, 68, 69, 70.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkDiagnosticCodeOutpatient(ClaimViewModel claim) {
    // Mandatory values should be validated in other rules
    if (!StringUtils.isBlank(claim.getServiceCodeValue())) {
      List<String> mandatoryCodes = Arrays.asList(new String[]{"02", "18", "19", "20", "68", "69", "70"});

      if (mandatoryCodes.contains(claim.getServiceCodeValue())) {
        if (StringUtils.isBlank(claim.getDiagnosisCodes()[0]) && StringUtils.isBlank(claim.getDiagnosisCodes()[1]) && StringUtils.isBlank(claim.getDiagnosisCodes()[2])) {
          String errMessage
                  = MessageFormat.format(bundle.getString("claim.validation.mandatory"), "Diagnostic Code");
          return new ValidationError(null, errMessage, claim.getHospitalNumber());
        }
      }
    }
    return null;
  }

   /**
   * checkProvinceRestrictedCode for the new codes 51-70
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkProvinceRestrictedCode(ClaimViewModel claim) {
    if (claim.getServiceDate() != null) {
      if (claim.getServiceDate().isAfter(appService.getCutOffDateNewCodes())) {
        if (!StringUtils.isBlank(claim.getServiceCodeValue())) {
          List<String> newCodes = Arrays.asList(new String[]{"QC", "MB", "SK", "AB", "BC", "NU"});
          List<String> oldCodes = Arrays.asList(new String[]{"NL", "PE", "NS", "NB", "ON", "NT", "YT"});
          if ((Integer.valueOf(claim.getServiceCodeValue()) > 49)) {
            if (oldCodes.contains(claim.getTreatingProvince())) {
              String errMessage = MessageFormat.format(bundle.getString("claim.validation.lookupprov"), claim.getServiceCodeValue(), claim.getTreatingProvince().trim());
              return new ValidationError(errMessage);
            }
          } else if (newCodes.contains(claim.getTreatingProvince())) {
            String errMessage = MessageFormat.format(bundle.getString("claim.validation.lookupprov"), claim.getServiceCodeValue(), claim.getTreatingProvince().trim());
            return new ValidationError(errMessage);
          }
        }
      }
    }
    return null;
  }
  
  public ValidationError checkExistingDiagnosticCode(ClaimViewModel claim) {
    if (!StringUtils.isEmpty(claim.getDiagnosisCodes()[0])) {
      if (appService.getDiagnosticCode(claim.getDiagnosisCodes()[0]) == null) {
        String errMessage = MessageFormat.format(bundle.getString("claim.validation.invaliddiagnostic"), claim.getDiagnosisCodes()[0]);
        return new ValidationError(errMessage);
      }
    } else if (!StringUtils.isEmpty(claim.getDiagnosisCodes()[1])) {
      if (appService.getDiagnosticCode(claim.getDiagnosisCodes()[1]) == null) {
        String errMessage = MessageFormat.format(bundle.getString("claim.validation.invaliddiagnostic"), claim.getDiagnosisCodes()[1]);
        return new ValidationError(errMessage);
      }
    } else if (!StringUtils.isEmpty(claim.getDiagnosisCodes()[2])) {
      if (appService.getDiagnosticCode(claim.getDiagnosisCodes()[2]) == null) {
        String errMessage = MessageFormat.format(bundle.getString("claim.validation.invaliddiagnostic"), claim.getDiagnosisCodes()[2]);
        return new ValidationError(errMessage);
      }
    }
    return null;
  }

  public ValidationError checkExistingProcedureCode(ClaimViewModel claim) {
    if (!StringUtils.isEmpty(claim.getProcedureCodes()[0])) {
      if (appService.getProcedureCode(claim.getProcedureCodes()[0]) == null) {
        String errMessage = MessageFormat.format(bundle.getString("claim.validation.invalidprocedure"), claim.getProcedureCodes()[0]);
        return new ValidationError(errMessage);
      }
    } else if (!StringUtils.isEmpty(claim.getProcedureCodes()[1])) {
      if (appService.getProcedureCode(claim.getProcedureCodes()[1]) == null) {
        String errMessage = MessageFormat.format(bundle.getString("claim.validation.invalidprocedure"), claim.getProcedureCodes()[1]);
        return new ValidationError(errMessage);
      }
    } else if (!StringUtils.isEmpty(claim.getProcedureCodes()[2])) {
      if (appService.getProcedureCode(claim.getProcedureCodes()[2]) == null) {
        String errMessage = MessageFormat.format(bundle.getString("claim.validation.invalidprocedure"), claim.getProcedureCodes()[2]);
        return new ValidationError(errMessage);
      }
    }
    return null;
  }
  
   /**
   * Check for expired service code 02
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkExpiredServiceCode(ClaimViewModel claim) {
    LocalDate cutDate = appService.getCutOffDateNewCodes();
    if (!StringUtils.isBlank(claim.getServiceCodeValue())) {
        if (Integer.valueOf(claim.getServiceCodeValue()) == 2) {
                if (claim.getServiceDate().isAfter(cutDate)) { 
                    String errMessage = MessageFormat.format(bundle.getString("claim.validation.RetiredCode"), claim.getServiceCodeValue(), claim.getServiceDate().toString());
                    return new ValidationError(errMessage);
                }
        } else if (Integer.valueOf(claim.getServiceCodeValue()) > 16) {
                if (claim.getServiceDate().isBefore(cutDate.plusDays(1))) { 
                    String errMessage = MessageFormat.format(bundle.getString("claim.validation.NewActiveCode"), claim.getServiceCodeValue(), claim.getServiceDate().toString());
                    return new ValidationError(errMessage);
                }
        }
    }
    return null;
  }
  
   /**
   * Check for procedure by service
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkServiceCodeLevelProcedure(ClaimViewModel claim) {
    if (claim.getServiceDate() != null) {
      if (claim.getServiceDate().isAfter(appService.getCutOffDateNewCodes())) {
        List<String> Level1 = Arrays.asList(new String[]{"18", "68"});
        List<String> Level2 = Arrays.asList(new String[]{"19", "69"});
        List<String> Level3 = Arrays.asList(new String[]{"20", "70"});
        String Code = claim.getServiceCodeValue();
        String[] procCode = claim.getProcedureCodes();
        String Level = "";
        if (!(StringUtils.isBlank(procCode[0]) && StringUtils.isBlank(procCode[1]) && StringUtils.isBlank(procCode[2]))) {
          String goodCode = procCode[0];
          if (!StringUtils.isBlank(procCode[0])) {
            goodCode = procCode[0];
          } else if (!StringUtils.isBlank(procCode[1])) {
            goodCode = procCode[1];
          } else if (!StringUtils.isBlank(procCode[2])) {
            goodCode = procCode[2];
          }
          if (!StringUtils.isBlank(claim.getServiceCodeValue()) && !StringUtils.isBlank(goodCode)) {
            //LocalDate.of(2021, 01, 31)
            if (claim.getServiceDate().isAfter(appService.getCutOffDateNewCodes()) && (Level1.contains(Code) || Level2.contains(Code) || Level3.contains(Code))) {
              if (Level1.contains(Code)) {
                Level = "01";
              } else if (Level2.contains(Code)) {
                Level = "02";
              } else if (Level3.contains(Code)) {
                Level = "03";
              }
              if (!appService.isValidProcedureForService(Level, goodCode)) {
                if (claim.getServiceDate().isAfter(appService.getCutOffDateNewCodes())) {
                  String errMessage = MessageFormat.format(bundle.getString("claim.validation.LevelService"), goodCode, Code);
                  return new ValidationError(errMessage);
                }
              }
            }
          }
        }
      }
    }
    return null;
  }


  
/*
claim.validation.lookup=Invalid code {0} for {1}  */
  /**
   * Claim Override Request Reason is mandatory if claimOverride selected.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkOverrideRequestReason(ClaimViewModel claim) {
    if (claim.getClaimOverride() != null && claim.getClaimOverride().isOverrideRequest()) {
      if (StringUtils.isBlank(claim.getClaimOverride().getOverrideRequestReason())) {
        String errMessage =
            MessageFormat.format(
                bundle.getString("claim.validation.mandatory"), "Override Hospital Reason");
        return new ValidationError(
            null, errMessage, claim.getClaimOverride().getOverrideRequestReason());
      }
    }
    return null;
  }

  /**
   * Claim Override Status Reason is mandatory if status is selected and one of "APPROVED" or
   * "DENIED".
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkOverrideStatusReason(ClaimViewModel claim) {
    if (claim.getClaimOverride() != null
        && !StringUtils.isBlank(claim.getClaimOverride().getOverrideStatus())) {
      // If Status selected
      if (StringUtils.equalsAnyIgnoreCase(
          claim.getClaimOverride().getOverrideStatus(),
          OverrideStatus.APPROVED.toString(),
          OverrideStatus.DENIED.toString())) {
        // If status other than requested
        if (StringUtils.isBlank(claim.getClaimOverride().getOverrideStatusReason())) {
          // Status reason is mandatory
          String errMessage =
              MessageFormat.format(
                  bundle.getString("claim.validation.mandatory"), "Override Status Reason");
          return new ValidationError(null, errMessage, null);
        }
      }
    }
    return null;
  }

  /**
   * Insurance card expiry date is mandatory if insurance expiry was implemented in the provided
   * province on or before the treatment date.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkInsuranceExpiry(ClaimViewModel claim) {
    if (claim.getServiceDate() != null) {
      if (claim.getPatient() != null
              && !StringUtils.isBlank(claim.getPatient().getProvince())
              && claim.getServiceDate() != null) {
        // Get the province info
        ProvincesTerritories province = appService.getProvince(claim.getPatient().getProvince());
        // If card expiry date is not given
        if (claim.getPatient().getCardExpiryDate() == null) {
          // If province has expiry indicator
          if (StringUtils.equalsIgnoreCase(province.getInsuranceExpiresInd(), "Y")) {
            // If start of expiry before (or equal) treatment date, or if start of expiry is not
            // specified
            if (province.getInsuranceExpiryImpltnDate() == null
                    || !province.getInsuranceExpiryImpltnDate().isAfter(claim.getServiceDate())) {
              String errMessage
                      = MessageFormat.format(
                              bundle.getString("claim.validation.mandatory"), "Insurance Card Expiry Date");
              return new ValidationError(null, errMessage, null);
            }
          }
        }
      }
    }
    return null;
  }

  /**
   * CHECKPROVPHNFORMAT if the provided insurance number passes the format or checksum validation
   * for the provided province. For all provinces/territories except BC.
   *
   * @param claim the claim
   * @return the validation error
   */
  public ValidationError checkProvPHNFormat(ClaimViewModel claim) {
    if (claim.getPatient() != null
        && !StringUtils.isBlank(claim.getPatient().getProvince())
        && !claim.getPatient().getProvince().equals("BC")
        && !StringUtils.isBlank(claim.getPatient().getInsuranceCardNumber())) {
      int retVal = 0;

      if (StringUtils.equalsIgnoreCase("QC", claim.getPatient().getProvince())
          && !StringUtils.isBlank(claim.getPatient().getSexCode())) {
        // For QC, needs to pass sexCode
        retVal =
            phnHelper.checkPHN(
                claim.getPatient().getProvince(),
                claim.getPatient().getInsuranceCardNumber(),
                claim.getPatient().getSexCode());
      } else {
        retVal =
            phnHelper.checkPHN(
                claim.getPatient().getProvince(), claim.getPatient().getInsuranceCardNumber());
      }
      switch (retVal) {
        case PHNHelper.PHN_ERROR_FORMAT:
          return new ValidationError(
              null, bundle.getString("claim.validation.checkProvPHNFormat.format"), null);
        case PHNHelper.PHN_ERROR_CHECKSUM:
          return new ValidationError(
              null, bundle.getString("claim.validation.checkProvPHNFormat.checksum"), null);
      }
    }
    return null;
  }
}
