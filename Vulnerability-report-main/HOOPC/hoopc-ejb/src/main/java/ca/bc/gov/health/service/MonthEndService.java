package ca.bc.gov.health.service;

import ca.bc.gov.health.constants.GlobalConstants;
import ca.bc.gov.health.database.entity.MonthendStatusTransitions;
import ca.bc.gov.health.database.entity.ProvinceMonthendStatus;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.exception.HoopcPLSQLException;
import ca.bc.gov.health.validation.ValidationError;
import jakarta.ejb.Stateless;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.ParameterMode;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.StoredProcedureQuery;
import jakarta.persistence.TypedQuery;
import jakarta.security.enterprise.SecurityContext;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Stateless
public class MonthEndService {

  private static final String RETURNED_RESULT_CODE_AND_MESSAGE_CONST =
      "{} returned resultCode {} and message {}";
  private static final String PV_MESSAGE_CONST = "pv_message";
  private static final String PN_RESULT_CODE_CONST = "pn_resultCode";
  private static final String PV_SESSION_ID_CONST = "pv_sessionID";
  private static final String PV_USER_ID_CONST = "pv_userID";
  private static final String PV_TRANSITION_CAUSE_CONST = "pv_transitionCause";
  private static final String PV_RESIDENCY_TYPE_CONST = "pv_residencyType";
  private static final String CALLING_METHOD_CONST = "Calling {}";

  @PersistenceContext(unitName = "hoopc-ejb_pu")
  private EntityManager em;

  @Inject HoopcAppService appService;

  private static Logger logger = LoggerFactory.getLogger("MonthEndService");

  @Inject SecurityContext securityContext;

  /**
   * Attempts to change the Month End status of the specified provinces and residency type to the
   * target status. If the status transition is not valid, returns a list of errors.
   *
   * @param targetStatus the target status code, e.g. SCHEDULED.
   * @param selectedProvinceCodes province codes (AB, NB, ON, etc.)
   * @param resType RES or NRES.
   * @return a list of errors or an empty list if there are no errors.
   * @throws HoopcPLSQLException if the PL/SQL procedure returned an unexpected error.
   */
  public List<ValidationError> validateAndChangeProvinceStatus(
      String targetStatus, List<String> selectedProvinceCodes, String resType)
      throws HoopcException {

    List<ProvinceMonthendStatus> statuses = getMonthEndStatuses(resType, selectedProvinceCodes);
    List<ValidationError> errors = validateTransition(statuses, targetStatus, resType);
    if (errors.isEmpty()) {
      for (ProvinceMonthendStatus status : statuses) {
        String finalStatus = targetStatus;
        if (targetStatus.equals("DISTPENDNG")
            && !isElectronicProvinces(status.getPteId().getProvinceCode())) {
          finalStatus = "DISTRIBUTD";
        }
        advanceMonthEndStatus(status, finalStatus);
      }
    }
    return errors;
  }

  /**
   * Get Month End statuses of the specified residency type.
   *
   * @param resType RES or NRES.
   * @return Month End statuses.
   */
  public List<ProvinceMonthendStatus> getMonthEndStatuses(String resType) {
    em.getEntityManagerFactory().getCache().evictAll();
    TypedQuery<ProvinceMonthendStatus> namedQuery =
        em.createNamedQuery("ProvinceMonthendStatus.findByRts", ProvinceMonthendStatus.class);
    namedQuery.setParameter("rtsTypeCode", resType);
    return namedQuery.getResultList();
  }

  /**
   * Get the Month End statuses of the specified provinces and residency type.
   *
   * @param resType RES or NRES.
   * @param selectedProvinceCodes province codes (AB, NB, ON, etc.)
   * @return Month End statuses.
   */
  public List<ProvinceMonthendStatus> getMonthEndStatuses(
      String resType, List<String> selectedProvinceCodes) {
    TypedQuery<ProvinceMonthendStatus> query =
        em.createQuery(
            "SELECT s FROM ProvinceMonthendStatus s "
                + "WHERE s.rtsId.typeCode = :rts AND s.pteId.provinceCode IN :selectedProvinces "
                + "ORDER By s.pteId.name",
            ProvinceMonthendStatus.class);
    query.setParameter("rts", resType);
    query.setParameter("selectedProvinces", selectedProvinceCodes);
    return query.getResultList();
  }

  /**
   * Does a first pass across actions asked to validate that all transitions are legal before
   * processing the request of change in the database.
   *
   * @param provMonthendStatus
   * @param targetStatus
   * @param resType
   * @return
   */
  private List<ValidationError> validateTransition(
      List<ProvinceMonthendStatus> provMonthendStatus, String targetStatus, String resType) {

    List<MonthendStatusTransitions> possibleTransitions =
        getAllTransitionsToTargetStatus(targetStatus, resType);
    List<ValidationError> errors = new ArrayList<>();
    for (ProvinceMonthendStatus provinceStatus : provMonthendStatus) {
      List<MonthendStatusTransitions> validTransitions;
      if (targetStatus.equals("DISTPENDNG")
          && !isElectronicProvinces(provinceStatus.getPteId().getProvinceCode())) {
        validTransitions = getTransition(provinceStatus, "DISTRIBUTD");
      } else {
        validTransitions = getTransition(provinceStatus, targetStatus);
      }
      if (validTransitions.isEmpty()) {
        errors.add(
            new ValidationError(
                MessageFormat.format(
                    GlobalConstants.MONTHEND_STATUS_ERROR_MESSAGE,
                    provinceStatus.getMesId().getStatusCode(),
                    possibleTransitionsMessage(possibleTransitions),
                    provinceStatus.getPteId().getProvinceCode())));
      }
    }
    return errors;
  }

  /**
   * Gets all possible status transitions for a specific destination status and residency type.
   *
   * @param toMesCode
   * @param resType
   * @return
   */
  private List<MonthendStatusTransitions> getAllTransitionsToTargetStatus(
      String toMesCode, String resType) {
    List<MonthendStatusTransitions> result =
        em.createNamedQuery("MonthendStatusTransitions.findAll", MonthendStatusTransitions.class)
            .getResultList();
    if (result != null) {
      result =
          result.stream()
              .filter(
                  r ->
                      r.getToMesId().getStatusCode().equals(toMesCode)
                          && r.getRtsId().getTypeCode().equals(resType))
              .collect(Collectors.toList());
    }
    return result;
  }

  /**
   * Returns a String for all possible status transitions for a specific destination status and
   * residency type.
   *
   * @param possibleTransitions
   * @return
   */
  private static String possibleTransitionsMessage(
      List<MonthendStatusTransitions> possibleTransitions) {
    if (possibleTransitions != null) {
      return possibleTransitions.stream()
          .map(t -> t.getFromMesId().getStatusCode())
          .collect(Collectors.joining(","));
    }
    return null;
  }

  /**
   * Returns all status transition for a start and end status and specific residency type into a
   * List.
   *
   * @param p
   * @param targetStatus
   * @return
   */
  private List<MonthendStatusTransitions> getTransition(
      ProvinceMonthendStatus p, String targetStatus) {
    TypedQuery<MonthendStatusTransitions> query =
        em.createQuery(
            "SELECT t FROM MonthendStatusTransitions t "
                + "WHERE t.fromMesId.statusCode = :currentStatus AND t.toMesId.statusCode = :targetStatus "
                + "AND t.rtsId.typeCode = :rts",
            MonthendStatusTransitions.class);
    query.setParameter("currentStatus", p.getMesId().getStatusCode());
    query.setParameter("targetStatus", targetStatus);
    query.setParameter("rts", p.getRtsId().getTypeCode());
    List<MonthendStatusTransitions> resultList = query.getResultList();
    if (resultList.size() > 1) {
      logger.error(
          "Should be at most one possible transition, but found {}. List: {}",
          resultList.size(),
          resultList);
    }
    return resultList;
  }

  /**
   * Calls plsql procedure to advance from a status to another for a specific province and residency
   * type.
   *
   * @param currentStatus
   * @param targetStatus
   * @throws HoopcPLSQLException
   */
  private void advanceMonthEndStatus(ProvinceMonthendStatus currentStatus, String targetStatus)
      throws HoopcException {
    String spName = "HOOPC2_MONTHEND.ADVANCEMONTHENDSTATUS";
    logger.info(CALLING_METHOD_CONST, spName);

    String transitionCause = getTransition(currentStatus, targetStatus).get(0).getTransitionCause();

    StoredProcedureQuery query = em.createStoredProcedureQuery(spName);

    query.registerStoredProcedureParameter("pv_provinceCode", String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter(PV_RESIDENCY_TYPE_CONST, String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter("pv_currentStatus", String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter(
        PV_TRANSITION_CAUSE_CONST, String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter(PV_USER_ID_CONST, String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter(PV_SESSION_ID_CONST, String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter(PN_RESULT_CODE_CONST, Integer.class, ParameterMode.OUT);
    query.registerStoredProcedureParameter(PV_MESSAGE_CONST, String.class, ParameterMode.OUT);

    query.setParameter("pv_provinceCode", currentStatus.getPteId().getProvinceCode());
    query.setParameter(PV_RESIDENCY_TYPE_CONST, currentStatus.getRtsId().getTypeCode());
    query.setParameter("pv_currentStatus", currentStatus.getMesId().getStatusCode());
    query.setParameter(PV_TRANSITION_CAUSE_CONST, transitionCause);
    query.setParameter(PV_USER_ID_CONST, securityContext.getCallerPrincipal().getName());
    query.setParameter(PV_SESSION_ID_CONST, "");

    query.execute();
    /* If we don't clear the cache, the EntityManager state is inconsisent. For example,
     given that Alberta is NOTSTARTED, we can SCHEDULE it, and then immediately
     CANCEL it, but the CANCEL operation will fail because the EntityManager
     seems to think it's still NOTSTARTED. This is probably because we are
     using PL/SQL to update the database.
    */
    em.getEntityManagerFactory().getCache().evictAll();

    String resultCode = ((Integer) query.getOutputParameterValue(PN_RESULT_CODE_CONST)).toString();
    String message = (String) query.getOutputParameterValue(PV_MESSAGE_CONST);

    logger.info(RETURNED_RESULT_CODE_AND_MESSAGE_CONST, spName, resultCode, message);

    if (StringUtils.isNotBlank(message)) {
      throw new HoopcException(message);
    }
  }

  /**
   * Calls plsql procedure to advance from a status to another for a specific province and residency
   * type.
   *
   * @param currentStatus
   * @param targetStatus
   * @throws HoopcException
   */
  public void advanceMonthEndStatusNonRes(String transitionCause) throws HoopcException {
    String spName = "HOOPC2_MONTHEND.APPROVENONRESPROVINCES";
    logger.info(CALLING_METHOD_CONST, spName);

    StoredProcedureQuery query = em.createStoredProcedureQuery(spName);

    query.registerStoredProcedureParameter(
        PV_TRANSITION_CAUSE_CONST, String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter(PV_USER_ID_CONST, String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter(PV_SESSION_ID_CONST, String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter(PN_RESULT_CODE_CONST, Integer.class, ParameterMode.OUT);
    query.registerStoredProcedureParameter(PV_MESSAGE_CONST, String.class, ParameterMode.OUT);

    query.setParameter(PV_TRANSITION_CAUSE_CONST, transitionCause);
    query.setParameter(PV_USER_ID_CONST, securityContext.getCallerPrincipal().getName());
    query.setParameter(PV_SESSION_ID_CONST, "");

    query.execute();

    em.getEntityManagerFactory().getCache().evictAll();

    String resultCode = ((Integer) query.getOutputParameterValue(PN_RESULT_CODE_CONST)).toString();
    String message = (String) query.getOutputParameterValue(PV_MESSAGE_CONST);

    logger.info(RETURNED_RESULT_CODE_AND_MESSAGE_CONST, spName, resultCode, message);

    if (StringUtils.isNotBlank(message)) {
      throw new HoopcException(message);
    }
  }

  public String getProcessingMonth(String residencyType) throws HoopcException {
    String spName = "HOOPC2_MONTHEND.GetProcessingMonth";
    logger.info(CALLING_METHOD_CONST, spName);

    StoredProcedureQuery query = em.createStoredProcedureQuery(spName);

    query.registerStoredProcedureParameter(PV_RESIDENCY_TYPE_CONST, String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter(PV_USER_ID_CONST, String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter(PV_SESSION_ID_CONST, String.class, ParameterMode.IN);
    query.registerStoredProcedureParameter("pv_processingMonth", String.class, ParameterMode.OUT);
    query.registerStoredProcedureParameter(PN_RESULT_CODE_CONST, Integer.class, ParameterMode.OUT);
    query.registerStoredProcedureParameter(PV_MESSAGE_CONST, String.class, ParameterMode.OUT);

    query.setParameter(PV_RESIDENCY_TYPE_CONST, residencyType);
    query.setParameter(PV_USER_ID_CONST, securityContext.getCallerPrincipal().getName());
    query.setParameter(PV_SESSION_ID_CONST, "");

    query.execute();
    em.getEntityManagerFactory().getCache().evictAll();

    String resultCode = ((Integer) query.getOutputParameterValue(PN_RESULT_CODE_CONST)).toString();
    String message = (String) query.getOutputParameterValue(PV_MESSAGE_CONST);

    logger.info(RETURNED_RESULT_CODE_AND_MESSAGE_CONST, spName, resultCode, message);

    if (StringUtils.isNotBlank(message)) {
      throw new HoopcException(message);
    }

    return (String) query.getOutputParameterValue("pv_processingMonth");
  }

  public boolean isElectronicProvinces(String provinceCode) {
    return appService.getProvince(provinceCode).getElectronicDataSubmitInd().equals("Y");
  }
}
