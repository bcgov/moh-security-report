package ca.bc.gov.health.service;

import ca.bc.gov.health.constants.ClaimContentContext;
import ca.bc.gov.health.constants.ClaimDetailCodePurpose;
import ca.bc.gov.health.constants.ClaimDetailCodeType;
import ca.bc.gov.health.database.entity.ApplicationSettings;
import ca.bc.gov.health.database.entity.ClaimDetailCodes;
import ca.bc.gov.health.database.entity.ClaimProcedureLevel;
import ca.bc.gov.health.database.entity.ClaimStatusCodes;
import ca.bc.gov.health.database.entity.ClaimTypes;
import ca.bc.gov.health.database.entity.HealthAuthorities;
import ca.bc.gov.health.database.entity.HighcostProcedureCodes;
import ca.bc.gov.health.database.entity.HospitalOopClaims;
import ca.bc.gov.health.database.entity.HospitalPerDiemRates;
import ca.bc.gov.health.database.entity.Hospitals;
import ca.bc.gov.health.database.entity.ProvincesTerritories;
import ca.bc.gov.health.database.entity.ReasonInProvCodes;
import ca.bc.gov.health.database.entity.ResidencyTypes;
import ca.bc.gov.health.database.entity.ServiceRates;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.exception.HoopcRuntimeException;
import ca.bc.gov.health.helper.SelectItemHelper;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.Asynchronous;
import jakarta.ejb.Singleton;
import jakarta.ejb.Startup;
import jakarta.enterprise.inject.Produces;
import jakarta.faces.model.SelectItem;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.TypedQuery;
import java.math.BigDecimal;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.text.MessageFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The Class HoopcAppService.
 *
 * @author christian.hudon
 */
@Singleton
@Startup
public class HoopcAppService {

  private static Logger log = LoggerFactory.getLogger(HoopcAppService.class);
  private static final String PROVINCE_CODE = "provinceCode";

  @PersistenceContext(unitName = "hoopc-ejb_pu")
  private EntityManager em;

  private Map<String, ProvincesTerritories> mapProvinces;
  private Map<HospitalKey, Hospitals> mapHospitals;
  private Map<String, ResidencyTypes> mapResidencyTypes;
  private Map<String, ClaimTypes> mapClaimTypes;
  private Map<String, ClaimStatusCodes> mapStatusCodes;
  // Contains all ICD10 Diagnostic codes
  private Map<String, ClaimDetailCodes> mapDiagnosticCodes;
  // Contains all ICD10 Procedure codes
  private Map<String, ClaimDetailCodes> mapProcedureCodes;
  // Contains all Service codes
  private Map<String, ClaimDetailCodes> mapServiceCodes;
  // Contains all Highcost codes
  private Map<Short, HighcostProcedureCodes> mapHighcostCodes;
  private Map<String, ReasonInProvCodes> mapReasonInProvCodes;
  private Map<String, HealthAuthorities> mapHealthAuthorities;

  private List<SelectItem> provincesList;
  private List<SelectItem> residentProvincesList;
  private List<SelectItem> provincesAbreviationList;
  private List<SelectItem> nresProvincesAbreviationList;
  private List<SelectItem> reasonInBcList;
  private List<SelectItem> healthAuthoritiesList;
  
  /** Inits the. */
  @PostConstruct
  private void init() {
    log.info("Initilazing static data");
    initReasonInProvCodes(false);
    initProvinces(false);
    initHospitals(false);
    initResidencyTypes(false);
    initClaimTypes(false);
    initStatusCodes(false);
    initDetailCodes(false);
    initServiceCodes(false);
    initHighcostCodes(false);
    initHealthAuthorities(false);
  }

  /** Inits the provinces. */
  @Asynchronous
  public void initProvinces() {
    initProvinces(true);
  }

  /** Inits the reason in prov codes. */
  @Asynchronous
  public void initReasonInProvCodes() {
    initReasonInProvCodes(true);
  }

  /** Inits the hospitals. */
  @Asynchronous
  public void initHospitals() {
    initHospitals(true);
  }

  /** Inits the detail codes. */
  @Asynchronous
  public void initDetailCodes() {
    initDetailCodes(true);
  }

  /** Inits the service codes. */
  @Asynchronous
  public void initServiceCodes() {
    initServiceCodes(true);
  }

  /** Inits the highcost codes. */
  @Asynchronous
  public void initHighcostCodes() {
    initHighcostCodes(true);
  }

  /** Inits the health authorities. */
  @Asynchronous
  public void initHealthAuthorities() {
    initHealthAuthorities(true);
  }

  private Map<String, ProvincesTerritories> initProvinces(boolean forceQuery) {
    try {
      log.info("Initilazing ProvincesTerritories");

      if (mapProvinces == null || forceQuery) {
        TypedQuery<ProvincesTerritories> query =
            em.createNamedQuery("ProvincesTerritories.findAll", ProvincesTerritories.class);
        Stream<ProvincesTerritories> allProvinces = query.getResultStream();
        mapProvinces =
            allProvinces.collect(
                Collectors.toMap(ProvincesTerritories::getProvinceCode, Function.identity()));
        provincesList = SelectItemHelper.buildSelectItemList(getProvinces(), "name", PROVINCE_CODE);
        residentProvincesList =
            SelectItemHelper.buildSelectItemList(getResidentProvinces(), "name", PROVINCE_CODE);
        provincesAbreviationList =
            SelectItemHelper.buildSelectItemList(getProvinces(), PROVINCE_CODE, PROVINCE_CODE);
        nresProvincesAbreviationList =
            SelectItemHelper.buildSelectItemList(
                getResidentProvinces(), PROVINCE_CODE, PROVINCE_CODE);
      }

      return mapProvinces;
    } catch (Exception e) {
      log.error("Error initilazing ProvincesTerritories", e);
      return null;
    }
  }

  private Map<String, ReasonInProvCodes> initReasonInProvCodes(boolean forceQuery) {
    try {
      log.info("Initilazing ReasonInProvCodes");

      if (mapReasonInProvCodes == null || forceQuery) {
        TypedQuery<ReasonInProvCodes> query =
            em.createNamedQuery("ReasonInProvCodes.findAll", ReasonInProvCodes.class);
        Stream<ReasonInProvCodes> allReasonInProvCodes = query.getResultStream();
        mapReasonInProvCodes =
            allReasonInProvCodes.collect(
                Collectors.toMap(ReasonInProvCodes::getReasonCode, Function.identity()));
        reasonInBcList =
            SelectItemHelper.buildSelectItemList(
                getReasonInProvCodes(), "reasonCode", "reasonCode");
      }

      return mapReasonInProvCodes;
    } catch (Exception e) {
      log.error("Error initilazing ProvincesTerritories", e);
      return null;
    }
  }

  /**
   * Inits the hospitals.
   *
   * @param forceQuery the force query
   * @return the map
   */
  public Map<HospitalKey, Hospitals> initHospitals(boolean forceQuery) {
    try {
      log.info("Initilazing Hospitals");
      if (mapHospitals == null || forceQuery) {
        TypedQuery<Hospitals> query = em.createNamedQuery("Hospitals.findAll", Hospitals.class);
        Stream<Hospitals> allHospitals = query.getResultStream();
        mapHospitals =
            allHospitals.collect(
                Collectors.toMap(
                    h -> new HospitalKey(h.getPteId().getProvinceCode(), h.getHospitalNumber()),
                    Function.identity()));
      }
      return mapHospitals;
    } catch (Exception e) {
      log.error("Error initilazing Hospitals", e);
      return null;
    }
  }

  private Map<String, ResidencyTypes> initResidencyTypes(boolean forceQuery) {
    try {
      log.info("Initilazing ResidencyTypes");

      if (mapResidencyTypes == null || forceQuery) {
        TypedQuery<ResidencyTypes> query =
            em.createNamedQuery("ResidencyTypes.findAll", ResidencyTypes.class);
        Stream<ResidencyTypes> allTypes = query.getResultStream();
        mapResidencyTypes =
            allTypes.collect(Collectors.toMap(ResidencyTypes::getTypeCode, Function.identity()));
      }

      return mapResidencyTypes;
    } catch (Exception e) {
      log.error("Error initilazing ResidencyTypes", e);
      return null;
    }
  }

  private Map<String, ClaimTypes> initClaimTypes(boolean forceQuery) {
    try {
      log.info("Initilazing ClaimTypes");

      if (mapClaimTypes == null || forceQuery) {
        TypedQuery<ClaimTypes> query = em.createNamedQuery("ClaimTypes.findAll", ClaimTypes.class);
        Stream<ClaimTypes> allTypes = query.getResultStream();
        mapClaimTypes =
            allTypes.collect(Collectors.toMap(ClaimTypes::getClaimType, Function.identity()));
      }

      return mapClaimTypes;
    } catch (Exception e) {
      log.error("Error initilazing ClaimTypes", e);
      return null;
    }
  }

  private Map<String, ClaimStatusCodes> initStatusCodes(boolean forceQuery) {
    try {
      log.info("Initilazing ClaimStatusCodes");

      if (mapStatusCodes == null || forceQuery) {
        TypedQuery<ClaimStatusCodes> query =
            em.createNamedQuery("ClaimStatusCodes.findAll", ClaimStatusCodes.class);
        Stream<ClaimStatusCodes> allTypes = query.getResultStream();
        mapStatusCodes =
            allTypes.collect(
                Collectors.toMap(ClaimStatusCodes::getStatusCode, Function.identity()));
      }

      return mapStatusCodes;
    } catch (Exception e) {
      log.error("Error initilazing ClaimStatusCodes", e);
      return null;
    }
  }

    /**
   * Inits the detail codes.
   *
   * @param forceQuery the force query
   */
  public void initDetailCodes(boolean forceQuery) {
    try {
      log.info("Initilazing ClaimDetailCodes");

      if (mapDiagnosticCodes == null || forceQuery) {
        TypedQuery<ClaimDetailCodes> query =
            em.createNamedQuery("ClaimDetailCodes.findAllICD10", ClaimDetailCodes.class);
        List<ClaimDetailCodes> allTypes = query.getResultList();
        mapDiagnosticCodes =
            allTypes.stream()
                .filter(
                    c -> c.getCodePurpose().equals(ClaimDetailCodePurpose.DIAGNOSTIC.toString()))
                .collect(Collectors.toMap(ClaimDetailCodes::getCodeValue, Function.identity()));
        mapProcedureCodes =
            allTypes.stream()
                .filter(c -> c.getCodePurpose().equals(ClaimDetailCodePurpose.PROCEDURE.toString()))
                .collect(Collectors.toMap(ClaimDetailCodes::getCodeValue, Function.identity()));
      }
    } catch (Exception e) {
      log.error("Error initilazing ClaimDetailCodes", e);
    }
  }

  /**
   * Inits the service codes.
   *
   * @param forceQuery the force query
   */
  public void initServiceCodes(boolean forceQuery) {
    try {
      log.info("Initilazing ServiceCodes");

      if (mapServiceCodes == null || forceQuery) {
        TypedQuery<ClaimDetailCodes> query =
            em.createNamedQuery("ClaimDetailCodes.findAllService", ClaimDetailCodes.class);
        Stream<ClaimDetailCodes> allTypes = query.getResultStream();
        mapServiceCodes =
            allTypes.collect(Collectors.toMap(ClaimDetailCodes::getCodeValue, Function.identity()));
      }
    } catch (Exception e) {
      log.error("Error initilazing ServiceCodes", e);
    }
  }

  /**
   * Inits the highcost codes.
   *
   * @param forceQuery the force query
   */
  public void initHighcostCodes(boolean forceQuery) {
    try {
      log.info("Initilazing HighcostCodes");

      if (mapHighcostCodes == null || forceQuery) {
        TypedQuery<HighcostProcedureCodes> query =
            em.createNamedQuery("HighcostProcedureCodes.findAll", HighcostProcedureCodes.class);
        Stream<HighcostProcedureCodes> allTypes = query.getResultStream();
        mapHighcostCodes =
            allTypes.collect(
                Collectors.toMap(
                    HighcostProcedureCodes::getHighCostProcedureCode, Function.identity()));
      }
    } catch (Exception e) {
      log.error("Error initilazing HighcostProcedureCodes", e);
    }
  }

  private Map<String, HealthAuthorities> initHealthAuthorities(boolean forceQuery) {
    try {
      log.info("Initilazing HealthAuthorities");

      if (mapHealthAuthorities == null || forceQuery) {
        TypedQuery<HealthAuthorities> query =
            em.createNamedQuery("HealthAuthorities.findAll", HealthAuthorities.class);
        Stream<HealthAuthorities> allHealthAuthorities = query.getResultStream();
        mapHealthAuthorities =
            allHealthAuthorities.collect(
                Collectors.toMap(HealthAuthorities::getHaNumber, Function.identity()));
        healthAuthoritiesList =
            SelectItemHelper.buildSelectItemList(getHealthAuthorities(), "name", "haNumber");
      }

      return mapHealthAuthorities;
    } catch (Exception e) {
      log.error("Error initilazing HealthAuthorities", e);
      return null;
    }
  }

  /**
   * Gets the province.
   *
   * @param provinceId the province id
   * @return the province
   */
  public ProvincesTerritories getProvince(Long provinceId) {
    return mapProvinces.values().stream()
        .filter(p -> p.getId().equals(provinceId))
        .findFirst()
        .orElse(null);
  }

  /**
   * Gets the province.
   *
   * @param provinceCode the province code
   * @return the province
   */
  public ProvincesTerritories getProvince(String provinceCode) {
    return mapProvinces.get(provinceCode);
  }

  @Produces
  public List<ProvincesTerritories> getProvinces() {
    return new ArrayList<>(mapProvinces.values());
  }

  public List<ProvincesTerritories> getResidentProvinces() {
    Map<String, ProvincesTerritories> mapResidentProvinces = new HashMap<>();
    mapResidentProvinces.putAll(mapProvinces);
    mapResidentProvinces.remove("BC");
    return new ArrayList<>(mapResidentProvinces.values());
  }

  public List<ReasonInProvCodes> getReasonInProvCodes() {
    return new ArrayList<>(mapReasonInProvCodes.values());
  }

  /**
   * Gets the reason in prov codes.
   *
   * @param reasonCode the reason code
   * @return the reason in prov codes
   */
  public ReasonInProvCodes getReasonInProvCodes(String reasonCode) {
    return mapReasonInProvCodes.get(reasonCode);
  }

  /**
   * Gets the hospital.
   *
   * @param provinceCode the province code
   * @param hospitalNumber the hospital number
   * @return the hospital
   */
  public Hospitals getHospital(String provinceCode, String hospitalNumber) {
    return getHospital(new HospitalKey(provinceCode, hospitalNumber));
  }

  /**
   * Gets the hospital.
   *
   * @param key the key
   * @return the hospital
   */
  public Hospitals getHospital(HospitalKey key) {
    return mapHospitals.get(key);
  }

  /**
   * Return hospitals for a province. If province is null, return hospitals for all provinces.
   *
   * @param province provinceCode
   * @param healthAuthority the health authority
   * @return the hospitals
   */
  @SuppressWarnings("squid:S2293")
  public List<Hospitals> getHospitals(String province, String healthAuthority) {
    if (!StringUtils.isBlank(healthAuthority)) {
      return mapHospitals.values().stream()
          .filter(
              h ->
                  h.getHaId() != null
                      && StringUtils.equalsIgnoreCase(healthAuthority, h.getHaId().getHaNumber()))
          .collect(Collectors.toList());

    } else if (!StringUtils.isBlank(province)) {
      return mapHospitals.values().stream()
          .filter(h -> StringUtils.equalsIgnoreCase(province, h.getProvince()))
          .collect(Collectors.toList());

    } else {
      return new ArrayList<Hospitals>(mapHospitals.values());
    }
  }

  /**
   * TODO Javadoc, junits + exceptions.
   *
   * @param codeValue the code value
   * @return the diagnostic code
   */
  public ClaimDetailCodes getDiagnosticCode(String codeValue) {
    return mapDiagnosticCodes.get(codeValue);
  }

  /**
   * TODO Javadoc, junits + exceptions.
   *
   * @param codeValue the code value
   * @return the procedure code
   */
  public ClaimDetailCodes getProcedureCode(String codeValue) {
    return mapProcedureCodes.get(codeValue);
  }

  /**
   * Gets the highcost code.
   *
   * @param codeValue the code value
   * @return the highcost code
   */
  public HighcostProcedureCodes getHighcostCode(Short codeValue) {
    return mapHighcostCodes.get(codeValue);
  }

  /**
   * TODO Javadoc, junits + exceptions.
   *
   * @param codeValue the code value
   * @param codeType the code type
   * @param codePurpose the code purpose
   * @return the claim detail code
   */
  public ClaimDetailCodes getClaimDetailCode(
      String codeValue, String codeType, String codePurpose) {
    return getClaimDetailCode(
        codeValue,
        ClaimDetailCodeType.valueOf(codeType),
        ClaimDetailCodePurpose.valueOf(codePurpose));
  }

  /**
   * TODO Javadoc, junits + exceptions.
   *
   * @param codeValue the code value
   * @param codeType the code type
   * @param codePurpose the code purpose
   * @return the claim detail code
   */
  public ClaimDetailCodes getClaimDetailCode(
          String codeValue, ClaimDetailCodeType codeType, ClaimDetailCodePurpose codePurpose) {

    if (!StringUtils.isBlank(codeValue) && codeType != null && codePurpose != null) {
      if (codeType == ClaimDetailCodeType.SERVICE) {
        return mapServiceCodes.get(codeValue);
      } else if (codeType == ClaimDetailCodeType.ICD10
              && codePurpose == ClaimDetailCodePurpose.DIAGNOSTIC) {
        return mapDiagnosticCodes.get(codeValue);
      } else if (codeType == ClaimDetailCodeType.ICD10
              && codePurpose == ClaimDetailCodePurpose.PROCEDURE) {
        return mapProcedureCodes.get(codeValue);
      } else {
        // other cases: NEWBORN, ICD09, etc
        try {
          TypedQuery<ClaimDetailCodes> query;
          if (codePurpose.toString().equalsIgnoreCase("SERVICE")) {
            query = em.createNamedQuery("ClaimDetailCodes.findByCodeTypePurpose", ClaimDetailCodes.class)
                    .setParameter("codeValue", codeValue)
                    .setParameter("codeType", "SERVICE")
                    .setParameter("codePurpose", codePurpose.toString());
          } else {
            query = em.createNamedQuery("ClaimDetailCodes.findByCodeTypePurpose", ClaimDetailCodes.class)
                    .setParameter("codeValue", codeValue)
                    .setParameter("codeType", codeType.toString())
                    .setParameter("codePurpose", codePurpose.toString());
          }
          ClaimDetailCodes testingCode = query.getSingleResult();
          return testingCode;
          //return query.getSingleResult();
        } catch (NoResultException e) {
          // Do notting
        }
      }
    }
    return null;
  }

  /**
   * Gets the newborn code.
   *
   * @param codeValue the code value
   * @return the newborn code
   */
  public ClaimDetailCodes getNewbornCode(String codeValue) {
    return getClaimDetailCode(
        codeValue, ClaimDetailCodeType.NEWBORN, ClaimDetailCodePurpose.DIAGNOSTIC);
  }

  /**
   * Gets the service code.
   *
   * @param codeValue the code value
   * @return the service code
   */
  public ClaimDetailCodes getServiceCode(String codeValue) {
    return mapServiceCodes.get(codeValue);
  }

  /**
   * TODO Javadoc, junits + exceptions.
   *
   * @param codeValue the code value
   * @param context the context
   * @return the claim detail code
   */
  public ClaimDetailCodes getClaimDetailCode(String codeValue, ClaimContentContext context) {
    return getClaimDetailCode(
        codeValue, ClaimDetailCodeType.ICD10, ClaimDetailCodePurpose.valueOf(context.toString()));
  }

  /**
   * TODO Javadoc, junits + exceptions.
   *
   * @param codeValue the code value
   * @param codePurpose the code purpose
   * @return the claim detail code any scheme
   */
  public ClaimDetailCodes getClaimDetailCodeAnyScheme(
      String codeValue, ClaimDetailCodePurpose codePurpose) {
    // Try ICD10 first 
    ClaimDetailCodes ret = null;
    ClaimDetailCodes code10 = getClaimDetailCode(codeValue, ClaimDetailCodeType.ICD10, codePurpose);
    if (code10 != null) {
     ret = code10;
    } else {
      ret = getClaimDetailCode(codeValue, ClaimDetailCodeType.ICD09, codePurpose);
    }

    return ret;
  }

  /**
   * TODO Javadoc, junits + exceptions.
   *
   * @param codeValue the code value
   * @param codePurpose the code purpose
   * @return the claim detail codes
   */
  public List<ClaimDetailCodes> getClaimDetailCodes(
      String codeValue, ClaimDetailCodePurpose codePurpose) {
    if (!StringUtils.isBlank(codeValue) && codePurpose != null) {

      TypedQuery<ClaimDetailCodes> query =
          em.createNamedQuery("ClaimDetailCodes.findByCodePurpose", ClaimDetailCodes.class)
              .setParameter("codeValue", codeValue)
              .setParameter("codePurpose", codePurpose.toString());

      return query.getResultList();
    }
    // empty list if bad params (TODO: exceptions?)
    return new ArrayList<>();
  }

  public List<ClaimDetailCodes> getDiagnosticCodes() {
    return mapDiagnosticCodes.values().stream().collect(Collectors.toList());
  }

  public List<ClaimDetailCodes> getProcedureCodes() {
    return mapProcedureCodes.values().stream().collect(Collectors.toList());
  }

  public List<ClaimDetailCodes> getServiceCodes() {
    return mapServiceCodes.values().stream().collect(Collectors.toList());
  }

  public List<HighcostProcedureCodes> getHighcostCodes() {
    return mapHighcostCodes.values().stream().collect(Collectors.toList());
  }

  public List<HealthAuthorities> getHealthAuthorities() {
    return mapHealthAuthorities.values().stream().collect(Collectors.toList());
  }

  public List<ClaimStatusCodes> getStatusCodes() {
    return mapStatusCodes.values().stream().collect(Collectors.toList());
  }

  //BCMOHAD-10169-28Feb22: Removed loaded status code from claim search
  public List<ClaimStatusCodes> getResidentStatusCodes() {
    Map<String, ClaimStatusCodes> mapResidentStatusCodes = new HashMap<>();
    mapResidentStatusCodes.putAll(mapStatusCodes);
    mapResidentStatusCodes.remove("VALID");
    mapResidentStatusCodes.remove("INVALID");
    mapResidentStatusCodes.remove("LOADED");
    return mapResidentStatusCodes.values().stream().collect(Collectors.toList());
  }

  //BCMOHAD-10169-28Feb22: Removed loaded status code from claim search
  public List<ClaimStatusCodes> getNonResidentStatusCodes() {
    Map<String, ClaimStatusCodes> mapNonResidentStatusCodes = new HashMap<>();
    mapNonResidentStatusCodes.putAll(mapStatusCodes);
    mapNonResidentStatusCodes.remove("PENDING");
    mapNonResidentStatusCodes.remove("LOADED");
    return mapNonResidentStatusCodes.values().stream().collect(Collectors.toList());
  }

  /**
   * Gets the health authorities.
   *
   * @param ha the ha
   * @return the health authorities
   */
  public HealthAuthorities getHealthAuthorities(String ha) {
    return mapHealthAuthorities.get(ha);
  }

  /**
   * Gets the claim type.
   *
   * @param claimType the claim type
   * @return the claim type
   */
  public ClaimTypes getClaimType(String claimType) {
    return mapClaimTypes.get(claimType);
  }

  /**
   * Gets the by status code.
   *
   * @param statusCode the status code
   * @return the by status code
   */
  public ClaimStatusCodes getByStatusCode(String statusCode) {
    return mapStatusCodes.get(statusCode);
  }

  /**
   * Gets the residency type.
   *
   * @param typeCode the type code
   * @return the residency type
   */
  public ResidencyTypes getResidencyType(String typeCode) {
    return mapResidencyTypes.get(typeCode);
  }

  /**
   * TODO.
   *
   * @param provinceCode the province code
   * @param hospitalNumber the hospital number
   * @param hospitalName the hospital name
   * @return the hospitals
   */
  public Hospitals checkValidHospital(
      String provinceCode, String hospitalNumber, String hospitalName) {
    // TODO: DBUnit test this
    Hospitals hospitals;
    try {
      hospitals =
          em.createNamedQuery("Hospitals.checkValidHospital", Hospitals.class)
              .setParameter(PROVINCE_CODE, provinceCode)
              .setParameter("hospitalNumber", hospitalNumber)
              .setParameter("hospitalName", hospitalName)
              .getSingleResult();
    } catch (NoResultException nre) {
      // Not Found
      return null;
    } catch (Exception ex) {
      // TODO: Throw new HoopcException("Error in checkValidHospital", ex);
      log.error("Error in checkValidHospital", ex);
      return null;
    }
    return hospitals;
  }

  /**
   * TODO.
   *
   * @param provinceCode the province code
   * @param hospitalNumber the hospital number
   * @param serviceDate ServiceDate or DischargeDate
   * @return the per diem rate
   */
  public BigDecimal getPerDiemRate(
      String provinceCode, String hospitalNumber, LocalDate serviceDate) {

    // Get the hospital
    Hospitals hospital = getHospital(provinceCode, hospitalNumber);

    if (hospital == null) {
      return null;
    }

    // Find if a perdiem rate active for this date
    return hospital.getHospitalPerDiemRatesList().stream()
        .filter(p -> !serviceDate.isBefore(p.getEffectiveDate()))
        .filter(p -> p.getEndDate() == null || !serviceDate.isAfter(p.getEndDate()))
        .map(h -> h.getPerDiemRate())
        .findFirst()
        .orElse(null);
  }

  /**
   * TODO.
   *
   * @param detailCodeId the detail code id
   * @return the service rates
   * @throws HoopcException the hoopc exception
   */
  public List<ServiceRates> getServiceRates(Long detailCodeId) throws HoopcException {
    // TODO: DBUnit test this
    List<ServiceRates> rates = new ArrayList<>();
    try {
      rates =
          em.createNamedQuery("ServiceRates.getServiceRates", ServiceRates.class)
              .setParameter("cdcId", detailCodeId)
              .getResultList();
    } catch (Exception ex) {
      throw new HoopcException("Error in getServiceRates", ex);
    }
    return rates;
  }

  /**
   * TODO.
   *
   * @param serviceCode value
   * @param serviceDate the service date
   * @return the service rate
   */
  public BigDecimal getServiceRate(String serviceCode, LocalDate serviceDate) {
    // TODO: DBUnit test this
    BigDecimal rate;
    try {
      ClaimDetailCodes detailCode = getServiceCode(serviceCode);
      this.getClaimDetailCode(serviceCode, ClaimContentContext.SERVICE);
      if (detailCode == null) {
        return null;
      }
      rate =
          em.createNamedQuery("ServiceRates.getServiceRate", BigDecimal.class)
              .setParameter("cdcId", detailCode.getId())
              .setParameter("serviceDate", serviceDate)
              .getSingleResult();
    } catch (NoResultException nre) {
      // Not Found
      return null;
    } catch (Exception ex) {
      throw new HoopcRuntimeException("Error in getServiceRate", ex);
    }
    return rate;
  }

  /**
   * TODO.
   *
   * @param treatingProvince the treating province
   * @param hospitalNumber the hospital number
   * @return the hospital rates
   */
  public List<HospitalPerDiemRates> getHospitalRates(
      String treatingProvince, String hospitalNumber) {
    Hospitals hsp = getHospital(treatingProvince, hospitalNumber);
    if (hsp != null) {
      return hsp.getHospitalPerDiemRatesList();
    } else {
      return new ArrayList<>();
    }
  }

  /**
   * TODO: Move to ClaimService?.
   *
   * @param insuranceCardNumber the insurance card number
   * @param province the province
   * @param birthDate the birth date
   * @return the list
   */
  public List<HospitalOopClaims> findClaimsForPatient(
      String insuranceCardNumber, String province, LocalDate birthDate) {
    // TODO log.trace
    log.info("Calling ClaimService.findClaimsForPatient()");

    return em.createNamedQuery("HospitalOopClaims.findClaimsForPatient", HospitalOopClaims.class)
        .setParameter("insuranceCardNumber", insuranceCardNumber)
        .setParameter("province", province)
        .setParameter("birthDate", birthDate)
        .getResultList();
  }

  /**
   * Find highcost procedure by code.
   *
   * @param code the code
   * @return the highcost procedure codes
   */
  public HighcostProcedureCodes findHighcostProcedureByCode(Short code) {
    return this.mapHighcostCodes.get(code);
  }

  /**
   * Gets the health authorities by number.
   *
   * @param haNumber the ha number
   * @return the health authorities by number
   */
  public HealthAuthorities getHealthAuthoritiesByNumber(String haNumber) {
    return this.mapHealthAuthorities.get(haNumber);
  }

  public List<SelectItem> getProvincesList() {
    return provincesList;
  }

  public List<SelectItem> getProvincesAbreviationList() {
    return provincesAbreviationList;
  }

  public List<SelectItem> getReasonInBcList() {
    return reasonInBcList;
  }

  public List<SelectItem> getHealthAuthoritiesList() {
    return healthAuthoritiesList;
  }

  public List<SelectItem> getResidentProvincesList() {
    return residentProvincesList;
  }

  public List<SelectItem> getNresProvincesAbreviationList() {
    return nresProvincesAbreviationList;
  }

  public void setNresProvincesAbreviationList(List<SelectItem> nresProvincesAbreviationList) {
    this.nresProvincesAbreviationList = nresProvincesAbreviationList;
  }
  
  public boolean isValidProcedureForService(String pLevel, String pCode) {
    TypedQuery<ClaimProcedureLevel> query;
    try {
      query =
        em.createNamedQuery("ClaimProcedureLevel.findByPcode", ClaimProcedureLevel.class)
          .setParameter("pcode", pCode);
      if (query.getSingleResult().getPlevel().equals(pLevel)) {
        return true;
      } 
    } catch (NoResultException nre) {
      // Not Found
    } catch (Exception ex) {
      // TODO: Throw new HoopcException("Error in checkValidHospital", ex);
      log.error("Error in isValidProcedureForService", ex);
    }    
    return false;
  }

  public LocalDate getCutOffDateNewCodes() {
    LocalDate retval = LocalDate.parse("20210331", DateTimeFormatter.ofPattern("yyyyMMdd"));
    String dateCut = "";
    TypedQuery<ApplicationSettings> query;
    try {
      query
              = em.createNamedQuery("ApplicationSettings.findByParam", ApplicationSettings.class)
                      .setParameter("param", "LastDateBeforeNewCodes");

      dateCut = query.getSingleResult().getParamValue();

      retval = LocalDate.parse(dateCut, DateTimeFormatter.ofPattern("yyyyMMdd"));

    } catch (NoResultException nre) {
      // Not Found
      log.error("Error in getCutOffDateNewCodes, parameter not found in the database.", nre);
    } catch (Exception ex) {
      log.error("Error in getCutOffDateNewCodes", ex);
    }
    return retval;
  }



  /**
   * create on May 28, 2021 for validating the Insurance No field.
   * Use only in Import Claim
   * Validate and insuranceNumber for Province and Territories other than QC.
   *
   * @param provinceCode the province code
   * @param insuranceNumber the insurance number
   * @param sexCode the sex code
   * @return the int
   */
  public int checkPHN(String provinceCode, String insuranceNumber, String sexCode) {
    if (StringUtils.equalsIgnoreCase("QC", provinceCode)) {
      return checkXXPHN(provinceCode, insuranceNumber, sexCode);
    } else {
      return checkXXPHN(provinceCode, insuranceNumber, null);
    }
  }

  /**
   * Validate insuranceNumber for Province.
   *
   * @param provinceCode the province code
   * @param insuranceNumber Insurance number to validate
   * @param sexCode the sex code
   * @return PHN_ERROR_NONE, PHN_ERROR_FORMAT, PHN_ERROR_CHECKSUM
   * @throws HoopcRuntimeException the hoopc runtime exception
   */
  public int checkXXPHN(String provinceCode, String insuranceNumber, String sexCode) {
    /*
    There is a different stored procedure for each Province. They all use two
    parameters (one IN and one OUT), but Quebec uses three (two INs and one OUT).
    */
    String spName;
    spName =
            MessageFormat.format("'{' call HOOPC2_InsuranceNums2.Check{0}PHN(?, ?) '}'", provinceCode);
    if (provinceCode.equalsIgnoreCase("QC")) {
      spName =
              MessageFormat.format(
                      "'{' call HOOPC2_InsuranceNums2.checkqcphn(?, ?, ?) '}'", provinceCode);
    }

    /*
    Use the raw JDBC API here because EclipseLink 2.7.1 (Payara's JPA implementation)
    isn't closing the Statement used by jakarta.persistence.StoredProcedureQuery
    and the JPA API doesn't let us close it manually. This results in a Statement
    leak detectable by Payara's "statement leak detection" feature, which
    results in an "ORA-01000: maximum open cursors exceeded" error when
    processing lots of claims in a single transaction, for example when importing
    a big claims file on the ImportClaims.xhtml page.

    See also: https://github.com/eclipse-ee4j/jpa-api/issues/162
     */
    Connection connection = em.unwrap(Connection.class);
    try (CallableStatement callableStatement = connection.prepareCall(spName)) {
      callableStatement.setString("pv_insuranceNumber", insuranceNumber);
      callableStatement.registerOutParameter("pn_resultCode", java.sql.Types.INTEGER);
      if (!StringUtils.isBlank(sexCode)) {
        // Only Quebec uses this parameter.
        callableStatement.setString("pv_sexcode", sexCode);
      }
      callableStatement.execute();
      return callableStatement.getInt("pn_resultCode");
    } catch (Exception e) {
      //String errMsg = MessageFormat.format("Oracle error in {0}", spName);
      //throw new HoopcRuntimeException(errMsg, e);
      return 18;
    }
  }



}
