package ca.bc.gov.health.service;

import ca.bc.gov.health.constants.ClaimContentContext;
import ca.bc.gov.health.constants.ClaimStatus;
import ca.bc.gov.health.constants.ClaimType;
import ca.bc.gov.health.constants.GlobalConstants;
import static ca.bc.gov.health.constants.GlobalConstants.CLAIM_ADJ_DEC_TYPE;
import static ca.bc.gov.health.constants.GlobalConstants.CLAIM_ADJ_REQ_TYPE;
import static ca.bc.gov.health.constants.GlobalConstants.CLAIM_NOT_EDITABLE;
import static ca.bc.gov.health.constants.GlobalConstants.RESIDENT_PROVINCE;
import ca.bc.gov.health.database.entity.AdjustmentReasons;
import ca.bc.gov.health.database.entity.ClaimAdjustments;
import ca.bc.gov.health.database.entity.ClaimContents;
import ca.bc.gov.health.database.entity.ClaimDetailCodes;
import ca.bc.gov.health.database.entity.ClaimErrors;
import ca.bc.gov.health.database.entity.ClaimTypes;
import ca.bc.gov.health.database.entity.HighcostProcedureCodes;
import ca.bc.gov.health.database.entity.HighcostProcedurePerformed;
import ca.bc.gov.health.database.entity.HospitalOopClaims;
import ca.bc.gov.health.database.entity.ResidencyTypes;
import ca.bc.gov.health.exception.HoopcException;
import ca.bc.gov.health.service.viewmodel.ClaimViewModel;
import ca.bc.gov.health.service.viewmodel.HighcostViewModel;
import ca.bc.gov.health.transformer.ClaimModelTransformer;
import ca.bc.gov.health.validation.ValidationError;
import ca.bc.gov.health.validation.Validator;
import ca.bc.gov.health.validation.claim.ClaimValidatorFactory;
import jakarta.ejb.Local;
import jakarta.ejb.LocalBean;
import jakarta.ejb.Stateless;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import jakarta.validation.ConstraintViolationException;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import org.apache.commons.lang3.NotImplementedException;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Class ClaimService. */
/** @author christian.hudon */
@Stateless
@Local(ClaimServiceLocal.class)
@LocalBean
public class ClaimService implements ClaimServiceLocal, Serializable {

  private static final long serialVersionUID = 1535499494327229908L;

  private static Logger log = LoggerFactory.getLogger(ClaimService.class);

  @Inject private transient HoopcAppService appService;

  @Inject private transient ClaimEligibilityService eligiblityService;

  @Inject private transient ClaimModelTransformer claimModelTransformer;

  @Inject private transient ClaimSearchBuilder searchBuilder;

  @Inject private transient ClaimValidatorFactory validatorFactory;

  @Inject private transient ClaimServiceDao serviceDao;

  @Inject private transient ClaimPreProcessor preProcessor;

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#createClaim(ca.bc.gov.health.service.viewmodel.
   * ClaimViewModel)
   */
  @Override
  @Transactional
  public Long createClaim(ClaimViewModel claimView) throws HoopcException {
    try {
      log.trace("Calling ClaimService.createClaim()");

      HospitalOopClaims newClaim = new HospitalOopClaims();
      List<ValidationError> validationErrors = new ArrayList<>();

      // TODO more of this claim data manipulation logic should be moved into a pre-processor
      // This could maybe also include some of the data manipulation in the saveCode and
      // saveContents methods
      if (ClaimType.INPATIENT.toString().equals(claimView.getClaimType().getClaimType())) {
        claimView.setServiceDate(claimView.getAdmission().getAdmissionDate());
        preProcessor.updateHighCostRate(claimView);
      }

      if (claimView.getResidencyType().getTypeCode().equals(GlobalConstants.NRES_RESIDENCY_TYPE)) {
        claimView.setReceivingProvince(claimView.getPatient().getProvince());
      } else if (claimView
          .getResidencyType()
          .getTypeCode()
          .equals(GlobalConstants.RES_RESIDENCY_TYPE)) {
        claimView.setReceivingProvince(RESIDENT_PROVINCE);
        // Do the E45 and GetDemo to validate Eligiblity and Demographcis
        validationErrors.addAll(
            eligiblityService.validateClaimEligiblityAndDemographics(claimView));
      }

      if (claimView.getSubmissionDate() == null) {
        claimView.setSubmissionDate(LocalDate.now());
      }
      claimModelTransformer.claimViewToEntity(claimView, newClaim);
      newClaim.setSubmissionDate(LocalDate.now());

      saveServiceCode(claimView, newClaim);
      saveAccidentCode(claimView, newClaim);
      saveClaimContents(ClaimContentContext.DIAGNOSTIC, claimView.getDiagnosisCodes(), newClaim);
      saveClaimContents(ClaimContentContext.PROCEDURE, claimView.getProcedureCodes(), newClaim);
      saveHighcostCode(claimView.getHighCostProcedures(), newClaim);

      // Create the claim
      claimView.setClaimId(serviceDao.addClaim(newClaim));

      // validationRules
      Validator<ClaimViewModel> validator =
          validatorFactory.createInsertValidator(
              claimView.getClaimType().getClaimType(), claimView.getResidencyType().getTypeCode());
      validationErrors.addAll(validator.validate(claimView));
      saveValidationErrors(validationErrors, newClaim);

      // Post-validation rules
      setReviewClaim(newClaim);
      setStatusValidInvalid(newClaim);

      // Calls a JPA flush to catch oracle exceptions before exiting the @Transactional method
      serviceDao.save(newClaim);

      return claimView.getClaimId();

    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.createClaim()", e);
    }
  }

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#loadClaim(java.lang.Long)
   */
  @Override
  @Transactional
  public ClaimViewModel loadClaim(Long claimId) throws HoopcException {
    try {
      log.trace("Calling ClaimService.loadClaim({})", claimId);

      serviceDao.flushCache();
      HospitalOopClaims claim = serviceDao.findByClaimId(claimId);

      if (claim == null) {
        log.error("Claim {} not found", claimId);
        return null;
      }

      ClaimViewModel claimView = claimModelTransformer.claimEntityToView(claim);

      log.trace("Claim {} loaded", claim.getId());
      return claimView;

    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.loadClaim()", e);
    }
  }
  //BCMOHAD-9622-24Feb22: checks whether override status and reason is edited.
  public boolean checkDataEditedForOverrides(ClaimViewModel claimView, HospitalOopClaims claim) {
      String originalStatus = claim.getClaimOverrides().getOverrideStatus();
      String newStatus = claimView.getClaimOverride().getOverrideStatus();
      String originalStatusReason = claim.getClaimOverrides().getOverrideStatusReason();
      String newStatusReason = claimView.getClaimOverride().getOverrideStatusReason();
      
      if (isEqual(originalStatus, newStatus) && isEqual(originalStatusReason, newStatusReason)) {
          return false;
      } else {
          return true;
      }
    }

    private static boolean isEqual(String string1, String string2) {
        if (StringUtils.isBlank(string1) && StringUtils.isBlank(string2)) {
            return true;
        }
        return string1 != null && string1.equals(string2);
    }

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#saveClaim(ca.bc.gov.health.service.viewmodel.
   * ClaimViewModel)
   */
  @Override
  @Transactional
  public void saveClaim(ClaimViewModel claimView) throws HoopcException {
    try {
      log.trace("Calling ClaimService.saveClaim({})", claimView.getClaimId());

      HospitalOopClaims claim = serviceDao.findByClaimId(claimView.getClaimId());

      List<ValidationError> validationErrors = new ArrayList<>();

      if (claim != null) {
          //BCMOHAD-9622-24Feb22: removes the overrides if claim gets edited after approving the override status.   
          if (claim.getClaimOverrides() != null && !checkDataEditedForOverrides(claimView, claim)) {
          serviceDao.remove(claim.getClaimOverrides());
              //BCMOHAD-10404-11Mar22: clearing the Override status.
              claimView.getClaimOverride().setOverrideStatus(null);
        }

        if (claimView
            .getResidencyType()
            .getTypeCode()
            .equals(GlobalConstants.NRES_RESIDENCY_TYPE)) {
          claimView.setReceivingProvince(claimView.getPatient().getProvince());
        } else if (claimView
            .getResidencyType()
            .getTypeCode()
            .equals(GlobalConstants.RES_RESIDENCY_TYPE)) {
          // Do the E45 and GetDemo to validate Eligiblity and Demographcis
          claimView.setReceivingProvince(RESIDENT_PROVINCE);
          validationErrors.addAll(
              eligiblityService.validateClaimEligiblityAndDemographics(claimView));
        }

        claimModelTransformer.claimViewToEntity(claimView, claim);

        saveServiceCode(claimView, claim);
        saveAccidentCode(claimView, claim);
        saveClaimContents(ClaimContentContext.DIAGNOSTIC, claimView.getDiagnosisCodes(), claim);
        saveClaimContents(ClaimContentContext.PROCEDURE, claimView.getProcedureCodes(), claim);
        saveHighcostCode(claimView.getHighCostProcedures(), claim);

        log.trace("Claim {} validating", claim.getId());
        // validationRules
        Validator<ClaimViewModel> validator =
            validatorFactory.createEditValidator(
                claimView.getClaimType().getClaimType(),
                claimView.getResidencyType().getTypeCode());
        validationErrors.addAll(validator.validate(claimView));
        saveValidationErrors(validationErrors, claim);

        // Post-validation rules
        setReviewClaim(claim);
        setStatusValidInvalid(claim);

        // Calls a JPA flush to catch oracle exceptions before exiting the @Transactional method
        serviceDao.save(claim);

        log.trace("Claim {} saved", claim.getId());
      }
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.saveClaim()", e);
    }
  }

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#deleteClaim(java.lang.Long)
   */
  @Override
  @Transactional
  public void deleteClaim(Long claimId) throws HoopcException {
    try {
      log.trace("Calling ClaimService.deleteClaim({})", claimId);

      HospitalOopClaims claim = serviceDao.findByClaimId(claimId);

      if (claim != null) {
        // delete claim errors
        clearValidationErrors(claim);
        // delete cliam
        serviceDao.remove(claim);

        log.trace("Claim {} deleted", claimId);
      }
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.deleteClaim()", e);
    }
  }

  /*
   * (non-Javadoc)
   *
   * @see
   * ca.bc.gov.health.service.ClaimServiceLocal#saveClaimRequest(ca.bc.gov.health.service.viewmodel.
   * ClaimViewModel)
   */
  @Override
  @Transactional
  public void saveClaimRequest(ClaimViewModel claimView) throws HoopcException {
    try {
      log.trace("Calling ClaimService.saveClaimRequest({})", claimView.getClaimId());

      saveClaimAdjustments(claimView, GlobalConstants.CLAIM_ADJ_REQ_TYPE);

      log.trace("Claim Request {} saved", claimView.getClaimId());
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.saveClaimRequest()", e);
    }
  }

  /*
   * (non-Javadoc)
   *
   * @see
   * ca.bc.gov.health.service.ClaimServiceLocal#saveClaimDecision(ca.bc.gov.health.service.viewmodel
   * .ClaimViewModel)
   */
  @Override
  @Transactional
  public void saveClaimDecision(ClaimViewModel claimView) throws HoopcException {
    try {
      log.trace("Calling ClaimService.saveClaimDecision({})", claimView.getClaimId());

      saveClaimAdjustments(claimView, GlobalConstants.CLAIM_ADJ_DEC_TYPE);

      log.trace("Claim Decision {} saved", claimView.getClaimId());
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.saveClaimDecision()", e);
    }
  }

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#deleteClaimRequest(java.lang.Long)
   */
  @Override
  @Transactional
  public void deleteClaimRequest(Long claimId) throws HoopcException {
    try {
      log.trace("Calling ClaimService.deleteClaimRequest({})", claimId);

      deleteClaimAdjustment(claimId, GlobalConstants.CLAIM_ADJ_REQ_TYPE);

      log.trace("Claim Request {} deleted", claimId);
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.deleteClaimRequest()", e);
    }
  }

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#deleteClaimDecision(java.lang.Long)
   */
  @Override
  @Transactional
  public void deleteClaimDecision(Long claimId) throws HoopcException {
    try {
      log.trace("Calling ClaimService.deleteClaimDecision({})", claimId);

      deleteClaimAdjustment(claimId, GlobalConstants.CLAIM_ADJ_DEC_TYPE);

      log.trace("Claim Decision {} deleted", claimId);
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.deleteClaimDecision()", e);
    }
  }

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#claimHasDecision(java.lang.Long)
   */
  @Override
  public boolean claimHasDecision(Long claimId) throws HoopcException {
    try {
      if (claimId != null) {
        HospitalOopClaims claim = serviceDao.findByClaimId(claimId);

        if (claim != null) {
          return claim.getClaimAdjustmentsList().stream()
              .anyMatch(a -> a.getAdjustmentType().equals(CLAIM_ADJ_DEC_TYPE));
        }
      }
      return false;
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.claimHasDecision()", e);
    }
  }

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#claimHasRequest(java.lang.Long)
   */
  @Override
  public boolean claimHasRequest(Long claimId) throws HoopcException {
    try {
      if (claimId != null) {
        HospitalOopClaims claim = serviceDao.findByClaimId(claimId);

        if (claim != null) {
          return claim.getClaimAdjustmentsList().stream()
              .anyMatch(a -> a.getAdjustmentType().equals(CLAIM_ADJ_REQ_TYPE));
        }
      }
      return false;
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.claimHasRequest()", e);
    }
  }

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#claimIsEditable(java.lang.Long)
   */
  @Override
  public boolean claimIsEditable(Long claimId) throws HoopcException {
    try {
      HospitalOopClaims claim = serviceDao.findByClaimId(claimId);

      return !claim.getCsId().getStatusCode().equals(CLAIM_NOT_EDITABLE);
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.claimIsEditable()", e);
    }
  }

  /**
   * SETREVIEWCLAIM: Called after all validations on resident claims are complete. Sets or clears
   * the claim to be reviewed flag depending on whether there are errors logged against the claim.
   * <br>
   *
   * @param HospitalOopClaims claim
   */
  public void setReviewClaim(HospitalOopClaims claim) {
    if (claim == null
        || claim.getRtsId() == null
        || !claim.getRtsId().getTypeCode().equals(GlobalConstants.RES_RESIDENCY_TYPE)) {
      return;
    }
    if (claim.getClaimErrorsList().isEmpty()) {
      claim.setClaimToBeReviewedInd("N");
    } else {
      claim.setClaimToBeReviewedInd("Y");
    }
  }

  
  /**
   * SETSTATUSVALIDINVALID: Called after all validations on non-resident claims are complete. Sets
   * the claim status to VALID or INVALID depending on whether there are errors logged against the
   * claim.<br>
   * BCMOHAD-9622-15Feb22: Setting the claim status as per the override status options.
   * @param HospitalOopClaims claim
   */
public void setStatusValidInvalid(HospitalOopClaims claim) {
    if (claim == null || claim.getRtsId() == null || claim.getClaimErrorsList() == null) {
      return;
    }
    if (claim.getRtsId().getTypeCode().equals(GlobalConstants.NRES_RESIDENCY_TYPE)) {
      if (!claim.getClaimErrorsList().isEmpty()) {
        if (claim.getClaimOverrides() != null
            && claim.getClaimOverrides().getOverrideRequest() != null
                    && claim.getClaimOverrides().getOverrideRequest().equals("Y")) {
                if (claim.getClaimOverrides().getOverrideStatus() != null
                        && claim.getClaimOverrides().getOverrideStatus().equals("APPROVED")
                        && !claim.getClaimOverrides().getOverrideStatusReason().isEmpty()) {
          claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_VALID));
        } else {
          claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_INVALID));
        }
      } else {
                claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_INVALID));
            }
        } else {

            if (claim.getClaimOverrides() != null
                    && claim.getClaimOverrides().getOverrideRequest() != null
                    && claim.getClaimOverrides().getOverrideRequest().equals("Y")) {
                claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_VALID));
                if (claim.getClaimOverrides().getOverrideStatus() != null
                        && claim.getClaimOverrides().getOverrideStatus().equals("DENIED")
                        && !claim.getClaimOverrides().getOverrideStatusReason().isEmpty()) {
                    claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_INVALID));
                } else if (claim.getClaimOverrides().getOverrideStatus() != null
                        && claim.getClaimOverrides().getOverrideStatus().equals("APPROVED")
                        && !claim.getClaimOverrides().getOverrideStatusReason().isEmpty()) {
                    claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_VALID));
                }
            } else {
        claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_VALID));
      }
    }
  }
}

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#getResidencyType(java.lang.String)
   */
  public ResidencyTypes getResidencyType(String residencyType) {
    return appService.getResidencyType(residencyType);
  }

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#getClaimType(java.lang.String)
   */
  public ClaimTypes getClaimType(String claimType) {
    return appService.getClaimType(claimType);
  }

  /*
   * (non-Javadoc)
   *
   * @see ca.bc.gov.health.service.ClaimServiceLocal#getClaimErrors(java.lang.Long)
   */
  public List<String> getClaimErrors(Long claimid) {
    List<ClaimErrors> claimerrors = serviceDao.getClaimErrors(claimid);
    return claimModelTransformer.claimErrorsToList(claimerrors);
  }

  public Long selectCountByCriteria(ClaimViewModel claimCriteria) throws HoopcException {
    try {
      log.trace("Calling ClaimService.searchByCriteria()");
      Long totalRowCount = 0L;
      totalRowCount = serviceDao.runCountQuery(searchBuilder.buildCountSearchQuery(claimCriteria));
      return totalRowCount;
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.searchByCriteria()", e);
    }
  }

  /*
   * (non-Javadoc)
   *
   * @see
   * ca.bc.gov.health.service.ClaimServiceLocal#searchByCriteria(ca.bc.gov.health.service.viewmodel.
   * ClaimViewModel)
   */
  @Override
  public List<HospitalOopClaims> searchByCriteria(
      ClaimViewModel claimCriteria,
      int firstResult,
      int maxResult,
      String sortField,
      String sortOrder)
      throws HoopcException {
    try {
      log.trace("Calling ClaimService.searchByCriteria()");

      return serviceDao.runQuery(
          searchBuilder.buildSearchQuery(claimCriteria, sortField, sortOrder),
          firstResult,
          maxResult);
    } catch (Exception e) {
      throw createHoopcException("Error in ClaimService.searchByCriteria()", e);
    }
  }

  /**
   * Update the ClaimContents list.
   *
   * @param context the context
   * @param claimContents the claim contents
   * @param claim the claim
   */
  @SuppressWarnings("squid:S3776")
  protected void saveClaimContents(
      ClaimContentContext context, String[] claimContents, HospitalOopClaims claim) {
    List<ClaimContents> entities = contentsToList(claim, context);

    //BCMOHAM-9608 - Ordering the codes to correct the occasional error placing codes in the second or third field.
    if (claimContents.length > 1 && claimContents[0] == "") {
      if (!claimContents[1].equalsIgnoreCase("")){
        claimContents[0] = claimContents[1];
        claimContents[1] = "";
      } else if (!claimContents[2].equalsIgnoreCase("")){
        claimContents[0] = claimContents[2];
        claimContents[2] = "";
      }
    }
    
    for (int i = 0; i < claimContents.length; i++) {
      ClaimContents contentEntity = entities.size() > i ? entities.get(i) : null;
      String viewContent = claimContents[i];

      if (contentEntity == null) {
        if (!StringUtils.isBlank(viewContent)) {
          // No content + code -> New content
          ClaimDetailCodes cdc = appService.getClaimDetailCode(viewContent, context);
          if (cdc != null) {
            // TODO: cdc not found?
            addContent(context, cdc, claim);
          }
        } else {
          // No contentId + No codeId -> Nothing to do
        }
      } else {
        if (StringUtils.isBlank(viewContent)) {
          // content + No code -> Delete content
          claim.getClaimContentsList().remove(contentEntity);
          serviceDao.remove(contentEntity);
        } else if (!contentEntity.getCdcId().getCodeValue().equals(viewContent)) {
          // content + code -> Edit the code (if different)
          ClaimDetailCodes cdc = appService.getClaimDetailCode(viewContent, context);
          if (cdc != null) {
            contentEntity.setCdcId(cdc);
          } else {
            // Invalid Code, Do nothing (like Hoopc V1)
          }
        }
      }
    }
  }

  /**
   * Contents to list.
   *
   * @param claim the claim
   * @param context the context
   * @return the list
   */
  // TODO: move to util
  protected List<ClaimContents> contentsToList(
      HospitalOopClaims claim, ClaimContentContext context) {
    return claim.getClaimContentsList().stream()
        .filter(c -> c.getContext().equals(context.toString()))
        .sorted((c1, c2) -> c1.getSequenceNum().compareTo(c2.getSequenceNum()))
        .collect(Collectors.toList());
  }

  /**
   * Adds the content.
   *
   * @param context the context
   * @param cdc the cdc
   * @param claim the claim
   * @return the claim contents
   */
  protected ClaimContents addContent(
      ClaimContentContext context, ClaimDetailCodes cdc, HospitalOopClaims claim) {
    ClaimContents newContent = new ClaimContents(cdc, claim);
    newContent.setContext(context.toString());
    newContent.setSequenceNum(nextSeq(claim.getClaimContentsList()));
    // TODO: Not sure if always equals
    newContent.setCodeType(cdc.getCodeType());
    claim.getClaimContentsList().add(newContent);
    serviceDao.add(newContent);
    return newContent;
  }

  @SuppressWarnings("squid:S3776")
  private void saveHighcostCode(HighcostViewModel[] highCostProcedures, HospitalOopClaims claim) {
    for (HighcostViewModel viewContent : highCostProcedures) {
      if (viewContent.getId() == null) {
        if (!StringUtils.isBlank(viewContent.getCodeValue())) {
          // No contentId + codeId -> New content
          HighcostProcedureCodes code =
              appService.getHighcostCode(Short.valueOf(viewContent.getCodeValue()));
          if (code != null) {
            // TODO: code not found?
            HighcostProcedurePerformed newContent = new HighcostProcedurePerformed();
            newContent.setSequenceNum(nextSeqHighcost(claim.getHighcostProcedurePerformedList()));
            newContent.setProcedureCost(viewContent.getProcedureCost());
            newContent.setProcedureDate(viewContent.getProcedureDate());
            newContent.setHocId(claim);
            newContent.setHcppId(code);
            claim.getHighcostProcedurePerformedList().add(newContent);
            serviceDao.add(newContent);
          }
        } else {
          // No contentId + No codeId -> Nothing to do
        }
      } else {
        HighcostProcedurePerformed highcostEntity =
            claim.getHighcostProcedurePerformedList().stream()
                .filter(c -> c.getId().equals(viewContent.getId()))
                .findFirst()
                .orElse(null);
        if (StringUtils.isBlank(viewContent.getCodeValue())) {
          // contentId + No codeId -> Delete content
          claim.getHighcostProcedurePerformedList().remove(highcostEntity);
          serviceDao.remove(highcostEntity);
        } else if (highcostEntity != null && highcostEntity.getHcppId() != null) {
          // contentId + codeId -> Edit the code (if different)
          HighcostProcedureCodes code =
              appService.getHighcostCode(Short.valueOf(viewContent.getCodeValue()));
          highcostEntity.setHcppId(code);
          highcostEntity.setProcedureCost(viewContent.getProcedureCost());
          highcostEntity.setProcedureDate(viewContent.getProcedureDate());
        }
      }
    }
  }

  /**
   * Next seq highcost.
   *
   * @param list the list
   * @return the long
   */
  // TOOD Utils?
  protected Long nextSeqHighcost(List<HighcostProcedurePerformed> list) {
    Long ret = 1l;
    if (list != null && !list.isEmpty()) {
      ret = list.stream().mapToLong(c -> c.getSequenceNum()).max().getAsLong() + 1;
    }
    return ret;
  }

  /**
   * Next seq.
   *
   * @param claimContentsList the claim contents list
   * @return the long
   */
  // TOOD Utils?
  protected Long nextSeq(List<ClaimContents> claimContentsList) {
    Long ret = 1l;
    if (claimContentsList != null && !claimContentsList.isEmpty()) {
      ret = claimContentsList.stream().mapToLong(c -> c.getSequenceNum()).max().getAsLong() + 1;
    }
    return ret;
  }

  /**
   * Save claim adjustments.
   *
   * @param claimView the claim view
   * @param adjType the adj type
   */
  protected void saveClaimAdjustments(ClaimViewModel claimView, String adjType) {

    HospitalOopClaims claim = serviceDao.findByClaimId(claimView.getClaimId());

    // Check if add or edit
    ClaimAdjustments adjustment = getClaimAdjustment(claim, adjType);

    if (adjustment == null) {
      // No current request, add it
      ClaimAdjustments newAdjustment = createNewAdjustment(claimView, adjType);

      claim.getClaimAdjustmentsList().add(newAdjustment);
      serviceDao.add(newAdjustment);

      if (claim.getRtsId().getTypeCode().equals("NRES")) {
        if (GlobalConstants.CLAIM_ADJ_REQ_TYPE.equals(adjType)) {
          claim.setCsId(appService.getByStatusCode("ADJUST REQ"));
        } else {
          claim.setCsId(appService.getByStatusCode("ADJUST APP"));
        }
      }

      // set claim status when adding decision
      if (GlobalConstants.CLAIM_ADJ_DEC_TYPE.equals(adjType)) {
        if (newAdjustment.getAdjustmentStatus().equals(GlobalConstants.CLAIM_ADJ_DEC_APP)) {
          claim.setCsId(appService.getByStatusCode("ADJUST APP"));
        } else if (newAdjustment.getAdjustmentStatus().equals(GlobalConstants.CLAIM_ADJ_DEC_DEN)) {
          claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_NOT_EDITABLE));
        }
      }
    } else {
      //BCMOHAD-9593-10Feb22: Passing claim object to set the claim status 
      updateAdjustmentRequest(claimView, claim, adjustment, adjType);
      
    }
  }

  /**
   * Update adjustment request.
   *
   * @param claimView the claim view
   * @param adjustment the adjustment
   * @param adjType the adj type
   */
  @SuppressWarnings("squid:S5413")
  protected void updateAdjustmentRequest(
      ClaimViewModel claimView, HospitalOopClaims claim, ClaimAdjustments adjustment, String adjType) {

    ClaimAdjustments adjustmentView =
        (GlobalConstants.CLAIM_ADJ_REQ_TYPE.equals(adjType)
            ? claimView.getClaimAdjustmentsRequest()
            : claimView.getClaimAdjustmentsDecision());

    adjustment.setAdjustmentDate(adjustmentView.getAdjustmentDate());
    adjustment.setAdjustmentStatus(adjustmentView.getAdjustmentStatus());

    //BCMOHAD-9593-10Feb22: updating adjustment request source
    adjustment.setSource(adjustmentView.getSource());
    
    //BCMOHAD-9593-10Feb22: flipping the claim status as per edited adjustment decision status
    if (GlobalConstants.CLAIM_ADJ_DEC_TYPE.equals(adjType)) {
      if (adjustment.getAdjustmentStatus().equals(GlobalConstants.CLAIM_ADJ_DEC_APP)) {
        claim.setCsId(appService.getByStatusCode("ADJUST APP"));
      } else if (adjustment.getAdjustmentStatus().equals(GlobalConstants.CLAIM_ADJ_DEC_DEN)) {
        claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_NOT_EDITABLE));
      }
    } 
    
    AdjustmentReasons[] viewReasons =
        (GlobalConstants.CLAIM_ADJ_REQ_TYPE.equals(adjType)
            ? claimView.getAdjRequestReasons()
            : claimView.getAdjDecisionReasons());

    for (int i = 0; i < viewReasons.length; i++) {
      // Get the reason from the view
      AdjustmentReasons viewreason = viewReasons[i];
      boolean emptyReason = StringUtils.isBlank(viewreason.getFreeFormReason());

      // Find corresponding reason objet from entity
      // Order by sequence
      List<AdjustmentReasons> sorted =
          adjustment.getAdjustmentReasonsList().stream()
              .sorted(Comparator.comparing(AdjustmentReasons::getSequenceNum))
              .collect(Collectors.toList());
      AdjustmentReasons datareason = sorted.size() > i ? sorted.get(i) : null;

      // check if exists or not (return null or the list index if exists
      boolean reasonExists = datareason != null;

      // if reason exist && viewValue : update reason
      if (reasonExists && !emptyReason) {
        datareason.setFreeFormReason(viewreason.getFreeFormReason());
        // if reason exist && !viewValue : delete reason
      } else if (reasonExists && emptyReason) {
        serviceDao.remove(datareason);
        adjustment.getAdjustmentReasonsList().remove(i);
        // if !reason exist && viewValue : add reason
      } else if (!reasonExists && !emptyReason) {
        adjustment.getAdjustmentReasonsList().add(viewreason);
        viewreason.setCajId(adjustment);
      }
    }
  }

  /**
   * Creates the new adjustment.
   *
   * @param claimView the claim view
   * @param adjType the adj type
   * @return the claim adjustments
   */
  protected ClaimAdjustments createNewAdjustment(ClaimViewModel claimView, String adjType) {
    ClaimAdjustments newRequest = new ClaimAdjustments();

    // get request
    ClaimAdjustments adjus =
        (GlobalConstants.CLAIM_ADJ_REQ_TYPE.equals(adjType)
            ? claimView.getClaimAdjustmentsRequest()
            : claimView.getClaimAdjustmentsDecision());

    // get reasons
    AdjustmentReasons[] reasons =
        (GlobalConstants.CLAIM_ADJ_REQ_TYPE.equals(adjType)
            ? claimView.getAdjRequestReasons()
            : claimView.getAdjDecisionReasons());

    if (GlobalConstants.CLAIM_ADJ_REQ_TYPE.equals(adjType)) {
      if (StringUtils.isBlank(adjus.getAdjustmentStatus())) {
        adjus.setAdjustmentStatus(GlobalConstants.CLAIM_ADJ_REQ_TYPE_REQUIRED);
      }
    }

    // TODO create method in transformer
    newRequest.setHocId(new HospitalOopClaims(claimView.getClaimId()));
    newRequest.setAmount(adjus.getAmount());
    newRequest.setSource(adjus.getSource());
    newRequest.setAdjustmentDate(adjus.getAdjustmentDate());
    newRequest.setAdjustmentStatus(adjus.getAdjustmentStatus());
    newRequest.setAdjustmentType(adjType);

    // TODO Should be strings in viewmodel
    for (AdjustmentReasons reason : reasons) {
      if (reason != null && !StringUtils.isBlank(reason.getFreeFormReason())) {
        newRequest.getAdjustmentReasonsList().add(reason);
        reason.setCajId(newRequest);
      }
    }

    return newRequest;
  }

  /**
   * Delete claim adjustment.
   *
   * @param claimId the claim id
   * @param adjType the adj type
   */
  protected void deleteClaimAdjustment(Long claimId, String adjType) {
    HospitalOopClaims claim = serviceDao.findByClaimId(claimId);

    if (claim != null) {
      ClaimAdjustments adj = getClaimAdjustment(claim, adjType);
      if (adj != null) {

        if (claim.getRtsId().getTypeCode().equals(GlobalConstants.NRES_RESIDENCY_TYPE)) {
          if (GlobalConstants.CLAIM_ADJ_REQ_TYPE.equals(adjType)) {
            // We can do this because we know that for NonRes adjustments can only be created on
            // claims that have been processed
            claim.setCsId(appService.getByStatusCode(ClaimStatus.PROCESSED.toString()));
          } else {
            claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_AJUST_REQ));
          }
        }

        // set status on decision delete
        if (GlobalConstants.CLAIM_ADJ_DEC_TYPE.equals(adjType)) {
          setStatusOnDecisionDelete(claim);
        }

        claim.getClaimAdjustmentsList().remove(adj);
        serviceDao.remove(adj);
      }
    }
  }

  private void setStatusOnDecisionDelete(HospitalOopClaims claim) {
    ClaimAdjustments adjReq = getClaimAdjustment(claim, GlobalConstants.CLAIM_ADJ_REQ_TYPE);
    if (adjReq != null) {
      if (claim.getRtsId().getTypeCode().equals(GlobalConstants.NRES_RESIDENCY_TYPE)) {
        adjReq.setAdjustmentStatus(GlobalConstants.CLAIM_ADJ_REQ_TYPE_REQUIRED);
      } else if (claim.getRtsId().getTypeCode().equals(GlobalConstants.RES_RESIDENCY_TYPE)) {
        if (adjReq.getIbpId() != null) {
          adjReq.setAdjustmentStatus(GlobalConstants.CLAIM_ADJ_REQ_TYPE_REQUESTED);
          claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_AJUST_REQ));
        } else {
          claim.setCsId(appService.getByStatusCode(GlobalConstants.CLAIM_NOT_EDITABLE));
        }
      }
    } else {
      claim.setCsId(appService.getByStatusCode(ClaimStatus.PROCESSED.toString()));
    }
  }

  /**
   * Gets the claim adjustment.
   *
   * @param claim the claim
   * @param adjType the adj type
   * @return the claim adjustment
   */
  protected ClaimAdjustments getClaimAdjustment(HospitalOopClaims claim, String adjType) {
    if (claim.getClaimAdjustmentsList() != null && !claim.getClaimAdjustmentsList().isEmpty()) {
      return claim.getClaimAdjustmentsList().stream()
          .filter(c -> c.getAdjustmentType().equals(adjType))
          .findFirst()
          .orElse(null);
    }
    return null;
  }

  /**
   * Save service code.
   *
   * @param claimView the claim view
   * @param claim the claim
   */
  protected void saveServiceCode(ClaimViewModel claimView, HospitalOopClaims claim) {
    // Find service code
    ClaimDetailCodes serviceCode = appService.getServiceCode(claimView.getServiceCodeValue());

    // Find if existing ClaimContents
    ClaimContents contentEntity =
        claim.getClaimContentsList().stream()
            .filter(c -> ClaimContentContext.SERVICE.toString().equals(c.getContext()))
            .findFirst()
            .orElse(null);

    saveClaimContent(ClaimContentContext.SERVICE, serviceCode, contentEntity, claim);
  }

  /**
   * Save accident code.
   *
   * @param claimView the claim view
   * @param claim the claim
   */
  protected void saveAccidentCode(ClaimViewModel claimView, HospitalOopClaims claim) {
    // Find service code
    ClaimDetailCodes serviceCode = appService.getDiagnosticCode(claimView.getAccidentCode());

    // Find if existing ClaimContents
    ClaimContents contentEntity =
        claim.getClaimContentsList().stream()
            .filter(c -> ClaimContentContext.ACCIDENT.toString().equals(c.getContext()))
            .findFirst()
            .orElse(null);

    saveClaimContent(ClaimContentContext.ACCIDENT, serviceCode, contentEntity, claim);
  }

  /**
   * Save claim content.
   *
   * @param context the context
   * @param serviceCode the service code
   * @param contentEntity the content entity
   * @param claim the claim
   */
  protected void saveClaimContent(
      ClaimContentContext context,
      ClaimDetailCodes serviceCode,
      ClaimContents contentEntity,
      HospitalOopClaims claim) {
    if (serviceCode != null) {
      if (contentEntity == null) {
        // Create new content
        addContent(context, serviceCode, claim);
      } else {
        // Edit existing service content
        contentEntity.setCdcId(serviceCode);
      }
    } else {
      if (contentEntity == null) {
        // Nothing to do
      } else {
        claim.getClaimContentsList().remove(contentEntity);
        serviceDao.remove(contentEntity);
      }
    }
  }

  /**
   * Save validation errors.
   *
   * @param validationErrors the validation errors
   * @param claim the claim
   */
  protected void saveValidationErrors(
      List<ValidationError> validationErrors, HospitalOopClaims claim) {
    clearValidationErrors(claim);
    validationErrors.forEach(e -> saveValidationError(e, claim));
  }

  /**
   * Clear validation errors.
   *
   * @param claim the claim
   */
  protected void clearValidationErrors(HospitalOopClaims claim) {
    for (ClaimErrors error : claim.getClaimErrorsList()) {
      serviceDao.remove(error);
    }
    claim.getClaimErrorsList().clear();
  }

  /**
   * Save validation error.
   *
   * @param error the error
   * @param claim the claim
   */
  protected void saveValidationError(ValidationError error, HospitalOopClaims claim) {
    ClaimErrors newClaimError = new ClaimErrors();
    // TODO: determine what to log
    newClaimError.setHocId(claim);
    newClaimError.setErrorType("CLAIM");
    newClaimError.setContext(error.getRule() != null ? error.getRule().getRuleIdentifier() : null);
    newClaimError.setErrorText(error.getMessage());
    claim.getClaimErrorsList().add(newClaimError);
    serviceDao.add(newClaimError);
  }

  private HoopcException createHoopcException(String message, Exception e) {
    // If ConstraintViolationException, log the violation details
    if (e instanceof ConstraintViolationException) {
      ((ConstraintViolationException) e)
          .getConstraintViolations().stream()
              .forEach(
                  v ->
                      log.error(
                          "ConstraintViolation {}, {}, {}",
                          v.getRootBean(),
                          v.getPropertyPath(),
                          v.getMessage()));
    }
    log.error(message, e);
    return new HoopcException(message, e);
  }

  public Long findByProvincialClaimNumber(ClaimTypes cType, ResidencyTypes resType, String provincialClaimNumber) {
    // TODO Auto-generated method stub
    throw new NotImplementedException("findByProvincialClaimNumber");
    
  }

  public Long findMatchingClaim(ClaimTypes claimType, ResidencyTypes resType, String insuranceNumber,
      LocalDate birthDate, String hospitalNumber, LocalDate serviceDate, BigDecimal totalAmount) {
    return serviceDao.findMatchingClaim(claimType, resType, insuranceNumber,
        birthDate, hospitalNumber, serviceDate, totalAmount);
  }
}
