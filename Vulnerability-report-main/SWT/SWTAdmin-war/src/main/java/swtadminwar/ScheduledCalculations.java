/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package swtadminwar;

import ca.bc.gov.hlth.swt.entity.Calculation;
import ca.bc.gov.hlth.swt.entity.Site;
import ca.bc.gov.hlth.swt.session.RecalculateFacadeLocal;
import ca.bc.gov.hlth.swt.session.SiteFacadeLocal;
import ca.bc.gov.hlth.swt.session.SystemConstantFacadeLocal;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Named;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * This class is responsible for scheduling recalculations.
 * It delegates the actual recalculation job to RecalculateFacadeLocal.java.
 *
 * This implemenation is based on the rules below:
 * <ul>
 *      <li>Only one recalculation can be in progress at any instant</li>
 *      <li>Recalculation can not be scheduled on the same day as normal monthly site load</li>
 * </ul>
 *
 * There is only one instance of this class; therefore, thread synchronization is needed.
 *
 * @author Adebiyi.Kuseju
 */
@ApplicationScoped
@Named("ScheduledCalculations")
public class ScheduledCalculations {

    private Lock lockForNow = new ReentrantLock();
    private Lock lockForOvernight = new ReentrantLock();
    @EJB
    private RecalculateFacadeLocal recalculateFacade;
    @EJB
    private SystemConstantFacadeLocal systemContantFacade;
    @EJB
    private SiteFacadeLocal siteFacade;
    // This represent the day on which the monthly site load calculation is done every month
    private int DAY_OF_MONTHLY_LOAD = 9;

    public enum ScheduleType {

        NOW, OVERNIGHT
    }

    @PostConstruct
    public void init() {
       // DAY_OF_MONTHLY_LOAD = systemContantFacade.find("MONTHLY_LOAD_DAY").getConstantValueVal().toBigInteger().intValue();
    }

    /**
     * Fetches all scheduld recalculations
     *
     * @return A list of all scheduled recalculations.
     */
    public List<CalculationDTO> getCalculations() {

        List<CalculationDTO> result = new ArrayList<CalculationDTO>();
        Iterator<Calculation> itrCalcs = recalculateFacade.findAll().iterator();

        Calculation temp;

        while (itrCalcs.hasNext()) {
            temp = itrCalcs.next();
            CalculationDTO calc = new CalculationDTO();

            calc.setSite(temp.getSiteId().longValue());
            calc.setType(temp.getType());
            calc.setStatus(temp.getStatus());
            result.add(calc);
        }

        return result;
    }

    /**
     * Schedules a site for recalculation
     *
     * @param siteId The site id of the site to be recalculated
     * @param type A enum representing when to recalculation(Now or Overnight)
     * @throws swtadminwar.CalculationException
     */
    public void scheduleCalculation(long siteId, ScheduleType type) throws CalculationException {

        if (type == ScheduleType.NOW) {

            // If we have any calculation in progress, then we can't
            // schedule another recalculation to be done immediately.
            // Note: this may not be a recalculation.
            List<Site> inProgressLoad = siteFacade.findInProgress();

            // If we have any recalcution in progress, we cannot sc
            if (inProgressLoad != null && inProgressLoad.size() > 0) {
                throw new CalculationException("You cannot recalculate 2 sites concurrently - Recalculation on site " + inProgressLoad.get(0).getSiteId() + " is in progress.");
            }

            lockForNow.lock();
            try {
                // Retrieve all recalculations in progress
                List<Calculation> inProgress = recalculateFacade.findInProgress();

                // If we have any recalculation in progress, then we can't
                // schedule another recalculation to be done immediately
                if (inProgress.size() > 0) {
                    throw new CalculationException("You cannot recalculate 2 sites concurrently - Recalculation on site " + inProgress.get(0).getSiteId() + " is in progress.");
                }

                recalculateFacade.recalculateNow(siteId);

            } finally {
                lockForNow.unlock();
            }

        } else if (type == ScheduleType.OVERNIGHT) {

            // Is there a clash with the date for monthly site load?
            // If yes, recalculation is cannot be scheduled.
            if (isOvernightClashedWithMonthly()) {
                throw new CalculationException("You cannot recalculate a site on the same day as normal monthly site load - Day " + DAY_OF_MONTHLY_LOAD + " of every month.");
            }

            lockForOvernight.lock();
            try {
                // Retrieve all recalculations scheduled to run overnight
                List<Calculation> overnight = recalculateFacade.findOvernight();

                // If we have any recalculation scheduled to run overnight, then
                // we can'tschedule another recalculation to be done overnight
                if (overnight.size() > 0) {
                    throw new CalculationException("You cannot recalculate 2 sites concurrently - Recalculation on site " + overnight.get(0).getSiteId() + " is scheduled to run overnight.");
                }

                recalculateFacade.recalculateOvernight(siteId);

            } finally {
                lockForOvernight.unlock();
            }
        }
    }

    private boolean isOvernightClashedWithMonthly() {
        Calendar now = Calendar.getInstance();
        return now.get(Calendar.DAY_OF_MONTH) + 1 == DAY_OF_MONTHLY_LOAD;
    }
}
