/*
 * MaintainNonSPRStatistics.java
 *
 * Created on Nov 21, 2008, 12:30:29 PM
 */
package swtadminwar;

import ca.bc.gov.health.auth.jsf.SelectItemHelper;
import ca.bc.gov.health.login.RoleHelper;
import ca.bc.gov.hlth.swt.entity.NonSprDataEntry;
import ca.bc.gov.hlth.swt.entity.NonSprStatistic;
import ca.bc.gov.hlth.swt.entity.RollupFacility;
import ca.bc.gov.hlth.swt.entity.RollupPriority;
import ca.bc.gov.hlth.swt.entity.RollupProcedureGroup;
import ca.bc.gov.hlth.swt.entity.RollupSurgeon;
import ca.bc.gov.hlth.swt.session.NonSprDataEntryFacadeLocal;
import ca.bc.gov.hlth.swt.session.NonSprStatisticFacadeLocal;
import ca.bc.gov.hlth.swt.session.RollupFacilityFacadeLocal;
import ca.bc.gov.hlth.swt.session.RollupPriorityFacadeLocal;
import ca.bc.gov.hlth.swt.session.RollupProcedureGroupFacadeLocal;
import ca.bc.gov.hlth.swt.session.RollupSurgeonFacadeLocal;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.component.UIComponent;
import jakarta.faces.context.FacesContext;
import jakarta.faces.convert.ConverterException;
import jakarta.faces.convert.DateTimeConverter;
import jakarta.faces.convert.LongConverter;
import jakarta.faces.event.ValueChangeEvent;
import jakarta.faces.model.SelectItem;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.Serializable;
import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.primefaces.component.datatable.DataTable;
import org.primefaces.event.FileUploadEvent;
import org.primefaces.event.RowEditEvent;
import org.primefaces.model.file.UploadedFile;

/**
 * @author greg.perkins
 */
@ViewScoped
@Named("MaintainNonSPRStatistics")
public class MaintainNonSPRStatistics implements Serializable {

    private static final long serialVersionUID = 1L;

    private final Logger log = Logger.getLogger(getClass().getName());

    private UploadedFile file;

    @PersistenceContext(unitName = "SWTAdmin-warPU")
    private EntityManager em;

    @EJB
    private RollupFacilityFacadeLocal facilityFacade;
    
    @EJB
    private RollupSurgeonFacadeLocal surgeonFacade;
    
    @EJB
    private NonSprStatisticFacadeLocal sprFacade;
    
    @EJB
    private RollupPriorityFacadeLocal priorityFacade;
    
    @EJB
    private NonSprDataEntryFacadeLocal nonSprDataEntryFacade;
    
    @EJB
    private RollupProcedureGroupFacadeLocal rollupProcedureGroupFacade;

    private List<RollupFacility> facilities;
    private List<RollupSurgeon> specialists;
    private List<RollupPriority> priorities;
    private List procedures;
    private List dates;

    private List<NonSprStatistic> statistics;
    private List<NonSprStatistic> newStats;

    private NonSprDataEntry stat;

    private Long selectedProcedure;
    private Long selectedDataEntryId;
    private String selectedDate;
    private String dropListDate;
    private String approvedYn;
    private boolean showDate = false;
    private boolean hipFracture = false;
    private Date patientsWaitingAsOf;
    private Date proceduresCompletedFrom;
    private Date proceduresCompletedTo;

    /**
     * <p>Construct a new Page bean instance.</p>
     */
    public MaintainNonSPRStatistics() {
    }

    /**
     * <p>Callback method that is called whenever a page is navigated to, either directly via a URL, or indirectly via page
     * navigation. Customize this method to acquire resources that will be needed for event handlers and lifecycle
     * methods, whether or not this page is performing post back processing.</p>
     *
     * <p>Note that, if the current request is a postback, the property values of the components do <strong>not</strong>
     * represent any values submitted with this request. Instead, they represent the property values that were saved for
     * this view when it was rendered.</p>
     */
    @PostConstruct
    public void init() {
        priorityFacade.refreshPriorityRollups();
        specialists = surgeonFacade.findAll(); // < PERFORMANCE KILLER!!!
        facilities = facilityFacade.findAll(); // < PERFORMANCE KILLER!!!
        priorities = priorityFacade.findAll();
        procedures = SelectItemHelper.buildSelectItemList(rollupProcedureGroupFacade.findAllNonSpr(), "procedureGroupNm", "rollupProcedureGroupId", false);
        dates = new ArrayList();
        stat = new NonSprDataEntry();
        stat.setRollupProcedureGroupId(new RollupProcedureGroup());
        statistics = new ArrayList<>();
        newStats = new ArrayList<>();
    }

    public void onAddNew() {
        // go to the first page
        DataTable d = (DataTable) FacesContext.getCurrentInstance().getViewRoot().findComponent("form1:theTable");
        d.setFirst(0);
        // make a blank record
        NonSprStatistic newStat = new NonSprStatistic();
        String userName = RoleHelper.getUserName(FacesContext.getCurrentInstance());
        newStat.setCreatedByNm(userName);
        newStat.setCreatedOnDtm(new Date());
        newStat.setLastModifiedOnDtm(new Date());
        newStat.setLastModifiedByNm(userName);
        statistics.add(0, newStat);
        newStats.add(newStat);
    }

    public void onRowEdit(RowEditEvent event) {
        NonSprStatistic newStat = (NonSprStatistic) event.getObject();

        // update audit fields
        try {
            String userName = RoleHelper.getUserName(FacesContext.getCurrentInstance());
            PropertyUtils.setProperty(newStat, "lastModifiedByNm", userName);
            PropertyUtils.setProperty(newStat, "lastModifiedOnDtm", new Date());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        // add rollups if neccessary
        /*     if (newStat.getRollupFacilityId() == null) {
            newStat.setRollupFacilityId(new RollupFacility());
        }
        if (newStat.getRollupPriorityId() == null) {
            newStat.setRollupPriorityId(new RollupPriority());
        }
        if (newStat.getRollupSurgeonId() == null) {
            newStat.setRollupSurgeonId(new RollupSurgeon());
        }*/
        if (isValid(newStat)) {
            // create or edit
            if (newStat.getStatelessTransactionNbr() == 0) {
                try {
                    PropertyUtils.setProperty(newStat, "statelessTransactionNbr", 1);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                newStat.setNonSprDataEntryId(stat);
                sprFacade.create(newStat);
            } else {
                sprFacade.edit(newStat);
            }
            newStats.clear();
            refreshData();
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("Save Successful"));
        } else {
            FacesContext.getCurrentInstance().validationFailed();
        }
    }

    public void onRowRemove(NonSprStatistic target) {
        if (target == null) {
            statistics.remove(0);
            return;
        }

        long statelessTransactionNbr = 0;
        try {
            Long stn = (Long) PropertyUtils.getProperty(target, "statelessTransactionNbr");
            statelessTransactionNbr = stn.longValue();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        if (statelessTransactionNbr != 0) {
            try {
                this.statistics.remove(target);
                if (target.getNonSprStatisticId() != 0) {
                    sprFacade.remove(target);
                }
                FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("Delete Successful"));
            } catch (Exception e) {
                FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, "Delete Failed", e.getMessage()));
                e.printStackTrace();
            }
        }
        this.refreshData();
    }

    public void onRowCancel() {
        newStats.forEach((statistic) -> {
            statistics.remove(statistic);
        });
        newStats.clear();
        statistics.clear();
        statistics.addAll(sprFacade.findByDataEntryId(stat.getNonSprDataEntryId()));
    }

    public void procedureChanged(ValueChangeEvent event) {
        stat.getRollupProcedureGroupId().setRollupProcedureGroupId((Long) event.getNewValue());
        procedureChanged();
    }

    private String procedureChanged() {
        log.log(java.util.logging.Level.INFO, "procedureChanged");
        this.statistics = null;
        Long selectedId = stat.getRollupProcedureGroupId().getRollupProcedureGroupId();
        if (selectedId != null && selectedId != 0) {
            stat = new NonSprDataEntry();
            RollupProcedureGroup rpg = rollupProcedureGroupFacade.find(selectedId);
            stat.setRollupProcedureGroupId(rpg);
            List<NonSprDataEntry> newDates = nonSprDataEntryFacade.findByProcedure(stat.getRollupProcedureGroupId().getRollupProcedureGroupId());
            dates = new ArrayList();
            SimpleDateFormat sdf = new SimpleDateFormat("dd-MMM-yyyy");
            for (NonSprDataEntry object : newDates) {
                String val = sdf.format(object.getPatientsWaitingAsOfDt()) + " ( " + sdf.format(object.getProcedureCompletedFromDt()) + " to " + sdf.format(object.getProcedureCompletedToDt()) + ")";
                SelectItem item = new SelectItem(object.getNonSprDataEntryId(), val);
                dates.add(item);
            }
            hipFracture = rpg.getProcedureGroupNm().equals("Hip Fracture Fixation");
        } else {
            hipFracture = false;
            stat = new NonSprDataEntry();
            stat.setRollupProcedureGroupId(new RollupProcedureGroup());
            dates = new ArrayList();
        }
        sortDates();
        return null;
    }

    public String saveNewReportingPeriod() {
        if (stat.getRollupProcedureGroupId() == null) {
            FacesContext.getCurrentInstance().addMessage("theStatistic", new FacesMessage(FacesMessage.SEVERITY_ERROR, "Non-SPR Procedure is required", ""));
            return null;
        }
        NonSprDataEntry nonSpr = new NonSprDataEntry();
        nonSpr.setRollupProcedureGroupId(stat.getRollupProcedureGroupId());
        nonSpr.setPatientsWaitingAsOfDt(patientsWaitingAsOf);
        nonSpr.setProcedureCompletedFromDt(proceduresCompletedFrom);
        nonSpr.setProcedureCompletedToDt(proceduresCompletedTo);
        nonSpr.setApprovedForSiteYn("N");

        // audit fields
        String userName = RoleHelper.getUserName(FacesContext.getCurrentInstance());
        nonSpr.setCreatedByNm(userName);
        nonSpr.setCreatedOnDtm(new Date());
        nonSpr.setLastModifiedOnDtm(new Date());
        nonSpr.setLastModifiedByNm(userName);

        NonSprDataEntry existing = nonSprDataEntryFacade.findByUK(
                nonSpr.getRollupProcedureGroupId().getRollupProcedureGroupId(),
                patientsWaitingAsOf,
                proceduresCompletedFrom,
                proceduresCompletedTo);
        patientsWaitingAsOf = null;
        proceduresCompletedFrom = null;
        proceduresCompletedTo = null;

        if (existing == null) {
            nonSprDataEntryFacade.create(nonSpr);
            FacesContext.getCurrentInstance().addMessage("theProcedure", new FacesMessage("Reporting Period Created"));
        } else {
            nonSpr = existing;
            FacesContext.getCurrentInstance().addMessage("theStatistic", new FacesMessage(FacesMessage.SEVERITY_ERROR, "Reporting Period Already Exists", ""));
        }
        stat = nonSpr;
        selectedDataEntryId = stat.getNonSprDataEntryId();
        procedureChanged();
        dateChanged();
        return null;
    }

    public String dateChanged() {
        log.log(Level.INFO, "dateChanged");
        refreshData();
        return null;
    }

    public void dataEntryCompleteChanged(ValueChangeEvent vce) {
        if (vce.getNewValue().equals(Boolean.TRUE)) {
            stat.setApprovedByNm(RoleHelper.getUserName(FacesContext.getCurrentInstance()));
            stat.setApprovedOnDtm(new Date());
        } else {
            stat.setApprovedByNm(null);
            stat.setApprovedOnDtm(null);
        }
    }

    public void refreshData() {
        try {
            if (selectedDataEntryId != null) {
                NonSprDataEntry found = nonSprDataEntryFacade.find(selectedDataEntryId);
                if (found != null) {
                    stat = found;
                    statistics = new ArrayList<>();
                    statistics.addAll(sprFacade.findByDataEntryId(found.getNonSprDataEntryId()));
                } else {
                    NonSprDataEntry newStat = new NonSprDataEntry();
                    newStat.setRollupProcedureGroupId(stat.getRollupProcedureGroupId());
                    //newStat.setDataLastRevisedDt(stat.getDataLastRevisedDt());
                    stat = newStat;
                    statistics = new ArrayList<>();
                }
                FacesContext.getCurrentInstance().renderResponse();
            } else {
                NonSprDataEntry newStat = new NonSprDataEntry();
                newStat.setRollupProcedureGroupId(stat.getRollupProcedureGroupId());
                //newStat.setDataLastRevisedDt(stat.getDataLastRevisedDt());
                stat = newStat;
                statistics = new ArrayList<>();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public List<NonSprStatistic> getStatistics() {
        return statistics;
    }

    public void setStatistics(List<NonSprStatistic> statistics) {
        this.statistics = statistics;
    }

    public List getFacilities() {
        return facilities;
    }

    public void setFacilities(List facilities) {
        this.facilities = facilities;
    }

    public List getSpecialists() {
        return specialists;
    }

    public void setSpecialists(List specialists) {
        this.specialists = specialists;
    }

    public boolean isSiteApproved() {

        if (stat == null || stat.getApprovedForSiteYn() == null) {
            return false;
        }
        return stat.getApprovedForSiteYn().equalsIgnoreCase("Y");
    }

    public void setSiteApproved(boolean siteApproved) {
        stat.setApprovedForSiteYn(siteApproved ? "Y" : "N");
    }

    /**
     * Persists a row
     *
     * @param row
     * @return boolean - true if save was successful
     */
    /*    protected boolean saveObject(EditableTableRow row) {
        EntityManager em = getEntityManager();
        Object target = row.getOrig();
        long statelessTransactionNbr = 0;
        try {
            Long stn = (Long) PropertyUtils.getProperty(target, "statelessTransactionNbr");
            statelessTransactionNbr = stn.longValue();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Object updated = null;
        try {


            // Ensure we remove placeholder objects if no user provides to no values
            if (((NonSprStatistic) row.getTarget()).getRollupPriorityId().getRollupPriorityId() == null) {
                ((NonSprStatistic) row.getTarget()).setRollupPriorityId(null);
            }

            if (((NonSprStatistic) row.getTarget()).getRollupFacilityId().getRollupFacilityId() == null) {
                ((NonSprStatistic) row.getTarget()).setRollupFacilityId(null);
            }

            if (((NonSprStatistic) row.getTarget()).getRollupSurgeonId().getRollupSurgeonId() == null) {
                ((NonSprStatistic) row.getTarget()).setRollupSurgeonId(null);
            }

            utx.begin();
            if (statelessTransactionNbr != 0) {
                updated = sprFacade.edit((NonSprStatistic) row.getTarget());
            } else {
                PropertyUtils.setProperty(target, "statelessTransactionNbr", 1);
                sprFacade.create((NonSprStatistic) row.getTarget());
            }
            utx.commit();
            if (updated != null) {
                PropertyUtils.copyProperties(row.getTarget(), updated);
            }
            row.saveChanges();

            return true;
        } catch (Exception e) {
            try {
                if (!(e instanceof OptimisticLockException)) {
                    while (e.getCause() != null) {
                        e = (Exception) e.getCause();
                    }
                }
                if (e instanceof OptimisticLockException) {
                    FacesContext.getCurrentInstance().addMessage("", new FacesMessage("Another User has updated this record"));
                    reloadEntity(row);
                } else {
                    FacesContext.getCurrentInstance().addMessage("", new FacesMessage(e.getMessage()));
                }
                utx.rollback();
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        return false;
    }*/
    /**
     * Deletes a row
     *
     * @param
     */
    /*    @Override
    protected void onRemove(EditableTableRow row) {
        Object target = row.getOrig();
        long statelessTransactionNbr = 0;
        try {
            Long stn = (Long) PropertyUtils.getProperty(target, "statelessTransactionNbr");
            statelessTransactionNbr = stn.longValue();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        if (statelessTransactionNbr != 0) {
            try {
                utx.begin();
                target = sprFacade.edit((NonSprStatistic) target);
                sprFacade.remove((NonSprStatistic) target);
                utx.commit();
            } catch (Exception e) {
                try {
                    e.printStackTrace();
                    utx.rollback();
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        }
    }*/
    //@Override
    protected EntityManager getEntityManager() {
        return em;
    }

    public List getPriorities() {
        return priorities;
    }

    public void setPriorities(List priorities) {
        this.priorities = priorities;
    }

    public Long getSelectedProcedure() {
        return selectedProcedure;
    }

    public void setSelectedProcedure(Long selectedProcedure) {
        this.selectedProcedure = selectedProcedure;
    }

    public List getProcedures() {
        return procedures;
    }

    public void setProcedures(List procedures) {
        this.procedures = procedures;
    }

    public List getDates() {
        return dates;
    }

    public void setDates(List dates) {
        this.dates = dates;
    }

    public String getApprovedYn() {
        return approvedYn;
    }

    public void setApprovedYn(String approvedYn) {
        this.approvedYn = approvedYn;
    }

    public String getSelectedDate() {
        return selectedDate;
    }

    public void setSelectedDate(String selectedDate) {
        this.selectedDate = selectedDate;
    }

    public boolean getShowDate() {
        return showDate;
    }

    public void setShowDate(boolean showDate) {
        this.showDate = showDate;
    }
    private LongConverter longConverter = new LongConverter();

    public LongConverter getLongConverter() {
        return longConverter;
    }

    public UploadedFile getFile() {
        return file;
    }

    public void setFile(UploadedFile file) {
        this.file = file;
    }

    public void setLongConverter(LongConverter longConverter) {
        this.longConverter = longConverter;
    }
    private DateTimeConverter dateConverter = new DateTimeConverter() {
        private SimpleDateFormat fmt = new SimpleDateFormat("dd-MMM-yyyy");

        @Override
        public Object getAsObject(FacesContext context, UIComponent component, String s) throws ConverterException {
            try {
                if (s == null) {
                    return null;
                }
                return fmt.parse(s);
            } catch (Exception e) {
                e.printStackTrace();
                throw new ConverterException(e);
            }
        }

        @Override
        public String getAsString(FacesContext context, UIComponent component, Object o) throws ConverterException {
            if (o == null) {
                return null;
            }
            if (o instanceof String) {
                return (String) o;
            }
            return fmt.format(o);
        }
    };

    public DateTimeConverter getDateConverter() {
        return dateConverter;
    }

    public void setDateConverter(DateTimeConverter dateConverter) {
        this.dateConverter = dateConverter;
    }

    public String getDropListDate() {
        return dropListDate;
    }

    public void setDropListDate(String dropListDate) {
        this.dropListDate = dropListDate;
    }

    public NonSprDataEntry getStat() {
        return stat;
    }

    public void setStat(NonSprDataEntry stat) {
        this.stat = stat;
    }

    private void sortDates() {
        Collections.sort(dates, new Comparator<SelectItem>() {
            DateFormat df = new SimpleDateFormat("dd-MMM-yyyy");

            public int compare(SelectItem o1, SelectItem o2) {
                try {
                    return (df.parse(o1.getLabel()).compareTo(df.parse(o2.getLabel()))) * -1;
                } catch (Exception e) {
                    return 0;
                }
            }
        });
    }

    public Date getProceduresCompletedFrom() {
        return proceduresCompletedFrom;
    }

    public void setProceduresCompletedFrom(Date proceduresCompletedFrom) {
        this.proceduresCompletedFrom = proceduresCompletedFrom;
    }

    public Date getProceduresCompletedTo() {
        return proceduresCompletedTo;
    }

    public void setProceduresCompletedTo(Date proceduresCompletedTo) {
        this.proceduresCompletedTo = proceduresCompletedTo;
    }

    public Date getPatientsWaitingAsOf() {
        return patientsWaitingAsOf;
    }

    public void setPatientsWaitingAsOf(Date patientsWaitingAsOf) {
        this.patientsWaitingAsOf = patientsWaitingAsOf;
    }

    public Long getSelectedDataEntryId() {
        return selectedDataEntryId;
    }

    public void setSelectedDataEntryId(Long selectedDataEntryId) {
        this.selectedDataEntryId = selectedDataEntryId;
    }

    public boolean getHipFracture() {
        return hipFracture;
    }

    public void setHipFracture(boolean hipFracture) {
        this.hipFracture = hipFracture;
    }

    public void handleFileUpload(FileUploadEvent event) throws Exception {
        //FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("Successful", event.getFile().getFileName() + " is uploaded."));
        file = event.getFile();
        try {
            InputStream fileinit = file.getInputStream();
            Reader targetReader = new InputStreamReader(fileinit);
            CSVParser records = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(targetReader);

            // Will controll variables coming as names and being translated into ids
            // This avoids repeativelly going to database to retrieve same multiple times
            HashMap<String, RollupProcedureGroup> procedureGroupNamesWithDbObj = new HashMap();
            HashMap<String, RollupFacility> facilityNamesWithDbObj = new HashMap();
            HashMap<String, RollupPriority> priorityNamesWithDbObj = new HashMap();
            HashMap<Long, RollupSurgeon> surgeonCollegeIdsWithDbObj = new HashMap();

            // Make sure there is no duplicated data entries
            HashSet<NonSprDataEntry> nonSprDataSet = new HashSet();

            // Will control every error, per line
            HashMap<Long, String> errorlns = new HashMap<>();

            for (CSVRecord record : records) {
                NonSprStatistic newStat = new NonSprStatistic();
                NonSprDataEntry nonSpr = new NonSprDataEntry();
                try {
                    patientsWaitingAsOf = extractDateFromCsvColumnValue(record.get("PATIENTS_WAITING_AS_OF_DT"));
                    proceduresCompletedFrom = extractDateFromCsvColumnValue(record.get("PROCEDURE_COMPLETED_FROM_DT"));
                    proceduresCompletedTo = extractDateFromCsvColumnValue(record.get("PROCEDURE_COMPLETED_TO_DT"));
                } catch (ParseException e) {
                    errorlns.put(records.getCurrentLineNumber(), "Invalid date format. Only yyyy-MM-dd and M/d/yyyy formats are allowed");
                    continue;
                }
                String patientsWaitingNbr = record.get("PATIENTS_WAITING_NBR");
                String procedurePerformedNbr = record.get("PROCEDURES_PERFORMED_NBR");
                String fiftyPctWeeksNbr = record.get("WT2_FIFTY_PCT_WEEKS_NBR");
                String ninetyPctWeeksNbr = record.get("WT2_NINETY_PCT_WEEKS_NBR");

                // British Columbia can't have surgeon set
                String facilityName = record.get("Facility");
                String surgeonCollegeIdStr = record.get("Surgeon College ID");
                if (facilityName.equals("British Columbia") && !"".equals(surgeonCollegeIdStr)) {
                    errorlns.put(records.getCurrentLineNumber(), "Can't have surgeon when facility is British Columbia");
                    continue;
                }

                // Set procedure id based on procedure name
                String procedureGroupName = record.get("Non-SPR Procedure");
                if (!procedureGroupNamesWithDbObj.containsKey(procedureGroupName)) {
                    List<RollupProcedureGroup> nonsprProcedures = rollupProcedureGroupFacade.findByProcedureNm(procedureGroupName);
                    nonsprProcedures.stream().filter((nonsprProcedure) -> (nonsprProcedure.getExpiryDtm() == null)).forEachOrdered((nonsprProcedure) -> {
                        procedureGroupNamesWithDbObj.put(procedureGroupName, nonsprProcedure);
                    });
                }
                nonSpr.setRollupProcedureGroupId(procedureGroupNamesWithDbObj.get(procedureGroupName));
                // Ignore lines in which procedure id wasn't found
                if (nonSpr.getRollupProcedureGroupId() == null) {
                    errorlns.put(records.getCurrentLineNumber(), "Non-SPR Procedure is required"); //must concat here
                    continue;
                }

                // Set facility id based on facility name
                if (!facilityName.equals("British Columbia")) {
                    if (!facilityNamesWithDbObj.containsKey(facilityName)) {
                        List<RollupFacility> facilityNms = facilityFacade.findByFacilityNm(facilityName);
                        facilityNms.stream().filter((facility) -> (facility.getFacilityNm().equals(facilityName))).forEachOrdered((facility) -> {
                            facilityNamesWithDbObj.put(facilityName, facility);
                        });
                    }
                    newStat.setRollupFacilityId(facilityNamesWithDbObj.get(facilityName));
                    // Ignore lines in which facility id wasn't found
                    if (newStat.getRollupFacilityId() == null) {
                        errorlns.put(records.getCurrentLineNumber(), "Facility not found");
                        continue;
                    }
                }

                // Set priority id based on priority name
                String priorityName = record.get("Priority");
                if (!priorityName.equals("")) {
                    if (!priorityNamesWithDbObj.containsKey(priorityName)) {
                        List<RollupPriority> priorityNms = priorityFacade.findByPriorityDsc(priorityName);
                        priorityNms.stream().filter((priority) -> (priority.getExpiryDtm() == null)).forEachOrdered((priority) -> {
                            priorityNamesWithDbObj.put(priorityName, priority);
                        });
                    }
                    newStat.setRollupPriorityId(priorityNamesWithDbObj.get(priorityName));
                    // Ignore lines in which facility id wasn't found
                    if (newStat.getRollupPriorityId() == null) {
                        errorlns.put(records.getCurrentLineNumber(), "Priority not found");
                        continue;
                    }
                }

                // Set surgeon id based on surgeon name
                Long surgeonCollegeId = !"".equals(surgeonCollegeIdStr) ? Long.valueOf(surgeonCollegeIdStr) : 0;
                if (surgeonCollegeId != 0) {
                    if (!surgeonCollegeIdsWithDbObj.containsKey(surgeonCollegeId)) {
                        List<RollupSurgeon> surgeonNms = surgeonFacade.findByCollegeId(surgeonCollegeId.toString());
                        surgeonNms.stream().filter((surgeon) -> (surgeon.getExpiryDtm() == null)).forEachOrdered((surgeon) -> {
                            surgeonCollegeIdsWithDbObj.put(surgeonCollegeId, surgeon);
                        });
                    }
                    newStat.setRollupSurgeonId(surgeonCollegeIdsWithDbObj.get(surgeonCollegeId));
                    // Ignore lines in which facility id wasn't found
                    if (newStat.getRollupSurgeonId() == null) {
                        errorlns.put(records.getCurrentLineNumber(), "Surgeon not found");
                        continue;
                    }
                }

                // Check if given period isn't already aprooved
                // @TODO make this a set.
                // @TODO reuse this at the end, avoiding re-quering the same thing twice
                NonSprDataEntry periodOnDb = nonSprDataEntryFacade.findByUK(
                        nonSpr.getRollupProcedureGroupId().getRollupProcedureGroupId(),
                        patientsWaitingAsOf,
                        proceduresCompletedFrom,
                        proceduresCompletedTo);
                if (periodOnDb != null) {
                    if ("Y".equals(periodOnDb.getApprovedForSiteYn())) {
                        errorlns.put(records.getCurrentLineNumber(), "Period already approved can't be re-imported");
                        continue;
                    }
                }

                nonSpr.setPatientsWaitingAsOfDt(patientsWaitingAsOf);
                nonSpr.setProcedureCompletedFromDt(proceduresCompletedFrom);
                nonSpr.setProcedureCompletedToDt(proceduresCompletedTo);
                nonSpr.setApprovedForSiteYn("N");

                // audit fields
                String userName = RoleHelper.getUserName(FacesContext.getCurrentInstance());
                nonSpr.setCreatedByNm(userName);
                nonSpr.setCreatedOnDtm(new Date());
                nonSpr.setLastModifiedOnDtm(new Date());
                nonSpr.setLastModifiedByNm(userName);

                newStat.setNonSprDataEntryId(nonSpr);

                // to control unicity
                nonSprDataSet.add(nonSpr);

                newStat.setCreatedByNm(userName);
                newStat.setCreatedOnDtm(new Date());
                newStat.setLastModifiedOnDtm(new Date());
                newStat.setLastModifiedByNm(userName);
                if (!fiftyPctWeeksNbr.trim().toUpperCase().equals("N/A")) {
                    newStat.setFiftyPctWeeksNbr(new BigDecimal(fiftyPctWeeksNbr));
                }
                if (!ninetyPctWeeksNbr.trim().toUpperCase().equals("N/A")) {
                    newStat.setNinetyPctWeeksNbr(new BigDecimal(ninetyPctWeeksNbr));
                }
                newStat.setPatientsWaitingNbr(new Integer(patientsWaitingNbr));
                newStat.setProceduresPerformedNbr(new Integer(procedurePerformedNbr));

                newStats.add(newStat);
            }

            // There is no error.
            // Check, clean and insert data from file on database
            if (errorlns.isEmpty()) {

                // Check and create periods if needed
                Integer numDeletion = 0;
                for (NonSprDataEntry sprData : nonSprDataSet) {
                    NonSprDataEntry finalSprData = nonSprDataEntryFacade.findByUK(
                            sprData.getRollupProcedureGroupId().getRollupProcedureGroupId(),
                            sprData.getPatientsWaitingAsOfDt(),
                            sprData.getProcedureCompletedFromDt(),
                            sprData.getProcedureCompletedToDt());
                    // Period exists, clean it by removing all data
                    if (finalSprData != null) {
                        numDeletion = sprFacade.remove(finalSprData);
                    } // Period doesn't exist, create it
                    else {
                        nonSprDataEntryFacade.create(sprData);
                        finalSprData = nonSprDataEntryFacade.findByUK(
                                sprData.getRollupProcedureGroupId().getRollupProcedureGroupId(),
                                sprData.getPatientsWaitingAsOfDt(),
                                sprData.getProcedureCompletedFromDt(),
                                sprData.getProcedureCompletedToDt());
                    }

                    // Insert entries with created or existent period
                    for (NonSprStatistic stats : newStats) {
                        // Equals will match with dates and procedure group even if ids are missing or different
                        if (stats.getNonSprDataEntryId().equals(finalSprData)) {
                            stats.setNonSprDataEntryId(finalSprData);
                            sprFacade.create(stats);
                        }
                    }
                }

                StringBuilder successMessage = new StringBuilder()
                        .append(newStats.size())
                        .append(" records were imported.");
                FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("Importation successful. ", successMessage.toString()));
            } // There is error
            else {
                FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("CSV Upload Failed.", "Failing rows are:"));
                errorlns.entrySet().forEach((set) -> {
                    String messageHeader = "Line # " + String.valueOf(set.getKey());
                    FacesMessage message = new FacesMessage(FacesMessage.SEVERITY_ERROR, messageHeader, set.getValue());
                    FacesContext.getCurrentInstance().addMessage(null, message);
                });
                FacesContext.getCurrentInstance().validationFailed();
            }
        } catch (IOException | NumberFormatException e) {
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("Internal error at parsing CSV file with message: " + e.getMessage()));
        } finally {
            newStats.clear();
        }
    }

    private Date extractDateFromCsvColumnValue(String columnValue) throws ParseException {
        Date output;
        try {
            output = new SimpleDateFormat("yyyy-MM-dd").parse(columnValue);
        } catch (ParseException ex) {
            output = new SimpleDateFormat("M/d/yyyy").parse(columnValue);
        }
        return output;
    }

    public String save() {
        if (stat.getRollupProcedureGroupId() == null || stat.getRollupProcedureGroupId().getRollupProcedureGroupId() == null) {
            FacesContext.getCurrentInstance().addMessage("theProcedure", new FacesMessage("Non-SPR Procedure is required"));
        }
        //if (stat.getDataLastRevisedDt()==null){
        //    getFacesContext().addMessage("theDate",  new FacesMessage("Last Revised Date is required"));
        //}
        if (FacesContext.getCurrentInstance().getMessages().hasNext()) {
            FacesContext.getCurrentInstance().renderResponse();
            return null;
        }
        // audit fields
        String userName = RoleHelper.getUserName(FacesContext.getCurrentInstance());

        stat.setLastModifiedOnDtm(new Date());
        stat.setLastModifiedByNm(userName);
        stat.setRollupProcedureGroupId(rollupProcedureGroupFacade.find(stat.getRollupProcedureGroupId().getRollupProcedureGroupId()));
        if (stat.getStatelessTransactionNbr() == 0) {
            nonSprDataEntryFacade.create(stat);
        } else {
            nonSprDataEntryFacade.edit(stat);
        }
        procedureChanged();
        dateChanged();
        return null;
    }

    public boolean isValid(NonSprStatistic statistic) {

        if (statistic.getRollupPriorityId() != null && statistic.getRollupPriorityId().getPriorityCd() != null) {
            if (priorityFacade.find(statistic.getRollupPriorityId().getRollupPriorityId()).getExpiryDtm() != null) {
                FacesContext.getCurrentInstance().addMessage("theStatistic", new FacesMessage(FacesMessage.SEVERITY_ERROR, "Non SPR Statistics must use active priorities", ""));
                FacesContext.getCurrentInstance().renderResponse();
                return false;
            }
        }

        for (NonSprStatistic row : statistics) {

            if (row == statistic) {
                continue;
            }

            if ((statistic.getRollupFacilityId() != null && row.getRollupFacilityId() == null)
                    || (statistic.getRollupFacilityId() == null && row.getRollupFacilityId() != null)
                    || (statistic.getRollupFacilityId() != null && row.getRollupFacilityId() != null
                    && !row.getRollupFacilityId().getRollupFacilityId().equals(statistic.getRollupFacilityId().getRollupFacilityId()))) {
                continue;
            }

            if ((statistic.getRollupSurgeonId() != null && row.getRollupSurgeonId() == null)
                    || (statistic.getRollupSurgeonId() == null && row.getRollupSurgeonId() != null)
                    || (statistic.getRollupSurgeonId() != null && row.getRollupSurgeonId() != null
                    && !row.getRollupSurgeonId().getRollupSurgeonId().equals(statistic.getRollupSurgeonId().getRollupSurgeonId()))) {
                continue;
            }

            if ((statistic.getRollupPriorityId() != null && row.getRollupPriorityId() == null)
                    || (statistic.getRollupPriorityId() == null && row.getRollupPriorityId() != null)
                    || (statistic.getRollupPriorityId() != null && row.getRollupPriorityId() != null
                    && !row.getRollupPriorityId().getRollupPriorityId().equals(statistic.getRollupPriorityId().getRollupPriorityId()))) {
                continue;
            }

            FacesContext.getCurrentInstance().addMessage("theStatistic", new FacesMessage(FacesMessage.SEVERITY_ERROR, "Non SPR Statistics must be unique", ""));
            return false;
        }

        return true;
    }
}
