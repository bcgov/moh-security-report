/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        LoadFacade.java                                *
 * Date of Last Commit: $Date::                                              $ *
 * Revision Number:      $Rev::                                              $ *
 * Last Commit by:    $Author::                                              $ *
 *                                                                             *
 *******************************************************************************/

package ca.bc.gov.health.tap.session;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.Resource;
import jakarta.ejb.Stateless;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.DataSource;
import org.springframework.jdbc.core.BatchPreparedStatementSetter;
import org.springframework.jdbc.core.JdbcTemplate;

/**
 * Facade class to assist with loading data into the DB.
 *
 * @author greg.perkins
 */
@Stateless
public class LoadFacade implements LoadFacadeLocal {

    private static final String CLASSNAME = LoadFacade.class.getSimpleName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);

    /* INSERT SQL statement */
    private static String INSERT_SCRIPT = "INSERT INTO MAIN(LOAD_ID, APPRVL_DT, CNFRMTN_NMBR, PRSNL_HLTH_NMBR, FRM_CTY, PSTL_CD, LHA_CD, HLTH_ATHRTY,"
            + "RFRNG_PRCTNR_NMBR, RFRNG_PRCTNR_CTY, RFRNG_PRC_SPCLTY1, RFRNG_PRC_SPCLTY2, RFRNG_PRCTNR_LHA,"
            + "SPCLST_PRCTNR_NMBR, SPCLST_CTY, SPCLST_LHA, SPCLST_SPCLTY_1, SPCLST_SPCLTY_2, TRVL_MD,"
            + "ESCRT, ONE_WY, VHCL, APNTMNT_DT, CLNT_BRTH_DT, GRP_NMBR_1, ADJSTD_RT_CD_1, GRP_NMBR_2,"
            + "ADJSTD_RT_CD_2, GRP_NMBR_3, ADJSTD_RT_CD_3, ACTN, PRMM_AST, RJCT_RSN, BYPS_CD, RFRNG_PRCTNR_HA, SPCLST_HA) "
            + "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
    private List<Integer> fieldLengths;

    /**
     * DataSource to be injected
     */
    @Resource(name = "java:app/jdbc/tap")
    private DataSource ds;

    @PostConstruct
    public void initBean() {

        fieldLengths = new ArrayList<Integer>(35);

        // There might be a better way to dynamically retreive table structure from the DB even if the table is empty
        // This will suffice for now
        fieldLengths.add(0);
        fieldLengths.add(9);
        fieldLengths.add(10);
        fieldLengths.add(25);
        fieldLengths.add(6);
        fieldLengths.add(3);
        fieldLengths.add(2);
        fieldLengths.add(5);
        fieldLengths.add(25);
        fieldLengths.add(2);
        fieldLengths.add(2);
        fieldLengths.add(3);
        fieldLengths.add(5);
        fieldLengths.add(25);
        fieldLengths.add(3);
        fieldLengths.add(2);
        fieldLengths.add(2);
        fieldLengths.add(1);
        fieldLengths.add(1);
        fieldLengths.add(1);
        fieldLengths.add(1);
        fieldLengths.add(0);
        fieldLengths.add(0);
        fieldLengths.add(7);
        fieldLengths.add(1);
        fieldLengths.add(7);
        fieldLengths.add(1);
        fieldLengths.add(7);
        fieldLengths.add(1);
        fieldLengths.add(1);
        fieldLengths.add(1);
        fieldLengths.add(2);
        fieldLengths.add(1);
        fieldLengths.add(2);
        fieldLengths.add(2);

    }

    /**
     * Inserts all the rows into the database
     *
     * @param rows List<Object[]>
     */
    public void loadRows(final String loadid, final List<Object[]> rows, long loaded) throws Exception {
        JdbcTemplate jt = new JdbcTemplate(ds);

        final List<Object[]> validated = validateRecords(rows, loaded);

        jt.batchUpdate(INSERT_SCRIPT, new BatchPreparedStatementSetter() {

            public void setValues(PreparedStatement ps, int i) throws SQLException {
                Object[] values = validated.get(i);
                // set loadid
                ps.setString(1, loadid);

                // query parameter position has to be incremented by one because of loadid
                for (int j = 1; j <= values.length; j++) {
                    if (j == 1 || j == 22 || j == 23) {
                        ps.setDate(j + 1, (Date) values[j - 1]);
                    } else {
                        ps.setString(j + 1, values[j - 1].toString());
                    }
                }
            }

            public int getBatchSize() {
                return validated.size();
            }
        });
    }

    /* Getters and Setters */
    public DataSource getDs() {
        return ds;
    }

    public void setDs(DataSource ds) {
        this.ds = ds;
    }

    @Override
    public int processDuplicates() {
        JdbcTemplate jt = new JdbcTemplate(ds);
        return jt.queryForInt("SELECT CHECK_DUPLICATES FROM DUAL");
    }

    @Override
    public void createDuplicateCountEntry(String new_load_id, long duplicatesCount) {
        JdbcTemplate jt = new JdbcTemplate(ds);
        jt.batchUpdate(new String[]{"DELETE FROM DUPLICATES", String.format("INSERT INTO DUPLICATES VALUES('%s', %s)", new_load_id, duplicatesCount)});
    }

    @Override
    public int getDuplicatesCount() {
        JdbcTemplate jt = new JdbcTemplate(ds);
        int result = 0;

        try {
            result = jt.queryForInt("SELECT DUP_COUNT FROM DUPLICATES");
        } catch (Exception e) {
            LOG.log(Level.SEVERE, "Error retrieving duplicates count");
        }
        return result;
    }

    private List<Object[]> validateRecords(List<Object[]> rows, long loaded) throws Exception {

        List<Object[]> validatedRecords = new ArrayList<Object[]>(rows.size());
        Object[] temp = null;
        Object[] validatedValues = null;

        OUTER:
        for (int i = 0; i < rows.size(); i++) {
            temp = rows.get(i);
            validatedValues = new Object[temp.length];

            for (int j = 0; j < temp.length; j++) {

                if (fieldLengths.get(j) == 0) {  // if field length is zero, then it must be a date field
                    validatedValues[j] = new Date(((java.util.Date) temp[j]).getTime());
                    continue;
                }

                if (temp[j].toString().length() > fieldLengths.get(j)) {
                    LOG.log(Level.SEVERE, "Record " + (loaded + i) + " is not loaded because data is too big for column \"" + (j + 1) + "\" (Record Skipped)");
                    continue OUTER;
                } else {
                    validatedValues[j] = temp[j];
                }
            }

            validatedRecords.add(validatedValues);
        }

        return validatedRecords;
    }
}
