/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        ReportFacade.java                              *
 * Date of Last Commit: $Date::                                              $ *
 * Revision Number:      $Rev::                                              $ *
 * Last Commit by:    $Author::                                              $ *
 *                                                                             *
 *******************************************************************************/

package ca.bc.gov.health.tap.session;

import ca.bc.gov.health.tap.session.valueObjects.FerryOnlyReportItem;
import ca.bc.gov.health.tap.session.valueObjects.FrequencyReportItem;
import ca.bc.gov.health.tap.session.valueObjects.FromResidenceReportItem;
import ca.bc.gov.health.tap.session.valueObjects.PatientSpecialistReportItem;
import ca.bc.gov.health.tap.session.valueObjects.PerPatientReportItem;
import ca.bc.gov.health.tap.session.valueObjects.ToDestinationReportItem;
import ca.bc.gov.health.tap.session.valueObjects.TravelAssistanceReportItem;
import ca.bc.gov.health.tap.session.valueObjects.TravelForWhatServiceItem;
import ca.bc.gov.health.tap.session.valueObjects.WhyReportItem;
import jakarta.annotation.Resource;
import jakarta.ejb.Stateless;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.ResultSet;
import java.text.DateFormat;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.sql.DataSource;
import oracle.jdbc.OracleTypes;

/**
 *
 * @author greg.perkins
 */
@Stateless
public class ReportFacade implements ReportFacadeLocal {

    @Resource(name = "java:app/jdbc/tap")
    private DataSource ds;
    private NumberFormat percentFormat = NumberFormat.getPercentInstance();
    private final String NO_DATA = "No matching records";

    public ReportFacade() {
        percentFormat.setMinimumFractionDigits(1);
        percentFormat.setMaximumFractionDigits(1);
    }

    @Override
    public List travelAssistanceSummary(Date startDate, Date endDate, String[] healthAuthorities, String[] clientLHA) {
        ArrayList<TravelAssistanceReportItem> result = new ArrayList();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {

            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.summary_rep(?, ?, ?, ?, ?); END;");
            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
            stmt.setString(3, combineArray(healthAuthorities));
            stmt.setString(4, combineArray(clientLHA));
            stmt.registerOutParameter(5, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            TravelAssistanceReportItem temp;
            TravelAssistanceReportItem total = new TravelAssistanceReportItem();
            total.setMode("TOTAL");
            rs = (ResultSet) stmt.getObject(5);

            int totalMode = 0;
            int totalEscort = 0;
            int totalOneWay = 0;
            float totalModePercent = 0;
            float tempValue = 0;
            String strTempValue;

            while (rs.next()) {
                temp = new TravelAssistanceReportItem();

                temp.setMode(rs.getString(1));
                temp.setModeNumber(rs.getString(2));

                tempValue = getValue(rs.getString(3));
                temp.setModePercent(percentFormat.format(tempValue));

                totalMode += Integer.parseInt(temp.getModeNumber());
                totalModePercent += tempValue;

                temp.setEscortNumber(rs.getString(4));
                temp.setEscortPercent(percentFormat.format(getValue(rs.getString(5))));
                totalEscort += Integer.parseInt(temp.getEscortNumber());

                temp.setOneWayNumber(rs.getString(6));
                temp.setOneWayPercent(percentFormat.format(getValue(rs.getString(7))));
                totalOneWay += Integer.parseInt(temp.getOneWayNumber());

                temp.setVehicleNumber(getValueItem(rs.getString(8)));
                strTempValue = getValueItem(rs.getString(9));

                if (strTempValue.length() > 0) {
                    temp.setVehiclePercent(percentFormat.format(getValue(strTempValue)));
                } else {
                    temp.setVehiclePercent(strTempValue);
                }

                result.add(temp);

            }

            total.setModeNumber(String.valueOf(totalMode));
            total.setModePercent(percentFormat.format(Math.round(totalModePercent)));
            total.setEscortNumber(String.valueOf(totalEscort));
            total.setOneWayNumber(String.valueOf(totalOneWay));

            if (totalMode > 0) {
                total.setEscortPercent(percentFormat.format(((float) totalEscort) / totalMode));
                total.setOneWayPercent(percentFormat.format(((float) totalOneWay) / totalMode));
            } else {
                total.setEscortPercent(percentFormat.format(0));
                total.setOneWayPercent(percentFormat.format(0));
            }

            result.add(total);

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }

        return result;
    }

    @Override
    public List ferryOnlySummary(Date startDate, Date endDate, String[] healthAuthorities, String[] clientLHA) {
        ArrayList<FerryOnlyReportItem> result = new ArrayList<FerryOnlyReportItem>();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {

            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.ferry_only(?, ?, ?, ?, ?); END;");
            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
            stmt.setString(3, combineArray(healthAuthorities));
            stmt.setString(4, combineArray(clientLHA));
            stmt.registerOutParameter(5, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            FerryOnlyReportItem temp;
            FerryOnlyReportItem total = new FerryOnlyReportItem();
            total.setMode("TOTAL");
            rs = (ResultSet) stmt.getObject(5);

            int totalMode = 0;
            int totalEscort = 0;
            int totalOneWay = 0;
            float totalModePercent = 0;
            float tempValue = 0;

            while (rs.next()) {
                temp = new FerryOnlyReportItem();

                temp.setMode(rs.getString(1));
                temp.setModeNumber(rs.getString(2));

                tempValue = getValue(rs.getString(3));
                temp.setModePercent(percentFormat.format(tempValue));

                totalMode += Integer.parseInt(temp.getModeNumber());
                totalModePercent += tempValue;

                temp.setEscortNumber(rs.getString(4));
                temp.setEscortPercent(percentFormat.format(getValue(rs.getString(5))));
                totalEscort += Integer.parseInt(temp.getEscortNumber());

                temp.setOneWayNumber(rs.getString(6));
                temp.setOneWayPercent(percentFormat.format(getValue(rs.getString(7))));
                totalOneWay += Integer.parseInt(temp.getOneWayNumber());

                result.add(temp);
            }

            total.setModeNumber(String.valueOf(totalMode));
            total.setModePercent(percentFormat.format(Math.round(totalModePercent)));
            total.setEscortNumber(String.valueOf(totalEscort));
            total.setOneWayNumber(String.valueOf(totalOneWay));

            if (totalMode > 0) {
                total.setEscortPercent(percentFormat.format(((float) totalEscort) / totalMode));
                total.setOneWayPercent(percentFormat.format(((float) totalOneWay) / totalMode));
            } else {
                total.setEscortPercent(percentFormat.format(0));
                total.setOneWayPercent(percentFormat.format(0));
            }

            result.add(total);

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }

        return result;
    }

    @Override
    public List fromRsidenceSummary(Date startDate, Date endDate) {

        ArrayList<FromResidenceReportItem> result = new ArrayList<FromResidenceReportItem>();

        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {

            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.from_residence(?, ?, ?); END;");
            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
            stmt.registerOutParameter(3, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            FromResidenceReportItem temp;
            FromResidenceReportItem total = new FromResidenceReportItem();
            total.setCode("TOTAL");
            rs = (ResultSet) stmt.getObject(3);

            int totalCode = 0;
            float totalCodePercent = 0;
            float tempValue = 0;

            while (rs.next()) {
                temp = new FromResidenceReportItem();

                temp.setCode(rs.getString(1));
                temp.setCodeNumber(rs.getString(2));

                tempValue = getValue(rs.getString(3));
                temp.setCodePercent(percentFormat.format(tempValue));

                totalCode += Integer.parseInt(temp.getCodeNumber());
                totalCodePercent += tempValue;

                result.add(temp);
            }

            if (totalCode > 0) {
                total.setCodeNumber(String.valueOf(totalCode));
                total.setCodePercent(percentFormat.format(Math.round(totalCodePercent)));
            } else {
                total.setCodeNumber("0");
                total.setCodePercent(percentFormat.format(0));
            }

            result.add(total);

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }

        return result;
    }

    @Override
    public List toDestinationSummary(Date startDate, Date endDate) {
        ArrayList<ToDestinationReportItem> result = new ArrayList<ToDestinationReportItem>();

        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {

            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.to_destination(?, ?, ?); END;");
            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
            stmt.registerOutParameter(3, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            ToDestinationReportItem temp;
            ToDestinationReportItem total = new ToDestinationReportItem();
            total.setCode("TOTAL");
            rs = (ResultSet) stmt.getObject(3);

            int totalCode = 0;
            float totalCodePercent = 0;
            float tempValue = 0;

            while (rs.next()) {
                temp = new ToDestinationReportItem();

                temp.setCode(rs.getString(1));
                temp.setCodeNumber(rs.getString(2));

                tempValue = getValue(rs.getString(3));
                temp.setCodePercent(percentFormat.format(tempValue));

                totalCode += Integer.parseInt(temp.getCodeNumber());
                totalCodePercent += tempValue;

                result.add(temp);
            }

            if (totalCode > 0) {
                total.setCodeNumber(String.valueOf(totalCode));
                total.setCodePercent(percentFormat.format(Math.round(totalCodePercent)));
            } else {
                total.setCodeNumber("0");
                total.setCodePercent(percentFormat.format(0));
            }

            result.add(total);

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }

        return result;

    }

    @Override
    public List perPatientSummary(Date startDate, Date endDate, String[] healthAuthorities, String[] clientLHA) {
        ArrayList<PerPatientReportItem> result = new ArrayList<PerPatientReportItem>();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {

            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.conf_per_patient(?, ?, ?, ?, ?); END;");
            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
            stmt.setString(3, combineArray(healthAuthorities));
            stmt.setString(4, combineArray(clientLHA));
            stmt.registerOutParameter(5, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            PerPatientReportItem temp;
            PerPatientReportItem total = new PerPatientReportItem();
            total.setConfPerPatient("TOTAL");
            rs = (ResultSet) stmt.getObject(5);

            int totalPatients = 0;
            int totalConfirmations = 0;
            int totalSeniors = 0;
            int totalPA = 0;
            float totalPatientsPercent = 0;
            float totalConfirmationsPercent = 0;
            float tempValue = 0;

            while (rs.next()) {
                temp = new PerPatientReportItem();

                temp.setConfPerPatient(rs.getString(1));

                temp.setNoOfPatients(rs.getString(2));
                tempValue = getValue(rs.getString(3));
                temp.setNoOfPatientsInPercent(percentFormat.format(tempValue));
                totalPatients += Integer.parseInt(temp.getNoOfPatients());
                totalPatientsPercent += tempValue;

                temp.setTotalConfimations(rs.getString(4));
                tempValue = getValue(rs.getString(5));
                temp.setTotalConfirmationsPercent(percentFormat.format(tempValue));
                totalConfirmations += Integer.parseInt(temp.getTotalConfimations());
                totalConfirmationsPercent += tempValue;

                temp.setNoOfSeniors(rs.getString(6));
                temp.setSeniorsPercent(percentFormat.format(getValue(rs.getString(7))));
                totalSeniors += Integer.parseInt(temp.getNoOfSeniors());

                temp.setNoOnPa(rs.getString(8));
                temp.setPercentOnPa(percentFormat.format(getValue(rs.getString(9))));
                totalPA += Integer.parseInt(temp.getNoOnPa());

                result.add(temp);
            }

            total.setNoOfPatients(String.valueOf(totalPatients));
            total.setNoOfPatientsInPercent(percentFormat.format(Math.round(totalPatientsPercent)));
            total.setTotalConfimations(String.valueOf(totalConfirmations));
            total.setTotalConfirmationsPercent(percentFormat.format(Math.round(totalConfirmationsPercent)));
            total.setNoOfSeniors(String.valueOf(totalSeniors));
            total.setSeniorsPercent(percentFormat.format((float) totalSeniors / totalPatients));
            total.setNoOnPa(String.valueOf(totalPA));
            total.setPercentOnPa(percentFormat.format((float) totalPA / totalPatients));

            result.add(total);

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }

        return result;
    }

    @Override
    public List patientAndSpecialistSummary(Date startDate, Date endDate, String[] countRanges, String[] clientHA, String[] clientLHA, String[] specialistHA, String[] specialistLHA) {
        ArrayList<PatientSpecialistReportItem> result = new ArrayList<PatientSpecialistReportItem>();

        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {

            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.patient_specialist(?, ?, ?, ?, ?, ?, ?, ?); END;");
            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
            stmt.setString(3, combineArray(countRanges));
            stmt.setString(4, combineArray(clientHA));
            stmt.setString(5, combineArray(clientLHA));
            stmt.setString(6, combineArray(specialistHA));
            stmt.setString(7, combineArray(specialistLHA));
            stmt.registerOutParameter(8, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            PatientSpecialistReportItem temp;
            PatientSpecialistReportItem total = new PatientSpecialistReportItem();
            total.setMode("TOTAL");
            rs = (ResultSet) stmt.getObject(8);

            int totalMode = 0;
            int totalEscort = 0;
            int totalOneWay = 0;
            float totalModePercent = 0;
            float tempValue = 0;
            String strTempValue;

            while (rs.next()) {
                temp = new PatientSpecialistReportItem();

                temp.setMode(rs.getString(1));
                temp.setModeNumber(rs.getString(2));

                tempValue = getValue(rs.getString(3));
                temp.setModePercent(percentFormat.format(tempValue));

                totalMode += Integer.parseInt(temp.getModeNumber());
                totalModePercent += tempValue;

                temp.setEscortNumber(rs.getString(4));
                temp.setEscortPercent(percentFormat.format(getValue(rs.getString(5))));
                totalEscort += Integer.parseInt(temp.getEscortNumber());

                temp.setOneWayNumber(rs.getString(6));
                temp.setOneWayPercent(percentFormat.format(getValue(rs.getString(7))));
                totalOneWay += Integer.parseInt(temp.getOneWayNumber());

                temp.setVehicleNumber(getValueItem(rs.getString(8)));
                strTempValue = getValueItem(rs.getString(9));

                if (strTempValue.length() > 0) {
                    temp.setVehiclePercent(percentFormat.format(getValue(strTempValue)));
                } else {
                    temp.setVehiclePercent(strTempValue);
                }

                result.add(temp);

            }

            total.setModeNumber(String.valueOf(totalMode));
            total.setModePercent(percentFormat.format(Math.round(totalModePercent)));
            total.setEscortNumber(String.valueOf(totalEscort));
            total.setOneWayNumber(String.valueOf(totalOneWay));

            if (totalMode > 0) {
                total.setEscortPercent(percentFormat.format(((float) totalEscort) / totalMode));
                total.setOneWayPercent(percentFormat.format(((float) totalOneWay) / totalMode));
            } else {
                total.setEscortPercent(percentFormat.format(0));
                total.setOneWayPercent(percentFormat.format(0));
            }

            result.add(total);

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }

        return result;
    }

    @Override
    public List whyReport(Date startDate, Date endDate, String[] healthAuthorities, String[] clientLHA) {
        ArrayList<WhyReportItem> result = new ArrayList<>();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {

            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.why_ferry_only(?, ?, ?, ?, ?); END;");
            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
            stmt.setString(3, combineArray(healthAuthorities));
            stmt.setString(4, combineArray(clientLHA));
            stmt.registerOutParameter(5, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();
            rs = (ResultSet) stmt.getObject(5);

            WhyReportItem temp;

            int phnCount = 0;
            int grandTotalConfirmations = 0;
            int totalConfirmationsForEachLHA = 0;
            int totalConfirmationsForEachPHN = 0;
            int uniquePHNCountByPatientLHA = 0;
            int lastPatientLHACount = 0;
            int lastSpecialistLHACount = 0;
            String lastPHN = "";
            String lastPatientLHA = "";
            String lastSpecialistLHA = "";

            WhyReportItem grandTotalIteration = new WhyReportItem(true);
            WhyReportItem currentLHAIteration = new WhyReportItem(true);
            WhyReportItem currentPHNIteration = new WhyReportItem(true);

            while (rs.next()) {
                temp = new WhyReportItem();
                String phn = rs.getString(1);
                String patientLHA = rs.getString(3);
                String specialistLHA = rs.getString(5);

                if (phnCount == 0) {
                    temp.setMiscellaneuous(String.valueOf(++phnCount));
                    uniquePHNCountByPatientLHA++;

                } else if (!lastPHN.isEmpty() && !lastPHN.equals(phn)) {
                    // Different PHN, but the same patient LHA, add subtotal entry for PHN
                    // Only add a subtotal if we have more than one entry                                      

                    currentPHNIteration.setNoOfConfirmations(String.valueOf(totalConfirmationsForEachPHN));

                    if (!lastPatientLHA.isEmpty() && lastPatientLHA.equals(patientLHA)) {
                        uniquePHNCountByPatientLHA++;
                    }

                    totalConfirmationsForEachLHA += totalConfirmationsForEachPHN;
                    currentLHAIteration.addChild(currentPHNIteration);
                    currentPHNIteration = new WhyReportItem(true);
                    totalConfirmationsForEachPHN = 0;
                    lastPatientLHACount = 0;
                    lastSpecialistLHACount = 0;
                    temp.setMiscellaneuous(String.valueOf(++phnCount));

                }

                if (!lastPatientLHA.isEmpty() && !lastPatientLHA.equals(patientLHA)) {
                    // Different patient LHA means we are starting another group of Patient LHA, 
                    // then add subtotal entry for the last Patient LHA group

                    currentLHAIteration.setMiscellaneuous("Total " + lastPatientLHA + " " + uniquePHNCountByPatientLHA);
                    currentLHAIteration.setNoOfConfirmations(String.valueOf(totalConfirmationsForEachLHA));
                    grandTotalIteration.addChild(currentLHAIteration);
                    uniquePHNCountByPatientLHA = 1;
                    lastPatientLHACount = 0;
                    lastSpecialistLHACount = 0;
                    totalConfirmationsForEachLHA = 0;
                    currentLHAIteration = new WhyReportItem(true);

                } else if (!lastSpecialistLHA.isEmpty() && !lastSpecialistLHA.equals(specialistLHA)) {
                    // Different PHN, but the same patient LHA, add subtotal entry for PHN
                    // Only add a subtotal if we have more than one entry
                    if (lastSpecialistLHACount > 1 && uniquePHNCountByPatientLHA > 1) {
                        WhyReportItem subTotalByPhysicianLHA = new WhyReportItem();
                        subTotalByPhysicianLHA.setNoOfConfirmations(String.valueOf(totalConfirmationsForEachPHN));
                        currentPHNIteration.addChild(subTotalByPhysicianLHA);
                    }

                    lastSpecialistLHACount = 0;
                }

                temp.setPremiumAssistance(rs.getString(2));
                temp.setPatientLHA(rs.getString(3));
                temp.setReferringPhysicianNumber(rs.getString(4));
                temp.setSpecialistLHA(rs.getString(5));
                //temp.setSpecialistNumber(rs.getString(6));
                temp.setSpecialistSpecialty(rs.getString(7));
                temp.setNoOfConfirmations(rs.getString(8));

                totalConfirmationsForEachPHN += rs.getInt(8);
                grandTotalConfirmations += rs.getInt(8);
                lastPatientLHACount++;
                lastSpecialistLHACount++;
                lastPHN = phn;
                lastPatientLHA = patientLHA;
                lastSpecialistLHA = specialistLHA;

                currentPHNIteration.addChild(temp);
            }

            // Remember to process the last record in the record set just like
            // the ones processed in the while loop above
            totalConfirmationsForEachLHA += totalConfirmationsForEachPHN;

            if (lastSpecialistLHACount > 0 || lastPatientLHACount > 0) {
                currentPHNIteration.setNoOfConfirmations(String.valueOf(totalConfirmationsForEachPHN));
                currentLHAIteration.addChild(currentPHNIteration);
            }

            if (!currentLHAIteration.getChildren().isEmpty()) {
                currentLHAIteration.setMiscellaneuous("Total " + lastPatientLHA + " " + uniquePHNCountByPatientLHA);
                currentLHAIteration.setNoOfConfirmations(String.valueOf(totalConfirmationsForEachLHA));
                grandTotalIteration.addChild(currentLHAIteration);

                grandTotalIteration.setMiscellaneuous("Total " + phnCount);
                grandTotalIteration.setNoOfConfirmations(String.valueOf(grandTotalConfirmations));
            }

            // If no data is returned, then add a record showing no data
            if (grandTotalIteration.getChildren().isEmpty()) {
                grandTotalIteration.setMiscellaneuous(NO_DATA);
            }

            result.add(grandTotalIteration);

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }

        return result;
    }

//    @Override
//    public List whyReport(Date startDate, Date endDate, String[] healthAuthorities, String[] clientLHA) {
//        ArrayList<WhyReportItem> result = new ArrayList<>();
//        Connection conn = null;
//        CallableStatement stmt = null;
//        ResultSet rs = null;
//
//        try {
//
//            conn = ds.getConnection();
//            stmt = conn.prepareCall("BEGIN REPORTS.why_ferry_only(?, ?, ?, ?, ?); END;");
//            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
//            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
//            stmt.setString(3, combineArray(healthAuthorities));
//            stmt.setString(4, combineArray(clientLHA));
//            stmt.registerOutParameter(5, OracleTypes.CURSOR); //REF CURSOR
//            stmt.execute();
//            rs = (ResultSet) stmt.getObject(5);
//
//            WhyReportItem temp;
//
//            int phnCount = 0;
//            int grandTotalConfirmations = 0;
//            int totalConfirmationsForEachPHN = 0;
//            int uniquePHNCountByPatientLHA = 0;
//            int lastPatientLHACount = 0;
//            int lastSpecialistLHACount = 0;
//            String lastPHN = "";
//            String lastPatientLHA = "";
//            String lastSpecialistLHA = "";
//
//            while (rs.next()) {
//                temp = new WhyReportItem();
//                String phn = rs.getString(1);
//                String patientLHA = rs.getString(3);
//                String specialistLHA = rs.getString(5);
//
//                if (phnCount == 0) {
//                    temp.setMiscellaneuous(String.valueOf(++phnCount));
//                    uniquePHNCountByPatientLHA++;
//                    //      phns.add(key);
//                } else if (!lastPHN.isEmpty() && !lastPHN.equals(phn)) {
//                    // Different PHN, but the same patient LHA, add subtotal entry for PHN
//                    // Only add a subtotal if we have more than one entry
//
//                    if ((lastPatientLHACount > 1 && uniquePHNCountByPatientLHA > 1) || lastPatientLHA.equals(patientLHA)) {
//                        WhyReportItem subTotalByPHN = new WhyReportItem();
//                        subTotalByPHN.setNoOfConfirmations(String.valueOf(totalConfirmationsForEachPHN));
//                        result.add(subTotalByPHN);
//                        uniquePHNCountByPatientLHA++;
//                    }
//
//                    totalConfirmationsForEachPHN = 0;
//                    lastPatientLHACount = 0;
//                    lastSpecialistLHACount = 0;
//                    temp.setMiscellaneuous(String.valueOf(++phnCount));
//
//                }
//
//                if (!lastPatientLHA.isEmpty() && !lastPatientLHA.equals(patientLHA)) {
//                    // Different patient LHA means we are starting another group of Patient LHA, 
//                    // then add subtotal entry for the last Patient LHA group
//                    WhyReportItem subTotalByPatientLHA = new WhyReportItem();
//                    subTotalByPatientLHA.setMiscellaneuous("Total " + lastPatientLHA + " " + uniquePHNCountByPatientLHA);
//                    subTotalByPatientLHA.setNoOfConfirmations(String.valueOf(totalConfirmationsForEachPHN));
//                    lastPatientLHACount = 0;
//                    lastSpecialistLHACount = 0;
//                    totalConfirmationsForEachPHN = 0;
//                    result.add(subTotalByPatientLHA);
//
//                } else if (!lastSpecialistLHA.isEmpty() && !lastSpecialistLHA.equals(specialistLHA)) {
//                    // Different PHN, but the same patient LHA, add subtotal entry for PHN
//                    // Only add a subtotal if we have more than one entry
//                    if (lastSpecialistLHACount > 1 && uniquePHNCountByPatientLHA > 1) {
//                        WhyReportItem subTotalByPhysicianLHA = new WhyReportItem();
//                        subTotalByPhysicianLHA.setNoOfConfirmations(String.valueOf(totalConfirmationsForEachPHN));
//                        result.add(subTotalByPhysicianLHA);
//                    }
//
//                    lastSpecialistLHACount = 0;
//                }
//
//
//                temp.setPremiumAssistance(rs.getString(2));
//                temp.setPatientLHA(rs.getString(3));
//                temp.setReferringPhysicianNumber(rs.getString(4));
//                temp.setSpecialistLHA(rs.getString(5));
//                //temp.setSpecialistNumber(rs.getString(6));
//                temp.setSpecialistSpecialty(rs.getString(7));
//                temp.setNoOfConfirmations(rs.getString(8));
//
//                totalConfirmationsForEachPHN += rs.getInt(8);
//                grandTotalConfirmations += rs.getInt(8);
//                lastPatientLHACount++;
//                lastSpecialistLHACount++;
//                lastPHN = phn;
//                lastPatientLHA = patientLHA;
//                lastSpecialistLHA = specialistLHA;
//
//
//                result.add(temp);
//            }
//
//
//
//            if (lastSpecialistLHACount > 1 || lastPatientLHACount > 1) {
//                temp = new WhyReportItem();
//                temp.setNoOfConfirmations(String.valueOf(totalConfirmationsForEachPHN));
//                result.add(temp);
//            }
//
//            temp = new WhyReportItem();
//            temp.setMiscellaneuous("Total " + lastPatientLHA + " " + uniquePHNCountByPatientLHA);
//            temp.setNoOfConfirmations(String.valueOf(grandTotalConfirmations));
//            result.add(temp);
//
//
//
//            temp = new WhyReportItem();
//            temp.setMiscellaneuous("Total " + phnCount);
//            temp.setNoOfConfirmations(String.valueOf(grandTotalConfirmations));
//            result.add(temp);
//
//            if (result.isEmpty()) {
//                temp = new WhyReportItem();
//                temp.setMiscellaneuous(NO_DATA);
//                result.add(temp);
//            }
//
//        } catch (Exception e) {
//            e.printStackTrace();
//        } finally {
//            cleanup(conn, stmt, rs);
//        }
//
//        return result;
//    }
    @Override
    public List frequencyReport(Date startDate, Date endDate, String[] healthAuthorities, String[] clientLHA) {
        ArrayList<FrequencyReportItem> result = new ArrayList<>();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {

            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.frequency(?, ?, ?, ?, ?); END;");
            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
            stmt.setString(3, combineArray(healthAuthorities));
            stmt.setString(4, combineArray(clientLHA));
            stmt.registerOutParameter(5, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();
            rs = (ResultSet) stmt.getObject(5);

            FrequencyReportItem temp;
            List<FrequencyReportItem> currentIteration = new ArrayList<>();
            FrequencyReportItem greaterThan30 = new FrequencyReportItem(true);
            FrequencyReportItem greaterThan20 = new FrequencyReportItem(true);
            FrequencyReportItem greaterThan10 = new FrequencyReportItem(true);
            int currentFiscalTotal = 0;
            int currentFiscal_1Total = 0;
            int currentFiscal_2Total = 0;
            int currentFiscal_3Total = 0;

            String lastPHN = "";

            while (rs.next()) {
                temp = new FrequencyReportItem();
                String phn = rs.getString(1);

                if (lastPHN.isEmpty()) { // execute if we are on the first record
                    temp.setMiscellaneuous(String.valueOf(phn));
                } else if (!lastPHN.equals(phn)) {

                    // If the current PHN is different from the one for the last record
                    // then we need to add subtotal for the last PHN
                    temp = new FrequencyReportItem(true);
                    temp.setMiscellaneuous(" Total " + lastPHN);
                    temp.setCurrentFiscalCount(String.valueOf(currentFiscalTotal));
                    temp.setCurrentFiscal_1Count(String.valueOf(currentFiscal_1Total));
                    temp.setCurrentFiscal_2Count(String.valueOf(currentFiscal_2Total));
                    temp.setCurrentFiscal_3Count(String.valueOf(currentFiscal_3Total));
                    temp.addChildren(currentIteration);

                    // Add phn set to the right category based on number of visits
                    if (currentFiscalTotal > 30) {
                        greaterThan30.addChild(temp);
                    } else if (currentFiscalTotal > 20) {
                        greaterThan20.addChild(temp);
                    } else if (currentFiscalTotal > 10) {
                        greaterThan10.addChild(temp);
                    }

                    // Reset all variable for each set of records for a PHN
                    currentIteration.clear();
                    currentFiscalTotal = 0;
                    currentFiscal_1Total = 0;
                    currentFiscal_2Total = 0;
                    currentFiscal_3Total = 0;

                    temp = new FrequencyReportItem();
                    temp.setMiscellaneuous(phn);

                }

                lastPHN = phn;

                currentFiscalTotal += rs.getInt(7);
                currentFiscal_1Total += rs.getInt(8);
                currentFiscal_2Total += rs.getInt(9);
                currentFiscal_3Total += rs.getInt(10);

                temp.setPatientLHA(rs.getString(2));
                temp.setReferringPhysicianNumber(rs.getString(3));
                temp.setSpecialistLHA(rs.getString(4));
                temp.setSpecialistNumber(rs.getString(5));
                temp.setSpecialistSpecialty(rs.getString(6));
                temp.setCurrentFiscalCount(rs.getString(7));
                temp.setCurrentFiscal_1Count(rs.getString(8));
                temp.setCurrentFiscal_2Count(rs.getString(9));
                temp.setCurrentFiscal_3Count(rs.getString(10));

                currentIteration.add(temp);
            }

            // We need to process the last record just like within the while loop
            // to ensure it is included in the result to be sent to the caller
            temp = new FrequencyReportItem(true);
            temp.setMiscellaneuous(" Total " + lastPHN);
            temp.setCurrentFiscalCount(String.valueOf(currentFiscalTotal));
            temp.setCurrentFiscal_1Count(String.valueOf(currentFiscal_1Total));
            temp.setCurrentFiscal_2Count(String.valueOf(currentFiscal_2Total));
            temp.setCurrentFiscal_3Count(String.valueOf(currentFiscal_3Total));
            temp.addChildren(currentIteration);

            if (currentFiscalTotal > 30) {
                greaterThan30.addChild(temp);
            } else if (currentFiscalTotal > 20) {
                greaterThan20.addChild(temp);
            } else if (currentFiscalTotal > 10) {
                greaterThan10.addChild(temp);
            }

            // We only want a category added to the result if we have data for that category
            if (!greaterThan30.getChildren().isEmpty()) {
                greaterThan30.setMiscellaneuous("Total > 30");
                result.add(greaterThan30);
            }

            if (!greaterThan20.getChildren().isEmpty()) {
                greaterThan20.setMiscellaneuous("Total > 20");
                result.add(greaterThan20);
            }

            if (!greaterThan10.getChildren().isEmpty()) {
                greaterThan10.setMiscellaneuous("Total > 10");
                result.add(greaterThan10);
            }

            // What if we have no data for any of the categories, then we add a record
            // to show no data available
            if (result.isEmpty()) {
                temp = new FrequencyReportItem();
                temp.setMiscellaneuous(NO_DATA);
                result.add(temp);
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }
        return result;
    }

    @Override
    public List travelForWhatServiceReport(Date startDate, Date endDate, String[] healthAuthorities, String[] clientLHA) {
        ArrayList<TravelForWhatServiceItem> result = new ArrayList<>();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {
            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.travel_for_what(?, ?, ?, ?, ?); END;");
            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
            System.out.println(combineArray(healthAuthorities));
            stmt.setString(3, combineArray(healthAuthorities));
            stmt.setString(4, combineArray(clientLHA));
            stmt.registerOutParameter(5, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();
            rs = (ResultSet) stmt.getObject(5);

            TravelForWhatServiceItem temp;

            String lastHA = "";
            String lastLHA = "";
            String lastSPEC = "";

            while (rs.next()) {
                temp = new TravelForWhatServiceItem();

                String HA = rs.getString(1);
                String LHA = rs.getString(2);
                String SPEC = rs.getString(3);
                int CONF = rs.getInt(4);

                if (lastHA.equals(HA) == false) {
                    lastHA = HA;
                    lastLHA = "";
                    lastSPEC = "";

                    temp.setHA(HA);
                }
                if (lastLHA.equals(LHA) == false) {
                    lastLHA = LHA;
                    lastSPEC = "";

                    temp.setLHA(LHA);
                }
                if (lastSPEC.equals(SPEC) == false) {
                    lastSPEC = SPEC;

                    temp.setSPEC(SPEC);
                }

                temp.setCONF(CONF);

                result.add(temp);
            }

            // What if we have no data for any of the categories, then we add a record
            // to show no data available
            if (result.isEmpty()) {
                temp = new TravelForWhatServiceItem();
                temp.setHA(NO_DATA);
                result.add(temp);
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }

        int LHA_count = 0;
        int last = 0;

        for (int c = 0; c < result.size(); c++) {
            boolean reset = false;

            if (result.get(c).getHA().isEmpty() == false) {
                reset = true;
            }

            if (result.get(c).getLHA().isEmpty() == false) {
                reset = true;
            }

            if (reset == true) {
                for (int d = last; d < c; d++) {
                    result.get(d).setLHA_count(LHA_count);
                }

                LHA_count = 0;
                last = c;
            }

            LHA_count += result.get(c).getCONF();
        }

        for (int d = last; d < result.size(); d++) {
            result.get(d).setLHA_count(LHA_count);
        }

        for (int c = 0; c < result.size(); c++) {
            int CONF = result.get(c).getCONF();
            LHA_count = result.get(c).getLHA_count();
            result.get(c).setPercent(String.format("%.1f%%", (float) CONF / LHA_count * 100));
        }

        return result;
    }

//    @Override
//    public List frequencyReport(Date startDate, Date endDate, String[] healthAuthorities, String[] clientLHA) {
//        ArrayList<FrequencyReportItem> result = new ArrayList<>();
//        Connection conn = null;
//        CallableStatement stmt = null;
//        ResultSet rs = null;
//
//        try {
//
//            conn = ds.getConnection();
//            stmt = conn.prepareCall("BEGIN REPORTS.frequency(?, ?, ?, ?, ?); END;");
//            stmt.setDate(1, new java.sql.Date(startDate.getTime()));
//            stmt.setDate(2, new java.sql.Date(endDate.getTime()));
//            stmt.setString(3, combineArray(healthAuthorities));
//            stmt.setString(4, combineArray(clientLHA));
//            stmt.registerOutParameter(5, OracleTypes.CURSOR); //REF CURSOR
//            stmt.execute();
//            rs = (ResultSet) stmt.getObject(5);
//
//            FrequencyReportItem temp;
//            List<FrequencyReportItem> currentIteration = new ArrayList<>();
//            List<FrequencyReportItem> greaterThan30 = new ArrayList<>();
//            List<FrequencyReportItem> greaterThan20 = new ArrayList<>();
//            List<FrequencyReportItem> greaterThan10 = new ArrayList<>();
//            int currentFiscalTotal = 0;
//            int currentFiscal_1Total = 0;
//            int currentFiscal_2Total = 0;
//            int currentFiscal_3Total = 0;
//
//            String lastPHN = "";
//
//            while (rs.next()) {
//                temp = new FrequencyReportItem();
//                String phn = rs.getString(1);
//
//                if (lastPHN.isEmpty()) {
//                    temp.setMiscellaneuous(String.valueOf(phn));
//                } else if (!lastPHN.equals(phn)) {
//
//                    temp.setMiscellaneuous(" Total " + lastPHN);
//                    temp.setCurrentFiscalCount(String.valueOf(currentFiscalTotal));
//                    temp.setCurrentFiscal_1Count(String.valueOf(currentFiscal_1Total));
//                    temp.setCurrentFiscal_2Count(String.valueOf(currentFiscal_2Total));
//                    temp.setCurrentFiscal_3Count(String.valueOf(currentFiscal_3Total));
//                    currentIteration.add(temp);
//
//                    if (currentFiscalTotal > 30) {
//                        greaterThan30.addAll(currentIteration);
//                    } else if (currentFiscalTotal > 20) {
//                        greaterThan20.addAll(currentIteration);
//                    } else if (currentFiscalTotal > 10) {
//                        greaterThan10.addAll(currentIteration);
//                    }
//
//                    currentIteration.clear();
//                    currentFiscalTotal = 0;
//                    currentFiscal_1Total = 0;
//                    currentFiscal_2Total = 0;
//                    currentFiscal_3Total = 0;
//
//                    temp = new FrequencyReportItem();
//                    temp.setMiscellaneuous(phn);
//
//                }
//
//                lastPHN = phn;
//
//                currentFiscalTotal += rs.getInt(7);
//                currentFiscal_1Total += rs.getInt(8);
//                currentFiscal_2Total += rs.getInt(9);
//                currentFiscal_3Total += rs.getInt(10);
//
//                temp.setPatientLHA(rs.getString(2));
//                temp.setReferringPhysicianNumber(rs.getString(3));
//                temp.setSpecialistLHA(rs.getString(4));
//                temp.setSpecialistNumber(rs.getString(5));
//                temp.setSpecialistSpecialty(rs.getString(6));
//                temp.setCurrentFiscalCount(rs.getString(7));
//                temp.setCurrentFiscal_1Count(rs.getString(8));
//                temp.setCurrentFiscal_2Count(rs.getString(9));
//                temp.setCurrentFiscal_3Count(rs.getString(10));
//
//
//                currentIteration.add(temp);
//            }
//
//
//            if (currentFiscalTotal > 30) {
//                greaterThan30.addAll(currentIteration);
//            } else if (currentFiscalTotal > 20) {
//                greaterThan20.addAll(currentIteration);
//            } else if (currentFiscalTotal > 10) {
//                greaterThan10.addAll(currentIteration);
//            }
//
//            if (!greaterThan30.isEmpty()) {
//                temp = new FrequencyReportItem();
//                greaterThan30.add(temp);
//                temp = new FrequencyReportItem();
//                temp.setMiscellaneuous("Total > 30");
//                greaterThan30.add(temp);
//                temp = new FrequencyReportItem();
//                greaterThan30.add(temp);
//                result.addAll(greaterThan30);
//            }
//
//            if (!greaterThan20.isEmpty()) {
//                temp = new FrequencyReportItem();
//                greaterThan20.add(temp);
//                temp = new FrequencyReportItem();
//                temp.setMiscellaneuous("Total > 20");
//                greaterThan20.add(temp);
//                temp = new FrequencyReportItem();
//                greaterThan20.add(temp);
//                result.addAll(greaterThan20);
//            }
//
//            if (!greaterThan10.isEmpty()) {
//                temp = new FrequencyReportItem();
//                greaterThan10.add(temp);
//                temp = new FrequencyReportItem();
//                temp.setMiscellaneuous("Total > 10");
//                greaterThan10.add(temp);
//                temp = new FrequencyReportItem();
//                greaterThan10.add(temp);
//                result.addAll(greaterThan10);
//            }
//
//            if (result.isEmpty()) {
//                temp = new FrequencyReportItem();
//                temp.setMiscellaneuous(NO_DATA);
//                result.add(temp);
//            }
//
//        } catch (Exception e) {
//            e.printStackTrace();
//        } finally {
//            cleanup(conn, stmt, rs);
//        }
//
//        return result;
//    }
    @Override
    public String lastDataUpdate() {

        String result = null;
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;
        DateFormat dfmt = new SimpleDateFormat("MMMM dd, yyyy");

        try {
            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.last_data_update(?); END;");
            stmt.registerOutParameter(1, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            rs = (ResultSet) stmt.getObject(1);

            while (rs.next()) {
                result = dfmt.format(rs.getDate(1));
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }
        return result;

    }

    @Override
    public List<String> reportDateRanges() {
        List<String> result = new ArrayList<String>();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {
            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.date_ranges(?); END;");
            stmt.registerOutParameter(1, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            Calendar reportStartDate = Calendar.getInstance();
            Calendar reportEndDate = Calendar.getInstance();
            rs = (ResultSet) stmt.getObject(1);

            rs.next();
            reportStartDate.setTimeInMillis(rs.getDate(1).getTime());
            reportEndDate.setTimeInMillis(rs.getDate(2).getTime());

            int startYear = reportStartDate.get(Calendar.YEAR);
            int endYear = reportEndDate.get(Calendar.YEAR);
            int startMonth = reportStartDate.get(Calendar.MONTH);
            int endMonth = reportEndDate.get(Calendar.MONTH);

            // Process every year from the start year to the end year of data
            for (int i = startYear; i <= endYear; i++) {
                //for (int i = startYear; i <= startYear + (endYear - startYear); i++) {

                // if this is the start year
                if (i == startYear) {

                    // and the end month is before April then add the entry
                    // from October the previous year
                    if (startMonth < Calendar.APRIL) {
                        result.add("JANUARY 1 " + i + " - MARCH 31 " + i);
                    }

                    // and we have only one year's worth of data
                    if (endYear == startYear) {

                        if (endMonth > Calendar.MARCH) {
                            result.add("APRIL 1 " + i + " - JUNE 30 " + i);
                        }

                        if (endMonth > Calendar.JUNE) {
                            result.add("JULY 1 " + i + " - SEPTEMBER 30 " + i);
                        }

                        if (endMonth > Calendar.SEPTEMBER) {
                            result.add("OCTOBER 1 " + i + " - DECEMBER 31 " + i);
                        }

                        // Add yearly date range
                        if (endMonth > Calendar.MARCH) {
                            result.add("APRIL 1 " + i + " - MARCH 31 " + (i + 1));
                        }

                        break;

                    }
                }

                if (i == endYear) {
                    // if this is the final year

                    result.add("JANUARY 1 " + i + " - MARCH 31 " + i);

                    if (endMonth > Calendar.MARCH) {
                        result.add("APRIL 1 " + i + " - JUNE 30 " + i);
                    }

                    if (endMonth > Calendar.JUNE) {
                        result.add("JULY 1 " + i + " - SEPTEMBER 30 " + i);
                    }

                    if (endMonth > Calendar.SEPTEMBER) {
                        result.add("OCTOBER 1 " + i + " - DECEMBER 31 " + i);
                    }

                    // Add yearly date range
                    if (endMonth > Calendar.MARCH) {
                        result.add("APRIL 1 " + i + " - MARCH 31 " + (i + 1));
                    }

                    continue;
                }

                if (i != startYear) {
                    result.add("JANUARY 1 " + i + " - MARCH 31 " + i);
                }

                result.add("APRIL 1 " + i + " - JUNE 30 " + i);
                result.add("JULY 1 " + i + " - SEPTEMBER 30 " + i);
                result.add("OCTOBER 1 " + i + " - DECEMBER 31 " + i);

                // Yearly range
                result.add("APRIL 1 " + i + " - MARCH 31 " + (i + 1));

            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }
        return result;
    }

    @Override
    public Map<String, Object> retrieveHealthAuthorities() {

        Map<String, Object> result = new LinkedHashMap<String, Object>();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {
            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.health_authorities(?); END;");
            stmt.registerOutParameter(1, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            rs = (ResultSet) stmt.getObject(1);

            while (rs.next()) {
                result.put(rs.getString(2), rs.getString(1));
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }
        return result;

    }

    public Map<String, Object> retrieveSpecialistHAs() {

        Map<String, Object> result = new LinkedHashMap<String, Object>();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {
            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.specialist_ha(?); END;");
            stmt.registerOutParameter(1, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            rs = (ResultSet) stmt.getObject(1);

            while (rs.next()) {
                result.put(rs.getString(2), rs.getString(1));
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }
        return result;

    }

    @Override
    public Map<String, Object> retrieveCountRanges() {

        Map<String, Object> result = new LinkedHashMap<String, Object>();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {
            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.count_ranges(?); END;");
            stmt.registerOutParameter(1, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            rs = (ResultSet) stmt.getObject(1);

            while (rs.next()) {
                result.put(rs.getString(2), rs.getString(1));
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }
        return result;

    }

    @Override
    public Map<String, Object> retrieveLHAs() {

        Map<String, Object> result = new LinkedHashMap<String, Object>();
        Connection conn = null;
        CallableStatement stmt = null;
        ResultSet rs = null;

        try {
            conn = ds.getConnection();
            stmt = conn.prepareCall("BEGIN REPORTS.lhas(?); END;");
            stmt.registerOutParameter(1, OracleTypes.CURSOR); //REF CURSOR
            stmt.execute();

            rs = (ResultSet) stmt.getObject(1);

            while (rs.next()) {
                result.put(rs.getString(2), rs.getString(1));
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            cleanup(conn, stmt, rs);
        }
        return result;

    }

    private void cleanup(Connection conn, CallableStatement stmt, ResultSet rs) {
        try {
            if (rs != null) {
                rs.close();
                rs = null;
            }

            if (stmt != null) {
                stmt.close();
                stmt = null;
            }

            if (conn != null) {
                conn.close();
                conn = null;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private float getValue(String value) {

        if (value == null || value.length() == 0) {
            return 0;
        }
        return Float.parseFloat(value);
    }

    private String getValueItem(String value) {

        if (value == null || value.length() == 0) {
            return "";
        }
        return value;
    }

    private String combineArray(String[] choices) {

        StringBuilder builder = new StringBuilder();

        if (choices != null && choices.length > 0) {

            for (String s : choices) {
                builder.append(s).append(";");
            }

            if (builder.length() > 0) {
                builder.delete(builder.length() - 1, builder.length());
            }
        }

        return builder.toString();
    }
}
