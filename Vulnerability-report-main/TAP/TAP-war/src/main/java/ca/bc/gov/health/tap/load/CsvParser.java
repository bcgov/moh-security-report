/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        CsvParser.java                                 *
 * Date of Last Commit: $Date::                                              $ *
 * Revision Number:      $Rev::                                              $ *
 * Last Commit by:    $Author::                                              $ *
 *                                                                             *
 *******************************************************************************/

package ca.bc.gov.health.tap.load;

import au.com.bytecode.opencsv.CSVReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Utility class to parse CVS files in preparation for importing into the database.
 *
 * @author greg.perkins
 */
public class CsvParser {

    private static final String CLASSNAME = CsvParser.class.getSimpleName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);
    /**
     * DateFormat for parsing dates
     */
    private static DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

    /**
     * Column indicies with dates that must be parsed
     */
    private static final List<Integer> dateColumns;

    /**
     * The maximum number of records that we can store in memory at an instance
     */
    private static final int MAX_RECORD_LIMIT = 1000;

    /**
     * The number of records that we want to store in memory at an instance
     */
    private static final int RECORD_LIMIT = 100;

    private CSVReader reader;

    static {
        dateColumns = new ArrayList<>();
        dateColumns.add(0);
        dateColumns.add(21);
        dateColumns.add(22);
    }

    public CsvParser(Reader is) {
        reader = new CSVReader(is);
    }

    public CsvParser(String fileContents) {
        reader = new CSVReader(new StringReader(fileContents));
    }
    /**
     * Column names for destination table
     */
    private static final String[] COLUMN_NAMES = new String[]{
        "APPRVL_DT", "CNFRMTN_NMBR", "PRSNL_HLTH_NMBR", "FRM_CTY", "PSTL_CD", "LHA_CD", "HLTH_ATHRTY",
        "RFRNG_PRCTNR_NMBR", "RFRNG_PRCTNR_CTY", "RFRNG_PRC_SPCLTY1", "RFRNG_PRC_SPCLTY2", "RFRNG_PRCTNR_LHA",
        "SPCLST_PRCTNR_NMBR", "SPCLST_CTY", "SPCLST_LHA", "SPCLST_SPCLTY_1", "SPCLST_SPCLTY_2", "TRVL_MD",
        "ESCRT", "ONE_WY", "VHCL", "APNTMNT_DT", "CLNT_BRTH_DT", "GRP_NMBR_1", "ADJSTD_RT_CD_1", "GRP_NMBR_2",
        "ADJSTD_RT_CD_2", "GRP_NMBR_3", "ADJSTD_RT_CD_3", "ACTN", "PRMM_AST", "RJCT_RSN", "BYPS_CD", "RFRNG_PRCTNR_HA",
        "SPCLST_HA"
    };

    /**
     * Parses the the csv content specified in the constructor.
     *
     * @param batchSize An integer representing number of records we want to read.
     *                  If the batchSize is negative, it defaults to 100. If it is
     *                  more than 1000, it is restricted to 1000.
     * @param skip The number of lines to skip at the start of this read operation.
     *             If value specified is negative, it defaults to 0.
     * @return A list of Object array
     * @throws java.io.IOException
     */
    public List<Object[]> parse(int batchSize, int skip) throws IOException {

        int recsToRead = 0;
        if (batchSize > 0) {
            if (batchSize <= MAX_RECORD_LIMIT) {
                recsToRead = batchSize;
            } else {
                recsToRead = MAX_RECORD_LIMIT;
            }
        } else {
            recsToRead = RECORD_LIMIT;
        }

        List<Object[]> lines = new ArrayList<>(batchSize);

        if (skip < 0) {
            skip = 0;
        }

        String[] nextLine;

        if (skip > 0) {

            for (int i = 0; i < skip; i++) {
                nextLine = reader.readNext();
                if (nextLine == null) {
                    break;
                }
            }
        }

        for (int i = 0; i < recsToRead; i++) {
            nextLine = reader.readNext();

            if (nextLine == null) {
                break;
            }

            trim(nextLine);
            Object[] row = parseLine(nextLine);
            lines.add(row);
        }

        return lines;
    }

    /**
     * Parses the the csv content specified in the constructor.
     *
     * @param batchSize An integer representing number of records we want to read
     *                  If the batchSize is negative, it defaults to 10. If it is
     *                  more than 1000, it is restricted to 1000.
     * @return A list of Object array
     * @throws java.io.IOException
     */
    public List<Object[]> parse(int batchSize) throws IOException {
        return parse(batchSize, 0);

    }

    /**
     * Parses the the csv content specified in the constructor.
     *
     * @return
     * @throws java.io.IOException
     */
    public List<Object[]> parse() throws IOException {
        return parse(0);

    }

    /**
     * Removes trailing spaces from every element in the array
     *
     * @param values
     */
    public static void trim(String[] values) {

        for (int i = 0; i < values.length; i++) {
            values[i] = values[i] == null ? null : values[i].trim();
        }
    }

    private static Object[] parseLine(String[] line) {
        Object[] row = new Object[line.length];

        for (int i = 0; i < line.length; i++) {
            if (dateColumns.contains(i)) {
                row[i] = parseDate(line[i]);
                continue;
            }
            row[i] = line[i];
        }

        return row;
    }

    /**
     * Parses a date object
     *
     * @param object String
     * @return Date
     */
    private static Date parseDate(Object object) {
        Date returnValue = null;
        if (object != null) {
            String dateStr = object.toString();
            try {
                returnValue = sdf.parse(dateStr);
            } catch (ParseException pe) {
                LOG.log(Level.WARNING, "Unparsable date:" + dateStr, pe);
            }
        }
        return returnValue;
    }

    public void done() {
        try {
            reader.close();
        } catch (IOException io) {
            LOG.log(Level.SEVERE, "Error closing the reader", io);
        }
    }
}
