/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        CustomReporting.java                           *
 * Date of Last Commit: $Date::                                              $ *
 * Revision Number:      $Rev::                                              $ *
 * Last Commit by:    $Author::                                              $ *
 *                                                                             *
 *******************************************************************************/

/*
 * TravelAssistanceSummary.java
 *
 * Created on Feb 9, 2011, 3:31:13 PM
 */
package ca.bc.gov.health.tap.web;

import ca.bc.gov.health.tap.session.ReportFacadeLocal;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.enterprise.context.RequestScoped;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.context.FacesContext;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

/**
 * <p>
 * Page bean that corresponds to a similarly named JSP page. This class contains component definitions (and
 * initialization code) for ALL components that you have defined on this page, as well as lifecycle methods and event
 * handlers where you may add behavior to respond to incoming events.</p>
 *
 * @author greg.perkins
 */
@RequestScoped
@Named("CustomReporting")
public class CustomReporting {

    @EJB
    private ReportFacadeLocal reportFacade;
    private static final String ALL = "ALL";
    private List results;
    private Date startDate;
    private Date endDate;
    private Date customStartDate;
    private Date customEndDate;
    private String selectedDateRange;
    private String[] countRanges;
    private String[] clientHealthAuthorities;
    private String[] specialistHealthAuthorities;
    private String[] clientLHA;
    private String[] specialistLHA;
    @Inject
    private Droplists dropList;

    private int selectedMenu;

    /**
     * <p>
     * Construct a new Page bean instance.</p>
     */
    @PostConstruct
    public void init() {
        FacesContext fc = FacesContext.getCurrentInstance();
        Map<String, String> params = fc.getExternalContext().getRequestParameterMap();
        String selMenu = params.get("selMenu");
        if (selMenu == null) {
            this.selectedMenu = 6;
        } else {
            this.selectedMenu = Integer.parseInt(selMenu);
        }
    }

    public String viewPatientAndSpecialistReport() {
        if (isValid()) {
            parseDate();

            ArrayList<String[]> container = new ArrayList<>(1);
            container.add(countRanges);

            String[][] args = new String[5][];
            args[0] = collateMultiSelectOptions(container, dropList.getCountRanges());
            countRanges = container.get(0);

            container.set(0, clientHealthAuthorities);
            args[1] = collateMultiSelectOptions(container, dropList.getHealthAuthorities());
            clientHealthAuthorities = container.get(0);

            container.set(0, clientLHA);
            args[2] = collateMultiSelectOptions(container, dropList.getLHAs());
            clientLHA = container.get(0);

            container.set(0, specialistHealthAuthorities);
            args[3] = collateMultiSelectOptions(container, dropList.getSpecialistHAs());
            specialistHealthAuthorities = container.get(0);

            container.set(0, specialistLHA);
            args[4] = collateMultiSelectOptions(container, dropList.getLHAs());
            specialistLHA = container.get(0);

            results = reportFacade.patientAndSpecialistSummary(startDate, endDate, args[0], args[1], args[2], args[3], args[4]);

        }

        return null;
    }
    
    public List printPatientAndSpecialistReport() {
        if (isValid()) {
            parseDate();

            ArrayList<String[]> container = new ArrayList<>(1);
            container.add(countRanges);

            String[][] args = new String[5][];
            args[0] = collateMultiSelectOptions(container, dropList.getCountRanges());
            countRanges = container.get(0);

            container.set(0, clientHealthAuthorities);
            args[1] = collateMultiSelectOptions(container, dropList.getHealthAuthorities());
            clientHealthAuthorities = container.get(0);

            container.set(0, clientLHA);
            args[2] = collateMultiSelectOptions(container, dropList.getLHAs());
            clientLHA = container.get(0);

            container.set(0, specialistHealthAuthorities);
            args[3] = collateMultiSelectOptions(container, dropList.getSpecialistHAs());
            specialistHealthAuthorities = container.get(0);

            container.set(0, specialistLHA);
            args[4] = collateMultiSelectOptions(container, dropList.getLHAs());
            specialistLHA = container.get(0);

            results = reportFacade.patientAndSpecialistSummary(startDate, endDate, args[0], args[1], args[2], args[3], args[4]);
            return results;

        }

        return null;
    }

    public List getResults() {
        return results;
    }

    public void setResults(List results) {
        this.results = results;
    }

    public Date getCustomEndDate() {
        return customEndDate;
    }

    public void setCustomEndDate(Date customEndDate) {
        this.customEndDate = customEndDate;
    }

    public Date getCustomStartDate() {
        return customStartDate;
    }

    public void setCustomStartDate(Date customStartDate) {
        this.customStartDate = customStartDate;
    }

    public String getSelectedDateRange() {
        return selectedDateRange;
    }

    public void setSelectedDateRange(String selectedDateRange) {
        this.selectedDateRange = selectedDateRange;
    }

    public String[] getCountRanges() {
        return countRanges;
    }

    public void setCountRanges(String[] countRanges) {
        this.countRanges = countRanges;
    }

    public String[] getClientHealthAuthorities() {
        return clientHealthAuthorities;
    }

    public void setClientHealthAuthorities(String[] healthAuthorities) {
        this.clientHealthAuthorities = healthAuthorities;
    }

    public String[] getClientLHA() {
        return clientLHA;
    }

    public void setClientLHA(String[] lha) {
        this.clientLHA = lha;
    }

    public String[] getSpecialistHealthAuthorities() {
        return specialistHealthAuthorities;
    }

    public void setSpecialistHealthAuthorities(String[] healthAuthorities) {
        this.specialistHealthAuthorities = healthAuthorities;
    }

    public String[] getSpecialistLHA() {
        return specialistLHA;
    }

    public void setSpecialistLHA(String[] lha) {
        this.specialistLHA = lha;
    }

    public Droplists getDropList() {
        return dropList;
    }

    public void setDropList(Droplists dropList) {
        this.dropList = dropList;
    }

    public String getDateRanges() {

        if (selectedDateRange != null && !selectedDateRange.equals("No Selection")) {
            return selectedDateRange;
        }

        if (customStartDate != null && customEndDate != null) {
            DateFormat df = new SimpleDateFormat("MMMM dd yyyy");
            df.format(customStartDate);

            return df.format(customStartDate) + " - " + df.format(customEndDate);
        }

        return null;

    }

    public String getConfirmationRangeCount() {
        return mergeArray(countRanges, dropList.getCountRanges());
    }

    public String getClientHACriteria() {
        return mergeArray(clientHealthAuthorities, dropList.getHealthAuthorities());
    }

    public String getClientLHACriteria() {
        return mergeArray(clientLHA, dropList.getLHAs());
    }

    public String getSpecialistHACriteria() {
        return mergeArray(specialistHealthAuthorities, dropList.getSpecialistHAs());
    }

    public String getSpecialistLHACriteria() {
        return mergeArray(specialistLHA, dropList.getLHAs());
    }

    private String mergeArray(String[] selection, Map<String, Object> keyVals) {
        StringBuilder builder = new StringBuilder();

        if (selection != null) {

            if (!selection[0].equals("ALL")) {

                Map<String, Object> transposed = new LinkedHashMap<>();
                Entry<String, Object> temp;

                for (Iterator<Entry<String, Object>> itr = keyVals.entrySet().iterator(); itr.hasNext();) {
                    temp = itr.next();
                    transposed.put((String) temp.getValue(), temp.getKey());
                }

                for (String s : selection) {
                    builder.append(transposed.get(s)).append(", ");
                }

                builder.delete(builder.length() - 2, builder.length());
            } else {
                builder.append(selection[0]);
            }

            return builder.toString();
        }

        return null;

    }

    public boolean isValid() {

        if (!selectedDateRange.equals("No Selection")) {

            if (customStartDate == null && customEndDate == null) {
                return true;
            } else {
                FacesContext.getCurrentInstance().addMessage("Only one date range entry is allowed", new FacesMessage("Only one date range entry is allowed"));
                return false;
            }
        } else {
            if (customStartDate == null && customEndDate == null) {
                FacesContext.getCurrentInstance().addMessage("Please select a date range entry", new FacesMessage("Please select a date range entry"));
                return false;

            } else if ((customStartDate == null && customEndDate != null) || (customStartDate != null && customEndDate == null)) {

                FacesContext.getCurrentInstance().addMessage("The two custom date entries are required", new FacesMessage("The two custom date entries are required"));
                return false;
            } else {

                if (customEndDate.before(customStartDate)) {
                    FacesContext.getCurrentInstance().addMessage("End date cannot be earlier than Start date", new FacesMessage("End date cannot be earlier than Start date"));
                    return false;
                }
            }
        }

        return true;
    }

    private void parseDate() {

        if (!selectedDateRange.equals("No Selection")) {

            int sepNdx = selectedDateRange.indexOf('-');
            DateFormat df = new SimpleDateFormat("MMMM dd yyyy");

            try {
                this.startDate = df.parse(selectedDateRange.substring(0, sepNdx).trim());
                this.endDate = df.parse(selectedDateRange.substring(sepNdx + 1).trim());

            } catch (ParseException pe) {
                pe.printStackTrace();
            }

        } else {
            startDate = customStartDate;
            endDate = customEndDate;
        }

    }

    private String[] collateMultiSelectOptions(List<String[]> container, Map<String, Object> possibleValues) {

        String[] collated;
        String[] selection = container.get(0);

        if (selection != null && selection.length > 1) {
            // If "ALL" and any other specific health authorities are selected then we default to ALL
            int ndx = -1;
            for (int i = 0; i < selection.length; i++) {

                if (selection[i].equals(ALL)) {
                    ndx = i;
                    break;
                }
            }

            if (ndx > -1) {
                selection = new String[1];
                selection[0] = ALL;
            }
        }

        if (selection == null || selection.length == 0 || (selection.length == 1 && selection[0].equals(ALL))) {
            collated = new String[possibleValues.keySet().size() - 1];
            Object[] temp = possibleValues.values().toArray();

            for (int i = 1; i < temp.length; i++) {
                collated[i - 1] = (String) temp[i];
            }

            if (selection == null || selection.length == 0) {
                selection = new String[1];
                selection[0] = ALL;
            }
        } else {
            collated = selection;
        }

        container.set(0, selection);

        return collated;
    }

    public int getSelectedMenu() {
        return selectedMenu;
    }

    public void setSelectedMenu(int selectedMenu) {
        this.selectedMenu = selectedMenu;
    }
}
