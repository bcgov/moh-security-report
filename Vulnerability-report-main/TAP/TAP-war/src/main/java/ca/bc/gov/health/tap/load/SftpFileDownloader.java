package ca.bc.gov.health.tap.load;

import ca.bc.gov.health.tap.load.util.BatchConstants;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.GZIPOutputStream;
import org.apache.commons.io.FilenameUtils;

public class SftpFileDownloader implements FileDownloader {

    private static final Logger logger = Logger.getLogger(SftpFileDownloader.class.getSimpleName());
    private static final int CONNECTION_TIMEOUT = 20000; // 20 seconds

    private final String sftpHost;
    private final String sftpUsername;
    private final String sftpFilename;
    private final String sftpArchiveDirectory;
    private final String privKeyFile;
    private final String knownHostsFile;
    private JSch jsch;
    private Session session;

    /**
     * Constructor for the SftpFileDownloader class. This constructor connects to a remote host using SSH. The required
     * credentials are provided through a map of properties.
     *
     * @param properties A map of credentials required to connect to remote host
     * @throws com.jcraft.jsch.JSchException
     */
    public SftpFileDownloader(Map<String, Object> properties) throws JSchException {
        // Extract the required credentials from the properties map
        sftpHost = (String) properties.get(BatchConstants.SFTP_HOST);
        sftpUsername = (String) properties.get(BatchConstants.SFTP_USER_ID);
        sftpFilename = (String) properties.get(BatchConstants.SFTP_FILE);
        sftpArchiveDirectory = (String) properties.get(BatchConstants.SFTP_ARCHIVE_PATH);
        privKeyFile = (String) properties.get(BatchConstants.PRIV_KEY_FILE);
        knownHostsFile = (String) properties.get(BatchConstants.KNOWN_HOSTS_FILE);

        // Initialize the JSch object and load the private key
        jsch = new JSch();
        jsch.addIdentity(privKeyFile);
        jsch.setKnownHosts(knownHostsFile);
    }

    /**
     * Fetch a file via SFTP and returns the content as a file
     *
     * @return the file located on the SFTP server
     * @throws java.io.IOException
     */
    @Override
    public File fetch() throws IOException {

        File tempFile = null;
        ChannelSftp sftpChannel = null;

        try {
            openSFTPConnection();
            logger.log(Level.INFO, "Fetching file {0}", sftpFilename);

            sftpChannel = (ChannelSftp) session.openChannel("sftp");
            sftpChannel.connect();

            if (!sftpChannel.ls(sftpFilename).isEmpty()) {
                logger.log(Level.INFO, "New file found on SFTP server {0}. Downloading file {1}...", new Object[]{sftpHost, sftpFilename});

                tempFile = Files.createTempFile(Objects.requireNonNull(FilenameUtils.getName(sftpFilename)), null).toFile();
                logger.log(Level.INFO, "Temporary file {0} has been created successfully", tempFile.getAbsolutePath());

                // Download the remote file from SFTP server in chunks, ensuring robustness and efficient handling of large files
                try (
                        InputStream inputStream = sftpChannel.get(sftpFilename); OutputStream outputStream = new FileOutputStream(tempFile)) {
                    int bytesRead;
                    byte[] buffer = new byte[1024];
                    while ((bytesRead = inputStream.read(buffer)) > 0) {
                        outputStream.write(buffer, 0, bytesRead);
                    }
                    logger.log(Level.INFO, "File {0} has been downloaded successfully into {1}", new Object[]{sftpFilename, tempFile.toPath().getFileName()});
                } // Auto-close the resources

            } else {
                logger.log(Level.INFO, "No file found on SFTP server {0}", sftpHost);
            }
            sftpChannel.disconnect();
        } catch (SftpException | JSchException ex) {
            ex.printStackTrace();
            if (ex.getMessage().contains("File not found") || ex.getMessage().contains("No such file")) {
                logger.log(Level.INFO, "File {0} does not exist", sftpFilename);
            } else if (ex.getMessage().contains("Connection timed out")) {
                logger.log(Level.WARNING, "Connection to SFTP server timed out: {0}", ex.getMessage());
            } else {
                logger.log(Level.WARNING, "Error listing files: {0}", ex.getMessage());
            }
        } finally {
            if (sftpChannel != null) {
                sftpChannel.disconnect();
            }
            if (session != null) {
                session.disconnect();
            }
        }
        return tempFile;
    }

    /**
     * Compress and archive a file on the SFTP server
     *
     * @param tempFile is the temporary file located on the local server
     * @throws java.io.IOException
     */
    @Override
    public void archiveFile(File tempFile) throws IOException {

        ChannelSftp sftpChannel = null;

        logger.log(Level.INFO, "Compressing, archiving and deleting file {0}", sftpFilename);

        logger.log(Level.INFO, "Compressing temporary file {0}", tempFile.toPath().getFileName());
        LocalDateTime now = LocalDateTime.now();
        String compressedTempFileName = FilenameUtils.getName(sftpFilename) + "_"
                + now.getYear() + "_"
                + now.getMonthValue() + "_"
                + now.getDayOfMonth() + "-"
                + now.getHour() + "h-"
                + now.getMinute() + "m-"
                + now.getSecond() + "s"
                + ".gz";
        Path compressedTempFile = Files.createFile(Paths.get(tempFile.getParent(), compressedTempFileName));
        logger.log(Level.INFO, "Temporary file {0} has been created successfully", compressedTempFile.getFileName());

        try (
                BufferedReader bufferedReader = Files.newBufferedReader(tempFile.toPath()); GZIPOutputStream outputStream = new GZIPOutputStream(new FileOutputStream(compressedTempFile.toFile()))) {
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                outputStream.write(line.getBytes());
            }
        } // Auto-close the resources

        try {
            openSFTPConnection();
            logger.log(Level.INFO, "Archiving file {0}", sftpFilename);

            sftpChannel = (ChannelSftp) session.openChannel("sftp");
            sftpChannel.connect();

            // Upload the local compressed file to the SFTP server
            String remoteCompressedFileName = sftpArchiveDirectory + "/" + compressedTempFile.getFileName();
            logger.log(Level.INFO, "Uploading temporary file {0} to {1} on {2}", new Object[]{compressedTempFile.getFileName(), sftpArchiveDirectory, sftpHost});
            sftpChannel.put(new FileInputStream(compressedTempFile.toFile()), remoteCompressedFileName);
            logger.log(Level.INFO, "Temporary file {0} has been uploaded successfully into {1} on {2}", new Object[]{compressedTempFile.getFileName(), sftpArchiveDirectory, sftpHost});

            // The original data file has been compressed and archived, we can now delete the original file on the SFTP server
            if (!sftpChannel.ls(sftpFilename).isEmpty()) {
                sftpChannel.rm(sftpFilename);
                logger.log(Level.INFO, "File {0} has been deleted", sftpFilename);
            } else {
                logger.log(Level.INFO, "No file found on SFTP server {0}", sftpHost);
            }

            // Delete both local temporary files (original and compressed)
            logger.log(Level.INFO, "Deleting temporary files {0} and {1}", new Object[]{tempFile.toPath().getFileName(), compressedTempFile.getFileName()});
            Files.deleteIfExists(tempFile.toPath());
            Files.deleteIfExists(compressedTempFile);
            logger.log(Level.INFO, "Temporary files {0} and {1} have been deleted successfully", new Object[]{tempFile.toPath().getFileName(), compressedTempFile.getFileName()});

            sftpChannel.disconnect();

            logger.log(Level.INFO, "File {0} has been archived successfully", sftpFilename);
        } catch (SftpException | JSchException ex) {
            if (ex.getMessage().contains("File not found") || ex.getMessage().contains("No such file")) {
                logger.log(Level.INFO, "File {0} does not exist", sftpFilename);
            } else if (ex.getMessage().contains("Connection timed out")) {
                logger.log(Level.WARNING, "Connection to SFTP server timed out: {0}", ex.getMessage());
            } else {
                logger.log(Level.WARNING, "Error listing files: {0}", ex.getMessage());
            }
        } finally {
            if (sftpChannel != null) {
                sftpChannel.disconnect();
            }
            if (session != null) {
                session.disconnect();
            }
        }
    }

    /**
     * Establishes an SFTP connection with the remote host.
     *
     * If legacy RSA keys are to be used on an SFTP server with a legacy version of OpenSSH (prior to 8.8), the
     * following JSch session configuration must be added to the method below prior to initiating a connection,
     *
     * <pre>
     * {@code
     *   // MoH SFTP server still proposes using ssh-rsa
     *   session.setConfig("server_host_key", session.getConfig("server_host_key") + ",ssh-rsa");
     *   session.setConfig("PubkeyAcceptedAlgorithms", session.getConfig("PubkeyAcceptedAlgorithms") + ",ssh-rsa");
     * }
     * </pre>
     *
     * @throws com.jcraft.jsch.JSchException
     */
    private void openSFTPConnection() throws JSchException {

        session = jsch.getSession(sftpUsername, sftpHost);
        session.connect(CONNECTION_TIMEOUT);
    }
}
