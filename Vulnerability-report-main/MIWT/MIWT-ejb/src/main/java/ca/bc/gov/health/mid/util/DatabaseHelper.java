package ca.bc.gov.health.mid.util;

import java.io.Serializable;
import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.DataSource;

/**
 *
 * @author CGI Information Management Consultants Inc.
 */
public class DatabaseHelper implements Serializable {

    private static final Logger logger = Logger.getLogger(DatabaseHelper.class.getName());

    public enum QueryType {

        INSERT, DELETE, UPDATE
    }
    private static final int BATCH_SIZE = 1000;
    private transient DataSource dataSource;
    private transient Statement dbInsStmts;
    private final Boolean optimize;
    private int counter;
    private String currentUser;
    private final ExecutorService executor;
    private final int executorThreads = 8;
    private AtomicBoolean dataInsertInprogress = new AtomicBoolean();
    private AtomicLong recordsRemaining = new AtomicLong();
    private AtomicLong totalRecords = new AtomicLong();
    private AtomicInteger acceptedWithDBErrors = new AtomicInteger();
    private List<String> errorMessages = new ArrayList<>();

    public DatabaseHelper() {
        optimize = true;
        executor = null;
    }

    public DatabaseHelper(DataSource dataSource, String user, boolean optimize) {
        this.dataSource = dataSource;
        this.currentUser = user;
        this.optimize = optimize;

        // only create executor if if want to execute each database operation individually i.e no batch operation
        executor = !optimize ? Executors.newFixedThreadPool(executorThreads) : null;

    }
    
    public void writeToDb(int lineNo, RecordWrapper recordWrapper, Map<String, String> properties, QueryType queryType) throws Exception {
        totalRecords.addAndGet(1);
        if (dbInsStmts == null) {
            dbInsStmts = createSqlStatment();
        }

        if (optimize) {
            // if entry is null, then we have reached the
            // end of the file, so execute any statements
            // left in the batch and release resources.
            if (recordWrapper == null) {
                try {
                    dbInsStmts.executeBatch();
                    counter = 0;

                } catch (BatchUpdateException be) {
                    logger.log(Level.SEVERE, "Error while doing batch record insert", be);

                } finally {

                    Connection c = dbInsStmts.getConnection();
                    c.commit();
                    recordsRemaining.set(recordsRemaining.get() - dbInsStmts.getUpdateCount());
                    dbInsStmts.close();
                    dbInsStmts = null;

                }

            } else if (counter % BATCH_SIZE == 0 && dbInsStmts != null) {

                try {
                    addToBatch(lineNo, recordWrapper, properties, queryType);
                    dbInsStmts.executeBatch();
                } catch (BatchUpdateException be) {
                    logger.log(Level.SEVERE, "Error while doing batch record insert", be);
                } finally {
                    dbInsStmts.getConnection().commit();
                    recordsRemaining.set(recordsRemaining.get() - BATCH_SIZE);
                    dbInsStmts.clearBatch();
                    counter = 0;

                }

            } else {
                addToBatch(lineNo, recordWrapper, properties, queryType);
            }

        } else {

            if (recordWrapper != null && recordWrapper.getEntry() != null) {
                addToBatch(lineNo, recordWrapper, properties, queryType);
            }
        }
    }

    public DataSource getDataSource() {
        return dataSource;
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public boolean isInUse() {
        return dataInsertInprogress.get();
    }

    public void markAsInUse() {
        dataInsertInprogress.set(true);
    }

    public long getRecordsRemaining(){
        return recordsRemaining.get();
    }
    
    public int getTotalRecords(){
        return totalRecords.intValue();
    }
    
    public boolean isDBInsertCompleted() {
        return recordsRemaining.get() == 0;
    }

    public int getAcceptedWithDBErrors() {
        return acceptedWithDBErrors.get();
    }

    public void reset() {
        dataInsertInprogress.set(false);
        acceptedWithDBErrors.set(0);
    }

    public void clearErrors() {
        errorMessages.clear();
    }

    public void incrementTotalSubmitted() {
        recordsRemaining.incrementAndGet();
    }

    public List<String> getErrorMessages() {
        return errorMessages;
    }

    private void addToBatch(int lineNo, RecordWrapper recordWrapper, Map<String, String> properties, QueryType queryType) throws Exception {

        if (optimize) {
            // If we have a delete query then we need we nead to also create 
            // an insert query for the current entry
            if (queryType.equals(QueryType.DELETE)) {
                dbInsStmts.addBatch(buildQuery(recordWrapper.getEntry(), properties, queryType));
                dbInsStmts.addBatch(buildQuery(recordWrapper.getEntry(), properties, QueryType.INSERT));
            } else {
                dbInsStmts.addBatch(buildQuery(recordWrapper.getEntry(), properties, queryType));
            }

            counter++;
        } else {
            String[] queries;
            if (queryType.equals(QueryType.DELETE)) {

                queries = new String[2];
                queries[0] = buildQuery(recordWrapper.getEntry(), properties, queryType);
                queries[1] = buildQuery(recordWrapper.getEntry(), properties, QueryType.INSERT);

            } else {
                queries = new String[1];
                queries[0] = buildQuery(recordWrapper.getEntry(), properties, queryType);
            }

            executor.submit(new DbTask(lineNo, queries, recordWrapper.getStatus()));
        }
        
    }

    protected void finalize() {
        if (executor != null) {
            executor.shutdownNow();
        }
    }

    private Statement createSqlStatment() throws Exception {
        Connection con = dataSource.getConnection();
        Statement t = con.createStatement();
        con.setAutoCommit(false);
        return t;
    }

    private Connection createSqlConnection() throws Exception {
        return dataSource.getConnection();
    }

    public static String escapeSingleQuotes(String rec) {

        StringBuilder builder = null;
        if (rec != null && !rec.isEmpty()) {
            builder = new StringBuilder(rec);

            int ndx = 0;
            while ((ndx < builder.length()) && (ndx = builder.indexOf("'", ndx)) >= 0) {
                builder.insert(ndx, "'");
                ndx += 2;   // move ndx forward two places because we have added a new quote             
            }
        }

        return builder != null ? builder.toString() : null;
    }

    private String buildQuery(String[] entry, Map<String, String> properties, QueryType queryType) throws ConversionException {

        StringBuilder queryBuilder = new StringBuilder();
        // if this record exists in the DB already, then we
        // want to delete it first before insert a new one
        if (queryType == QueryType.DELETE) {
            queryBuilder.delete(0, queryBuilder.length())
                    .append("DELETE FROM ").append(properties.get("TABLE_NAME")).append(" WHERE HEALTH_AUTHORITY_CD = ")
                    .append("'").append(properties.get("HEALTH_AUTHORITY_ID")).append("'")
                    .append(" AND BOOKING_ID = ").append("'").append(properties.get("BOOKING_ID")).append("'")
                    .append(" AND EXAM_ID = ").append("'").append(properties.get("EXAM_ID")).append("'");


            return queryBuilder.toString();

        }

        queryBuilder.delete(0, queryBuilder.length()) // Remove any existing query
                .append("INSERT INTO ").append(properties.get("TABLE_NAME")).append(" VALUES (")
                .append(properties.get("REC_ID")).append(", ");

        for (int i = 0; i < entry.length; i++) {


            if (entry[i] == null || entry[i].trim().isEmpty()) {
                queryBuilder.append("NULL, ");
                continue;
            }

            // remove any trailing spaces
            entry[i] = entry[i].trim();

            // if current iteration is a number field
            if (i == 1
                    || i == 16
                    || (i >= 17 && i <= 18)
                    || i == 46) {

                // if this is a numeric field, check that the number in field is valid
                // to prevent database error

                if (!checkNumberFieldConversion(entry[i])) {
                    throw new ConversionException(String.format("Column No. %s - '%s' contains invalid number", i + 1, RawDataValidator.FieldIndex.values()[i].getStringValue()));
                }

                queryBuilder.append(entry[i]).append(", ");
            } else if (i == 0 // if current iteration is a string field
                    || (i >= 2 && i <= 6)
                    || (i >= 8 && i <= 14)
                    || i == 15
                    || (i >= 19 && i <= 22)
                    || (i >= 23 && i <= 28)
                    || i == 34
                    || i == 36
                    || (i >= 43 && i <= 45)
                    || (i >= 47 && i <= 52)
                    || (i >= 55 && i <= 57)) {

                //Escape single quote before appending
                queryBuilder.append("'").append(escapeSingleQuotes(entry[i])).append("'").append(", ");

            } else if (i == 7
                    || i == 35
                    || i == 54
                    || (i >= 29 && i <= 33)
                    || (i >= 37 && i <= 42)) {// Must be a date field

                if (!checkDateFieldConversion(entry[i])) {
                    throw new ConversionException(String.format("Column %s contains invalid date", i + 1));
                }

                queryBuilder.append("TO_DATE('").append(entry[i]).append("', ").append("'yyyymmdd'").append(")").append(", ");

            } else if (i == 53) {
                queryBuilder.append("TO_DATE('").append(entry[i]).append("', 'HH24:MI')").append(", ");
            }
        }

        // add health authority code
        if (entry.length == 64) {
            queryBuilder.append("'").append(entry[58]).append("'").append(", ");

            queryBuilder.append("TO_DATE('").append(entry[59]).append("', 'yyyymmdd')").append(", ") // Created on
                    .append("TO_DATE('").append(entry[60]).append("', 'yyyymmdd')").append(", ") // Last modified on
                    .append("'").append(entry[61]).append("'").append(", ") // Created by
                    .append("'").append(entry[62]).append("'").append(", ") // Last modified by
                    .append(entry[63]).append(")");// stateless tansaction number

        } else {
            queryBuilder.append("'").append(properties.get("HEALTH_AUTHORITY_ID")).append("'").append(", ");

            queryBuilder.append("TO_DATE('").append(ConversionHelper.convertDateToString(new java.util.Date())).append("', 'yyyymmdd')").append(", ") // Created on
                    .append("TO_DATE('").append(ConversionHelper.convertDateToString(new java.util.Date())).append("', 'yyyymmdd')").append(", ") // Last modified on
                    .append("'").append(currentUser).append("'").append(", ") // Created by
                    .append("'").append(currentUser).append("'").append(", ") // Last modified by
                    .append(0).append(")");// stateless tansaction number
        }


        return queryBuilder.toString();
    }

    private boolean checkNumberFieldConversion(String strNumber) {

        try {
            Long.parseLong(strNumber);
            return true;
        } catch (Exception e) {
            return false;
        }

    }

    private boolean checkDateFieldConversion(String strNumber) {

        try {
            SimpleDateFormat sfmt = new SimpleDateFormat("yyyyMMdd");
            sfmt.parse(strNumber);
            return true;
        } catch (Exception e) {
            return false;
        }

    }
    
    public void shutdown() {
        
        if (executor != null) {
            executor.shutdown();
        }
    }

    class DbTask implements Runnable {

        private String[] statements;
        private int lineNo;
        private RecordWrapper.STATUS status;

        DbTask(int lineNo, String[] queries, RecordWrapper.STATUS status) {
            this.statements = queries;
            this.lineNo = lineNo;
            this.status = status;
        }

        @Override
        public void run() {

            try (Connection conn = createSqlConnection()) {
                conn.setAutoCommit(false);

                if (statements != null) {

                    try (Statement stmt = conn.createStatement()) {

                        for (String s : statements) {
                            stmt.addBatch(s);
                        }
                        stmt.executeBatch();
                        conn.commit();
                        logger.log(Level.FINE, String.format("%s inserted a record into the database", Thread.currentThread().getName()));
                    } finally {
                        
                        recordsRemaining.decrementAndGet();
                    }
                        
                }

            } catch (Exception e) {
                
                if (status.equals(RecordWrapper.STATUS.ACCEPTED) || status.equals(RecordWrapper.STATUS.ACCEPTED_WITH_WARNING)) {
                    acceptedWithDBErrors.incrementAndGet();
                }
                
                if (e.getMessage().contains("unique constraint (MIWT.MID_IMAGING_PROCEDURE_UK) violated")) {
                    errorMessages.add(String.format("Line %s - Database insertion error: %s", lineNo, "A record with the same Booking ID and Exam ID exists already"));
                } else {             
                    errorMessages.add(String.format("Line %s - Database insertion error: %s", lineNo, e.getMessage()));
                }
                logger.log(Level.SEVERE, String.format("Line %s - Database insertion error: %s", lineNo, statements.length == 2 ? statements[1] : statements[0]), e);
            } 
        }
    }
}
