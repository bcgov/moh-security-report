package ca.bc.gov.health.mid.ejb.snapshot;

import ca.bc.gov.health.mid.ejb.entity.SnapshotRecord;
import java.sql.*;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.DataSource;

public class ChunkInsertionTask implements Runnable {

    private static final Logger logger = Logger.getLogger(ChunkInsertionTask.class.getName());

    private static final String INSERT_QUERY_BOOKING = "INSERT ALL "
            + "INTO MIRD_PATIENT VALUES(MIRD_PATIENT_SEQ.nextVal,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,SYSDATE,NULL,?,NULL,1) "
            + "INTO MIRD_BOOKING VALUES(MIRD_BOOKING_SEQ.nextVal,?,?,MIRD_PATIENT_SEQ.currVal,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,SYSDATE,NULL,?,NULL,1,?,?,?,?,?,?) "
            + "SELECT 1 FROM DUAL";

    private static final String INSERT_QUERY_PROCEDURE = "INSERT ALL "
            + "INTO MIRD_PATIENT VALUES(MIRD_PATIENT_SEQ.nextVal,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,SYSDATE,NULL,?,NULL,1) "
            + "INTO MIRD_BOOKING VALUES(MIRD_BOOKING_SEQ.nextVal,?,?,MIRD_PATIENT_SEQ.currVal,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,SYSDATE,NULL,?,NULL,1,?,?,?,?,?,?) "
            + "INTO MIRD_COMPLETED_PROCEDURE (COMPLETED_PROCEDURE_ID,BOOKING_ID,HA_PROCEDURE_ID,URN,FACILITY_ID,EQUIPMENT_ID,FIRST_IMAGING_REGION_CD,SEDATION_YN,PROCEDURE_ID,PROCEDURE_DURATION,PROCEDURE_PERFORMED_DT,DRAFT_RESULTS_AVAIL_DT,FINAL_RESULTS_AVAIL_DT,FINDING_CD,FUNDING_TYPE_CD,PRACTITIONER_ID,MSP_NO,MODALITY_CD,AGE_RANGE_ID,CREATED_ON_DTM,LAST_MODIFIED_ON_DTM,CREATED_BY_NM,LAST_MODIFIED_BY_NM,STATELESS_TRANSACTION_NBR,HEALTH_AUTHORITY_ID,PRIORITY_LEVEL_ID,TIMED_EXAM_YN,GENDER_CD,BODY_PART_CD,EXAM_COUNT) VALUES(MIRD_COMPLETED_PROCEDURE_SEQ.nextVal,MIRD_BOOKING_SEQ.currVal,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,SYSDATE,NULL,?,NULL,1,?,?,?,?,?,?) "
            + "SELECT 1 FROM DUAL";

    private DataSource datasource;
    private String user;
    private List<SnapshotRecord> chunk;
    private AtomicInteger inserts;
    private ConcurrentLinkedQueue<String> messages;

    public ChunkInsertionTask(DataSource datasource, String user, List<SnapshotRecord> chunk, AtomicInteger inserts, ConcurrentLinkedQueue<String> messages) {
        this.datasource = datasource;
        this.user = user;
        this.chunk = chunk;
        this.inserts = inserts;
        this.messages = messages;
    }

    @Override
    public void run() {
        logger.log(Level.INFO, "Processing chunk {0} ({1} records)...", new Object[]{chunk.hashCode(), chunk.size()});
        try (Connection connection = datasource.getConnection();
                PreparedStatement bookingStatement = connection.prepareStatement(INSERT_QUERY_BOOKING);
                PreparedStatement procedureStatement = connection.prepareStatement(INSERT_QUERY_PROCEDURE)) {
            connection.setAutoCommit(false);
            processChunkBatch(connection, bookingStatement, procedureStatement);
        } catch (SQLException exception) {
            logger.log(Level.WARNING, "Chunk insertion failed.", exception);
        }
        chunk.clear();
    }

    private void processChunkBatch(Connection connection, PreparedStatement bookingStatement, PreparedStatement procedureStatement) {
        try {
            for (SnapshotRecord record : chunk) {
                if ("Completed".equals(record.getStatusCd())) {
                    setBookingParameters(procedureStatement, record);
                    setProcedureParameters(procedureStatement, record);
                    procedureStatement.addBatch();
                } else {
                    setBookingParameters(bookingStatement, record);
                    bookingStatement.addBatch();
                }
            }
            bookingStatement.executeBatch();
            procedureStatement.executeBatch();
            connection.commit();
            inserts.addAndGet(chunk.size());
            logger.log(Level.INFO, "Chunk {0} ({1} records) processed.", new Object[]{chunk.hashCode(), chunk.size()});
        } catch (SQLException exception) {
            logger.log(Level.SEVERE, "Batch insertion failed. Trying to insert row by row...", exception);
            processChunkSingle(connection, bookingStatement, procedureStatement);
        }
    }

    private void processChunkSingle(Connection connection, PreparedStatement bookingStatement, PreparedStatement procedureStatement) {
        try {
            connection.rollback();
            bookingStatement.clearBatch();
            procedureStatement.clearBatch();
            logger.log(Level.INFO, "Chunk {0} insertion rolled back.", chunk);
        } catch (SQLException exception) {
            logger.log(Level.SEVERE, "Unable to rollback chunk insertion. This may cause duplicate data in the database.", exception);
        }

        int count = 0;
        try (PreparedStatement countStatement = connection.prepareStatement("SELECT COUNT(*) FROM MIRD_BOOKING WHERE PROCEDURE_BOOKING_ID = ? AND HEALTH_AUTHORITY_ID = ? AND EXAM_ID = ?")) {
            for (SnapshotRecord record : chunk) {
                try {
                    if (isReinsertNeeded(countStatement, record)) {
                        if ("Completed".equals(record.getStatusCd())) {
                            setBookingParameters(procedureStatement, record);
                            setProcedureParameters(procedureStatement, record);
                            procedureStatement.executeUpdate();
                        } else {
                            setBookingParameters(bookingStatement, record);
                            bookingStatement.executeUpdate();
                        }
                        connection.commit();
                        count++;
                    }
                } catch (SQLException exception) {
                    logger.log(Level.WARNING, "Record insertion failed.", exception);
                    messages.add(exception.getMessage());
                }
            }
        } catch (SQLException exception) {
            messages.add(exception.getMessage());
            logger.log(Level.SEVERE, "Chunk insertion failed.", exception);
        }
        inserts.addAndGet(count);
        logger.log(Level.INFO, "Chunk {0} ({1} records) processed.", new Object[]{chunk.hashCode(), count});
    }

    private boolean isReinsertNeeded(PreparedStatement countStatement, SnapshotRecord record) {
        ResultSet resultSet = null;
        try {
            countStatement.setObject(1, record.getBookingId());
            countStatement.setObject(2, record.getHealthAuthorityId());
            countStatement.setObject(3, record.getExamId());
            resultSet = countStatement.executeQuery();
            resultSet.next();
            return resultSet.getInt(1) == 0;
        } catch (SQLException exception) {
            messages.add(exception.getMessage());
            logger.log(Level.WARNING, "Unable to count inserted records.", exception);
            return false;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (SQLException exception) {
                    logger.log(Level.WARNING, "Unable to close result set.", exception);
                }
            }
        }
    }

    /**
     * Important note: The order you set the fields here must respect the order in the SQL table.
     */
    private void setBookingParameters(PreparedStatement statement, SnapshotRecord record) throws SQLException {
        int parameter = 1;
        //Default value set here
        if (record.getFirstGivenNm() == null) {
            statement.setObject(parameter++, "Default_value");
        } else {
            statement.setObject(parameter++, record.getFirstGivenNm());
        }
        statement.setObject(parameter++, record.getSecondGivenNm());
        statement.setObject(parameter++, record.getThirdGivenNm());
        statement.setObject(parameter++, record.getSurnameNm());
        statement.setObject(parameter++, record.getPreferredNm());
        statement.setDate(parameter++, toSqlDate(record.getBirthDt()));
        //Default value set here
        if (record.getGenderCd() == null) {
            statement.setObject(parameter++, "UNK");
        } else {
            statement.setObject(parameter++, record.getGenderCd());
        }
        statement.setObject(parameter++, record.getMrn());
        statement.setObject(parameter++, record.getPhn());
        statement.setObject(parameter++, record.getAddressLine1());
        statement.setObject(parameter++, record.getAddressLine2());
        statement.setObject(parameter++, record.getAddressLine3());
        statement.setObject(parameter++, null); //City
        //Default value set here
        if (record.getProvinceCd() == null) {
            statement.setObject(parameter++, "BC");
        } else {
            statement.setObject(parameter++, record.getProvinceCd());
        }
        statement.setObject(parameter++, record.getPostalCode());
        statement.setObject(parameter++, user);

        statement.setObject(parameter++, record.getStatusCd());
        statement.setObject(parameter++, record.getExamId());
        //Patient ID via sequence
        statement.setObject(parameter++, record.getFacilityId());
        statement.setObject(parameter++, record.getEncounterTypeCd());
        statement.setObject(parameter++, record.getModalityCd());
        statement.setObject(parameter++, record.getExamReason());
        statement.setObject(parameter++, null); //wait time days
        statement.setDate(parameter++, toSqlDate(record.getReferralDt()));
        statement.setDate(parameter++, toSqlDate(record.getBookingFormReceivedDt()));
        statement.setDate(parameter++, toSqlDate(record.getBookingCreatedDt()));
        statement.setObject(parameter++, null); //patient preference
        statement.setDate(parameter++, toSqlDate(record.getProcedureScheduledDt()));
        statement.setDate(parameter++, toSqlDate(record.getProcedureCancelledDt()));
        statement.setDate(parameter++, toSqlDate(record.getProcedurePostponedDt()));
        statement.setDate(parameter++, toSqlDate(record.getPatientUnavailStartDt1()));
        statement.setDate(parameter++, toSqlDate(record.getPatientUnavailEndDt1()));
        statement.setDate(parameter++, toSqlDate(record.getPatientUnavailStartDt2()));
        statement.setDate(parameter++, toSqlDate(record.getPatientUnavailEndDt2()));
        statement.setDate(parameter++, toSqlDate(record.getPatientUnavailStartDt3()));
        statement.setDate(parameter++, toSqlDate(record.getPatientUnavailEndDt3()));
        statement.setObject(parameter++, record.getTimedExamYn());
        statement.setObject(parameter++, null); //Timed exam date
        statement.setObject(parameter++, record.getCancellationReasonCd());
        statement.setObject(parameter++, record.getPostponementReasonCd());
        statement.setObject(parameter++, record.getPriorityLevelId());
        statement.setObject(parameter++, null); //Benchmark wait time
        statement.setDate(parameter++, toSqlDate(record.getProcedurePerformedDt()));
        statement.setDate(parameter++, toSqlDate(record.getResultsAvailDt()));
        statement.setObject(parameter++, record.getProcedureDuration()); //Duration mins
        statement.setObject(parameter++, record.getProcedureId());
        statement.setObject(parameter++, record.getImagingRegionCd());
        statement.setObject(parameter++, record.getSedationYn());
        statement.setObject(parameter++, record.getMachineId());
        statement.setObject(parameter++, record.getAppropriatenessCd());
        statement.setObject(parameter++, user);
        statement.setObject(parameter++, record.getHealthAuthorityId());
        statement.setObject(parameter++, record.getBookingId());
        statement.setObject(parameter++, record.getBodyPartCd());
        statement.setObject(parameter++, record.getExamCount());
        statement.setObject(parameter++, record.getMspNo());
        statement.setObject(parameter++, record.getPractitionerId());
    }

    private void setProcedureParameters(PreparedStatement statement, SnapshotRecord record) throws SQLException {
        int parameter = 41 + 16 + 1; //41 params in Booking and 16 param in Patient + 1 to start here
        statement.setObject(parameter++, record.getHaProcedureCdCompleted());
        statement.setObject(parameter++, record.getUrn());
        statement.setObject(parameter++, record.getFacilityIdCompleted());
        statement.setObject(parameter++, record.getMachineId());
        statement.setObject(parameter++, record.getImagingRegionCdCompleted());
        statement.setObject(parameter++, record.getSedationYnCompleted());
        statement.setObject(parameter++, record.getProcedureIdCompleted());
        statement.setObject(parameter++, record.getProcedureDuration());
        statement.setDate(parameter++, toSqlDate(record.getProcedurePerformedDt()));
        statement.setObject(parameter++, null); //Draft Results
        statement.setDate(parameter++, toSqlDate(record.getResultsAvailDt()));
        statement.setObject(parameter++, record.getFindingCd());
        statement.setObject(parameter++, record.getFundingTypeCd());
        statement.setObject(parameter++, record.getPractitionerId());
        statement.setObject(parameter++, record.getMspNo());
        statement.setObject(parameter++, record.getModalityCdCompleted());
        statement.setObject(parameter++, record.getAgeRangeId());
        statement.setObject(parameter++, user);
        statement.setObject(parameter++, record.getHealthAuthorityId());
        statement.setObject(parameter++, record.getPriorityLevelId());
        statement.setObject(parameter++, record.getTimedExamYn());
        statement.setObject(parameter++, record.getGenderCd());
        statement.setObject(parameter++, record.getBodyPartCdCompleted());
        statement.setObject(parameter, record.getExamCountCompleted());
    }

    private static Date toSqlDate(java.util.Date date) {
        if (date == null) {
            return null;
        }
        return new java.sql.Date(date.getTime());
    }
}
