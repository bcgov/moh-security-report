package ca.bc.gov.health.ejb.entitylistener;

import ca.bc.gov.health.mid.ejb.entity.*;
import jakarta.annotation.Resource;
import jakarta.persistence.*;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.naming.InitialContext;
import javax.sql.DataSource;

/**
 * EntityListener class that inserts journal records when a row in the parent
 * table changes
 * 
 * @author CGI Information Management Consultants Inc.
 */
public class JournalListener {

    /**
     * DataSource for performing inserts
     */
    @Resource(name="java:app/jdbc/MIWT")
    private static DataSource ds;
    
    /**
     * Map of entity classes to their associated journal table names
     */
    public static final Map<Class,String> jnMappings = new HashMap<Class,String>();
    /*
     * Static Initializer for the map
     */
    static{
        jnMappings.put(AnatomicalImgagingRegionMap.class, "JN_ANA_IMG_REGION_MAP");
        jnMappings.put(AppropriatenessMap.class, "JN_APPROPRIATENESS_MAP");
        jnMappings.put(CancellationReasonMap.class, "JN_CANCELLATION_RSN_MAP");
        jnMappings.put(EncounterTypeMap.class, "JN_ENCOUNTER_TYPE_MAP");
        jnMappings.put(ExamReasonMap.class, "JN_EXAM_REASON_MAP");
        jnMappings.put(FindingsMap.class, "JN_FINDING_MAP");
        jnMappings.put(FundingTypeMap.class, "JN_FUNDING_TYPE_MAP");
        jnMappings.put(GenderMap.class, "JN_GENDER_MAP");
        jnMappings.put(ModalityMap.class, "JN_MODALITY_MAP");
        jnMappings.put(PostponeReasonMap.class, "JN_POSTPONE_REASON_MAP");
        jnMappings.put(PriorityLevelMap.class, "JN_PRIORITY_LEVEL_MAP");
        jnMappings.put(ProcedureMap.class, "JN_PROCEDURE_MAP");
        jnMappings.put(ProvinceMap.class, "JN_PROVINCE_MAP");
        jnMappings.put(StatusMap.class, "JN_STATUS_MAP");
        jnMappings.put(TimedExamMap.class, "JN_TIMED_EXAM_MAP");
    }
    
    /**
     * Lookup DataSource via JNDI if injection fails
     */
    private static void init(){
        if (ds==null){
            try{
            InitialContext ctx = new InitialContext();
            ds = (DataSource)ctx.lookup("java:app/jdbc/MIWT");
            }catch(Exception e){
                //Can't lookup data source
            }
        }
    }
    
    /**
     * Creates an insert query for recording the journal entry for a given
     * entity
     * @param entity - Entity instance
     */
    public void buildInsertQuery(Object entity) {
        //Initialize DB connection if required
        init();
        
        //1. Build list of column names and values for insert statement
        Class clazz = entity.getClass();
        List<String> cols = new ArrayList<String>();
        List<Object> values = new ArrayList<Object>();
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            try {
                Column col = field.getAnnotation(Column.class);
                String fieldName = null;
                if (col!=null){
                    fieldName = col.name();
                }else{
                    JoinColumn jc = field.getAnnotation(JoinColumn.class);
                    if (jc!=null){
                        fieldName = jc.name();
                    }
                }
                Method m = clazz.getMethod("get" + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1), new Class[0]);
                Object value = m.invoke(entity, new Object[0]);
                if (value != null && value.getClass().getAnnotation(Entity.class) != null) {
                    Field[] subFields = value.getClass().getDeclaredFields();
                    for (Field field1 : subFields) {
                        if (field1.getAnnotation(Id.class) != null) {
                           m = value.getClass().getMethod("get" + field1.getName().substring(0, 1).toUpperCase() + field1.getName().substring(1), new Class[0]);
                            break;
                        }
                    }
                    value = m.invoke(value, new Object[0]);
                }
                if (value != null
                        && !((value instanceof String)
                        && ((String) value).isEmpty())) {
                    cols.add(fieldName);
                    values.add(value);
                }

            } catch (Exception e) {
                //ignore
            }
        }
        //2. Build dynamic SQL insert script based on values we have in hand
        StringBuilder buff = new StringBuilder();
        buff.append("INSERT INTO "+jnMappings.get(clazz) +"(");
        for (int i = 0; i < values.size(); i++) {
            String col = cols.get(i);
            if (i > 0) {
                buff.append(", ");
            }
            buff.append(col);
        }
        buff.append(") VALUES (");
         for (int i = 0; i < values.size(); i++) {
             if (i > 0) {
                buff.append(", ");
            }
            buff.append("?");
        }
        buff.append(")");
        //3. Create a prepared statement based on our SQL, set the values, and execute
        Connection conn = null;
        PreparedStatement stmt = null;
        try{
            conn = ds.getConnection();
            stmt = conn.prepareStatement(buff.toString());
            for (int i = 0; i < values.size(); i++) {
                Object value = values.get(i);
                if (value instanceof java.util.Date){
                    stmt.setDate(i+1, new java.sql.Date(((java.util.Date)value).getTime()));
                }else{
                    stmt.setObject(i+1, value);
                }
            }
            stmt.executeUpdate();
            conn.commit();
        }catch(Exception ex){
            ex.printStackTrace();
            try{
                conn.rollback();
            }catch(Exception e){
                //ignore
            }
        }finally{
            if (stmt!=null){
                try{
                    stmt.close();
                }catch(Exception e){
                    //ignore
                }
            }
            if (conn!=null){
                try{
                    conn.close();
                }catch(Exception e){
                    //ignore
                }
            }
        }
        return;
    }

    /**
     * Inserts an audit record before an Insert
     * @param entity - Object
     */
    @PrePersist
    public void prePersist(Object entity) {
       buildInsertQuery(entity);
    }
    
    /**
     * Inserts an audit record before an Update
     * @param entity - Object
     */
    @PreUpdate
    public void preUpdate(Object entity) {
        buildInsertQuery(entity);
    }
}
