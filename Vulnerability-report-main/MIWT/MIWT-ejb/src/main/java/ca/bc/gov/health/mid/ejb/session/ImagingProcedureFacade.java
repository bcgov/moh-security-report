package ca.bc.gov.health.mid.ejb.session;

import ca.bc.gov.health.mid.ejb.entity.ImagingProcedure;
import jakarta.annotation.Resource;
import jakarta.ejb.Stateless;
import jakarta.ejb.TransactionAttribute;
import jakarta.ejb.TransactionAttributeType;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;
import jakarta.validation.*;
import java.sql.*;
import java.util.*;
import java.util.Date;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.DataSource;

/**
 *
 * @author CGI Information Management Consultants Inc.
 */
@Stateless
public class ImagingProcedureFacade extends AbstractFacade<ImagingProcedure> implements ImagingProcedureFacadeLocal {

    private static final Logger logger = Logger.getLogger(ImagingProcedureFacade.class.getName());
    
    @PersistenceContext(unitName = "MIDPU")
    private EntityManager em;
    @Resource(name = "java:app/jdbc/MIWT")
    private DataSource ds;
    private Validator v;

    protected EntityManager getEntityManager() {
        return em;
    }

    public ImagingProcedureFacade() {
        super(ImagingProcedure.class);
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        v = factory.getValidator();
    }
    
    /* Process data in the temp table, move them into the actual mid_imaging_procedure table
     * (insert or update)
     * AtomicInteger insertCount, AtomicInteger updateCount
     */
    @Override
    public void processData(String uploadFileKey,AtomicInteger insertCount, AtomicInteger updateCount, AtomicInteger dbErrors) {
        //
        long startTime = System.currentTimeMillis();
        long diff;
        logger.log(Level.INFO, "Start processing data in temp table");
        int inserts = 0;
        int updates = 0;
        int errors = 0;

        try (   Connection conn = ds.getConnection();
                CallableStatement cs = conn.prepareCall("BEGIN MIWT_SNAPSHOTLOAD_PKG.pr_data_move(?,?,?,?); END;"); ) 
        {
            cs.setString(1, uploadFileKey);
            cs.registerOutParameter(2, java.sql.Types.INTEGER);
            cs.registerOutParameter(3, java.sql.Types.INTEGER);
            cs.registerOutParameter(4, java.sql.Types.INTEGER);
            
            // execute pr_data_move procedure
            cs.executeUpdate();
            conn.commit();
            
            inserts = cs.getInt(2);
            updates = cs.getInt(3);
            errors = cs.getInt(4);
   
            diff = System.currentTimeMillis() - startTime;
            logger.log(Level.INFO, "Data moving from temp to mid_imaging_procedure table completed in " + diff / 1000 + " seconds");
            logger.log(Level.INFO, "inserts = " + inserts + " updates = " + updates + " errors = " + errors);
            insertCount.addAndGet(inserts);
            updateCount.addAndGet(updates);
            dbErrors.addAndGet(errors);
            return;
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error while processing data from temp table", e);
        }
    }
    
    /*
     * Clean up all old (records uploaded more than one day and left by the user in
     * the temp table
     */
    @Override
    public void cleanupOldRecords() {
        logger.log(Level.INFO, "Clean up old records from the temp table");
        long startTime = System.currentTimeMillis();
        Connection conn = null;
        PreparedStatement stmt = null;
        try {         
            conn = ds.getConnection();
            stmt = conn.prepareStatement("DELETE FROM MIWT.MID_IMAGING_PROCEDURE_T WHERE CREATED_ON_DTM < SYSDATE - 1 ");
            stmt.executeUpdate();                    
            conn.commit();
            logger.log(Level.INFO, "Old records in temp table is deleted in " + (System.currentTimeMillis() - startTime) + " ms");
        } catch (Exception e) {
            e.printStackTrace();
        }
        finally{
            if (stmt!=null){
                try{
                    stmt.close();
                }catch(Exception e){
                    //ignore
                }
            }
            if (conn!=null){
                try{
                    conn.close();
                }catch(Exception e){
                    //ignore
                }
            }
        }
    }
    
    /*
     * Clean up all current records in the mid_imaging_proceure_temp table
     */
    @Override
    public void cleanupTempTable(String uploadKey) {
        
        logger.log(Level.INFO, "Start cleanupTempTable(), uploadKey =" + uploadKey);
        long startTime = System.currentTimeMillis();
        Connection conn = null;
        PreparedStatement stmt = null;
        try {
            
            conn = ds.getConnection();
            stmt = conn.prepareStatement("DELETE FROM MIWT.MID_IMAGING_PROCEDURE_T WHERE UPLOAD_KEY =? ");
            stmt.setString(1, uploadKey);
            stmt.executeUpdate();                    
            conn.commit();
        
            logger.log(Level.INFO, "Temp Table cleaning completed in " + (System.currentTimeMillis() - startTime) + " ms");
        } catch (Exception e) {
            e.printStackTrace();
        }
        finally{
            if (stmt!=null){
                try{
                    stmt.close();
                }catch(Exception e){
                    //ignore
                }
            }
            if (conn!=null){
                try{
                    conn.close();
                }catch(Exception e){
                    //ignore
                }
            }
        }
        logger.log(Level.INFO, "cleanupTempTable() completed.");
    }

    @Override
    public List<String> findAllBookingIDsForHA(String haCode) {
        Query q = em.createNativeQuery("SELECT BOOKING_ID FROM MID_IMAGING_PROCEDURE MP WHERE MP.HEALTH_AUTHORITY_CD = ?1");
        q.setParameter(1, haCode);
        return q.getResultList();

    }

    @Override
    public Map<String, String> findBookingMapForHa(Long haCode) {
        
        Map<String, String> out = new HashMap<String, String>();
        // if database has no duplicate records
        String query = "SELECT BOOKING_ID, FACILITY_ID, CHECKSUM FROM MIWT.MID_IMAGING_PROCEDURE MP WHERE MP.HEALTH_AUTHORITY_CD = ?1";
        
        Query q = em.createNativeQuery(query);
        q.setHint("eclipselink.jdbc.fetch-size", 1000);
        q.setParameter(1, haCode);
        List<Object[]> results = q.getResultList();
        
        for (Object[] row : results) {
            if (row[0] == null) {row[0] = "";}
            if (row[1] == null) {row[1] = "";}
            if (row[2] == null) {row[2] = "";}
            
            // New unique key = booking_id + facility_id
            //c2-28262 MIWT key is just booking id
            String key = (String) (row[0]);
            out.put(key, (String)row[2]);
        }

        /*String query = "SELECT \n"
                + "BOOKING_ID, FACILITY_ID, EXAM_ID, IMAGING_PROCEDURE_ID \n"
                + ", CASE WHEN (AD.APPROVAL_DT > MP.CREATED_ON_DTM) THEN 1  ELSE 0 END AS EXISTING \n"
                + ", STATELESS_TRANSACTION_NBR \n"
                + ", CHECKSUM \n"
                + "FROM \n"
                + "MID_IMAGING_PROCEDURE MP,\n"
                + "(SELECT MAX (APPROVAL_DTM) APPROVAL_DT FROM MIRD_DATA_APPROVAL DA WHERE DA.HEALTH_AUTHORITY_ID = ?1) AD \n"
                + "WHERE MP.HEALTH_AUTHORITY_CD = ?2";
        Query q = em.createNativeQuery(query);
        q.setHint("eclipselink.jdbc.fetch-size", 1000);
        q.setParameter(1, haCode);
        q.setParameter(2, haCode);
        Map<String, Object[]> out = new HashMap<String, Object[]>();
        List<Object[]> results = q.getResultList();
        for (Object[] row : results) {
            if (row[0] == null) {
                row[0] = "";
            }
            if (row[1] == null) {
                row[1] = "";
            }
            if (row[2] == null) {
                row[2] = "";
            }
            if (row[6] == null) {
                row[6] = "";
            }
            
            // string booking id + facility id + exam id (might be empty) becomes key
            String key = (String) (row[0] + "-" + row[1] + "-" + row[2]);
            
            Object [] value = new Object[] { ((BigDecimal) row[3]).longValue(), // imaging_procedure_id
                                        Long.parseLong(row[4].toString()),     // whether has been proved (1 yes, 0 no)
                                        ((BigDecimal) row[5]).longValue(),      // transaction number 
                                        row[6] // checksum value
                                         };
            out.put(key, value);
        }
        */
        return out;
    }

    @Override
    public List<ImagingProcedure> findAllBookingIDsForHAFromDate(String haCode, Date date) {
        Query q = em.createNamedQuery("ImagingProcedure.findByHAAndBookingFormReceivedDate", ImagingProcedure.class);

        q.setParameter("haCode", haCode);
        q.setParameter("bookingFormReceivedDate", date);
        return q.getResultList();

    }

    @Override
    public List<ImagingProcedure> findAllForHAForDateRange(String haCode, Date fromDate, Date toDate) {
        Query q = em.createNamedQuery("ImagingProcedure.findByHAAndBookingFormReceivedDateRange", ImagingProcedure.class);

        q.setParameter("haCode", haCode);
        q.setParameter("startDate", fromDate);
        q.setParameter("endDate", toDate);

        return q.getResultList();
    }
    
    @Override
    public int batchToTempTable(List<ImagingProcedure> list, String uploadKey, int startLine, List<String> messages ) {
        int errorCount = 0;
        int line = startLine;
        long startTime = System.currentTimeMillis();
        long newId = 0;
        Connection conn = null;
        PreparedStatement insertStmt = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            conn = ds.getConnection();
            stmt = conn.createStatement();
            rs = stmt.executeQuery("SELECT MID_IMAGING_PROCEDURE_TEMP_SEQ.nextval FROM DUAL");
            rs.next();
            newId = rs.getLong(1);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        List<ImagingProcedure> tempList = new ArrayList<ImagingProcedure>();
         
        for (int i = 0; i < list.size(); i++ ) {
            ImagingProcedure imagingProcedure = list.get(i);
            try {
                Set<ConstraintViolation<ImagingProcedure>> msgs = v.validate(imagingProcedure);
                if (msgs.size() < 2) {

                    imagingProcedure.setImagingProcedureId(newId);

                    tempList.add(imagingProcedure);
                    newId++;                   

                } else {
                    errorCount++;
                }
            } catch (ConstraintViolationException cve) {
                errorCount++;
                for (ConstraintViolation cv : cve.getConstraintViolations()) {
                    messages.add("Error - Line " + line + ": " + cv.getPropertyPath().toString() + " " + cv.getMessage());
                }
            } catch (Throwable e) {
                errorCount++;
                messages.add("Error - Line " + line + ": " + e.getMessage());
            }
            line++;
        }
        try {

            //em.flush();
            conn = ds.getConnection();
            conn.setAutoCommit(false);
            insertStmt = conn.prepareStatement(getInsertToTempSql());
            for (ImagingProcedure imagingProcedure : tempList) {
                addParamsForTempTable(insertStmt, imagingProcedure, uploadKey, true);
                insertStmt.addBatch();
            }
            if (tempList.size() > 0) {
                insertStmt.executeBatch();
            }
            conn.commit();
            
        } catch (Throwable ejbe) {
            try {
                conn.rollback();
            } catch (Exception e) {
                e.printStackTrace();
            }
            ejbe.printStackTrace();
        } finally {
            if (insertStmt != null) {
                try {
                    insertStmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        System.out.println("Insert " + line + " records into temp table in " + (System.currentTimeMillis() - startTime) + " ms");
        return errorCount;
    };

    @Override
    public int batch(List<ImagingProcedure> list, Long ha, int startLine, List<String> messages, Map<String, Object[]> bookingIds, String username, AtomicInteger insertCount, AtomicInteger updateCount) {
        int errorCount = 0;
        int line = startLine;
        long startTime = System.currentTimeMillis();
        long newId = 0;
        Connection conn = null;
        PreparedStatement insertStmt = null;
        PreparedStatement updateStmt = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            conn = ds.getConnection();
            stmt = conn.createStatement();
            rs = stmt.executeQuery("SELECT MID_IMAGING_PROCEDURE_SEQ.nextval FROM DUAL");
            rs.next();
            newId = rs.getLong(1);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        int ins = 0;
        int up = 0;
        List<ImagingProcedure> inserts = new ArrayList<ImagingProcedure>();
        List<ImagingProcedure> updates = new ArrayList<ImagingProcedure>();
        synchronized (bookingIds) {
            //for (ImagingProcedure imagingProcedure : list) {  
            for (int i = 0; i < list.size(); i++ ) {
                ImagingProcedure imagingProcedure = list.get(i);
                try {
                    Set<ConstraintViolation<ImagingProcedure>> msgs = v.validate(imagingProcedure);
                    if (msgs.size() < 2) {
                        //C2-28262 key is just booking id
                        //String key = imagingProcedure.getBookingId() + "-" + imagingProcedure.getExamId() + "-" + imagingProcedure.getFacilityId();
                        String key = imagingProcedure.getBookingId(); 
                        //Object[] values = bookingIds.get(key);
                        
                        // if key is not in the map, then it will be a "insert" for a new record 
                        if (!bookingIds.containsKey(key)) {                          
                            imagingProcedure.setImagingProcedureId(newId);
                            imagingProcedure.setCreatedByNm(username);
                            imagingProcedure.setCreatedOnDtm(new Date());
                            imagingProcedure.setStatelessTransactionNbr(1l);
                            
                            Long STN = imagingProcedure.getStatelessTransactionNbr();
                            String CS = imagingProcedure.getChecksum();
                            bookingIds.put(key, new Object[]{newId, 0l, STN, CS});
                            
                            inserts.add(imagingProcedure);
                            newId++;
                            ins++;                          
                         
                        } else {
                            
                            Object[] temp = bookingIds.remove(key);
                            imagingProcedure.setImagingProcedureId((Long)temp[0]);
                            imagingProcedure.setLastModifiedOnDtm(new Date());
                            imagingProcedure.setLastModifiedByNm(username);
                            Long n = (Long)(temp[2]);
                            Long nPlus = Long.valueOf(n.longValue() + 1l);
                            imagingProcedure.setStatelessTransactionNbr(nPlus);
                            
                            String newChecksum = imagingProcedure.getChecksum();
                            bookingIds.put(key, new Object[]{temp[0], temp[1], imagingProcedure.getStatelessTransactionNbr(), newChecksum});
                            
                            updates.add(imagingProcedure);
                            up++;

                        }
                    } else {
                        errorCount++;
                    }
                } catch (ConstraintViolationException cve) {
                    errorCount++;
                    for (ConstraintViolation cv : cve.getConstraintViolations()) {
                        messages.add("Error - Line " + line + ": " + cv.getPropertyPath().toString() + " " + cv.getMessage());
                    }
                } catch (Throwable e) {
                    errorCount++;
                    messages.add("Error - Line " + line + ": " + e.getMessage());
                }
                line++;
            }
        }
        try {

            //em.flush();
            conn = ds.getConnection();
            conn.setAutoCommit(false);
            insertStmt = conn.prepareStatement(getInsertSql());
            for (ImagingProcedure imagingProcedure : inserts) {
                addParams(insertStmt, imagingProcedure,true);
                insertStmt.addBatch();
            }
            if (inserts.size() > 0) {
                insertStmt.executeBatch();
            }
            conn.commit();
            
            updateStmt = conn.prepareStatement(getUpdateSql());
            for (ImagingProcedure imagingProcedure : updates) {
                addParams(updateStmt, imagingProcedure,false);
                updateStmt.addBatch();
            }
            if (updates.size() > 0) {
                updateStmt.executeBatch();
            }
            conn.commit();
            insertCount.addAndGet(ins);
            updateCount.addAndGet(up);
        } catch (Throwable ejbe) {
            try {
                conn.rollback();
            } catch (Exception e) {
                e.printStackTrace();
            }
            ejbe.printStackTrace();
        } finally {
            if (insertStmt != null) {
                try {
                    insertStmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (updateStmt != null) {
                try {
                    updateStmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        System.out.println("Processed " + line + " records in " + (System.currentTimeMillis() - startTime) + " ms");
        return errorCount;
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    private void saveRecord(Map<String, Long> bookingIds, String key, ImagingProcedure imagingProcedure) {
        if (bookingIds.containsKey(key)) {
            imagingProcedure.setImagingProcedureId(bookingIds.get(key));
            em.merge(imagingProcedure);
        } else {
            em.persist(imagingProcedure);
            bookingIds.put(key, imagingProcedure.getImagingProcedureId());
        }
    }
    
    private String getInsertToTempSql() {
        //#18679 replaced PROV_PROCEDURE_CD and PROV_PROCEDURE_CD_COMPLETED by EXAM_COUNT and EXAM_COUNT_COMPLETED
        return "INSERT INTO MID_IMAGING_PROCEDURE_T (STATUS_CD, PHN, FIRST_GIVEN_NM, SECOND_GIVEN_NM, THIRD_GIVEN_NM, SURNAME_NM, PREFERRED_NM, BIRTH_DT, GENDER_CD, ADDRESS_LINE_1, ADDRESS_LINE_2, ADDRESS_LINE_3, CITY, PROVINCE_CD, POSTAL_CODE, BOOKING_ID, FACILITY_ID, PRACTITIONER_ID, MSP_NO, ENCOUNTER_TYPE_CD, EXAM_REASON, APPROPRIATENESS_CD, PRIORITY_LEVEL, MODALITY_CD, HA_PROCEDURE_CD, EXAM_COUNT, SNOMED_CD, SEDATION_YN, TIMED_EXAM_YN, REFERRAL_DT, BOOKING_FORM_RECEIVED_DT, BOOKING_CREATED_DT, PROCEDURE_SCHEDULED_DT, PROCEDURE_CANCELLED_DT, CANCELLATION_REASON_CD, PROCEDURE_POSTPONED_DT, POSTPONEMENT_REASON_CD, PATIENT_UNAVAIL_START_DT_1, PATIENT_UNAVAIL_END_DT_1, PATIENT_UNAVAIL_START_DT_2, PATIENT_UNAVAIL_END_DT_2, PATIENT_UNAVAIL_START_DT_3, PATIENT_UNAVAIL_END_DT_3, EXAM_ID, URN, MRN, FACILITY_ID_COMPLETED, MACHINE_ID, MODALITY_CD_COMPLETED, HA_PROCEDURE_CD_COMPLETED, EXAM_COUNT_COMPLETED, SNOMED_CD_COMPLETED, SEDATION_YN_COMPLETED, PROCEDURE_DURATION, PROCEDURE_PERFORMED_DT, RESULTS_AVAIL_DT, DIAGNOSIS_TXT, FUNDING_TYPE_CD, HEALTH_AUTHORITY_CD, CREATED_ON_DTM, LAST_MODIFIED_ON_DTM, CREATED_BY_NM, LAST_MODIFIED_BY_NM, STATELESS_TRANSACTION_NBR, CHECKSUM, UPLOAD_KEY, IMAGING_PROCEDURE_ID) VALUES ( ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,? )";
    }

    private String getInsertSql() {
        //#18679 replaced PROV_PROCEDURE_CD and PROV_PROCEDURE_CD_COMPLETED by EXAM_COUNT and EXAM_COUNT_COMPLETED
        return "INSERT INTO MID_IMAGING_PROCEDURE (STATUS_CD, PHN, FIRST_GIVEN_NM, SECOND_GIVEN_NM, THIRD_GIVEN_NM, SURNAME_NM, PREFERRED_NM, BIRTH_DT, GENDER_CD, ADDRESS_LINE_1, ADDRESS_LINE_2, ADDRESS_LINE_3, CITY, PROVINCE_CD, POSTAL_CODE, BOOKING_ID, FACILITY_ID, PRACTITIONER_ID, MSP_NO, ENCOUNTER_TYPE_CD, EXAM_REASON, APPROPRIATENESS_CD, PRIORITY_LEVEL, MODALITY_CD, HA_PROCEDURE_CD, EXAM_COUNT, SNOMED_CD, SEDATION_YN, TIMED_EXAM_YN, REFERRAL_DT, BOOKING_FORM_RECEIVED_DT, BOOKING_CREATED_DT, PROCEDURE_SCHEDULED_DT, PROCEDURE_CANCELLED_DT, CANCELLATION_REASON_CD, PROCEDURE_POSTPONED_DT, POSTPONEMENT_REASON_CD, PATIENT_UNAVAIL_START_DT_1, PATIENT_UNAVAIL_END_DT_1, PATIENT_UNAVAIL_START_DT_2, PATIENT_UNAVAIL_END_DT_2, PATIENT_UNAVAIL_START_DT_3, PATIENT_UNAVAIL_END_DT_3, EXAM_ID, URN, MRN, FACILITY_ID_COMPLETED, MACHINE_ID, MODALITY_CD_COMPLETED, HA_PROCEDURE_CD_COMPLETED, EXAM_COUNT_COMPLETED, SNOMED_CD_COMPLETED, SEDATION_YN_COMPLETED, PROCEDURE_DURATION, PROCEDURE_PERFORMED_DT, RESULTS_AVAIL_DT, DIAGNOSIS_TXT, FUNDING_TYPE_CD, HEALTH_AUTHORITY_CD, CREATED_ON_DTM, LAST_MODIFIED_ON_DTM, CREATED_BY_NM, LAST_MODIFIED_BY_NM, STATELESS_TRANSACTION_NBR, CHECKSUM, IMAGING_PROCEDURE_ID) VALUES ( ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,? )";
    }

    private String getUpdateSql() {
        //#18679 replaced PROV_PROCEDURE_CD and PROV_PROCEDURE_CD_COMPLETED by EXAM_COUNT and EXAM_COUNT_COMPLETED
        return "UPDATE MID_IMAGING_PROCEDURE SET STATUS_CD=?, PHN=?, FIRST_GIVEN_NM=?, SECOND_GIVEN_NM=?, THIRD_GIVEN_NM=?, SURNAME_NM=?, PREFERRED_NM=?, BIRTH_DT=?, GENDER_CD=?, ADDRESS_LINE_1=?, ADDRESS_LINE_2=?, ADDRESS_LINE_3=?, CITY=?, PROVINCE_CD=?, POSTAL_CODE=?, BOOKING_ID=?, FACILITY_ID=?, PRACTITIONER_ID=?, MSP_NO=?, ENCOUNTER_TYPE_CD=?, EXAM_REASON=?, APPROPRIATENESS_CD=?, PRIORITY_LEVEL=?, MODALITY_CD=?, HA_PROCEDURE_CD=?, EXAM_COUNT=?, SNOMED_CD=?, SEDATION_YN=?, TIMED_EXAM_YN=?, REFERRAL_DT=?, BOOKING_FORM_RECEIVED_DT=?, BOOKING_CREATED_DT=?, PROCEDURE_SCHEDULED_DT=?, PROCEDURE_CANCELLED_DT=?, CANCELLATION_REASON_CD=?, PROCEDURE_POSTPONED_DT=?, POSTPONEMENT_REASON_CD=?, PATIENT_UNAVAIL_START_DT_1=?, PATIENT_UNAVAIL_END_DT_1=?, PATIENT_UNAVAIL_START_DT_2=?, PATIENT_UNAVAIL_END_DT_2=?, PATIENT_UNAVAIL_START_DT_3=?, PATIENT_UNAVAIL_END_DT_3=?, EXAM_ID=?, URN=?, MRN=?, FACILITY_ID_COMPLETED=?, MACHINE_ID=?, MODALITY_CD_COMPLETED=?, HA_PROCEDURE_CD_COMPLETED=?, EXAM_COUNT_COMPLETED=?, SNOMED_CD_COMPLETED=?, SEDATION_YN_COMPLETED=?, PROCEDURE_DURATION=?, PROCEDURE_PERFORMED_DT=?, RESULTS_AVAIL_DT=?, DIAGNOSIS_TXT=?, FUNDING_TYPE_CD=?, HEALTH_AUTHORITY_CD=?, LAST_MODIFIED_ON_DTM=?, LAST_MODIFIED_BY_NM=?, STATELESS_TRANSACTION_NBR=?, CHECKSUM=? WHERE IMAGING_PROCEDURE_ID=?";
    }

    private void addParams(PreparedStatement stmt, ImagingProcedure imagingProcedure, boolean isInsert) throws SQLException {
        int i = 1;
        stmt.setObject(i++, imagingProcedure.getStatusCd());
        stmt.setObject(i++, imagingProcedure.getPHN());
        stmt.setObject(i++, imagingProcedure.getFirstGivenNm());
        stmt.setObject(i++, imagingProcedure.getSecondGivenNm());
        stmt.setObject(i++, imagingProcedure.getThirdGivenNm());
        stmt.setObject(i++, imagingProcedure.getSurnameNm());
        stmt.setObject(i++, imagingProcedure.getPreferredNm());
        stmt.setDate(i++, toDate(imagingProcedure.getBirthDt()));
        stmt.setObject(i++, imagingProcedure.getGenderCd());
        stmt.setObject(i++, imagingProcedure.getAddressLine1());
        stmt.setObject(i++, imagingProcedure.getAddressLine2());
        stmt.setObject(i++, imagingProcedure.getAddressLine3());
        stmt.setObject(i++, imagingProcedure.getCity());
        stmt.setObject(i++, imagingProcedure.getProvinceCd());
        stmt.setObject(i++, imagingProcedure.getPostalCode());
        stmt.setObject(i++, imagingProcedure.getBookingId());
        stmt.setObject(i++, imagingProcedure.getFacilityId());
        stmt.setObject(i++, imagingProcedure.getPractitionerId());
        stmt.setObject(i++, imagingProcedure.getMspNo());
        stmt.setObject(i++, imagingProcedure.getEncounterTypeCd());
        stmt.setObject(i++, imagingProcedure.getExamReason());
        stmt.setObject(i++, imagingProcedure.getAppropriatenessCd());
        stmt.setObject(i++, imagingProcedure.getPriorityLevel());
        stmt.setObject(i++, imagingProcedure.getModalityCd());
        stmt.setObject(i++, imagingProcedure.getHaProcedureCd());
        stmt.setObject(i++, imagingProcedure.getExamCount()); //#18679 replacing imagingProcedure.getProvProcedureCd
        stmt.setObject(i++, imagingProcedure.getSnomedCd());
        stmt.setObject(i++, imagingProcedure.getSedationYn());
        stmt.setObject(i++, imagingProcedure.getTimedExamYn());
        stmt.setDate(i++, toDate(imagingProcedure.getReferralDt()));
        stmt.setDate(i++, toDate(imagingProcedure.getBookingFormReceivedDt()));
        stmt.setDate(i++, toDate(imagingProcedure.getBookingCreatedDt()));
        stmt.setDate(i++, toDate(imagingProcedure.getProcedureScheduledDt()));
        stmt.setDate(i++, toDate(imagingProcedure.getProcedureCancelledDt()));
        stmt.setObject(i++, imagingProcedure.getCancellationReasonCd());
        stmt.setDate(i++, toDate(imagingProcedure.getProcedurePostponedDt()));
        stmt.setObject(i++, imagingProcedure.getPostponementReasonCd());
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailStartDt1()));
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailEndDt1()));
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailStartDt2()));
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailEndDt2()));
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailStartDt3()));
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailEndDt3()));
        stmt.setObject(i++, imagingProcedure.getExamId());
        stmt.setObject(i++, imagingProcedure.getUrn());
        stmt.setObject(i++, imagingProcedure.getMrn());
        stmt.setObject(i++, imagingProcedure.getFacilityIdCompleted());
        stmt.setObject(i++, imagingProcedure.getMachineId());
        stmt.setObject(i++, imagingProcedure.getModalityCdCompleted());
        stmt.setObject(i++, imagingProcedure.getHaProcedureCdCompleted());
        stmt.setObject(i++, imagingProcedure.getExamCountCompleted()); //#18679 replacing imagingProcedure.getProvProcedureCdCompleted
        stmt.setObject(i++, imagingProcedure.getSnomedCdCompleted());
        stmt.setObject(i++, imagingProcedure.getSedationYnCompleted());
        stmt.setObject(i++, imagingProcedure.getProcedureDuration());
        stmt.setDate(i++, toDate(imagingProcedure.getProcedurePerformedDt()));
        stmt.setDate(i++, toDate(imagingProcedure.getResultsAvailDt()));
        stmt.setObject(i++, imagingProcedure.getDiagnosisTxt());
        stmt.setObject(i++, imagingProcedure.getFundingTypeCd());
        stmt.setObject(i++, imagingProcedure.getHealthAuthorityCd());
        if (isInsert) {
            stmt.setTimestamp(i++, toTimestamp(imagingProcedure.getCreatedOnDtm()));
        }
        stmt.setTimestamp(i++, toTimestamp(imagingProcedure.getLastModifiedOnDtm()));
        if (isInsert) {
            stmt.setObject(i++, imagingProcedure.getCreatedByNm());
        }
        stmt.setObject(i++, imagingProcedure.getLastModifiedByNm());
        stmt.setObject(i++, imagingProcedure.getStatelessTransactionNbr());
        stmt.setObject(i++, imagingProcedure.getChecksum());
        stmt.setObject(i++, imagingProcedure.getImagingProcedureId());      
    }
    
    private void addParamsForTempTable(PreparedStatement stmt, ImagingProcedure imagingProcedure, String uploadKey, boolean isInsert) throws SQLException {
        int i = 1;
        stmt.setObject(i++, imagingProcedure.getStatusCd());
        stmt.setObject(i++, imagingProcedure.getPHN());
        stmt.setObject(i++, imagingProcedure.getFirstGivenNm());
        stmt.setObject(i++, imagingProcedure.getSecondGivenNm());
        stmt.setObject(i++, imagingProcedure.getThirdGivenNm());
        stmt.setObject(i++, imagingProcedure.getSurnameNm());
        stmt.setObject(i++, imagingProcedure.getPreferredNm());
        stmt.setDate(i++, toDate(imagingProcedure.getBirthDt()));
        stmt.setObject(i++, imagingProcedure.getGenderCd());
        stmt.setObject(i++, imagingProcedure.getAddressLine1());
        stmt.setObject(i++, imagingProcedure.getAddressLine2());
        stmt.setObject(i++, imagingProcedure.getAddressLine3());
        stmt.setObject(i++, imagingProcedure.getCity());
        stmt.setObject(i++, imagingProcedure.getProvinceCd());
        stmt.setObject(i++, imagingProcedure.getPostalCode());
        stmt.setObject(i++, imagingProcedure.getBookingId());
        stmt.setObject(i++, imagingProcedure.getFacilityId());
        stmt.setObject(i++, imagingProcedure.getPractitionerId());
        stmt.setObject(i++, imagingProcedure.getMspNo());
        stmt.setObject(i++, imagingProcedure.getEncounterTypeCd());
        stmt.setObject(i++, imagingProcedure.getExamReason());
        stmt.setObject(i++, imagingProcedure.getAppropriatenessCd());
        stmt.setObject(i++, imagingProcedure.getPriorityLevel());
        stmt.setObject(i++, imagingProcedure.getModalityCd());
        stmt.setObject(i++, imagingProcedure.getHaProcedureCd());
        stmt.setObject(i++, imagingProcedure.getExamCount()); //#18679 replacing imagingProcedure.getProvProcedureCd
        stmt.setObject(i++, imagingProcedure.getSnomedCd());
        stmt.setObject(i++, imagingProcedure.getSedationYn());
        stmt.setObject(i++, imagingProcedure.getTimedExamYn());
        stmt.setDate(i++, toDate(imagingProcedure.getReferralDt()));
        stmt.setDate(i++, toDate(imagingProcedure.getBookingFormReceivedDt()));
        stmt.setDate(i++, toDate(imagingProcedure.getBookingCreatedDt()));
        stmt.setDate(i++, toDate(imagingProcedure.getProcedureScheduledDt()));
        stmt.setDate(i++, toDate(imagingProcedure.getProcedureCancelledDt()));
        stmt.setObject(i++, imagingProcedure.getCancellationReasonCd());
        stmt.setDate(i++, toDate(imagingProcedure.getProcedurePostponedDt()));
        stmt.setObject(i++, imagingProcedure.getPostponementReasonCd());
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailStartDt1()));
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailEndDt1()));
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailStartDt2()));
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailEndDt2()));
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailStartDt3()));
        stmt.setDate(i++, toDate(imagingProcedure.getPatientUnavailEndDt3()));
        stmt.setObject(i++, imagingProcedure.getExamId());
        stmt.setObject(i++, imagingProcedure.getUrn());
        stmt.setObject(i++, imagingProcedure.getMrn());
        stmt.setObject(i++, imagingProcedure.getFacilityIdCompleted());
        stmt.setObject(i++, imagingProcedure.getMachineId());
        stmt.setObject(i++, imagingProcedure.getModalityCdCompleted());
        stmt.setObject(i++, imagingProcedure.getHaProcedureCdCompleted());
        stmt.setObject(i++, imagingProcedure.getExamCountCompleted()); //#18679 replacing imagingProcedure.getProvProcedureCdCompleted
        stmt.setObject(i++, imagingProcedure.getSnomedCdCompleted());
        stmt.setObject(i++, imagingProcedure.getSedationYnCompleted());
        stmt.setObject(i++, imagingProcedure.getProcedureDuration());
        stmt.setDate(i++, toDate(imagingProcedure.getProcedurePerformedDt()));
        stmt.setDate(i++, toDate(imagingProcedure.getResultsAvailDt()));
        stmt.setObject(i++, imagingProcedure.getDiagnosisTxt());
        stmt.setObject(i++, imagingProcedure.getFundingTypeCd());
        stmt.setObject(i++, imagingProcedure.getHealthAuthorityCd());
        if (isInsert) {
            stmt.setTimestamp(i++, toTimestamp(imagingProcedure.getCreatedOnDtm()));
        }
        stmt.setTimestamp(i++, toTimestamp(imagingProcedure.getLastModifiedOnDtm()));
        if (isInsert) {
            stmt.setObject(i++, imagingProcedure.getCreatedByNm());
        }
        stmt.setObject(i++, imagingProcedure.getLastModifiedByNm());
        stmt.setObject(i++, imagingProcedure.getStatelessTransactionNbr());
        stmt.setObject(i++, imagingProcedure.getChecksum());
        stmt.setObject(i++, uploadKey);
        stmt.setObject(i++, imagingProcedure.getImagingProcedureId());       
        
    }

    private java.sql.Date toDate(Date dt) {
        if (dt == null) {
            return null;
        } else {
            return new java.sql.Date(dt.getTime());
        }
    }

    private java.sql.Timestamp toTimestamp(Date dt) {
        if (dt == null) {
            return null;
        } else {
            return new java.sql.Timestamp(dt.getTime());
        }
    }

    private Time toTime(Date dt) {
        if (dt == null) {
            return null;
        } else {
            return new Time(dt.getTime());
        }

    }
}
