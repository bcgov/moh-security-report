package ca.bc.gov.health.mid.ejb.session.custom;

import ca.bc.gov.health.mid.ejb.entity.custom.CaseDistributionCriteria;
import ca.bc.gov.health.mid.ejb.entity.custom.CaseDistributionFilter;
import jakarta.ejb.Stateless;
import jakarta.faces.model.SelectItem;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Facade implementation for running case distribution reports
 *
 * @author CGI Information Management Consultants Inc.
 */
@Stateless
public class CaseDistributionFacade implements CaseDistributionFacadeLocal {

    @PersistenceContext(unitName = "MIDPU")
    private EntityManager em;

    @Override
    public Map<String, Map> getCaseDistributionForParams(Long snapshotId, Date startDate, Date endDate, CaseDistributionCriteria criteria) {
        CaseDistributionFilter primary = null;
        CaseDistributionFilter secondary = null;
        for (CaseDistributionFilter filter : criteria.getFilters()) {
            if (filter.getPrimaryGrouping()) {
                primary = filter;
            } else if (filter.getSecondaryGrouping()) {
                secondary = filter;
            }
        }

        Query query = buildQueryForParameters(startDate, endDate, criteria, primary, secondary, snapshotId);
        List results = query.getResultList();

        Map<String, Map> output = buildOutputList(results, primary, secondary);
        return output;
    }

    /**
     * Builds a native query based on the provided parameters
     *
     * @param startDate Date
     * @param endDate Date
     * @param criteria CaseDistributionCriteria
     * @param primary CaseDistributionFilter
     * @param secondary CaseDistributionFilter
     * @return Query
     */
    private Query buildQueryForParameters(Date startDate, Date endDate, CaseDistributionCriteria criteria, CaseDistributionFilter primary, CaseDistributionFilter secondary, Long snapshotId) {
        String tableName = snapshotId == null
                ? "MIRD_PATIENT PT JOIN MIRD_BOOKING BK ON PT.PATIENT_ID = BK.PATIENT_ID JOIN MIRD_COMPLETED_PROCEDURE CP ON BK.BOOKING_ID = CP.BOOKING_ID "
                : "MISA_PATIENT PT JOIN MISA_BOOKING BK ON PT.SNAPSHOT_ID = BK.SNAPSHOT_ID AND PT.PATIENT_ID = BK.PATIENT_ID JOIN MISA_COMPLETED_PROCEDURE CP ON BK.SNAPSHOT_ID = CP.SNAPSHOT_ID AND BK.BOOKING_ID = CP.BOOKING_ID ";
        int paramCount = 0;
        List<CaseDistributionFilter> selectedGroups = new ArrayList<>(2);
        StringBuilder innerSelect = new StringBuilder("SELECT ");
        StringBuilder outerSelect = new StringBuilder("SELECT ");


        if (primary != null) {
            outerSelect.append(constructColumn(innerSelect, primary));
            selectedGroups.add(primary);
        }
        if (secondary != null) {
            outerSelect.append(constructColumn(innerSelect, secondary));
            selectedGroups.add(secondary);
        }

        outerSelect.append("COUNT(*) FROM (");

        // delete trailing ", "
        innerSelect.delete(innerSelect.lastIndexOf(","), innerSelect.length()).append(" ")
                .append("FROM ").append(tableName).append(" ")
                .append("WHERE ");

        // if we are dealing with archived snapshot then add snapshot id
        if (snapshotId != null) {
            innerSelect.append("PT.SNAPSHOT_ID = ").append(snapshotId).append(" AND ");

        }

        innerSelect.append("CP.PROCEDURE_PERFORMED_DT BETWEEN ?1 AND ?2 ");
        paramCount += 2; // 2 params for start and end dates


        for (CaseDistributionFilter filter : selectedGroups) {
            String[] selected = filter.getSelectedOptions();
            if (selected != null && selected.length > 0) {

                if (filter.getColumn().equals("ADULT_YN") || filter.getColumn().equals("WITHIN_BENCHMARK")) {
                    String outcome = columnForWhereClause(filter);

                    if (!outcome.isEmpty()) {
                        innerSelect.append("AND ").append(columnForWhereClause(filter));
                    }
                } else {
                    innerSelect.append("AND ").append(columnForWhereClause(filter)).append(" IN (");

                    for (String s : selected) {
                        innerSelect.append("?").append(++paramCount).append(", ");
                    }
                    innerSelect.delete(innerSelect.length() - 2, innerSelect.length()).append(") ");
                }
            }
        }
        outerSelect.append(innerSelect).append(") ").append("GROUP BY ")
                .append(outerSelect.subSequence(outerSelect.indexOf("SELECT") + "SELECT".length(), outerSelect.indexOf("COUNT")))
                .delete(outerSelect.length() - 2, outerSelect.length());  // delete trailing ", "


        paramCount = 0;  // reset for reuse
        Query query = em.createNativeQuery(outerSelect.toString());
        query.setParameter(++paramCount, startDate);

        query.setParameter(++paramCount, endDate);

        for (CaseDistributionFilter filter : selectedGroups) {
            String[] selected = filter.getSelectedOptions();
            if (selected != null && selected.length > 0) {

                // if we yes and no are selcted for ADULT_YN or WITHIN_BENCHMARK,  
                // we skip adding parameters as it is redundant
                if ((filter.getColumn().equals("ADULT_YN") || filter.getColumn().equals("WITHIN_BENCHMARK"))
                        && filter.getSelectedOptions().length == 2) {
                    continue;
                }
                for (String value : selected) {
                    query.setParameter(++paramCount, value);
                }
            }
        }
        return query;
    }

    private String constructColumn(StringBuilder builder, CaseDistributionFilter filter) {
        String result;
        if (filter.getColumn().equals("ADULT_YN")) {
            builder.append("CASE WHEN MONTHS_BETWEEN(CP.PROCEDURE_PERFORMED_DT, PT.BIRTH_DT) / 12 >= 17 THEN 'Y' ELSE 'N' END IsAdult").append(", ");
            result = "IsAdult, ";
        } else if (filter.getColumn().equals("WITHIN_BENCHMARK")) {
            builder.append("CASE WHEN (CP.PROCEDURE_PERFORMED_DT - BK.BOOKING_FORM_RECEIVED_DT) <= BK.BENCHMARK_WAIT_TIME THEN 'Y' ELSE 'N' END WITHIN_BENCHMARK").append(", ");
            result = "WITHIN_BENCHMARK, ";
        } else {
            builder.append("CP.").append(filter.getColumn()).append(", ");
            result = filter.getColumn() + ", ";
        }

        return result;
    }

    private String columnForWhereClause(CaseDistributionFilter filter) {
        StringBuilder result = new StringBuilder();
        String[] selectedoptions = filter.getSelectedOptions();

        if (filter.getColumn().equals("ADULT_YN")) {

            if (selectedoptions.length == 1) {
                if (selectedoptions[0].equals("Y")) {
                    result.append("MONTHS_BETWEEN(CP.PROCEDURE_PERFORMED_DT, PT.BIRTH_DT) / 12 >= 17 ");
                } else {
                    result.append("MONTHS_BETWEEN(CP.PROCEDURE_PERFORMED_DT, PT.BIRTH_DT) / 12 < 17 ");
                }
            }

        } else if (filter.getColumn().equals("WITHIN_BENCHMARK")) {

            if (selectedoptions.length == 1) {
                if (selectedoptions[0].equals("Y")) {
                    result.append("(CP.PROCEDURE_PERFORMED_DT - BK.BOOKING_FORM_RECEIVED_DT) <= BK.BENCHMARK_WAIT_TIME ");
                } else {
                    result.append("(CP.PROCEDURE_PERFORMED_DT - BK.BOOKING_FORM_RECEIVED_DT) > BK.BENCHMARK_WAIT_TIME ");
                }
            }
        } else {
            result.append("CP.").append(filter.getColumn());
        }

        return result.toString();
    }

    /**
     * Transforms the resultset into a matrix format for display
     *
     * @param results - List in the format: primary, secondary, value
     * @param primary - Primary variable
     * @param secondary - Secondary variable
     * @return primary x secondary matrix
     */
    private Map<String, Map> buildOutputList(List results, CaseDistributionFilter primary, CaseDistributionFilter secondary) {
        //Build matrix
        List<SelectItem> rows = primary.getSelectedOptionAsSelectItem();
        if (rows == null || rows.isEmpty()) {
            rows = primary.getOptions();
        }
        List<SelectItem> cols = null;
        if (secondary != null) {
            cols = secondary.getSelectedOptionAsSelectItem();
            if (cols == null || cols.isEmpty()) {
                cols = secondary.getOptions();
            }
        }
        Map<String, Map> output = new LinkedHashMap<>();
        Map<Object, String> primaryDecode = buildDecode(rows);
        Map<Object, String> secondaryDecode = secondary == null ? null : buildDecode(cols);

        //Calculate totals
        Map totalRow = new HashMap();

        //Initialize empty matrix
        for (SelectItem row : rows) {
            Map values = new HashMap();
            values.put("label", row.getLabel());
            if (cols != null) {
                for (SelectItem col : cols) {
                    values.put(col.getLabel(), 0);
                    totalRow.put(col.getLabel(), 0);
                }
            }
            values.put("total", 0);
            totalRow.put("total", 0);

            output.put(row.getLabel(), values);
        }

        totalRow.put("label", "Total");
        output.put("total", totalRow);

        //Populate with values
        for (Object obj : results) {
            Object[] row = (Object[]) obj;
            if (secondary != null) {
                Object primaryKey = row[0]==null?null:row[0].toString(); //decodeResultField(primary, row[0]);
                Object secondaryKey = row[1]==null?null:row[1].toString(); //decodeResultField(secondary, row[1]);
                int value = ((BigDecimal) row[2]).intValueExact();
                String primaryLabel = primaryDecode.get(primaryKey);
                String secondaryLabel = secondaryDecode.get(secondaryKey);
                if (primaryLabel != null && secondaryLabel != null) {
                    output.get(primaryLabel).put(secondaryLabel, value);

                    // Get the current total for this row and add Value to it
                    int total = (Integer) output.get(primaryLabel).get("total");
                    output.get(primaryLabel).put("total", total + value);

                    total = (Integer) output.get("total").get(secondaryLabel);
                    output.get("total").put(secondaryLabel, total + value);

                    total = (Integer) output.get("total").get("total");
                    output.get("total").put("total", total + value);
                }
            } else {
                Object primaryKey = row[0].toString();
                Object value = row[1];
                output.get(primaryDecode.get(primaryKey)).put("total", value);
            }
        }

        return output;
    }

    private Map<Object, String> buildDecode(List<SelectItem> rows) {
        Map<Object, String> decode = new HashMap<>();
        for (SelectItem selectItem : rows) {
            decode.put(selectItem.getValue().toString(), selectItem.getLabel());
        }
        return decode;
    }
}
