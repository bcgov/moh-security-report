package ca.bc.gov.health.mid.util;

import ca.bc.gov.health.mid.ejb.entity.*;
import ca.bc.gov.health.mid.ejb.session.*;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.ejb.Singleton;
import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * @author CGI Information Management Consultants Inc.
 */
@Singleton
public class RawDataValidator implements Serializable, RawDataValidatorLocal {

    private static final Logger logger = Logger.getLogger(RawDataValidator.class.getName());
    private static final SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
    private static final String SPECIAL_CHARACTERS = StringUtils.deleteWhitespace("! \" # $ % ( ) * / : ; ? @ [ \\ ] ^ _ { | } ~ + < = >");
    private static final String ADDRESS_SPECIAL_CHARACTERS = StringUtils.deleteWhitespace("! \" $ % * : ; ? @ [ \\ ] ^ _ { | } ~ + < = >");

    private final Map<Integer, String> dateFieldsNdxMap = new HashMap<>();
    private final Map<Integer, String> nonFutureDateFieldsNdxMap = new HashMap<>();
    private final Map<Integer, String> nonFutureNonHistoricalDateFieldsNdxMap = new HashMap<>();
    private final Map<Integer, String> requiredFieldsNdxMap = new HashMap<>();
    private final Map<Integer, String> conditionallyRequiredFieldsNdxMap = new HashMap<>();
    private final Map<Integer, String> mappedFieldsNdxMap = new HashMap<>();
    private final Map<Integer, String> mappedFieldsWithNoUpdateNdxMap = new HashMap<>();
    private final Map<Integer, String> preferredAvailableFieldsNdxMap = new HashMap<>();
    private final Map<Integer, String> conditionalPreferredAvailableFieldsNdxMap = new HashMap<>();
    private final Map<Integer, String> mandatoryDateFieldsNdxMap = new HashMap<>();
    private final Map<Integer, String> requiredVCHAFieldsNdxMap = new HashMap<>();
    private final List<Integer> expiringMappings = new ArrayList<>();

    private static final Map facilitiesVCHA = new HashMap<>();

    @EJB
    protected AppropriatenessMapFacadeLocal apprMapFacade;

    @EJB
    protected CancellationReasonMapFacadeLocal canRsMapFacade;

    @EJB
    protected EncounterTypeMapFacadeLocal encMapFacade;

    @EJB
    protected ExamReasonMapFacadeLocal examRsnMapFacade;

    @EJB
    protected FindingsMapFacadeLocal fndsMapFacade;

    @EJB
    protected FundingTypeMapFacadeLocal fndgMapFacade;

    @EJB
    protected GenderMapFacadeLocal gndMapFacade;

    @EJB
    protected ModalityMapFacadeLocal modMapFacade;

    @EJB
    protected PostponeReasonMapFacadeLocal ppRsnMapFacade;

    @EJB
    protected PriorityLevelMapFacadeLocal pLvlMapFacade;

    @EJB
    protected ProcedureMapFacadeLocal procMapFacade;

    @EJB
    protected ProvinceMapFacadeLocal provMapFacade;

    @EJB
    protected StatusMapFacadeLocal stsMapFacade;

    @EJB
    protected TimedExamMapFacadeLocal timedExmMapFacade;

    @EJB
    protected AppropriatenessFacadeLocal apprFacade;

    @EJB
    protected CancellationReasonFacadeLocal canRsFacade;

    @EJB
    protected AnatomicalImagingRegionFacadeLocal anaImgRgFacade;

    @EJB
    protected EncounterTypeFacadeLocal encFacade;

    @EJB
    protected ExamReasonFacadeLocal examRsnFacade;

    @EJB
    protected FindingsFacadeLocal fndsFacade;

    @EJB
    protected FundingTypeFacadeLocal fndgFacade;

    @EJB
    protected GenderFacadeLocal gndFacade;

    @EJB
    protected ModalityFacadeLocal modFacade;

    @EJB
    protected PostponeReasonFacadeLocal ppRsnFacade;

    @EJB
    protected PriorityLevelFacadeLocal pLvlFacade;

    @EJB
    protected ProcedureFacadeLocal procFacade;

    @EJB
    protected ProvinceFacadeLocal provFacade;

    @EJB
    protected EquipmentFacadeLocal equipFacade;

    @EJB
    protected FacilityFacadeLocal facilityFacade;

    private Map<Integer, Date> lastUpdated = new HashMap<Integer, Date>();

    //Province Codes
    private List<String> apprProvCodes;
    private List<String> canRsProvCodes;
    private List<String> anaImgRgProvCodes;
    private List<String> encProvCodes;
    private List<String> examRsnProvCodes;
    private List<String> fndsProvCodes;
    private List<String> fndgProvCodes;
    private List<String> gndProvpCodes;
    private List<String> modProvCodes;
    private List<String> ppRsnProvCodes;
    private List<String> priorityLvlProvCodes;
    private List<String> procProvCodes;
    private List<String> provProvCodes;
    private List<String> stsProvCodes;
    private List<String> timedExmProvCodes;
    private List<String> machineProvCodes = new ArrayList<String>();
    private List<String> facilityProvCodes;
    private Set<String> mspNumbers = new HashSet<String>();
    private Set<String> collegeIds = new HashSet<String>();
    private Set<String> canadianProvinces = new HashSet<String>();
    private Map<Integer, Map<Long, Map<String, String>>> codeMappingsTracker;

    {
        nonFutureDateFieldsNdxMap.put(FieldIndex.BIRTH_DT.getValue(), FieldIndex.BIRTH_DT.toString());
        nonFutureDateFieldsNdxMap.put(FieldIndex.BOOKING_CREATED_DT.getValue(), FieldIndex.BOOKING_CREATED_DT.toString());
        nonFutureDateFieldsNdxMap.put(FieldIndex.BOOKING_FORM_RECEIVED_DT.getValue(), FieldIndex.BOOKING_FORM_RECEIVED_DT.toString());
        nonFutureDateFieldsNdxMap.put(FieldIndex.REFERRAL_DT.getValue(), FieldIndex.REFERRAL_DT.toString());
        nonFutureDateFieldsNdxMap.put(FieldIndex.PROCEDURE_POSTPONED_DT.getValue(), FieldIndex.PROCEDURE_POSTPONED_DT.toString());

        nonFutureNonHistoricalDateFieldsNdxMap.put(FieldIndex.PROCEDURE_PERFORMED_DT.getValue(), FieldIndex.PROCEDURE_PERFORMED_DT.toString());
        nonFutureNonHistoricalDateFieldsNdxMap.put(FieldIndex.PROCEDURE_CANCELLED_DT.getValue(), FieldIndex.PROCEDURE_CANCELLED_DT.toString());
        nonFutureNonHistoricalDateFieldsNdxMap.put(FieldIndex.REPORT_SENT_TO_PRACT_DT.getValue(), FieldIndex.REPORT_SENT_TO_PRACT_DT.toString());

        dateFieldsNdxMap.put(FieldIndex.PATIENT_UNAVAIL_START_DT_1.getValue(), FieldIndex.PATIENT_UNAVAIL_START_DT_1.toString());
        dateFieldsNdxMap.put(FieldIndex.PATIENT_UNAVAIL_START_DT_2.getValue(), FieldIndex.PATIENT_UNAVAIL_START_DT_2.toString());
        dateFieldsNdxMap.put(FieldIndex.PATIENT_UNAVAIL_START_DT_3.getValue(), FieldIndex.PATIENT_UNAVAIL_START_DT_3.toString());
        dateFieldsNdxMap.put(FieldIndex.PATIENT_UNAVAIL_END_DT_1.getValue(), FieldIndex.PATIENT_UNAVAIL_END_DT_1.toString());
        dateFieldsNdxMap.put(FieldIndex.PATIENT_UNAVAIL_END_DT_2.getValue(), FieldIndex.PATIENT_UNAVAIL_END_DT_2.toString());
        dateFieldsNdxMap.put(FieldIndex.PATIENT_UNAVAIL_END_DT_3.getValue(), FieldIndex.PATIENT_UNAVAIL_END_DT_3.toString());
        dateFieldsNdxMap.put(FieldIndex.PROCEDURE_SCHEDULED_DT.getValue(), FieldIndex.PROCEDURE_SCHEDULED_DT.toString());

        mandatoryDateFieldsNdxMap.put(FieldIndex.BIRTH_DT.getValue(), FieldIndex.BIRTH_DT.toString());
        mandatoryDateFieldsNdxMap.put(FieldIndex.BOOKING_FORM_RECEIVED_DT.getValue(), FieldIndex.BOOKING_FORM_RECEIVED_DT.toString());

        requiredFieldsNdxMap.put(FieldIndex.STATUS_CD.getValue(), FieldIndex.STATUS_CD.toString());
        requiredFieldsNdxMap.put(FieldIndex.PHN.getValue(), FieldIndex.PHN.toString());
        requiredFieldsNdxMap.put(FieldIndex.FIRST_GIVEN_NM.getValue(), FieldIndex.FIRST_GIVEN_NM.toString());
        requiredFieldsNdxMap.put(FieldIndex.SURNAME_NM.getValue(), FieldIndex.SURNAME_NM.toString());
        requiredFieldsNdxMap.put(FieldIndex.BIRTH_DT.getValue(), FieldIndex.BIRTH_DT.toString());
        requiredFieldsNdxMap.put(FieldIndex.GENDER_CD.getValue(), FieldIndex.GENDER_CD.toString());
        requiredFieldsNdxMap.put(FieldIndex.POSTAL_CD.getValue(), FieldIndex.POSTAL_CD.toString());
        requiredFieldsNdxMap.put(FieldIndex.PROVINCE_CD.getValue(), FieldIndex.PROVINCE_CD.toString());
        requiredFieldsNdxMap.put(FieldIndex.BOOKING_ID.getValue(), FieldIndex.BOOKING_ID.toString());
        requiredFieldsNdxMap.put(FieldIndex.FACILITY_ID.getValue(), FieldIndex.FACILITY_ID.toString());
        requiredFieldsNdxMap.put(FieldIndex.MSP_NO.getValue(), FieldIndex.MSP_NO.toString());
        requiredFieldsNdxMap.put(FieldIndex.ENCOUNTER_TYPE_CD.getValue(), FieldIndex.ENCOUNTER_TYPE_CD.toString());
        requiredFieldsNdxMap.put(FieldIndex.MODALITY_CD.getValue(), FieldIndex.MODALITY_CD.toString());
        requiredFieldsNdxMap.put(FieldIndex.HA_PROCEDURE_CD.getValue(), FieldIndex.HA_PROCEDURE_CD.toString());
        requiredFieldsNdxMap.put(FieldIndex.BOOKING_FORM_RECEIVED_DT.getValue(), FieldIndex.BOOKING_FORM_RECEIVED_DT.toString());
        requiredFieldsNdxMap.put(FieldIndex.PROCEDURE_SCHEDULED_DT.getValue(), FieldIndex.PROCEDURE_SCHEDULED_DT.toString());
        requiredFieldsNdxMap.put(FieldIndex.TIMED_FOLLOW_UP.getValue(), FieldIndex.TIMED_FOLLOW_UP.toString());

        //Mandatory fields for specific facilities of VCHA.
        requiredVCHAFieldsNdxMap.put(FieldIndex.STATUS_CD.getValue(), FieldIndex.STATUS_CD.toString());
        requiredVCHAFieldsNdxMap.put(FieldIndex.PHN.getValue(), FieldIndex.PHN.toString());
        requiredVCHAFieldsNdxMap.put(FieldIndex.BOOKING_ID.getValue(), FieldIndex.BOOKING_ID.toString());
        requiredVCHAFieldsNdxMap.put(FieldIndex.FACILITY_ID.getValue(), FieldIndex.FACILITY_ID.toString());
        requiredVCHAFieldsNdxMap.put(FieldIndex.MSP_NO.getValue(), FieldIndex.MSP_NO.toString());
        requiredVCHAFieldsNdxMap.put(FieldIndex.ENCOUNTER_TYPE_CD.getValue(), FieldIndex.ENCOUNTER_TYPE_CD.toString());
        requiredVCHAFieldsNdxMap.put(FieldIndex.PRIORITY_LEVEL.getValue(), FieldIndex.PRIORITY_LEVEL.toString());
        requiredVCHAFieldsNdxMap.put(FieldIndex.MODALITY_CD.getValue(), FieldIndex.MODALITY_CD.toString());
        requiredVCHAFieldsNdxMap.put(FieldIndex.TIMED_FOLLOW_UP.getValue(), FieldIndex.TIMED_FOLLOW_UP.toString());
        requiredVCHAFieldsNdxMap.put(FieldIndex.BOOKING_FORM_RECEIVED_DT.getValue(), FieldIndex.BOOKING_FORM_RECEIVED_DT.toString());

        conditionallyRequiredFieldsNdxMap.put(FieldIndex.PRIORITY_LEVEL.getValue(), FieldIndex.PRIORITY_LEVEL.toString());
        conditionallyRequiredFieldsNdxMap.put(FieldIndex.CANCELLATION_REASON_CD.getValue(), FieldIndex.CANCELLATION_REASON_CD.toString());
        conditionallyRequiredFieldsNdxMap.put(FieldIndex.POSTPONEMENT_REASON_CD.getValue(), FieldIndex.POSTPONEMENT_REASON_CD.toString());
        conditionallyRequiredFieldsNdxMap.put(FieldIndex.EXAM_ID.getValue(), FieldIndex.EXAM_ID.toString());
        conditionallyRequiredFieldsNdxMap.put(FieldIndex.MODALITY_CD_COMPLETED.getValue(), FieldIndex.MODALITY_CD_COMPLETED.toString());
        conditionallyRequiredFieldsNdxMap.put(FieldIndex.HA_PROCEDURE_CD_COMPLETED.getValue(), FieldIndex.HA_PROCEDURE_CD_COMPLETED.toString());
        conditionallyRequiredFieldsNdxMap.put(FieldIndex.PROCEDURE_PERFORMED_DT.getValue(), FieldIndex.PROCEDURE_PERFORMED_DT.toString());
        conditionallyRequiredFieldsNdxMap.put(FieldIndex.FACILITY_ID_COMPLETED.getValue(), FieldIndex.FACILITY_ID_COMPLETED.toString());
        conditionallyRequiredFieldsNdxMap.put(FieldIndex.PROCEDURE_CANCELLED_DT.getValue(), FieldIndex.PROCEDURE_CANCELLED_DT.toString());
        conditionallyRequiredFieldsNdxMap.put(FieldIndex.PROCEDURE_POSTPONED_DT.getValue(), FieldIndex.PROCEDURE_POSTPONED_DT.toString());
        //#18679 adding a validation rule for EXAM_COUNT_COMPLETED
        conditionallyRequiredFieldsNdxMap.put(FieldIndex.EXAM_COUNT_COMPLETED.getValue(), FieldIndex.EXAM_COUNT_COMPLETED.toString());

        mappedFieldsNdxMap.put(FieldIndex.STATUS_CD.getValue(), FieldIndex.STATUS_CD.toString());
        mappedFieldsNdxMap.put(FieldIndex.GENDER_CD.getValue(), FieldIndex.GENDER_CD.toString());
        mappedFieldsNdxMap.put(FieldIndex.PROVINCE_CD.getValue(), FieldIndex.PROVINCE_CD.toString());
        mappedFieldsNdxMap.put(FieldIndex.ENCOUNTER_TYPE_CD.getValue(), FieldIndex.ENCOUNTER_TYPE_CD.toString());
        //Defect 81 - remove validation on 3 fields
        //mappedFieldsNdxMap.put(FieldIndex.EXAM_REASON.getValue(), FieldIndex.EXAM_REASON.toString());
        //mappedFieldsNdxMap.put(FieldIndex.APPROPRIATENESS_CD.getValue(), FieldIndex.APPROPRIATENESS_CD.toString());
        //mappedFieldsNdxMap.put(FieldIndex.FINDINGS_CD.getValue(), FieldIndex.FINDINGS_CD.toString());
        mappedFieldsNdxMap.put(FieldIndex.PRIORITY_LEVEL.getValue(), FieldIndex.PRIORITY_LEVEL.toString());
        mappedFieldsNdxMap.put(FieldIndex.MODALITY_CD.getValue(), FieldIndex.MODALITY_CD.toString());
        mappedFieldsNdxMap.put(FieldIndex.TIMED_FOLLOW_UP.getValue(), FieldIndex.TIMED_FOLLOW_UP.toString());
        mappedFieldsNdxMap.put(FieldIndex.CANCELLATION_REASON_CD.getValue(), FieldIndex.CANCELLATION_REASON_CD.toString());
        mappedFieldsNdxMap.put(FieldIndex.POSTPONEMENT_REASON_CD.getValue(), FieldIndex.POSTPONEMENT_REASON_CD.toString());
        mappedFieldsNdxMap.put(FieldIndex.MODALITY_CD_COMPLETED.getValue(), FieldIndex.MODALITY_CD_COMPLETED.toString());
        mappedFieldsNdxMap.put(FieldIndex.FUNDING_TYPE_CD.getValue(), FieldIndex.FUNDING_TYPE_CD.toString());
        mappedFieldsNdxMap.put(FieldIndex.MACHINE_ID.getValue(), FieldIndex.MACHINE_ID.toString());

        mappedFieldsWithNoUpdateNdxMap.put(FieldIndex.HA_PROCEDURE_CD.getValue(), FieldIndex.HA_PROCEDURE_CD.toString());
        mappedFieldsWithNoUpdateNdxMap.put(FieldIndex.HA_PROCEDURE_CD_COMPLETED.getValue(), FieldIndex.HA_PROCEDURE_CD_COMPLETED.toString());

        //Defect 25 - Remove warning on Booking Created Date
        //preferredAvailableFieldsNdxMap.put(FieldIndex.BOOKING_CREATED_DT.getValue(), FieldIndex.BOOKING_CREATED_DT.toString());
        conditionalPreferredAvailableFieldsNdxMap.put(FieldIndex.MRN.getValue(), FieldIndex.MRN.toString());
        conditionalPreferredAvailableFieldsNdxMap.put(FieldIndex.FUNDING_TYPE_CD.getValue(), FieldIndex.FUNDING_TYPE_CD.toString());

        //#18679 - Adding list to identify mappings that can expire
        expiringMappings.add(FieldIndex.EXAM_REASON.value);
        expiringMappings.add(FieldIndex.APPROPRIATENESS_CD.value);
        expiringMappings.add(FieldIndex.FINDINGS_CD.value);
        expiringMappings.add(FieldIndex.CANCELLATION_REASON_CD.value);
        expiringMappings.add(FieldIndex.ENCOUNTER_TYPE_CD.value);
        expiringMappings.add(FieldIndex.FUNDING_TYPE_CD.value);
        expiringMappings.add(FieldIndex.GENDER_CD.value);
        expiringMappings.add(FieldIndex.MODALITY_CD.value);
        expiringMappings.add(FieldIndex.MODALITY_CD_COMPLETED.value);
        expiringMappings.add(FieldIndex.POSTPONEMENT_REASON_CD.value);
        expiringMappings.add(FieldIndex.PRIORITY_LEVEL.value);
        expiringMappings.add(FieldIndex.HA_PROCEDURE_CD.value);
        expiringMappings.add(FieldIndex.HA_PROCEDURE_CD_COMPLETED.value);
        expiringMappings.add(FieldIndex.PROVINCE_CD.value);
    }

    public RawDataValidator() {
        sdf.setLenient(false);
    }

    /**
     * Validate is a string is numeric
     *
     * @param str contains the characters to analyze
     * @return true if the characters are numeric
     */
    private boolean isNumeric(String str) {
        return NumberUtils.isParsable(str);
    }

    @PostConstruct
    @Override
    public void init() {
        logger.log(Level.INFO, "Initializing RawDataValidator.");

        long startTime = System.currentTimeMillis();
        codeMappingsTracker = new HashMap<>();
        initialize();
        retrieveHACodes();
        canadianProvinces.add("BC");
        canadianProvinces.add("AB");
        canadianProvinces.add("SK");
        canadianProvinces.add("MB");
        canadianProvinces.add("ON");
        canadianProvinces.add("QC");
        canadianProvinces.add("PE");
        canadianProvinces.add("MB");
        canadianProvinces.add("MS");
        canadianProvinces.add("NL");
        canadianProvinces.add("NU");
        canadianProvinces.add("NT");
        canadianProvinces.add("YT");
        logger.info("Initialized validator in " + (System.currentTimeMillis() - startTime) + "ms");
    }

    @Override
    public List<String> validate(Long healthAuthorityId, int line, String[] tokens, boolean updateMapping) {
        List<String> validationErrors = new ArrayList<>();
        validate(healthAuthorityId, line, tokens, validationErrors, updateMapping);

        return validationErrors;
    }

    /**
     * The "mod 11 check digit" algorithm for checking the check sum of a PHN
     * string the input string must be numeric and has 10 digits long.
     *
     * @param phnStr
     * @return pass
     */
    private boolean PHNCheckSum(String phnStr) {

        boolean pass = false;
        int sum = 0;
        int checksum;

        int[] weights = new int[]{0, 2, 4, 8, 5, 10, 9, 7, 3, 0};
        for (int pos = 1; pos < 9; pos++) {
            sum += weights[pos] * Integer.parseInt(phnStr.substring(pos, pos + 1));
        }

        checksum = (sum % 11);
        checksum = 11 - checksum;
        if (checksum == 10) {
            checksum = 0;
        }
        if (checksum == Integer.parseInt(phnStr.substring(9, 10))) {
            pass = true;
        }
        return pass;
    }

    /**
     * Validate is a string is alphanumeric
     *
     * @param str contains the characters to analyze
     * @return true if the characters are alphanumeric
     */
    private boolean isAlphanumeric(String str) {
        return StringUtils.isAlphanumeric(str);
    }

    private void validate(Long healthAuthorityId, int line, String[] tokens, List<String> validationErrors, boolean updateMapping) {

        long startTime = System.currentTimeMillis();

        for (int i = 0; i < tokens.length; i++) {
            try {
                if (i == FieldIndex.PHN.value) {

                    // PHN can be alphanumeric 0 to 10 digits
                    try {
                        String phn = tokens[i];

                        if (!StringUtils.isEmpty(phn)) {
                            if (!isAlphanumeric(phn)) {
                                addFatalErrMsg(line, FieldIndex.PHN.name() + " is not alphanumeric " + phn, validationErrors);
                            } else {
                                int length = phn.length();

                                if (length == 10) {
                                    if (isNumeric(phn)) {
                                        if (!PHNCheckSum(phn)) {
                                            addWarningMsg(line, FieldIndex.PHN.name() + " is 10 digit numeric but fail Mod 11 Check " + phn, validationErrors);
                                        }
                                    } else {
                                        addWarningMsg(line, FieldIndex.PHN.name() + " is 10 digit alphanumeric, fail Mod 11 Check " + phn, validationErrors);
                                    }

                                }
                            }
                        }

                    } catch (Exception e) {
                        addFatalErrMsg(line, FieldIndex.PHN.name() + " is invalid: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.BOOKING_ID.value) {

                    //first character not being an A
                    if (healthAuthorityId == 4 && tokens[15].charAt(0) != 'A') {
                        //  tokens[15]= "A"+tokens[15];
                        if (tokens[15].charAt(0) != 'a') {
                            addFatalErrMsg(line, "Missing an A on " + FieldIndex.BOOKING_ID.name() + ": " + tokens[i], validationErrors);
                        }
                    }
                }

                if (i == FieldIndex.FACILITY_ID.value) {
                    if (StringUtils.isNotEmpty(tokens[i]) && !facilityProvCodes.contains(tokens[i])) {
                        addFatalErrMsg(line, "Unknown " + FieldIndex.FACILITY_ID.name() + ": " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.FACILITY_ID_COMPLETED.value) {

                    if (!StringUtils.isEmpty(tokens[i]) && !facilityProvCodes.contains(tokens[i])) {
                        addFatalErrMsg(line, "Unknown " + FieldIndex.FACILITY_ID_COMPLETED.name() + ": " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.MSP_NO.value) {
                    if (tokens[i].length() > 5) {
                        addFatalErrMsg(line, FieldIndex.MSP_NO.name() + " size must be between 0 and 5: " + tokens[i], validationErrors);
                    }

                    if (!mspNumbers.contains(tokens[i])) {
                        //Ignore unmapped MSP NO values
                        //addErrMsg(line, FieldIndex.MSP_NO.name() + ": Value not found in Health Ideas: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.PROCEDURE_PERFORMED_DT.value) {
                    //Validate performed is >= booking form date
                    try {
                        Date procedureDt = sdf.parse(tokens[i]);
                        Date bookingDt = sdf.parse(tokens[FieldIndex.BOOKING_FORM_RECEIVED_DT.value]);
                        if (bookingDt.after(procedureDt)) {
                            addFatalErrMsg(line, "Booking Form Received Date cannot be after Procedure Completed Date: " + tokens[i], validationErrors);
                        }
                    } catch (Exception e) {
                        //Ignore - invalid dates will be caught by other validation checks
                    }
                }

                if (i == FieldIndex.FIRST_GIVEN_NM.value) {
                    if (containsInvalidCharacters(tokens[i])) {
                        addWarningMsg(line, FieldIndex.FIRST_GIVEN_NM.name() + " contains invalid characters: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.SECOND_GIVEN_NM.value) {
                    if (containsInvalidCharacters(tokens[i])) {
                        addWarningMsg(line, FieldIndex.SECOND_GIVEN_NM.name() + " contains invalid characters: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.THIRD_GIVEN_NM.value) {
                    if (containsInvalidCharacters(tokens[i])) {
                        addWarningMsg(line, FieldIndex.THIRD_GIVEN_NM.name() + " contains invalid characters: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.SURNAME_NM.value) {
                    if (containsInvalidCharacters(tokens[i])) {
                        addWarningMsg(line, FieldIndex.SURNAME_NM.name() + " contains invalid characters: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.PREFERRED_NM.value) {
                    if (containsInvalidCharacters(tokens[i])) {
                        addWarningMsg(line, FieldIndex.PREFERRED_NM.name() + " contains invalid characters: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.ADDRESS_LINE_1.value) {
                    if (addressContainsInvalidCharacters(tokens[i])) {
                        addWarningMsg(line, FieldIndex.ADDRESS_LINE_1.name() + " contains invalid characters: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.ADDRESS_LINE_2.value) {
                    if (addressContainsInvalidCharacters(tokens[i])) {
                        addWarningMsg(line, FieldIndex.ADDRESS_LINE_2.name() + " contains invalid characters: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.ADDRESS_LINE_3.value) {
                    if (addressContainsInvalidCharacters(tokens[i])) {
                        addWarningMsg(line, FieldIndex.ADDRESS_LINE_3.name() + " contains invalid characters: " + tokens[i], validationErrors);
                    }
                }

                if (mappedFieldsNdxMap.containsKey(i)) {
                    checkMappedFields(healthAuthorityId, line, i, tokens, validationErrors, updateMapping);

                } else if (mappedFieldsWithNoUpdateNdxMap.containsKey(i)) {
                    // we never want to update mapping for these fields
                    checkMappedNoUpdateFields(healthAuthorityId, line, i, tokens, validationErrors, false);
                }

                // Validations for specific Health Authority facilities of VCHA.
                // See facilitiesVCHA definition at the top.
                if (healthAuthorityId == 3 && facilitiesVCHA.containsKey(tokens[FieldIndex.FACILITY_ID.getValue()])) {
                    if (requiredVCHAFieldsNdxMap.containsKey(i) && StringUtils.isBlank(tokens[i])) {
                        addFatalErrMsg(line, requiredVCHAFieldsNdxMap.get(i) + " is a required field for VCHA specific facilities ID (101, 121 & 123)", validationErrors);
                    }

                } else {
                    if (requiredFieldsNdxMap.containsKey(i)) {
                        if (StringUtils.isBlank(tokens[i])
                                && (i != FieldIndex.POSTAL_CD.getValue() || (!"UNK".equals(tokens[FieldIndex.PROVINCE_CD.getValue()])
                                && tokens[FieldIndex.PROVINCE_CD.getValue()] != null
                                && !"OOC".equals(tokens[FieldIndex.PROVINCE_CD.getValue()])))) {
                            if (i == FieldIndex.PROCEDURE_SCHEDULED_DT.value) {
                                //addWarningMsg(line, requiredFieldsNdxMap.get(i) + " is missing", validationErrors);
                            } else if (i == FieldIndex.POSTAL_CD.value) {
                                addWarningMsg(line, requiredFieldsNdxMap.get(i) + " is blank", validationErrors);
                            } else {
                                addFatalErrMsg(line, requiredFieldsNdxMap.get(i) + " is a required field", validationErrors);
                            }
                        }

                    } else if (conditionallyRequiredFieldsNdxMap.containsKey(i)) {

                        checkConditionallyRequiredFields(healthAuthorityId, line, i, tokens, validationErrors);

                    } else if (preferredAvailableFieldsNdxMap.containsKey(i)) {
                        checkPreferredAvailableFields(line, i, tokens, validationErrors);

                    } else if (conditionalPreferredAvailableFieldsNdxMap.containsKey(i)) {
                        conditionalPreferredAvailableFields(healthAuthorityId, line, i, tokens, validationErrors);
                    }
                }

                if (dateFieldsNdxMap.containsKey(i)) {
                    checkDateFields(line, i, tokens, validationErrors, healthAuthorityId);
                }
                if (nonFutureDateFieldsNdxMap.containsKey(i)) {
                    checkNonFutureDateFields(line, i, tokens, validationErrors, healthAuthorityId);
                }
                if (nonFutureNonHistoricalDateFieldsNdxMap.containsKey(i)) {
                    checkNonFutureNonHistoricalDateFields(line, i, tokens, validationErrors, healthAuthorityId);
                }

                if (i == FieldIndex.PROCEDURE_IN_OUT_TIME.value) {
                    if (tokens[i] != null && !"".equals(tokens[i])) {
                        try {
                            Long.parseLong(tokens[i]);
                        } catch (NumberFormatException e) {
                            String errorMsg = "Invalid Time: " + tokens[i];
                            addFatalErrMsg(line, errorMsg, validationErrors);
                            tokens[i] = null;
                        }
                    }
                }

                if (i == FieldIndex.CITY.value) {
                    String city = tokens[i];
                    if (!"".equals(city) && containsInvalidCharacters(city)) {
                        addWarningMsg(line, FieldIndex.CITY.name() + " contains invalid characters: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.COLLEGE_ID.value) {
                    if (tokens[i] != null && tokens[i].length() > 0) {
                        //Ignore unmapped college id values
                        //if(!collegeIds.contains(tokens[i])){
                        //addWarningMsg(line, FieldIndex.COLLEGE_ID.name() + ": Value not found in Health Ideas: " + tokens[i], validationErrors);
                        //}
                        if (tokens[i].length() > 10) {
                            addFatalErrMsg(line, FieldIndex.COLLEGE_ID.name() + " size must be between 0 and 10", validationErrors);
                        }
//                        try{
//                            Long.parseLong(tokens[i]);
//                        }catch(NumberFormatException nfe){
//                            addFatalErrMsg(line, FieldIndex.COLLEGE_ID.name()+" must be numeric: "+tokens[i], validationErrors);
////                            tokens[i] = "";
//                        }
                    }
                }

                if (i == FieldIndex.POSTAL_CD.value) {
                    if (canadianProvinces.contains(tokens[FieldIndex.PROVINCE_CD.value].toUpperCase())) {
                        if (tokens[i] != null && !"".equals(tokens[i]) && !tokens[i].toUpperCase().matches("[ABCEGHJKLMNPRSTVWXYZ][0-9][ABCEGHJKLMNPRSTVWXYZ] *[0-9][ABCEGHJKLMNPRSTVWXYZ][0-9]")) {
                            addFatalErrMsg(line, FieldIndex.POSTAL_CD.name() + " is an invalid format: " + tokens[i], validationErrors);
                        }
                    } else {
                        //Keep non-canadian postal codes as-is
                        //tokens[i] = "";
                    }
                }

                if (i == FieldIndex.EXAM_REASON.value) {
                    if (containsOtherInvalidCharacters(tokens[i])) {
                        addFatalErrMsg(line, FieldIndex.EXAM_REASON.name() + " contains invalid characters: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.APPROPRIATENESS_CD.value) {
                    if (StringUtils.isNotBlank(tokens[i])) {
                        if (tokens[i].length() > 32) {
                            addFatalErrMsg(line, FieldIndex.APPROPRIATENESS_CD.name() + " size must be between 0 and 32: " + tokens[i], validationErrors);
                        }
                    }
                }

                if (i == FieldIndex.SEDATION_YN.value) {
                    if (StringUtils.isNotBlank(tokens[i]) && !"Y".equals(tokens[i]) && !"N".equals(tokens[i])) {
                        addWarningMsg(line, FieldIndex.SEDATION_YN.name() + " must by Y or N: " + tokens[i], validationErrors);
                    }
                }

                if (i == FieldIndex.SEDATION_YN_COMPLETED.value) {
                    if (StringUtils.isNotBlank(tokens[i]) && !"Y".equals(tokens[i]) && !"N".equals(tokens[i])) {
                        addWarningMsg(line, FieldIndex.SEDATION_YN_COMPLETED.name() + " must by Y or N: " + tokens[i], validationErrors);
                    }
                }

                //#18679 if exam count is not a number and has more than two digits then we add a fatal error.
                if (i == FieldIndex.EXAM_COUNT.value) {
                    if (StringUtils.isNotBlank(tokens[i])) {
                        if (tokens[i].length() > 2) {
                            addFatalErrMsg(line, FieldIndex.EXAM_COUNT.name() + " size must be between 0 and 2: " + tokens[i], validationErrors);
                        }
                        if (!StringUtils.isNumeric(tokens[i])) {
                            addFatalErrMsg(line, FieldIndex.EXAM_COUNT.name() + " should be a numeric value: " + tokens[i], validationErrors);
                        }
                    }
                }

            } catch (Throwable e) {
                addFatalErrMsg(line, e.getMessage() + "[" + tokens[i] + "]", validationErrors);
            }
        }

        checkUnavailableDates(line, tokens, validationErrors);
        //logger.log(Level.INFO, "RawDataValidator completed validation successfully in " + (System.currentTimeMillis() - startTime) + "ms");
    }

    private void checkUnavailableDates(int line, String[] tokens, List<String> validationErrors) {
        if (StringUtils.isNotEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_START_DT_1.value]) && StringUtils.isEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_END_DT_1.value])) {
            addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_END_DT_1.stringValue + " is required when " + FieldIndex.PATIENT_UNAVAIL_START_DT_1.stringValue + " is specified", validationErrors);
        }
        if (StringUtils.isNotEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_END_DT_1.value]) && StringUtils.isEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_START_DT_1.value])) {
            addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_1.stringValue + " is required when " + FieldIndex.PATIENT_UNAVAIL_END_DT_1.stringValue + " is specified", validationErrors);
        }
        if (StringUtils.isNotEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_START_DT_2.value]) && StringUtils.isEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_END_DT_2.value])) {
            addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_END_DT_2.stringValue + " is required when " + FieldIndex.PATIENT_UNAVAIL_START_DT_2.stringValue + " is specified", validationErrors);
        }
        if (StringUtils.isNotEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_END_DT_2.value]) && StringUtils.isEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_START_DT_2.value])) {
            addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_2.stringValue + " is required when " + FieldIndex.PATIENT_UNAVAIL_END_DT_2.stringValue + " is specified", validationErrors);
        }
        if (StringUtils.isNotEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_START_DT_3.value]) && StringUtils.isEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_END_DT_3.value])) {
            addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_END_DT_3.stringValue + " is required when " + FieldIndex.PATIENT_UNAVAIL_START_DT_3.stringValue + " is specified", validationErrors);
        }
        if (StringUtils.isNotEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_END_DT_3.value]) && StringUtils.isEmpty(tokens[FieldIndex.PATIENT_UNAVAIL_START_DT_3.value])) {
            addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_3.stringValue + " is required when " + FieldIndex.PATIENT_UNAVAIL_END_DT_3.stringValue + " is specified", validationErrors);
        }
        Date start1 = null, start2 = null, start3 = null, end1 = null, end2 = null, end3 = null;
        try {
            start1 = sdf.parse(tokens[FieldIndex.PATIENT_UNAVAIL_START_DT_1.value]);
        } catch (Exception e) {
        }
        try {
            start2 = sdf.parse(tokens[FieldIndex.PATIENT_UNAVAIL_START_DT_2.value]);
        } catch (Exception e) {
        }
        try {
            start3 = sdf.parse(tokens[FieldIndex.PATIENT_UNAVAIL_START_DT_3.value]);
        } catch (Exception e) {
        }
        try {
            end1 = sdf.parse(tokens[FieldIndex.PATIENT_UNAVAIL_END_DT_1.value]);
        } catch (Exception e) {
        }
        try {
            end2 = sdf.parse(tokens[FieldIndex.PATIENT_UNAVAIL_END_DT_2.value]);
        } catch (Exception e) {
        }
        try {
            end3 = sdf.parse(tokens[FieldIndex.PATIENT_UNAVAIL_END_DT_3.value]);
        } catch (Exception e) {
        }

        if (start1 != null) {
            if (start2 != null && !start1.before(start2)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_1.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_START_DT_2.stringValue, validationErrors);
            }
            if (start3 != null && !start1.before(start3)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_1.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_START_DT_3.stringValue, validationErrors);
            }
            if (end1 != null && !start1.before(end1)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_1.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_END_DT_1.stringValue, validationErrors);
            }
            if (end2 != null && !start1.before(end2)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_1.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_END_DT_2.stringValue, validationErrors);
            }
            if (end3 != null && !start1.before(end3)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_1.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_END_DT_3.stringValue, validationErrors);
            }
        }
        if (start2 != null) {
            if (start3 != null && !start2.before(start3)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_2.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_START_DT_3.stringValue, validationErrors);
            }
            if (end2 != null && !start2.before(end2)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_2.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_END_DT_2.stringValue, validationErrors);
            }
            if (end3 != null && !start2.before(end3)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_2.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_END_DT_3.stringValue, validationErrors);
            }
        }
        if (start3 != null) {
            if (end3 != null && !start3.before(end3)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_START_DT_3.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_END_DT_3.stringValue, validationErrors);
            }
        }
        if (end1 != null) {
            if (start2 != null && !end1.before(start2)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_END_DT_1.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_START_DT_2.stringValue, validationErrors);
            }
            if (start3 != null && !end1.before(start3)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_END_DT_1.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_START_DT_3.stringValue, validationErrors);
            }
            if (end2 != null && !end1.before(end2)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_END_DT_1.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_END_DT_2.stringValue, validationErrors);
            }
            if (end3 != null && !end1.before(end3)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_END_DT_1.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_END_DT_3.stringValue, validationErrors);
            }
        }
        if (end2 != null) {
            if (start3 != null && !end2.before(start3)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_END_DT_2.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_START_DT_3.stringValue, validationErrors);
            }
            if (end3 != null && !end2.before(end3)) {
                addFatalErrMsg(line, FieldIndex.PATIENT_UNAVAIL_END_DT_2.stringValue + " must be before " + FieldIndex.PATIENT_UNAVAIL_END_DT_3.stringValue, validationErrors);
            }
        }
    }

    private void checkNonFutureNonHistoricalDateFields(int line, int fieldNdx, String[] tokens, List<String> validationErrors, long healthAuthorityId) {
        if (tokens[fieldNdx] == null || "".equals(tokens[fieldNdx])) {
            return;
        }
        String errorMsg = null;

        String colName = nonFutureNonHistoricalDateFieldsNdxMap.get(fieldNdx);
        if (tokens[fieldNdx].length() == 8) {
            try {
                Date start = sdf.parse("20130101");
                Date theDt = sdf.parse(tokens[fieldNdx]);
                if (theDt.before(start)) {
                    errorMsg = colName + " cannot be before 20130101: " + tokens[fieldNdx];
                    addFatalErrMsg(line, errorMsg, validationErrors);
                }
            } catch (Exception pe) {
                //Format errors will be caught in regular date checks
            }
        }
        if (errorMsg == null) {
            checkNonFutureDateFields(line, fieldNdx, tokens, validationErrors, healthAuthorityId);
        }
    }

    private void checkNonFutureDateFields(int line, int fieldNdx, String[] tokens, List<String> validationErrors, long healthAuthorityId) {
        if (tokens[fieldNdx] == null || "".equals(tokens[fieldNdx])) {
            return;
        }
        String errorMsg = null;
        Date today = new Date();

        String colName = nonFutureNonHistoricalDateFieldsNdxMap.get(fieldNdx);
        if (colName == null) {
            colName = nonFutureDateFieldsNdxMap.get(fieldNdx);
        }
        if (tokens[fieldNdx].length() == 8) {
            try {
                Date theDt = sdf.parse(tokens[fieldNdx]);
                if (theDt.after(today)) {
                    errorMsg = colName + " cannot be a future date: " + tokens[fieldNdx];
                    addFatalErrMsg(line, errorMsg, validationErrors);
                }
            } catch (Exception pe) {
                //Format errors will be caught in regular date checks
            }
        }
        if (errorMsg == null) {
            checkDateFields(line, fieldNdx, tokens, validationErrors, healthAuthorityId);
        }

    }

    private void checkDateFields(int line, int fieldNdx, String[] tokens, List<String> validationErrors, long healthAuthorityId) {
        if (tokens[fieldNdx] == null || "".equals(tokens[fieldNdx])) {
            return;
        }
        String errorMsg;
        Date today = new Date();

        String colName = nonFutureNonHistoricalDateFieldsNdxMap.get(fieldNdx);
        if (colName == null) {
            colName = nonFutureDateFieldsNdxMap.get(fieldNdx);
        }
        if (colName == null) {
            colName = dateFieldsNdxMap.get(fieldNdx);
        }
        try {
            Date cutoff = sdf.parse("18850101");
            if (tokens[fieldNdx].length() > 8) {
                throw new Exception("Invalid date");
            }
            Date theDt = sdf.parse(tokens[fieldNdx]);
            if (theDt.before(cutoff)) {
                errorMsg = colName + " cannot be before 1885 ";
                addFatalErrMsg(line, errorMsg, validationErrors);
            }
            if (FieldIndex.BIRTH_DT.getValue() != fieldNdx) {
                try {
                    Date birthDt = sdf.parse(tokens[FieldIndex.BIRTH_DT.value]);
                    if (birthDt.after(theDt)) {
                        errorMsg = colName + " cannot be before Birth Date: " + tokens[fieldNdx];
                        addFatalErrMsg(line, errorMsg, validationErrors);
                    }
                } catch (Exception bdPe) {
                    //ignore birth date parse errors, will be caught in birth date validation phase.
                }
            }

        } catch (Exception pe) {
            errorMsg = colName + " is an invalid Date: " + tokens[fieldNdx];
            addFatalErrMsg(line, errorMsg, validationErrors);
        }

    }

    private void checkMappedFields(Long healthAuthorityId, int line, int fieldNdx, String[] tokens, List<String> validationErrors, boolean updateMapping) {

        boolean temp;

        if (FieldIndex.STATUS_CD.getValue() == fieldNdx) {

            // if this is STATUS_CD field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, stsProvCodes, validationErrors, updateMapping, true);

            if (temp) {
                // Must be a province code, ensure first letter is capitalized
                tokens[fieldNdx] = StringUtils.capitalize(tokens[fieldNdx]);
            }

        } else if (FieldIndex.GENDER_CD.getValue() == fieldNdx) { // if this is GENDER_CD field

            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, gndProvpCodes, validationErrors, updateMapping, true);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.PROVINCE_CD.getValue() == fieldNdx) { // if this is PROVINCE_CD field

            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, provProvCodes, validationErrors, updateMapping, true);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.ENCOUNTER_TYPE_CD.getValue() == fieldNdx) { // if this is ENCOUNTER_TYPE_CD field

            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, encProvCodes, validationErrors, updateMapping, true);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.EXAM_REASON.getValue() == fieldNdx) { // if this is EXAM_REASON field

            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, examRsnProvCodes, validationErrors, updateMapping, false);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.APPROPRIATENESS_CD.getValue() == fieldNdx) { // if this is APPROPRIATENESS_CD field

            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, apprProvCodes, validationErrors, updateMapping, false);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.PRIORITY_LEVEL.getValue() == fieldNdx) {

            // if this is PRIORITY_LEVEL field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, priorityLvlProvCodes, validationErrors, updateMapping, true);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.MODALITY_CD.getValue() == fieldNdx) {

            // if this is MODALITY_CD field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, modProvCodes, validationErrors, updateMapping, true);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } //        else if (FieldIndex.HA_PROCEDURE_CD.getValue() == fieldNdx) {
        //
        //            // if this is HA_PROCEDURE_CD field
        //            temp = mappedFieldCheckHelper(line, fieldNdx, tokens, procProvCodes, validationErrors, updateMapping);
        //
        //            // if  province code, ensure code is capitalized
        //            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);
        //
        //        }
        else if (FieldIndex.TIMED_FOLLOW_UP.getValue() == fieldNdx) {

            // if this is TIMED_EXAM_YN field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, timedExmProvCodes, validationErrors, updateMapping, true);

            if (!temp) {
// - Defect 47 indicates that timed exam is mandatory - don't map blanks to N
//                if (StringUtils.isBlank(tokens[fieldNdx])) {
//                    tokens[fieldNdx] = "N";
//                }
            } else {
                // if  province code, ensure code is capitalized
                tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);
            }

        } else if (FieldIndex.CANCELLATION_REASON_CD.getValue() == fieldNdx) {

            // if this is CANCELLATION_REASON_CD field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, canRsProvCodes, validationErrors, updateMapping, true);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.POSTPONEMENT_REASON_CD.getValue() == fieldNdx) {

            // if this is POSTPONEMENT_REASON_CD field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, ppRsnProvCodes, validationErrors, updateMapping, true);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.MODALITY_CD_COMPLETED.getValue() == fieldNdx) {

            // if this is MODALITY_CD_COMPLETED field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, modProvCodes, validationErrors, updateMapping, true);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.HA_PROCEDURE_CD_COMPLETED.getValue() == fieldNdx) {

            // if this is HA_PROCEDURE_CD_COMPLETED field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, procProvCodes, validationErrors, updateMapping, false);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.FINDINGS_CD.getValue() == fieldNdx) {

            // if this is FINDINGS_CD field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, fndsProvCodes, validationErrors, updateMapping, false);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.FUNDING_TYPE_CD.getValue() == fieldNdx) {
            // if this is FUNDING_CD field

            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, fndgProvCodes, validationErrors, updateMapping, true);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        } else if (FieldIndex.MACHINE_ID.getValue() == fieldNdx) {

            // if this is MACHINE_ID field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, machineProvCodes, validationErrors, updateMapping, false);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);
        }
    }

    private void checkMappedNoUpdateFields(Long healthAuthorityId, int line, int fieldNdx, String[] tokens, List<String> validationErrors, boolean updateMapping) {

        boolean temp;
        if (FieldIndex.HA_PROCEDURE_CD.getValue() == fieldNdx || FieldIndex.HA_PROCEDURE_CD_COMPLETED.getValue() == fieldNdx) {

            // if this is HA_PROCEDURE_CD field
            temp = mappedFieldCheckHelper(healthAuthorityId, line, fieldNdx, tokens, /*procProvCodes*/ new ArrayList<String>(), validationErrors, updateMapping, true);

            // if  province code, ensure code is capitalized
            tokens[fieldNdx] = normalizeInputProvCode(temp, tokens[fieldNdx]);

        }
    }

    /*
     * Helps to check whether a code is a province code or not.
     * If not a province code, looks for the province code the
     * specified code is mapped to
     */
    private String getFieldFinalValue(Long healthAuthorityId, int fieldNdx, String[] tokens, List<String> provinceCodes) {

        String finalValue = null;
        if (StringUtils.isNotBlank(tokens[fieldNdx])) {

            Iterator<String> itr = provinceCodes.iterator();

            while (itr.hasNext()) {
                if (itr.next().equalsIgnoreCase(tokens[fieldNdx])) {
                    finalValue = tokens[fieldNdx];
                    break;
                }
            }

            // If the code specified is not a province code
            if (finalValue == null) {
                Map<String, String> mapping = codeMappingsTracker.get(fieldNdx).get(healthAuthorityId);
                finalValue = mapping != null ? mapping.get(tokens[fieldNdx]) : null;
            }
        }

        return finalValue;

    }

    /*
     * Helps to check whether a code is a province code or not.
     * If not a province code, looks for the province code the
     * specified code is mapped to
     */
    private boolean mappedFieldCheckHelper(Long healthAuthorityId, int line, int fieldNdx, String[] tokens, List<String> provinceCodes, List<String> validationErrors, boolean updateMapping, boolean mappingCompulsory) {

        boolean isProvinceCd = false;

        if (StringUtils.isNotBlank(tokens[fieldNdx])) {
            if (healthAuthorityId == 6 && fieldNdx == 57 && ("PET/CT".equalsIgnoreCase(tokens[23])) && (StringUtils.isEmpty(tokens[fieldNdx]))) {
            } else {
                String comparisonValue = tokens[fieldNdx];
                String labelValue = tokens[fieldNdx];
                if (fieldNdx == FieldIndex.PRIORITY_LEVEL.value) {
                    Map<String, String> mapping = codeMappingsTracker.get(FieldIndex.MODALITY_CD.value).get(healthAuthorityId);
                    String modality = null;
                    if (mapping != null) {
                        modality = mapping.get(tokens[FieldIndex.MODALITY_CD.value]);
                    }
                    if (modality == null) {
                        modality = tokens[FieldIndex.MODALITY_CD.value];
                    }
                    comparisonValue = modality + ":" + comparisonValue;
                }
                if (fieldNdx == FieldIndex.HA_PROCEDURE_CD.value) {
                    Map<String, String> mapping = codeMappingsTracker.get(FieldIndex.MODALITY_CD.value).get(healthAuthorityId);
                    String modality = null;
                    if (mapping != null) {
                        modality = mapping.get(tokens[FieldIndex.MODALITY_CD.value]);
                    }
                    if (modality == null) {
                        modality = tokens[FieldIndex.MODALITY_CD.value];
                    }
                    comparisonValue = modality + ":" + comparisonValue;
                }
                if (fieldNdx == FieldIndex.HA_PROCEDURE_CD_COMPLETED.value) {
                    Map<String, String> mapping = codeMappingsTracker.get(FieldIndex.MODALITY_CD.value).get(healthAuthorityId);
                    String modality = null;
                    if (mapping != null) {
                        modality = mapping.get(tokens[FieldIndex.MODALITY_CD_COMPLETED.value]);
                    }
                    if (modality == null) {
                        modality = tokens[FieldIndex.MODALITY_CD_COMPLETED.value];
                    }
                    comparisonValue = modality + ":" + comparisonValue;
                }
                Iterator<String> itr = provinceCodes.iterator();

                while (itr.hasNext()) {
                    if (itr.next().equalsIgnoreCase(comparisonValue)) {
                        isProvinceCd = true;
                        break;
                    }
                }

                // If the code specified is not a province code
                if (expiringMappings.contains(fieldNdx) || !isProvinceCd) {
                    Map<String, String> mapping = codeMappingsTracker.get(fieldNdx).get(healthAuthorityId);
                    String value = mapping.get(comparisonValue);
                    String temp = (mapping != null) ? value : null;

                    if (temp != null && !"".equals(temp.trim())) {
                        if (updateMapping) {
                            tokens[fieldNdx] = temp;
                        }
                    } else {

                        // No mapping found for the HA code specified
                        if (updateMapping) {
                            tokens[fieldNdx] = "";
                        }
                        String label = mappedFieldsNdxMap.get(fieldNdx);
                        if (label == null) {
                            label = mappedFieldsWithNoUpdateNdxMap.get(fieldNdx);

                        }
                        if (mappingCompulsory) {
                            // 2015/07 MOH decided treating mapping error as fatal error
                            addFatalErrMsg(line, "Mapping either not found or expired for " + label + " => " + labelValue, validationErrors);
                        } else {
                            addWarningMsg(line, "Mapping either not found or expired for " + label + " => " + labelValue, validationErrors);
                            //addErrMsg(line, "No mapping found for " + mappedFieldsNdxMap.get(fieldNdx) + " => " + tokens[fieldNdx], validationErrors);
                        }
                    }
                }

            }
        }

        return isProvinceCd;

    }

    private String normalizeInputProvCode(boolean isProvCode, String code) {
        return isProvCode ? code.toUpperCase() : code;
    }

    private void checkConditionallyRequiredFields(Long healthAuthorityId, int line, int fieldNdx, String[] tokens, List<String> validationErrors) {

        if (fieldNdx == FieldIndex.PRIORITY_LEVEL.getValue()) {  // if this is PRIORITY_LEVEL field

            if (StringUtils.isBlank(tokens[fieldNdx])
                    && ("CT".equalsIgnoreCase(tokens[23]) || "MR".equalsIgnoreCase(tokens[23]))) {
                // if priority level is not provided and modality is either MD or MR reject record
                addFatalErrMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.PRIORITY_LEVEL.getValue()) + " must be provided when Modality_CD is either 'CT' or 'MR'", validationErrors);
            }
        } else if (fieldNdx == FieldIndex.CANCELLATION_REASON_CD.getValue()) { // if this is CANCELLATION_REASON_CD field
            String status = getFieldFinalValue(healthAuthorityId, 0, tokens, stsProvCodes);
            if (StringUtils.isNotBlank(status) && StringUtils.isBlank(tokens[fieldNdx]) && status.toLowerCase().startsWith("cancel")) {
                // if cancellation reason is not provided and cancellation date is available reject record
                addFatalErrMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.CANCELLATION_REASON_CD.getValue()) + " must be provided if status is Cancelled", validationErrors);
            }
        } else if (fieldNdx == FieldIndex.POSTPONEMENT_REASON_CD.getValue()) { // if this is POSTPONEMENT_REASON_CD field

            if (StringUtils.isBlank(tokens[fieldNdx]) && StringUtils.isNotBlank(tokens[35])) {
                // if postponement reason is not provided and procedure postponed date is available reject record
                addFatalErrMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.POSTPONEMENT_REASON_CD.getValue()) + " must be provided if PROCEDURE_POSTPONED_DT is specified", validationErrors);
            }
        } else if (fieldNdx == FieldIndex.EXAM_ID.getValue()) { // if this is EXAM_ID field

            if (StringUtils.isBlank(tokens[fieldNdx]) && StringUtils.isNotBlank(tokens[FieldIndex.PROCEDURE_PERFORMED_DT.value])) {
                // if exam id is not provided and procedure performed date is available reject record
                addFatalErrMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.EXAM_ID.getValue()) + " must be provided if procedure has been completed", validationErrors);
            }

//            if (containsInvalidCharacters(tokens[fieldNdx])) {
//                addFatalErrMsg(line, FieldIndex.EXAM_ID.name() + " contains invalid characters: " + tokens[fieldNdx], validationErrors);
//            }
        } else if (fieldNdx == FieldIndex.MODALITY_CD_COMPLETED.getValue()) { // if this is MODALITY_CD_COMPLETED field

            if (StringUtils.isBlank(tokens[fieldNdx])) {
                String status = getFieldFinalValue(healthAuthorityId, 0, tokens, stsProvCodes);
                if (StringUtils.isNotBlank(status) && StringUtils.startsWith(status.toLowerCase(), "complete")) {
                    // if modality code completed is not provided and status is set to completed
                    addFatalErrMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.MODALITY_CD_COMPLETED.getValue()) + " must be provided if procedure has been completed", validationErrors);
                }
            }
        } else if (fieldNdx == FieldIndex.HA_PROCEDURE_CD_COMPLETED.getValue()) { // if this is HA_PROCEDURE_CD_COMPLETED field

            if (StringUtils.isBlank(tokens[fieldNdx])) {
                String status = getFieldFinalValue(healthAuthorityId, 0, tokens, stsProvCodes);
                if (StringUtils.isNotBlank(status) && StringUtils.startsWith(status.toLowerCase(), "complete")) {
                    addFatalErrMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.HA_PROCEDURE_CD_COMPLETED.getValue()) + " must be provided if procedure has been completed", validationErrors);
                }
            }
        } else if (fieldNdx == FieldIndex.PROCEDURE_PERFORMED_DT.getValue()) { // if this is PROCEDURE_PERFORMED_DT field

            if (StringUtils.isBlank(tokens[fieldNdx])) {
                String status = getFieldFinalValue(healthAuthorityId, 0, tokens, stsProvCodes);
                if (StringUtils.isNotBlank(status) && StringUtils.startsWith(status.toLowerCase(), "complete")) {
                    // if procedure performed date is not provided and status is set to completed
                    addFatalErrMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.PROCEDURE_PERFORMED_DT.getValue()) + " must be provided if procedure has been completed", validationErrors);
                }
            }
        } else if (fieldNdx == FieldIndex.FACILITY_ID_COMPLETED.getValue()) { // if this is FACILITY_ID_COMPLETED field

            if (StringUtils.isBlank(tokens[fieldNdx])) {
                String status = getFieldFinalValue(healthAuthorityId, 0, tokens, stsProvCodes);
                if (StringUtils.isNotBlank(status) && StringUtils.startsWith(status.toLowerCase(), "complete")) {
                    // if facility ID completed is not provided and status is set to completed
                    addFatalErrMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.FACILITY_ID_COMPLETED.getValue()) + " must be provided if procedure has been completed", validationErrors);
                }
            }
        } else if (fieldNdx == FieldIndex.PROCEDURE_CANCELLED_DT.getValue()) {
            if (StringUtils.isBlank(tokens[fieldNdx])) {
                String status = getFieldFinalValue(healthAuthorityId, 0, tokens, stsProvCodes);
                if (StringUtils.isNotBlank(status) && status.toLowerCase().startsWith("cancel")) {
                    addFatalErrMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.PROCEDURE_CANCELLED_DT.getValue()) + " must be provided if status is Cancelled", validationErrors);
                }
            }
        } else if (fieldNdx == FieldIndex.PROCEDURE_POSTPONED_DT.getValue()) {
            if (StringUtils.isBlank(tokens[fieldNdx])) {
                if (StringUtils.isNotBlank(tokens[FieldIndex.POSTPONEMENT_REASON_CD.getValue()])) {
                    addWarningMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.PROCEDURE_POSTPONED_DT.getValue()) + " should be provided if Postponement Reason is provided", validationErrors);
                }
            }
        } else if (fieldNdx == FieldIndex.EXAM_COUNT_COMPLETED.getValue()) {
            if (StringUtils.isBlank(tokens[fieldNdx])) {
                String status = getFieldFinalValue(healthAuthorityId, 0, tokens, stsProvCodes);
                if (StringUtils.isNotBlank(status) && StringUtils.startsWith(status.toLowerCase(), "complete")) {
                    //FIXME currently commented out because HAs are not ready to use the Exam Count
                    //#18679 if exam count completed is not provided and status is set to completed
                    //addFatalErrMsg(line, conditionallyRequiredFieldsNdxMap.get(FieldIndex.EXAM_COUNT_COMPLETED.getValue()) + " must be provided if procedure has been completed", validationErrors);
                }
            } else {
                if (tokens[fieldNdx].length() > 2) {
                    addFatalErrMsg(line, FieldIndex.EXAM_COUNT_COMPLETED.name() + " size must be between 0 and 2: " + tokens[fieldNdx], validationErrors);
                }
                if (!StringUtils.isNumeric(tokens[fieldNdx])) {
                    addFatalErrMsg(line, FieldIndex.EXAM_COUNT_COMPLETED.name() + " should be a numeric value: " + tokens[fieldNdx], validationErrors);
                }
            }
        }
    }

    private void checkPreferredAvailableFields(int line, int fieldNdx, String[] tokens, List<String> validationErrors) {

        FieldIndex field = null;

        if (FieldIndex.BOOKING_CREATED_DT.getValue() == fieldNdx) {
            field = FieldIndex.BOOKING_CREATED_DT;
        } else if (FieldIndex.MRN.getValue() == fieldNdx) {
            field = FieldIndex.MRN;
        } else if (FieldIndex.FUNDING_TYPE_CD.getValue() == fieldNdx) {
            field = FieldIndex.FUNDING_TYPE_CD;
        }

        if (StringUtils.isBlank(tokens[fieldNdx])) {
            // if HA procedure code completed is not provided and procedure performed date  or exam id is available reject record
            addWarningMsg(line, preferredAvailableFieldsNdxMap.get(field.getValue()) + " is missing", validationErrors);
        }

    }

    private void conditionalPreferredAvailableFields(Long healthAuthorityId, int line, int fieldNdx, String[] tokens, List<String> validationErrors) {

        String status = getFieldFinalValue(healthAuthorityId, 0, tokens, stsProvCodes);
        if (status != null) {
            status = status.toLowerCase();
        }
        if (FieldIndex.MRN.getValue() == fieldNdx && StringUtils.isBlank(tokens[fieldNdx])
                && StringUtils.startsWith(status, "complete")) {
            addWarningMsg(line, conditionalPreferredAvailableFieldsNdxMap.get(FieldIndex.MRN.getValue()) + " is missing for a completed procedure", validationErrors);
        }

        //2/18/2020 added !(healthAuthorityId==6 && ("CT".equalsIgnoreCase(tokens[24]) || "PT".equalsIgnoreCase(tokens[24]) C2-27588
        if (FieldIndex.FUNDING_TYPE_CD.getValue() == fieldNdx && StringUtils.isBlank(tokens[fieldNdx])
                && StringUtils.startsWith(status, "complete")) {
            if (healthAuthorityId == 6 && fieldNdx == 57 && ("PET/CT".equalsIgnoreCase(tokens[23]))) {
            } else {

                addFatalErrMsg(line, conditionalPreferredAvailableFieldsNdxMap.get(FieldIndex.FUNDING_TYPE_CD.getValue()) + " is missing for a completed procedure", validationErrors);
            }
        }

    }

    private boolean addressContainsInvalidCharacters(String input) {
        return StringUtils.containsAny(input, ADDRESS_SPECIAL_CHARACTERS);
    }

    private boolean containsInvalidCharacters(String input) {
        return StringUtils.containsAny(input, SPECIAL_CHARACTERS);
    }

    private boolean containsOtherInvalidCharacters(String input) {
        if (input == null) {
            return false;
        }
        String badChars[] = {"\\", "%", "\"", "*"};
        for (String string : badChars) {
            if (input.contains(string)) {
                return true;
            }
        }
        return false;
    }

    private void addFatalErrMsg(int line, String message, List<String> validationErrors) {
        validationErrors.add(String.format("Fatal Error - Line %s: %s", line, message));
    }

    // From 2015/07, MOH decided to treat mapping errors as fatal errors, so in data summary window,
    // there will be no mapping errors anymore, when detect a mappping error, will always call the
    // above addFatalErrMsg() and display "Fatal Error..." on the page.
    private void addMappingErrMsg(int line, String message, List<String> validationErrors) {
        validationErrors.add(String.format("Mapping Error - Line %s: %s", line, message));
    }

    private void addWarningMsg(int line, String message, List<String> validationErrors) {
        validationErrors.add(String.format("Warning - Line %s: %s", line, message));
    }

    private void addMapping(Map<Long, Map<String, String>> haMappings, Long healhAuthorityId, String haCode, String provCode) {

        Map<String, String> codeMappings = haMappings.get(healhAuthorityId);

        if (codeMappings == null) {
            // 201507, defect 249&252, for mapping code, MOH confirms that all mapping codes should not be case sensitive.
            // for exaample, if existing value in status code in map table is "Test" => Active, then all values of tEst, TeST,
            // teST etc in the uploaded records should all be acceptable as valid values and won't cause mapping errors.
            // to be able to get case insensitive key from the map, switch normal map to treemap.

            //codeMappings = new HashMap<>();
            codeMappings = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
            haMappings.put(healhAuthorityId, codeMappings);
        }

        codeMappings.put(haCode, provCode);
    }

    @Override
    public void initialize() {
        long startTime = System.currentTimeMillis();
        Map<Long, Map<String, String>> haMappings;
        Iterator temp;
        Date now = new Date();
        Date lastCache;
        Date lastMapUpdate;
        Date lastCodeUpdate;

        // Add specific health authority of VCHA 
        // that need specific validation for Imaging procedures.
        facilitiesVCHA.put("101", "101");
        facilitiesVCHA.put("121", "121");
        facilitiesVCHA.put("123", "123");

        // Add StatusMap Codes
        lastMapUpdate = stsMapFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.STATUS_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate))) {
            lastUpdated.put(FieldIndex.STATUS_CD.getValue(), now);
            temp = stsMapFacade.findAll().iterator();

            haMappings = codeMappingsTracker.get(FieldIndex.STATUS_CD.getValue());
            if (haMappings == null) {
                haMappings = new HashMap<>();
            }
            while (temp.hasNext()) {
                StatusMap p = (StatusMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaStatusCd(), p.getStatusCd());
            }
            codeMappingsTracker.put(FieldIndex.STATUS_CD.getValue(), haMappings);
        }

        // Add GenderMap Codes
        lastMapUpdate = gndMapFacade.mostRecentUpdate();
        lastCodeUpdate = gndFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.GENDER_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.GENDER_CD.getValue(), now);
            temp = gndMapFacade.findNonExpired().iterator();

            haMappings = new HashMap<>();

            while (temp.hasNext()) {
                GenderMap p = (GenderMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaGenderCd(), p.getGenderCd().getGenderCd());
            }
            codeMappingsTracker.put(FieldIndex.GENDER_CD.getValue(), haMappings);
        }

        // Add Province Map Codes
        lastMapUpdate = provMapFacade.mostRecentUpdate();
        lastCodeUpdate = provFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.PROVINCE_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.PROVINCE_CD.getValue(), now);
            temp = provMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();
            while (temp.hasNext()) {
                ProvinceMap p = (ProvinceMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaProvinceCd(), p.getProvinceCd().getProvinceCd());
            }
            codeMappingsTracker.put(FieldIndex.PROVINCE_CD.getValue(), haMappings);
        }

        // Add EncounterTypeMap Codes
        lastMapUpdate = encMapFacade.mostRecentUpdate();
        lastCodeUpdate = encFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.ENCOUNTER_TYPE_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.ENCOUNTER_TYPE_CD.getValue(), now);
            temp = encMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();
            while (temp.hasNext()) {
                EncounterTypeMap p = (EncounterTypeMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaEncounterTypeCd(), p.getEncounterTypeCd().getEncounterTypeCd());
            }
            codeMappingsTracker.put(FieldIndex.ENCOUNTER_TYPE_CD.getValue(), haMappings);
        }

        // Add ExamReasonMap Codes
        lastMapUpdate = examRsnMapFacade.mostRecentUpdate();
        lastCodeUpdate = examRsnFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.EXAM_REASON.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.EXAM_REASON.getValue(), now);
            temp = examRsnMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();
            while (temp.hasNext()) {
                ExamReasonMap p = (ExamReasonMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaExamReasonCd(), p.getExamReasonCd().getExamReasonCd());
            }
            codeMappingsTracker.put(FieldIndex.EXAM_REASON.getValue(), haMappings);
        }

        // Add AppropriatenessMap Codes
        lastMapUpdate = apprMapFacade.mostRecentUpdate();
        lastCodeUpdate = apprFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.APPROPRIATENESS_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.APPROPRIATENESS_CD.getValue(), now);
            temp = apprMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();
            while (temp.hasNext()) {
                AppropriatenessMap p = (AppropriatenessMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaAppropriatenessCd(), p.getAppropriatenessCd().getAppropriatenessCd());
            }
            codeMappingsTracker.put(FieldIndex.APPROPRIATENESS_CD.getValue(), haMappings);
        }

        // Add PriorityLevelMap Codes
        lastMapUpdate = pLvlMapFacade.mostRecentUpdate();
        lastCodeUpdate = pLvlFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.PRIORITY_LEVEL.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.PRIORITY_LEVEL.getValue(), now);
            temp = pLvlMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();
            while (temp.hasNext()) {
                PriorityLevelMap p = (PriorityLevelMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), String.valueOf(p.getModalityTypeCd().getModalityTypeCd() + ":" + p.getHaPriorityLevelCd()), p.getPriorityLevelId().getPriorityLevelCd());
            }
            codeMappingsTracker.put(FieldIndex.PRIORITY_LEVEL.getValue(), haMappings);
        }

        // Add ModalityMap Codes
        lastMapUpdate = modMapFacade.mostRecentUpdate();
        lastCodeUpdate = modFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.MODALITY_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.MODALITY_CD.getValue(), now);
            temp = modMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();
            while (temp.hasNext()) {
                ModalityMap p = (ModalityMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaModalityCd(), p.getModalityCd().getModalityTypeCd());
            }
            codeMappingsTracker.put(FieldIndex.MODALITY_CD.getValue(), haMappings);
            codeMappingsTracker.put(FieldIndex.MODALITY_CD_COMPLETED.getValue(), haMappings);  // MODALITY_CD_COMPLETED
        }

        // Add ProcedureMap Codes
        lastMapUpdate = procMapFacade.mostRecentUpdate();
        lastCodeUpdate = procFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.HA_PROCEDURE_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.HA_PROCEDURE_CD.getValue(), now);
            temp = procMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();

            while (temp.hasNext()) {
                ProcedureMap p = (ProcedureMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getProcedureId().getModalityTypeCd().getModalityTypeCd() + ":" + p.getHaProcedureCd(), p.getProcedureId().getProcedureId().toString());
            }
            codeMappingsTracker.put(FieldIndex.HA_PROCEDURE_CD.getValue(), haMappings);
            codeMappingsTracker.put(FieldIndex.HA_PROCEDURE_CD_COMPLETED.getValue(), haMappings);  // HA_PROCEDURE_CD_COMPLETED
        }

        // Add TimedExamMap Codes
        lastMapUpdate = timedExmMapFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.TIMED_FOLLOW_UP.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate))) {
            lastUpdated.put(FieldIndex.TIMED_FOLLOW_UP.getValue(), now);
            temp = timedExmMapFacade.findAll().iterator();
            haMappings = codeMappingsTracker.get(FieldIndex.TIMED_FOLLOW_UP.getValue());
            if (haMappings == null) {
                haMappings = new HashMap<>();
            }
            while (temp.hasNext()) {
                TimedExamMap p = (TimedExamMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaTimedExamCd(), p.getTimedExamYn());
            }
            codeMappingsTracker.put(FieldIndex.TIMED_FOLLOW_UP.getValue(), haMappings);
        }

        // Add CancellationReasonMap Codes
        lastMapUpdate = canRsMapFacade.mostRecentUpdate();
        lastCodeUpdate = canRsFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.CANCELLATION_REASON_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.CANCELLATION_REASON_CD.getValue(), now);
            temp = canRsMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();
            while (temp.hasNext()) {
                CancellationReasonMap p = (CancellationReasonMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaCancellationReasonCd(), p.getCancellationReasonCd().getCancellationReasonCd());
            }
            codeMappingsTracker.put(FieldIndex.CANCELLATION_REASON_CD.getValue(), haMappings);
        }

        // Add PostponeReasonMap Codes
        lastMapUpdate = ppRsnMapFacade.mostRecentUpdate();
        lastCodeUpdate = ppRsnFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.POSTPONEMENT_REASON_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.POSTPONEMENT_REASON_CD.getValue(), now);
            temp = ppRsnMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();
            while (temp.hasNext()) {
                PostponeReasonMap p = (PostponeReasonMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaPostponeReasonCd(), p.getPostponeReasonCd().getPostponeReasonCd());
            }
            codeMappingsTracker.put(FieldIndex.POSTPONEMENT_REASON_CD.getValue(), haMappings);
        }

        // Add FindingsMap Codes
        lastMapUpdate = fndsMapFacade.mostRecentUpdate();
        lastCodeUpdate = fndsFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.FINDINGS_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.FINDINGS_CD.getValue(), now);
            temp = fndsMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();
            while (temp.hasNext()) {
                FindingsMap p = (FindingsMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaFindingCd(), p.getFindingCd().getFindingCd());
            }
            codeMappingsTracker.put(FieldIndex.FINDINGS_CD.getValue(), haMappings);
        }

        // Add FundingMap Codes
        lastMapUpdate = fndgMapFacade.mostRecentUpdate();
        lastCodeUpdate = fndgFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.FUNDING_TYPE_CD.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate)) || (lastCodeUpdate != null && lastCache.before(lastCodeUpdate))) {
            lastUpdated.put(FieldIndex.FUNDING_TYPE_CD.getValue(), now);
            temp = fndgMapFacade.findNonExpired().iterator();
            haMappings = new HashMap<>();
            while (temp.hasNext()) {
                FundingTypeMap p = (FundingTypeMap) temp.next();
                addMapping(haMappings, p.getHealthAuthorityId().getHealthAuthorityId(), p.getHaFundingTypeCd(), p.getFundingTypeCd().getFundingTypeCd());
            }
            codeMappingsTracker.put(FieldIndex.FUNDING_TYPE_CD.getValue(), haMappings);
        }

        // Add MachineIdMap Codes
        lastMapUpdate = equipFacade.mostRecentUpdate();
        lastCache = lastUpdated.get(FieldIndex.MACHINE_ID.getValue());
        if (lastCache == null || (lastMapUpdate != null && lastCache.before(lastMapUpdate))) {
            lastUpdated.put(FieldIndex.MACHINE_ID.getValue(), now);
            temp = equipFacade.findAll().iterator();
            haMappings = codeMappingsTracker.get(FieldIndex.MACHINE_ID.getValue());
            if (haMappings == null) {
                haMappings = new HashMap<>();
            }
            while (temp.hasNext()) {
                Equipment p = (Equipment) temp.next();
                addMapping(haMappings, p.getFacilityId().getHealthAuthorityId().getHealthAuthorityId(), p.getMachineId(), p.getMachineId());
            }
            codeMappingsTracker.put(FieldIndex.MACHINE_ID.getValue(), haMappings);
        }

        long endTime = System.currentTimeMillis() - startTime;
        logger.log(Level.INFO, "Finished initialize() in " + endTime + "ms");
    }

    private void retrieveHACodes() {
        long startTime = System.currentTimeMillis();
        stsProvCodes = new ArrayList<>();
        stsProvCodes.add("Active");
        stsProvCodes.add("Completed");
        stsProvCodes.add("Cancelled");

        gndProvpCodes = new ArrayList<>();
        List<Gender> gndList = gndFacade.findAll();

        for (Gender gnd : gndList) {
            gndProvpCodes.add(gnd.getGenderCd());
        }

        provProvCodes = new ArrayList<>();
        List<Province> prvList = provFacade.findAll();

        for (Province prv : prvList) {
            provProvCodes.add(prv.getProvinceCd());
        }

        encProvCodes = new ArrayList<>();
        List<EncounterType> encList = encFacade.findAll();

        for (EncounterType enc : encList) {
            encProvCodes.add(enc.getEncounterTypeCd());
        }

        examRsnProvCodes = new ArrayList<>();
        List<ExamReason> exmList = examRsnFacade.findAll();

        for (ExamReason exm : exmList) {
            examRsnProvCodes.add(exm.getExamReasonCd());
        }

        apprProvCodes = new ArrayList<>();
        List<Appropriateness> apprList = apprFacade.findAll();

        for (Appropriateness appr : apprList) {
            apprProvCodes.add(appr.getAppropriatenessCd());
        }

        priorityLvlProvCodes = new ArrayList<>();
        List<PriorityLevel> pLvlList = pLvlFacade.findAll();

        for (PriorityLevel pLvl : pLvlList) {
            priorityLvlProvCodes.add(pLvl.getModalityCd() + ":" + pLvl.getPriorityLevelCd().toString());
        }

        anaImgRgProvCodes = new ArrayList<>();
        List<AnatomicalImagingRegion> anaImgRgList = anaImgRgFacade.findAll();
        for (AnatomicalImagingRegion anaImgRg : anaImgRgList) {
            anaImgRgProvCodes.add(anaImgRg.getImagingRegionCd());
        }

        modProvCodes = new ArrayList<>();
        List<Modality> modList = modFacade.findAll();
        for (Modality mod : modList) {
            modProvCodes.add(mod.getModalityTypeCd());
        }

        procProvCodes = new ArrayList<>();
        List<Procedure> procList = procFacade.findAll();
        for (Procedure proc : procList) {
            procProvCodes.add(proc.getModalityTypeCd().getModalityTypeCd() + ":" + proc.getProvProcedureRpidCd());
        }

        timedExmProvCodes = new ArrayList<>();
        timedExmProvCodes.add("N");
        timedExmProvCodes.add("Y");

        canRsProvCodes = new ArrayList<>();
        List<CancellationReason> canRsList = canRsFacade.findAll();
        for (CancellationReason canRs : canRsList) {
            canRsProvCodes.add(canRs.getCancellationReasonCd());
        }

        ppRsnProvCodes = new ArrayList<>();
        List<PostponeReason> ppRsnList = ppRsnFacade.findAll();
        for (PostponeReason ppRsn : ppRsnList) {
            ppRsnProvCodes.add(ppRsn.getPostponeReasonCd());
        }

        fndsProvCodes = new ArrayList<>();
        List<Findings> fndsList = fndsFacade.findAll();
        for (Findings fnds : fndsList) {
            fndsProvCodes.add(fnds.getFindingCd());
        }

        fndgProvCodes = new ArrayList<>();
        List<FundingType> fndgList = fndgFacade.findAll();
        for (FundingType fndg : fndgList) {
            fndgProvCodes.add(fndg.getFundingTypeCd());
        }

        //MSP & college ID from healthideas
//        List<Practitioner> pracs = practitionerFacade.findAll();
//        for (Practitioner practitioner : pracs) {
//            mspNumbers.add("" + practitioner.getMspBillingNo());
//            collegeIds.add("" + practitioner.getCollegeId());
//        }
        facilityProvCodes = new ArrayList<>();
        List<Facility> facilityList = facilityFacade.findAll();
        for (Facility facility : facilityList) {
            facilityProvCodes.add(facility.getFacilityId().toString());
        }

        long endTime = System.currentTimeMillis() - startTime;
        logger.log(Level.INFO, "Finished retrieve ha codes in " + endTime + "ms");

    }

    public enum FieldIndex {

        //#18679 replaced PROV_PROCEDURE_CD and PROV_PROCEDURE_CD_COMPLETED by EXAM_COUNT and EXAM_COUNT_COMPLETED
        STATUS_CD(0, "STATUS CD"), PHN(1, "PHN"), FIRST_GIVEN_NM(2, "FIRST GIVEN NAME"), SECOND_GIVEN_NM(3, "SECOND GIVEN NAME"), THIRD_GIVEN_NM(4, "THIRD GIVEN NAME"), SURNAME_NM(5, "SURNAME"), PREFERRED_NM(6, "PREFERRED NAME"), BIRTH_DT(7, "BIRTH DATE"), GENDER_CD(8, "GENDER"),
        ADDRESS_LINE_1(9, "ADDRESS LINE 1"), ADDRESS_LINE_2(10, "ADDRESS LINE 2"), ADDRESS_LINE_3(11, "ADDRESS LINE 3"), CITY(12, "CITY"), PROVINCE_CD(13, "PROVINCE CD"), POSTAL_CD(14, "POSTAL CD"), BOOKING_ID(15, "BOOKING ID"), FACILITY_ID(16, "FACILITY ID"),
        COLLEGE_ID(17, "COLLEGE ID"), MSP_NO(18, "MSP NO"), ENCOUNTER_TYPE_CD(19, "ENCOUNTER TYPE CD"), EXAM_REASON(20, "EXAM REASON"), APPROPRIATENESS_CD(21, "APPROPRIATENESS CD"), PRIORITY_LEVEL(22, "PRIORITY LEVEL"), MODALITY_CD(23, "MODALITY CD"), HA_PROCEDURE_CD(24, "HA PROCEDURE CD"),
        EXAM_COUNT(25, "EXAM COUNT"), SNOMED_CD(26, "SNOMED CD"), SEDATION_YN(27, "SEDATION YES(Y)/NO(N)"), TIMED_FOLLOW_UP(28, "TIMED FOLLOW UP"), REFERRAL_DT(29, "REFERRAL DATE"), BOOKING_FORM_RECEIVED_DT(30, "BOOKING FORM RECEIVED DATE"), BOOKING_CREATED_DT(31, "BOOKING CREATED DATE"),
        PROCEDURE_SCHEDULED_DT(32, "PROCEDURE SCHEDULED DATE"), PROCEDURE_CANCELLED_DT(33, "PROCEDURE CANCELLED DATE"), CANCELLATION_REASON_CD(34, "CANCELLATION REASON CD"), PROCEDURE_POSTPONED_DT(35, "PROCEDURE POSTPONED DATE"), POSTPONEMENT_REASON_CD(36, "POSTPONEMENT REASON CD"),
        PATIENT_UNAVAIL_START_DT_1(37, "PATIENT UNAVAIL START DATE 1"), PATIENT_UNAVAIL_END_DT_1(38, "PATIENT UNAVAIL END DATE 1"), PATIENT_UNAVAIL_START_DT_2(39, "PATIENT UNAVAIL START DATE 2"), PATIENT_UNAVAIL_END_DT_2(40, "PATIENT UNAVAIL END DATE 2"), PATIENT_UNAVAIL_START_DT_3(41, "PATIENT UNAVAIL START DATE 3"),
        PATIENT_UNAVAIL_END_DT_3(42, "PATIENT UNAVAIL END DATE 3"), EXAM_ID(43, "EXAM ID"), URN(44, "URN"), MRN(45, "MRN"), FACILITY_ID_COMPLETED(46, "FACILITY ID COMPLETED"), MACHINE_ID(47, "MACHINE ID"), MODALITY_CD_COMPLETED(48, "MODALITY CD COMPLETED"),
        HA_PROCEDURE_CD_COMPLETED(49, "HA PROCEDURE CD COMPLETED"), EXAM_COUNT_COMPLETED(50, "EXAM COUNT COMPLETED"), SNOMED_CD_COMPLETED(51, "SNOMED CD COMPLETED"), SEDATION_YN_COMPLETED(52, "SEDATION YES(Y)/NO(N) COMPLETED"), PROCEDURE_IN_OUT_TIME(53, "PROCEDURE IN OUT TIME"),
        PROCEDURE_PERFORMED_DT(54, "PROCEDURE PERFORMED DATE"), REPORT_SENT_TO_PRACT_DT(55, "REPORT SENT TO ORDERING PRACTITIONER DATE"), FINDINGS_CD(56, "FINDINGS CD"), FUNDING_TYPE_CD(57, "FUNDING TYPE CD");
        private final int value;
        private final String stringValue;

        private FieldIndex(int value, String stringValue) {
            this.value = value;
            this.stringValue = stringValue;
        }

        public int getValue() {
            return value;
        }

        public String getStringValue() {
            return stringValue;
        }

        @Override
        public String toString() {
            return stringValue;
        }
    }

    public enum REQUIRED_FIELDS {

        BOOKING_ID, FACILITY_ID, EXAM_ID
    }
}
