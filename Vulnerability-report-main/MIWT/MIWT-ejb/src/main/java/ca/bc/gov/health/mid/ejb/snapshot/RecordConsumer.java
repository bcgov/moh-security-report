package ca.bc.gov.health.mid.ejb.snapshot;

import ca.bc.gov.health.mid.ejb.entity.SnapshotRecord;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.DataSource;

public class RecordConsumer implements Runnable {

    private static final Logger logger = Logger.getLogger(RecordConsumer.class.getName());

    private DataSource datasource;
    private String user;

    private BlockingQueue<List<SnapshotRecord>> records;

    private ExecutorService executor =
            new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors() * 5,
                    Runtime.getRuntime().availableProcessors() * 5,
                    0, TimeUnit.MILLISECONDS,
                    new ArrayBlockingQueue<>(4),
                    new ThreadPoolExecutor.CallerRunsPolicy());
    private ConcurrentLinkedQueue<String> messages = new ConcurrentLinkedQueue<>();
    private AtomicInteger inserts = new AtomicInteger();
    private CountDownLatch latch;

    public RecordConsumer(DataSource datasource, String user, BlockingQueue<List<SnapshotRecord>> records, CountDownLatch latch) {
        this.datasource = datasource;
        this.user = user;
        this.records = records;
        this.latch = latch;
    }

    @Override
    public void run() {
        try {
            while (true) {
                List<SnapshotRecord> chunk = records.poll(30, TimeUnit.MINUTES);
                if (chunk == null || chunk.isEmpty()) {
                    logger.log(Level.INFO, "Stopped after receiving empty chunk.");
                    break;
                }
                executor.execute(new ChunkInsertionTask(datasource, user, chunk, inserts, messages));
            }

            executor.shutdown();
            if (!executor.awaitTermination(60, TimeUnit.MINUTES)) {
                logger.log(Level.WARNING, "Forcefully shutting down the executor service...");
                executor.shutdownNow();
                if (!executor.awaitTermination(60, TimeUnit.MINUTES)) {
                    logger.log(Level.SEVERE, "Executor service did not shut down in time.");
                }
            }
        } catch (InterruptedException exception) {
            Thread.currentThread().interrupt();
            logger.log(Level.SEVERE, "Interrupted while adding records chunk", exception);
        }

        latch.countDown();
    }

    public int getInserts() {
        return inserts.get();
    }

    public List<String> getMessages() {
        return new ArrayList<>(messages);
    }
}
