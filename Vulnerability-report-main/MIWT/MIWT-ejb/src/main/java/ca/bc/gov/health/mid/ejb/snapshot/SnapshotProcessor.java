package ca.bc.gov.health.mid.ejb.snapshot;

import ca.bc.gov.health.mid.ejb.entity.HealthAuthority;
import ca.bc.gov.health.mid.ejb.entity.Snapshot;
import ca.bc.gov.health.mid.ejb.entity.SnapshotLog;
import ca.bc.gov.health.mid.ejb.entity.SnapshotRecord;
import ca.bc.gov.health.mid.ejb.session.HealthAuthorityFacadeLocal;
import ca.bc.gov.health.mid.ejb.session.SnapshotLogFacadeLocal;
import ca.bc.gov.health.mid.util.ApplicationConfig;
import ca.bc.gov.health.mid.util.MailService;
import ca.bc.gov.health.mid.util.SnapshotEmailEnum;
import jakarta.annotation.Resource;
import jakarta.ejb.EJB;
import jakarta.ejb.Lock;
import jakarta.ejb.LockType;
import jakarta.ejb.Singleton;
import jakarta.enterprise.concurrent.ManagedThreadFactory;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.validation.Validation;
import jakarta.validation.ValidatorFactory;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Types;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.DataSource;

@Singleton
@Lock(LockType.READ)
public class SnapshotProcessor {

    public enum State {
        COMPLETE, ARCHIVE, PROCESS, IDLE
    }

    private static final Logger logger = Logger.getLogger(SnapshotProcessor.class.getName());

    private static final int QUEUE_CAPACITY = 10;

    private static final int SNAPSHOT_TTL = 4 * 60 * 60 * 1000; // 4 hours

    @Resource(name = "java:app/jdbc/MIWT")
    private DataSource datasource;

    @Resource
    private ManagedThreadFactory threadFactory;

    @PersistenceContext(unitName = "MIDPU")
    private EntityManager entityManager;

    @EJB
    private HealthAuthorityFacadeLocal healthAuthorityFacade;

    @EJB
    private SnapshotLogFacadeLocal snapshotLogFacade;

    @Inject
    private ApplicationConfig applicationConfig;
    
    @Inject
    private MailService mailService;

    private BlockingQueue<List<SnapshotRecord>> queue;
    private RecordConsumer consumer;
    private RecordProducer producer;
    //private RecordProducerYear producerYear;
    private RecordValidator validator;

    private State state = State.IDLE;
    private long snapshotTimestamp = 0;
    private List<String> messages = new ArrayList<>();

    private long averageTime = 0;
 
    private boolean sentEmail = false;

    public SnapshotProcessor() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = new RecordValidator(factory.getValidator());

        queue = new LinkedBlockingQueue<>(QUEUE_CAPACITY);
    }

    public boolean createSnapshot(String user, String userEmail) {
        if (state == State.COMPLETE) {
            state = State.IDLE;
        }

        logger.log(Level.INFO, "Snapshot creation process initiated by user {0}.", user);
        long timeSinceLastSnapshot = System.currentTimeMillis() - snapshotTimestamp;
        if (state != State.IDLE && timeSinceLastSnapshot > SNAPSHOT_TTL) {
            logger.log(Level.INFO, "Snapshot already in progress.");
            return false;
        }

        threadFactory.newThread(() -> {
            snapshotTimestamp = System.currentTimeMillis();
            try {
                sentEmail = false;
                state = State.ARCHIVE;
                int snapshotId = prepare(user);
                state = State.PROCESS;
                List<String> errors = process(user, snapshotId);
                messages.addAll(errors);
                state = State.COMPLETE;

                long duration = System.currentTimeMillis() - snapshotTimestamp;
                averageTime = (averageTime + duration) / 2;
                logger.log(Level.INFO, "Snapshot {0} created in {1} ms.", new Object[]{snapshotId, duration});

                sendEmail(new Date(), user, userEmail);
            } catch (Exception exception) {
                messages.add("Snapshot creation failed: " + exception.getMessage());
                state = State.COMPLETE;
                logger.log(Level.SEVERE, "Snapshot creation failed.", exception);
            }
        }).start();
        return true;
    }

     /**
     * Send an email that a snapshot has been created
     * @param creationDate of the snapshot
     * @param userName of the snapshot
     * @param userEmail of the snapshot
     */
    private void sendEmail(Date creationDate, String userName, String userEmail) {
      if (!sentEmail) {

        final ZonedDateTime zonedDateTime = creationDate.toInstant().atZone(ZoneId.systemDefault());
        final String emailSubject = "Snapshot notification - " + DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(zonedDateTime);

        Map<String, Object> data = new HashMap<>();
        data.put(SnapshotEmailEnum.ENVIRONMENT.getValue(), applicationConfig.getEnvironment());
        data.put(SnapshotEmailEnum.USERNAME.getValue(), userName);
        data.put(SnapshotEmailEnum.SNAPSHOT_DATE_TIME.getValue(), DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(zonedDateTime));

        mailService.sendEmailTemplate(userEmail, emailSubject, SnapshotEmailEnum.getEmailTemplateName(), data);
        sentEmail = true;
      }  
    }
    
    public List<String> getMessages() {
        return messages;
    }

    public State getState() {
        return state;
    }

    public int getProgress() {
        long timeSinceLastSnapshot = System.currentTimeMillis() - snapshotTimestamp;
        if (state != State.IDLE && timeSinceLastSnapshot > SNAPSHOT_TTL) {
            state = State.IDLE;
            return 100;
        }

        if (state == State.COMPLETE) {
            return 100;
        }
        if (state == State.PROCESS) {
            return 50;
        }
        return 0;
    }

    public long getAverageTime() {
        return averageTime;
    }

    public long getRunningTime() {
        return System.currentTimeMillis() - snapshotTimestamp;
    }

    private int prepare(String user) throws SQLException {
        logger.log(Level.INFO, "Preparing new snapshot...");

        try (Connection connection = datasource.getConnection();
             CallableStatement statement = connection.prepareCall("{call MIWT_SNAPSHOTLOAD_PKG.pr_create_snapshot(?,?)}")) {
            connection.setAutoCommit(false);
            statement.setString(1, user);
            statement.registerOutParameter(2, Types.INTEGER);
            statement.executeUpdate();
            int snapshotId = statement.getInt(2);
            connection.commit();
            logger.log(Level.INFO, "New snapshot ({0}) prepared.", snapshotId);
            return snapshotId;
        }
    }

    private List<String> process(String user, int snapshotId) {
        logger.log(Level.INFO, "Processing snapshot...");

        CountDownLatch latch = new CountDownLatch(2);
        producer = new RecordProducer(datasource, queue, validator, latch);
        //producerYear = new RecordProducerYear(datasource, queue, validator, latch);
        consumer = new RecordConsumer(datasource, user, queue, latch);
        threadFactory.newThread(producer).start();
        //threadFactory.newThread(producerYear).start();
        threadFactory.newThread(consumer).start();

        try {
            if (!latch.await(4, TimeUnit.HOURS)) {
                logger.log(Level.WARNING, "Timed out while waiting on producer/consumer.");
            }
        } catch (InterruptedException exception) {
            Thread.currentThread().interrupt();
            logger.log(Level.SEVERE, "Interrupted while waiting on producer/consumer.", exception);
        }

        log(snapshotId, producer.getCountPerHA(), producer.getErrorPerHA());
        //log(snapshotId, producerYear.getCountPerHA(), producerYear.getErrorPerHA());

        return consumer.getMessages();
    }

    private void log(long snapshotId, Map<Long, Long> rowCounts, Map<Long, Long> errorCounts) {
        logger.log(Level.INFO, "Persisting snapshot logs...");

        Snapshot snapshot = entityManager.find(Snapshot.class, snapshotId);
        List<HealthAuthority> healthAuthorities = healthAuthorityFacade.findAll();
        for (HealthAuthority authority : healthAuthorities) {
            SnapshotLog log = new SnapshotLog();
            log.setHealthAuthorityId(authority);
            log.setSnapshotId(snapshot);
            log.setRowsProcessed(rowCounts.getOrDefault(authority.getHealthAuthorityId(), 0L));
            log.setRowsRejected(errorCounts.getOrDefault(authority.getHealthAuthorityId(), 0L));
            log.setRowsWithWarnings(0L);
            snapshotLogFacade.create(log);
        }
    }
}
