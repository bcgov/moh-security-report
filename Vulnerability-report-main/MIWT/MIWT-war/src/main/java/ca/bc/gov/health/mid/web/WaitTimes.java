package ca.bc.gov.health.mid.web;

import ca.bc.gov.health.jsf.BaseBean;
import ca.bc.gov.health.mid.ejb.entity.Snapshot;
import ca.bc.gov.health.mid.ejb.entity.custom.DynamicColumn;
import ca.bc.gov.health.mid.ejb.entity.custom.WaitTimesCriteria;
import ca.bc.gov.health.mid.ejb.entity.custom.WaitTimesFilter;
import ca.bc.gov.health.mid.ejb.session.SnapshotFacadeLocal;
import ca.bc.gov.health.mid.ejb.session.custom.WaitTimesFacadeLocal;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.context.FacesContext;
import jakarta.faces.model.SelectItem;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import org.primefaces.PrimeFaces;

/**
 * Backing Bean for the Wait Times reporting screen
 * @author CGI Information Management Consultants Inc.
 */
@Named("WaitTimes")
@ViewScoped
public class WaitTimes extends BaseBean {

    /**
     * Facade for running queries
     */
    @EJB
    private WaitTimesFacadeLocal waitTimesFacade;
    @EJB
    private SnapshotFacadeLocal snapshotFacade;
    /**
     * Search Criteria
     */
    private WaitTimesCriteria criteria;
    private Date startDate;
    private Date endDate;
    private Long snapshotId;
    private List results;
    
    @Inject
    private Droplists droplists;
    
    private int indexToReorder;

    public WaitTimes() {
    }

    @PostConstruct
    public void init() {
        criteria = new WaitTimesCriteria();
        int order = 0;
        criteria.getFilters().add(new WaitTimesFilter("MODALITY_TYPE_CD", "Modality", droplists.getValidModalitys(), order++));
        criteria.getFilters().add(new WaitTimesFilter("HEALTH_AUTHORITY_ID", "Health Authority", droplists.getHealthAuthoritys(), order++));
        criteria.getFilters().add(new WaitTimesFilter("FACILITY_ID", "Facility", droplists.getValidFacilitys(), order++));
        criteria.getFilters().add(new WaitTimesFilter("FIRST_IMAGING_REGION_CD", "Anatomical Imaging Region", droplists.getValidAnatomicalImagingRegions(), order++));
        criteria.getFilters().add(new WaitTimesFilter("BODY_PART_CD", "Body Part", droplists.getValidBodyParts(), order++));
        criteria.getFilters().add(new WaitTimesFilter("PRIORITY_LEVEL_ID", "Priority Level", droplists.getValidPriorityLevels(), order++));
        criteria.getFilters().add(new WaitTimesFilter("GENDER_CD", "Gender", droplists.getValidGenders(), order++));
        criteria.getFilters().add(new WaitTimesFilter("AGE_RANGE_ID", "Age", droplists.getValidAgeRanges(), order++));
        List<SelectItem> adultYn = new ArrayList<>();
        adultYn.add(new SelectItem("Y", "Adult"));
        adultYn.add(new SelectItem("N", "Pediatric"));
        criteria.getFilters().add(new WaitTimesFilter("ADULT_YN", "Adult(17+) / Pediatric(<17)", adultYn, order++));
        List<SelectItem> timedExamYn = new ArrayList<>();
        timedExamYn.add(new SelectItem("Y", "Yes"));
        timedExamYn.add(new SelectItem("N", "No"));
        criteria.getFilters().add(new WaitTimesFilter("TIMED_EXAM_YN", "Timed Follow up", timedExamYn, order++));
        criteria.getFilters().add(new WaitTimesFilter("ENCOUNTER_TYPE_CD", "Encounter Type", droplists.getValidEncounterTypes(), order++));
        criteria.getFilters().add(new WaitTimesFilter("FUNDING_TYPE_CD", "Funding Type", droplists.getValidFundingTypes(), order++));
        criteria.getFilters().add(new WaitTimesFilter("TOTAL", "Total Cases", null, order++));
        criteria.getFilters().add(new WaitTimesFilter("MIN", "Minimum", null, order++));
        criteria.getFilters().add(new WaitTimesFilter("MAX", "Maximum", null, order++));
        criteria.getFilters().add(new WaitTimesFilter("AVG", "Average", null, order++));
        criteria.getFilters().add(new WaitTimesFilter("25", "25th", null, order++));
        criteria.getFilters().add(new WaitTimesFilter("50", "50th [Median]", null, order++));
        criteria.getFilters().add(new WaitTimesFilter("75", "75th", null, order++));
        criteria.getFilters().add(new WaitTimesFilter("90", "90th", null, order++));
        results = null;
        startDate = null;
        endDate = null;
        snapshotId = null;
    }
    
    public String clear(){
        init();
        return null;
    }    

    public String moveUp(int indexToReorder) {
        if (indexToReorder > 0) {
            int currentOrder = criteria.getFilters().get(indexToReorder).getSortOrder();
            criteria.getFilters().get(indexToReorder).setSortOrder(currentOrder - 1);
            criteria.getFilters().get(indexToReorder - 1).setSortOrder(currentOrder);
            Collections.sort(criteria.getFilters());
        }
        return null;
    }

    public String moveDown(int indexToReorder) {
        if (indexToReorder < criteria.getFilters().size() - 1) {
            int currentOrder = criteria.getFilters().get(indexToReorder).getSortOrder();
            criteria.getFilters().get(indexToReorder).setSortOrder(currentOrder + 1);
            criteria.getFilters().get(indexToReorder + 1).setSortOrder(currentOrder);
            Collections.sort(criteria.getFilters());
        }
        return null;
    }

    public String moveUp() {
        if (indexToReorder > 0) {
            int currentOrder = criteria.getFilters().get(indexToReorder).getSortOrder();
            criteria.getFilters().get(indexToReorder).setSortOrder(currentOrder - 1);
            criteria.getFilters().get(indexToReorder - 1).setSortOrder(currentOrder);
            Collections.sort(criteria.getFilters());
        }
        return null;
    }

    public String moveDown() {
        if (indexToReorder < criteria.getFilters().size() - 1) {
            int currentOrder = criteria.getFilters().get(indexToReorder).getSortOrder();
            criteria.getFilters().get(indexToReorder).setSortOrder(currentOrder + 1);
            criteria.getFilters().get(indexToReorder + 1).setSortOrder(currentOrder);
            Collections.sort(criteria.getFilters());
        }
        return null;
    }

    public int getIndexToReorder() {
        return indexToReorder;
    }

    public void setIndexToReorder(int indexToReorder) {
        this.indexToReorder = indexToReorder;
    }

    public String viewDetails() {
        if (!validate()) {
            PrimeFaces.current().scrollTo("navbar");
            return null;
        }

        // Since the backing map for droplist is LinkedHashMap, order is guaranteed
        // therefore, the first value should be the most current snapshop
        Long[] snapshotIds = droplists.getSnapshots().values().toArray(new Long[0]);

        // if we ar esearch again the most current snapshot, then 
        // we want to set the snapshot criterion to null to differentiate 
        // from archived snapshot
        if (snapshotIds[0].equals(snapshotId)) {
            snapshotId = null;
        }

        results = waitTimesFacade.getResultsForForParams(snapshotId, startDate, endDate, criteria);
        return null;
    }



    public List<DynamicColumn> getColumns() {
        return criteria.buildColumnList();
    }

    /** Getters and Setters */
    public List getResults() {
        return results;
    }

    public void setResults(List results) {
        this.results = results;
    }

    public Date getEndDate() {
        return endDate;
    }

    public void setEndDate(Date endDate) {
        this.endDate = endDate;
    }

    public Long getSnapshotId() {
        return snapshotId;
    }

    public void setSnapshotId(Long snapshotId) {
        this.snapshotId = snapshotId;
    }

    public Date getStartDate() {
        return startDate;
    }

    public void setStartDate(Date startDate) {
        this.startDate = startDate;
    }

    public WaitTimesCriteria getCriteria() {
        return criteria;
    }

    public void setCriteria(WaitTimesCriteria criteria) {
        this.criteria = criteria;
    }

    private boolean validate() {

        boolean isvalid = true;
        Snapshot snapshot = snapshotFacade.find(snapshotId);

        if (startDate == null) {
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, "'From' date range is required", "'From' date is required"));
            isvalid = false;
        } else {
            if (startDate.before(snapshot.getReportingPeriodStartDt()) || startDate.after(snapshot.getReportingPeriodEndDt())){
                super.addErrorMessage("Start Date must be within Snapshot reporting period");
                isvalid = false;
            }
            if (endDate != null) {
                if (startDate.after(endDate)) {
                    addErrorMessage("'From' date cannot be after 'To' date.");
                    isvalid = false;
                }
            if (endDate.before(snapshot.getReportingPeriodStartDt()) || endDate.after(snapshot.getReportingPeriodEndDt())){
                super.addErrorMessage("End Date must be within Snapshot reporting period");
                isvalid = false;
            }                
            }
        }

        if (endDate == null) {
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, "'To' date range is required", "'To' date range is required"));
            isvalid = false;
        }

        List<WaitTimesFilter> filters = criteria.getFilters();

        // Confirm that at least one criterion is selected
        boolean criteriaSelected = false;
        boolean outputColSelected = false;
        for (WaitTimesFilter f : filters) {

            if (f.isIncludeInReport()) {
                if (f.getOptions()==null || f.getOptions().size()==0){
                    outputColSelected = true;
                }else{
                    criteriaSelected = true;
                }
            }
        }

        if (!criteriaSelected) {
            addErrorMessage("At least one field must be selected for inclusion in the report");
            isvalid = false;
        }
        
        if (!outputColSelected) {
            addErrorMessage("At least one statistic must be selected for report output");
            isvalid = false;
        }        
        
        return isvalid;
    }
}
