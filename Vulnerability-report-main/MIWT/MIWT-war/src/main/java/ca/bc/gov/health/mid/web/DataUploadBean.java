package ca.bc.gov.health.mid.web;

import au.com.bytecode.opencsv.CSVReader;
import ca.bc.gov.health.jsf.BaseBean;
import ca.bc.gov.health.mid.ejb.entity.DataApproval;
import ca.bc.gov.health.mid.ejb.entity.HealthAuthority;
import ca.bc.gov.health.mid.ejb.entity.ImagingProcedure;
import ca.bc.gov.health.mid.ejb.entity.UploadStat;
import ca.bc.gov.health.mid.ejb.session.DataApprovalFacadeLocal;
import ca.bc.gov.health.mid.ejb.session.ImagingProcedureFacadeLocal;
import ca.bc.gov.health.mid.ejb.session.UploadStatFacadeLocal;
import ca.bc.gov.health.mid.util.*;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.enterprise.context.SessionScoped;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.context.FacesContext;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.primefaces.model.file.UploadedFile;

/**
 * Session bean to handle loading data from uploaded files into the staging tables of the database.
 *
 * @author CGI Information Management Consultants Inc.
 */
@Named("DataUploadBean")
@SessionScoped
public class DataUploadBean extends BaseBean {

    private static final Logger logger = Logger.getLogger(DataUploadBean.class.getName());

    @EJB
    private transient RawDataValidatorLocal dataValidator;

    @EJB
    private transient ImagingProcedureFacadeLocal imagingProcedureFacade;

    @EJB
    private transient DataApprovalFacadeLocal dataApprovalFacade;

    @EJB
    private transient UploadStatFacadeLocal statFacade;

    @Inject
    private transient User user;

    @Inject
    private MailService mailService;

    @Inject
    private ApplicationConfig applicationConfig;

    private boolean firstLineHeader = true;
    private AtomicBoolean uploadComplete = new AtomicBoolean();
    private String[][] stats;
    private HealthAuthority healthAuthority;
    private List<String> validationErrors = new ArrayList<>();
    private int submitted;
    private int accepted;
    private int warnings;
    private int fatalErrors;
    private int mappingErrors;
    private int ignored;
    private int acceptedInserts;
    private int acceptedUpdates;
    private int databaseErrors;

    // mErrors array keeps track of mapping errors from each type (insert, update, ignored)
    // [0] counter for new inserted record with mapping error
    // [1] counter for updated record with mapping error
    // [2] counter for ignored record with mapping error
    // total mapping errors in valid records = [0] + [1} + [2}
    private int[] mErrors = new int[3];

    private long totalSize = 1;
    private long processedLines = -1;
    private long totalLines = 1;
    private long sizeCompleted = 0;
    private AtomicBoolean uploadInProgress = new AtomicBoolean();
    private static final int BATCH_SIZE = 100; //Must match MID_IMAGING_PROCEDURE_SEQ
    private int totalRecords;
    private AtomicInteger recordsProcessed = new AtomicInteger(0);
    private AtomicInteger dbInsertErrors = new AtomicInteger(0);
    private AtomicInteger inserts = new AtomicInteger(0);
    private AtomicInteger updates = new AtomicInteger(0);
    private AtomicInteger dbErrors = new AtomicInteger(0);
    private List<String> dbErrorMessages;
    private Validator dbValidator;
    private String filename;
    private boolean doingExport = false;

    private final boolean m_debug = false; // debug mode
    private String debugStr = ""; // for debug info only

    private String uploadKey = "";
    private Date uploadDate;

    private int databaseDuplicates;
    private int fileDuplicates;


    /**
     * Initialize this bean for the first time.
     */
    @PostConstruct
    public void init() {

        healthAuthority = user.getHealthAuthority();       
        // this reset the value back to true when click on "upload" button, so
        // need to comment out.
        //firstLineHeader = true;
        stats = null;
        validationErrors = new ArrayList<>();
        dbErrorMessages = new ArrayList<>();
        uploadComplete.set(false);
        resetFields();
        uploadInProgress.set(false);
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        dbValidator = factory.getValidator();
    }

    /**
     * Get the date of the most recent approval for the User's health authority
     *
     * @return Date - The timestamp of the approval
     */
    public Date getLastApprovalDate() {
        if (healthAuthority != null) {
            List<DataApproval> approvals = healthAuthority.getDataApprovalList();
            if (approvals != null && approvals.size() > 0) {
                return approvals.get(approvals.size() - 1).getApprovalDtm();
            }
        }
        return null;
    }

    /*
     * Check whether a record is already existed in either the uploading file, or in DB.
     */

     private boolean isDuplicated(int lineNumber, Map<String, String> dbRecordMap, Map<String, String> fileMap,
                                 String currentKey, String checksum) {
        boolean result = false;

        // check to see if the checksum of this current record exists in the filemap, if yes, then
        // it means a duplicate record in this file has been added before.
        if (!fileMap.containsKey(checksum)) {
            fileMap.put(checksum, currentKey);
            if (dbRecordMap.containsKey(currentKey)) {
                String db_checksum = dbRecordMap.get(currentKey);
                if (checksum.equals(db_checksum)) {
                    databaseDuplicates++;
                    result = true;
                }
            }
        } else {
            fileDuplicates++;
            result = true;
        }
        return result;
    }
    /*
     * This method is for testing upload file.
     */
    public void processUploadFile(UploadedFile uploadedFile, long size) {
        filename = uploadedFile.getFileName();
        totalSize = size;
        List<ImagingProcedure> procedures = new ArrayList<ImagingProcedure>();
        long startTime = System.currentTimeMillis();

        try (LineNumberReader lineNumberReader = new LineNumberReader(new InputStreamReader(uploadedFile.getInputStream()), Short.MAX_VALUE)) {
            while (lineNumberReader.readLine() != null) {
                continue;
            }
            totalLines = lineNumberReader.getLineNumber();
        } catch (Exception io) {
            io.printStackTrace();
        }

        try (CSVReader reader = new CSVReader(new InputStreamReader(uploadedFile.getInputStream()), ',', '"', '\0')) {

            String[] nextLine;
            int i = 1;
            if (firstLineHeader) {
                nextLine = reader.readNext();
                sizeCompleted += getSize(nextLine);
                processedLines++;
                // if first line is treated as a header, then we line
                // counter needs to be incremented by 1 to ensure warning
                // and error are reported using correct line number
                i++;
            }

            while ((nextLine = reader.readNext()) != null) {
                RecordWrapper recordWrapper = new RecordWrapper();
                recordWrapper.setEntry(nextLine);
                ImagingProcedure record = ConversionHelper.convertToImagingProcedure(nextLine);

                sizeCompleted += getSize(nextLine);
                processedLines++;
                procedures.add(record);
            }

        } catch (Exception e) {
            FacesContext.getCurrentInstance().getExternalContext().log(e.getMessage(), e);
            logger.log(Level.INFO, "Exception while processing CSV file.", e);
            addErrorMessage(e.getMessage());
        }
        processedLines++;
        logger.log(Level.INFO, "Processing upload file spent: " + (System.currentTimeMillis() - startTime) + " ms, processed file size is: " + procedures.size());

    }

    /**
     * Handles a file upload by validating the file, uploading the parsed records, and updating the statistics of
     * accepted / rejected rows
     *
     * @param uploadedFile UploadedFile - file provided by the end user
     * @param size         long - Size of the file in bytes
     */
    public void uploadDataEjb(UploadedFile uploadedFile, long size) {

        filename = uploadedFile.getFileName();
        String username = user.getUserName();

        // if uploadKey created from previous uploading, then delete those uploaded records from temp table
        // else: delect all older than 24 hour records in temp table.
        if ("".equals(uploadKey)) {
            imagingProcedureFacade.cleanupOldRecords();
        } else {
            imagingProcedureFacade.cleanupTempTable(uploadKey);
        }

        resetFields();
        long startTime;
                logger.log(Level.INFO, "LINEREADER");

        try (LineNumberReader lineNumberReader = new LineNumberReader(new InputStreamReader(uploadedFile.getInputStream()), Short.MAX_VALUE)) {
            while (lineNumberReader.readLine() != null) {
                continue;
            }
            totalLines = lineNumberReader.getLineNumber();
        } catch (Exception io) {
            io.printStackTrace();
        }

        totalSize = size;
        int numThreads = Math.min(Runtime.getRuntime().availableProcessors() / 2, 8);
        ExecutorService es = Executors.newFixedThreadPool(numThreads);

        uploadInProgress.set(true);
        dataValidator.initialize(); // Re-initialize validator in case new mappings are available

        // current health Authority Id
        Long HaId = healthAuthority.getHealthAuthorityId();
                logger.log(Level.INFO, "CSVREADER");

        try (CSVReader reader = new CSVReader(new InputStreamReader(uploadedFile.getInputStream()), ',', '"', '\0')) {

            String[] nextLine;

            int i = 1;
            if (firstLineHeader) {
                nextLine = reader.readNext();
                sizeCompleted += getSize(nextLine);
                processedLines++;
                // if first line is treated as a header, then we line
                // counter needs to be incremented by 1 to ensure warning
                // and error are reported using correct line number
                i++;
            }

            startTime = System.currentTimeMillis();
            // Now create a new upload key with username and CURRENT time!
            uploadKey = username + "+" + startTime;
            uploadDate = new Date();
            logger.log(Level.INFO, "Current uploadKey = " + uploadKey);

            Map<String, String> dbRecordMap = Collections.synchronizedMap(imagingProcedureFacade.findBookingMapForHa(HaId));
            logger.log(Level.INFO, "Loaded database keys' map in " + (System.currentTimeMillis() - startTime) + " ms");

            Map<String, String> fileMap = new HashMap<>(); // map for keeping track of all keys of records in the uploaded file

            startTime = System.currentTimeMillis();
            List<ImagingProcedure> procedures = new ArrayList<ImagingProcedure>();
            List<Future> tasks = new ArrayList<>();

            databaseDuplicates = 0;
            fileDuplicates = 0;

            while ((nextLine = reader.readNext()) != null) {
                logger.log(Level.INFO, "NEXTLINE");
                sizeCompleted += getSize(nextLine);
                processedLines++;
                RecordWrapper recordWrapper = new RecordWrapper();
                recordWrapper.setEntry(nextLine);

                try {
                    submitted++;
                    ImagingProcedure record = ConversionHelper.convertToImagingProcedure(nextLine);
                    // set user and date for both created and modified, when moving
                    // data from temp table to real table, they will be assigned correctly according
                    // to either created or modified (also the statelessNbr)
                    record.setCreatedByNm(username);
                    record.setLastModifiedByNm(username);
                    record.setCreatedOnDtm(uploadDate);
                    record.setLastModifiedOnDtm(uploadDate);
                    record.setStatelessTransactionNbr(1l);


                    boolean valid = validate(i, HaId, recordWrapper, record, true);
                    //RecordWrapper.STATUS currentStatus = recordWrapper.getStatus();
                    if (valid) {
                       // String key = record.getBookingId() + "-" + record.getFacilityId().toString();
                       //C2-27588 Booking id is unic 
                       String key = record.getBookingId();
                      
                       //C2-27588 for VCHA if the booking id is all numeric we need to add the booking form received date                     
                        if (HaId==3){
                         // logger.log(Level.INFO, "health: " + HaId);
                            SimpleDateFormat format1 = new SimpleDateFormat("yyyyMMdd"); 
                            String inActiveDate = null;
          
                            int len = key.length();
                           
                            for (int x = 0; x < len; x++) {
                                 if ((Character.isLetter(key.charAt(x)) == true)){  
                                     key = record.getBookingId();
                                     x=len; 
                                 }
                                 else {
                                     Date date = record.getBookingFormReceivedDt();
                                     inActiveDate = format1.format(date);  
                                     key = record.getBookingId()+inActiveDate;
                          
                                 }
                            }
                            record.setBookingId(key);
                            //if FHA, concatenate bookingID with BookingFormReceivedDate
                        } else if (HaId==2){
                         // logger.log(Level.INFO, "health: " + HaId);
                            SimpleDateFormat format1 = new SimpleDateFormat("yyyyMMdd"); 
                            String inActiveDate = null;  
                            Date date = record.getBookingFormReceivedDt();
                            inActiveDate = format1.format(date);  
                             key = record.getBookingId()+inActiveDate;                      
                                 
                            
                            record.setBookingId(key);
                        } 
                        
                      //  logger.log(Level.INFO, "key is outside of if" + key + " funding:" + record.getFundingTypeCd() + " Booking: " +record.getBookingId());
                            
                        if (isDuplicated(i, dbRecordMap, fileMap, key, record.getChecksum())) {
                            ignored++;
                        } else {
                            record.setHealthAuthorityCd(HaId.toString());
                            procedures.add(record);

                            if (procedures.size() == BATCH_SIZE) {
                                //We have queued up 2 x numThreads, so pull the first one off and wait for it to complete
                                if (tasks.size() >= (numThreads)) {
                                    Future task = tasks.remove(0);
                                    task.get();
                                }
                                Future task = es.submit(new InsertTask(imagingProcedureFacade, procedures, dbErrorMessages, recordsProcessed.get(), dbInsertErrors, recordsProcessed, uploadKey));
                                tasks.add(task);
                                procedures = new ArrayList<ImagingProcedure>();
                            }
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    logger.log(Level.WARNING, e.getMessage());
                    validationErrors.add("Fatal Error - Line " + i + ": Record has data format error. ");
                    ignored++;
                } finally {
                    i++;
                }
            }

            if (databaseDuplicates > 0) {
                validationErrors.add("Fatal Error - Found " + databaseDuplicates + " duplicated line(s) matching with an existing record in database. ");
            }
            if (fileDuplicates > 0) {
                validationErrors.add("Fatal Error - Found " + fileDuplicates + " duplicated line(s) matching with an existing record in this upload file. ");
            }

            es.execute(new InsertTask(imagingProcedureFacade, procedures, dbErrorMessages, recordsProcessed.get(), dbInsertErrors, recordsProcessed, uploadKey));
            recordsProcessed.addAndGet(procedures.size());

            es.shutdown();
            es.awaitTermination(10, TimeUnit.MINUTES);
            totalRecords = i;
            logger.log(Level.INFO, "Upload completed in " + (System.currentTimeMillis() - startTime) + " ms");
            populateUploadStats(username);
        } catch (Exception e) {
            FacesContext.getCurrentInstance().getExternalContext().log(e.getMessage(), e);
            e.printStackTrace();
            addErrorMessage(e.getMessage());
        } finally {
            uploadInProgress.set(false);
            uploadComplete.set(true);
            processedLines++;
        }
    }

    public long getSize(String[] values) {
        long size = values.length; //1 byte for each comma, plus a newline
        for (String string : values) {
            size += string.length();
        }
        return size;
    }

    public boolean isUploadInProgress() {
        return uploadInProgress.get();
    }

    public String fileUploadInProgress() {
        return null;
    }

    public int getProgress() {
        System.out.println("processedLines = " + processedLines + ", totalLines = " + totalLines);
        int progress = processedLines == -1 ? 0 : (int) ((processedLines * 100) / totalLines);

        if (progress == 100) {
            processedLines = -1;
            totalLines = 1;
        }
        return progress;

    }

    public String getProgressMessage() {
        if (getProgress() == 0) {
            return "Preparing file for processing";
        } else {
            return "Processing rows";
        }
    }

    public String checkUploadDone() {

        if (!uploadInProgress.get()) {

            //reset to ensure correct data upload signalling
            // in case the dbHelper is being reused.
            populateStats();

        }

        return null;
    }

    public List<String> getDbErrors() {
        Collections.sort(dbErrorMessages, new Comparator<String>() {
            private static final String match = "Line ";

            @Override
            public int compare(String o1, String o2) {
                try {
                    int idx1 = o1.indexOf(match) + match.length();
                    int idx2 = o2.indexOf(match) + match.length();
                    String line1 = o1.substring(idx1, o1.indexOf(":"));
                    String line2 = o2.substring(idx2, o2.indexOf(":"));
                    return Integer.valueOf(line1).compareTo(Integer.valueOf(line2));
                } catch (Exception e) {
                    return o1.compareTo(o2);
                }
            }
        });
        return dbErrorMessages;
    }

    /**
     * Validates a single record against the business rules in RawDataValidator, as well as schema constraints in the
     * database.
     *
     * @param line         int - Line number in the file, used for reporting errors
     * @param haID         Long - HealthAutority ID.
     * @param record       RecordWrapper - The values for this line in the file
     * @Param ima          ImagingProcedure - The object to make the check against
     * @param withMessages boolean - Should the errors be added to the global collection?
     * @return boolean - true if the record has no fatal errors, false otherwise
     */
    private boolean validate(int line, Long haID, RecordWrapper record, ImagingProcedure ima, boolean withMessages) {
        List<String> validationMsgs = dataValidator.validate(haID, line, record.getEntry(), false);
        Set<ConstraintViolation<ImagingProcedure>> msgs = dbValidator.validate(ima);
        for (ConstraintViolation cv : msgs) {
            if (!"imagingProcedureId".equals(cv.getPropertyPath().toString())) {
                validationMsgs.add("Fatal Error - Line " + line + ": " + cv.getPropertyPath().toString() + " " + cv.getMessage());
            }
        }
        boolean isValid = false;
        if (noOfFatalErrorsInRec(validationMsgs) > 0) {
            record.setStatus(RecordWrapper.STATUS.FATAL_ERROR);
            fatalErrors++;
        } else {
            isValid = true;
            if (noOfMappingErrorsInRec(validationMsgs) > 0) {
                record.setStatus(RecordWrapper.STATUS.MAPPING_ERROR);
                mappingErrors++;
            } else {
                if (noOfWarningsInRec(validationMsgs) > 0) {
                    record.setStatus(RecordWrapper.STATUS.ACCEPTED_WITH_WARNING);
                    warnings++;
                } else {
                    record.setStatus(RecordWrapper.STATUS.ACCEPTED);
                    accepted++;
                }
            }
        }

        if (withMessages) {
            validationErrors.addAll(validationMsgs);
        }

        return isValid;
    }

    /**
     * Counts the number of Fatal Errors in the validation messages
     *
     * @param validationMsgs List<String> - The validation messages to check
     * @return int - The number of fatal errors found
     */
    private int noOfFatalErrorsInRec(List<String> validationMsgs) {

        int errors = 0;

        for (String s : validationMsgs) {
            if (s.contains("Fatal Error")) {
                errors++;
            }
        }

        return errors;
    }

    /**
     * Counts the number of Mapping Errors in the validation messages
     *
     * @param validationMsgs List<String> - The validation messages to check
     * @return int - The number of Mapping errors found
     */
    private int noOfMappingErrorsInRec(List<String> validationMsgs) {

        int errors = 0;

        for (String s : validationMsgs) {
            if (s.contains("Mapping Error")) {
                errors++;
            }
        }

        return errors;
    }

    /**
     * Counts the number of warnings in the validation messages
     *
     * @param validationMsgs List<String> - The validation messages to check
     * @return int - The number of warnings found
     */
    private int noOfWarningsInRec(List<String> validationMsgs) {

        int warnings = 0;

        for (String s : validationMsgs) {
            if (s.contains("Warning")) {
                warnings++;
            }
        }

        return warnings;
    }

    public List<String> getValidationErrors() {
        return validationErrors;
    }

    private void saveStats() {
        UploadStat stats = new UploadStat();
        stats.setHealthAuthorityId(healthAuthority.getHealthAuthorityId());
        stats.setUploadDate(uploadDate);
        stats.setFilename(filename);
        stats.setUploaded(submitted);
        stats.setFatalError(fatalErrors);
        stats.setSubmitted(submitted - fatalErrors - ignored);
        stats.setMappingError(mappingErrors);
        stats.setWarning(warnings);
        stats.setAccepted(inserts.intValue() + updates.intValue());
        stats.setInserted(inserts.intValue());
        stats.setUpdated(updates.intValue());
        stats.setIgnored(ignored);
        statFacade.create(stats);

        sendEmail(user.getUserName(),
                filename,
                uploadDate,
                submitted,
                fatalErrors + ignored,
                inserts.intValue() + updates.intValue(),
                inserts.intValue(),
                updates.intValue(),
                warnings,
                fatalErrors);
    }

    private void sendEmail(String username,
                           String fileName,
                           Date uploadDate,
                           long rowUploaded,
                           long rowRejected,
                           long rowAccepted,
                           long newRow,
                           long updatedRow,
                           long warnings,
                           long fatalErrors) {

        final ZonedDateTime zonedDateTime = uploadDate.toInstant().atZone(ZoneId.systemDefault());
        final String emailSubject = "Submission notification - " + DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(zonedDateTime);

        Map<String, Object> data = new HashMap<>();
        data.put(UploadEmailEnum.ENVIRONMENT.getValue(), applicationConfig.getEnvironment());
        data.put(UploadEmailEnum.USERNAME.getValue(), username);
        data.put(UploadEmailEnum.FILENAME.getValue(), fileName);
        data.put(UploadEmailEnum.UPLOAD_DATE_TIME.getValue(), DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(zonedDateTime));
        data.put(UploadEmailEnum.UPLOADED_ROWS.getValue(), rowUploaded);
        data.put(UploadEmailEnum.REJECTED_ROWS.getValue(), rowRejected);
        data.put(UploadEmailEnum.ACCEPTED_ROWS.getValue(), rowAccepted);
        data.put(UploadEmailEnum.NEW_ROWS.getValue(), newRow);
        data.put(UploadEmailEnum.UPDATED_ROWS.getValue(), updatedRow);
        data.put(UploadEmailEnum.WARNINGS.getValue(), warnings);
        data.put(UploadEmailEnum.FATAL_ERRORS.getValue(), fatalErrors);

        mailService.sendEmailTemplate(user.getEmail(), emailSubject, UploadEmailEnum.getEmailTemplateName(), data);
    }

    /**
     * Prepare the upload statistics
     */
    private void populateUploadStats(String username) {
        stats = new String[3][2];
        stats[0][0] = "Rows uploaded";
        stats[0][1] = String.valueOf(submitted);
        stats[1][0] = "Rows rejected";
        stats[1][1] = String.valueOf(fatalErrors + ignored);
        stats[2][0] = "Rows pending approval by Data Submitter ( " + username + " )";
        stats[2][1] = String.valueOf(submitted - (fatalErrors + ignored));

    }

    /**
     * Prepare the approval statistics
     */
    private void populateApprovalStats() {
        stats = new String[3][2];

        // inserts
        stats[0][0] = "New rows";
        stats[0][1] = String.valueOf(acceptedInserts);

        // updates
        stats[1][0] = "Updated rows";
        stats[1][1] = String.valueOf(acceptedUpdates);

        // Total approved records
        stats[2][0] = "Total Rows Approved for submission to the Ministry";
        stats[2][1] = String.valueOf(acceptedInserts + acceptedUpdates);

    }

    /**
     * Prepares the statistics to be displayed to the user
     */
    private void populateStats() {
        stats = new String[9][2];
        stats[0][0] = "Rows Uploaded";
        stats[0][1] = String.valueOf(submitted);
        stats[1][0] = "Rows with Fatal Errors (Rejected rows)";
        stats[1][1] = String.valueOf(fatalErrors);
        stats[2][0] = "Rows Submitted (Excluding Fatal Errors)";
        stats[2][1] = String.valueOf(submitted - fatalErrors);
        stats[3][0] = "&nbsp;&nbsp;<i>Newly inserted rows</i>";
        stats[3][1] = String.valueOf(inserts);
        stats[4][0] = "&nbsp;&nbsp;<i>Updates of previously submitted rows</i>";
        stats[4][1] = String.valueOf(updates);
        stats[5][0] = "&nbsp;&nbsp;<i>Unchanged or duplicate rows</i>";
        stats[5][1] = String.valueOf(ignored);
        stats[6][0] = "Rows Submitted with Mapping Errors";
        stats[6][1] = String.valueOf(mErrors[0] + mErrors[1] + mErrors[2]);
        stats[7][0] = "Rows Submitted with Warnings";
        stats[7][1] = String.valueOf(warnings);
        stats[8][0] = "Rows Accepted for Ministry Snapshot (Excluding Fatal and Mapping Errors)";
        stats[8][1] = String.valueOf(accepted);

        String result = "";
        for (int i = 0; i < 9; i++) {
            result += stats[i][0] + " = " + stats[i][1] + "\n";
        }

        result += "Inserts with mapping errors" + " = " + mErrors[0] + "\n" +
                "Updates with mapping errors" + " = " + mErrors[1] + "\n" +
                "Ignored with mapping errors" + " = " + mErrors[2] + "\n" +
                "Accpeted from inserts" + " = " + acceptedInserts + "\n" +
                "Accpeted from updates" + " = " + acceptedUpdates;

        logger.log(Level.INFO, "Upload STATS : " + result);

    }

    /* The user choose not to approve the data, this function will clean up
     * all data from the current uploaded file in the temp table.
     */
    public void cleanupTemp() {
        logger.log(Level.INFO, "User choose not to approve the data, temp table will be cleaned up");
        imagingProcedureFacade.cleanupTempTable(uploadKey);
        resetFields();

    }

    // CAST-22794: synchronize this method to avoid concurrent call confusing the counters

    /**
     * Approves the uploaded data by adding a record in the approval table for the current user's Health Authority.
     *
     * @return String
     */
    synchronized public String approveData() {

        logger.log(Level.INFO, "User approve the data, records in temp table will be transferred to main table, uploadKey: " + uploadKey);

        DataApproval dataApproval = new DataApproval();
        dataApproval.setHealthAuthorityId(healthAuthority);
        dataApproval.setApprovalDtm(new java.util.Date());
        dataApprovalFacade.create(dataApproval);
        healthAuthority.getDataApprovalList().add(dataApproval);

        // CAST-22794: Reset the counter to 0 when approved
        inserts = new AtomicInteger(0);
        updates = new AtomicInteger(0);
        dbErrors = new AtomicInteger(0);

        imagingProcedureFacade.processData(uploadKey, inserts, updates, dbErrors);

        acceptedInserts = inserts.intValue();
        acceptedUpdates = updates.intValue();
        databaseErrors = dbErrors.intValue();

        saveStats();
        populateApprovalStats();

        FacesMessage message = new FacesMessage(FacesMessage.SEVERITY_INFO, "Data Approved Successfully", "Data Approved Successfully");
        FacesContext.getCurrentInstance().addMessage(null, message);

        return null;
    }

    public String[][] getStats() {
        return stats;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public boolean isFirstLineHeader() {
        return firstLineHeader;
    }

    public void setFirstLineHeader(boolean firstLineHeader) {
        this.firstLineHeader = firstLineHeader;
    }

    public String clearMessages() {
        validationErrors.clear();
        dbErrorMessages.clear();
        return null;
    }

   

    private void resetFields() {
        stats = null;
        submitted = accepted = warnings = fatalErrors = mappingErrors = ignored = acceptedInserts = acceptedUpdates = databaseErrors = 0;

        for (int i = 0; i < 3; i++) {
            mErrors[i] = 0;
        }

        totalRecords = 0;
        recordsProcessed = new AtomicInteger(0);
        dbInsertErrors = new AtomicInteger(0);
        inserts = new AtomicInteger(0);
        updates = new AtomicInteger(0);
        dbErrors = new AtomicInteger(0);
        validationErrors.clear();
        dbErrorMessages.clear();
        uploadInProgress.set(true);
        uploadComplete.set(false);
        sizeCompleted = 0;
        totalSize = 1;
        processedLines = -1;
        totalLines = 1;
        debugStr = "";

        //uploadKey = "";
        uploadDate = new Date();


    }

    public String exportStatistics() {
        FacesContext fc = FacesContext.getCurrentInstance();
        HttpServletResponse response = (HttpServletResponse) fc.getExternalContext().getResponse();
        response.reset();
        response.setHeader("content-type", "application/vnd.ms-excel");
        response.setHeader("content-disposition", "attachment;filename=export.xls");
        try {
            PrintWriter out = response.getWriter();
            out.println("Summary Results,Row Counts");
            for (int i = 0; i < stats.length; i++) {
                out.println(escape(stats[i][0]) + "," + stats[i][1]);
            }
            out.flush();
            fc.responseComplete();
        } catch (Exception e) {
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, "Unable to export: " + e.getMessage(), "Unable to export: " + e.getMessage()));
        }
        return null;
    }

    private String escape(String in) {
        return in.replaceAll("&nbsp;", "").replaceAll("<i>", "").replaceAll("</i>", "");
    }

    

    public HealthAuthority getHealthAuthority() {
        return healthAuthority;
    }

    public void setHealthAuthority(HealthAuthority healthAuthority) {
        this.healthAuthority = healthAuthority;
    }

    public boolean isUploadComplete() {
        return uploadComplete.get();
    }

    public void setUploadComplete(boolean uploadComplete) {
        this.uploadComplete.set(uploadComplete);
    }

    public boolean isDoingExport() {
        return doingExport;
    }

    public void setDoingExport(boolean doingExport) {
        this.doingExport = doingExport;
    }
}

/**
 * Runnable class used for multi-threading the inserts of data into the database. Each instance of this class with
 * insert/update a batch of records into the DB.
 */
class InsertTask implements Runnable {

    ImagingProcedureFacadeLocal imagingProcedureFacade;
    List<ImagingProcedure> procedures;
    long healthAuthorityId;
    Map<String, Object[]> dbRecordMap;
    List<String> dbErrorMessages;
    int startLine;
    AtomicInteger dbInsertErrors;
    AtomicInteger recordsProcessed;
    AtomicInteger inserts = new AtomicInteger(0);
    AtomicInteger updates = new AtomicInteger(0);
    String username;
    String uploadKey;

    /**
     * Creates a new InsertTask object
     *
     * @param imagingProcedureFacade
     * @param procedures
     * @param healthAuthorityId
     * @param dbRecordMap
     * @param dbErrorMessages
     * @param startLine
     * @param dbInsertErrors
     * @param recordsProcessed
     * @param inserts
     * @param updates
     * @param username
     */
    public InsertTask(ImagingProcedureFacadeLocal imagingProcedureFacade, List<ImagingProcedure> procedures,
                      List<String> dbErrorMessages, int startLine, AtomicInteger dbInsertErrors, AtomicInteger recordsProcessed,
                      String key) {
        this.imagingProcedureFacade = imagingProcedureFacade;
        this.procedures = procedures;
        this.dbErrorMessages = dbErrorMessages;
        this.startLine = startLine;
        this.dbInsertErrors = dbInsertErrors;
        this.recordsProcessed = recordsProcessed;
        this.uploadKey = key;
    }

    /**
     * Starts the execution of the batch transaction
     */
    @Override
    public void run() {
        dbInsertErrors.addAndGet(imagingProcedureFacade.batchToTempTable(procedures, uploadKey, startLine, dbErrorMessages));
        recordsProcessed.addAndGet(procedures.size());
    }
}
