package ca.bc.gov.health.mid.web;

import ca.bc.gov.health.jsf.BaseBean;
import ca.bc.gov.health.mid.ejb.entity.Snapshot;
import ca.bc.gov.health.mid.ejb.entity.custom.CaseDistributionCriteria;
import ca.bc.gov.health.mid.ejb.entity.custom.CaseDistributionFilter;
import ca.bc.gov.health.mid.ejb.entity.custom.DynamicColumn;
import ca.bc.gov.health.mid.ejb.session.SnapshotFacadeLocal;
import ca.bc.gov.health.mid.ejb.session.custom.CaseDistributionFacadeLocal;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.context.FacesContext;
import jakarta.faces.model.SelectItem;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.util.*;
import org.primefaces.PrimeFaces;

/**
 * @author CGI Information Management Consultants Inc.
 */
@Named("CaseDistribution")
@ViewScoped
public class CaseDistribution extends BaseBean {

    @EJB
    private CaseDistributionFacadeLocal caseDistributionFacade;
    @EJB
    private SnapshotFacadeLocal snapshotFacade;
    private CaseDistributionCriteria criteria;
    private Long snapshotId;
    private Date startDate;
    private Date endDate;
    private Map<String, Map> data;
    private List<Map> dataAsList = new ArrayList<>();
    private List<DynamicColumn> resultTableCols;
    private boolean showChart;
    private boolean showTable;
    @Inject
    private Droplists droplists;

    public CaseDistribution() {
    }

    @PostConstruct
    public void init() {
        criteria = new CaseDistributionCriteria();
        criteria.getFilters().add(new CaseDistributionFilter("MODALITY_CD", "Modality", droplists.getValidModalitys()));
        criteria.getFilters().add(new CaseDistributionFilter("HEALTH_AUTHORITY_ID", "Health Authority", droplists.getHealthAuthoritys()));
        criteria.getFilters().add(new CaseDistributionFilter("FACILITY_ID", "Facility", droplists.getValidFacilitys()));
        criteria.getFilters().add(new CaseDistributionFilter("FIRST_IMAGING_REGION_CD", "Anatomical Imaging Region", droplists.getValidAnatomicalImagingRegions()));
        criteria.getFilters().add(new CaseDistributionFilter("PRIORITY_LEVEL_ID", "Priority Level", droplists.getValidPriorityLevels()));
        criteria.getFilters().add(new CaseDistributionFilter("GENDER_CD", "Gender", droplists.getValidGenders()));
        criteria.getFilters().add(new CaseDistributionFilter("AGE_RANGE_ID", "Age", droplists.getValidAgeRanges()));
        List<SelectItem> adultYn = new ArrayList<>();
        adultYn.add(new SelectItem("Y", "Adult"));
        adultYn.add(new SelectItem("N", "Pediatric"));
        criteria.getFilters().add(new CaseDistributionFilter("ADULT_YN", "Adult (+17) / Pediatric (<17)", adultYn));
        List<SelectItem> timedExamYn = new ArrayList<>();
        timedExamYn.add(new SelectItem("Y", "Yes"));
        timedExamYn.add(new SelectItem("N", "No"));
        criteria.getFilters().add(new CaseDistributionFilter("WITHIN_BENCHMARK", "Within Benchmark", timedExamYn));
        criteria.getFilters().add(new CaseDistributionFilter("TIMED_EXAM_YN", "Timed Follow up", timedExamYn));


    }

    public void clear() {
        data = null;
        resultTableCols = null;
        dataAsList.clear();
        showChart = false;
        showTable = false;
        startDate = null;
        endDate = null;
        init();
    }



    /**
     * Getters and Setters
     */
    public List<DynamicColumn> getColumns() {
        return criteria.buildColumnList();
    }

    public CaseDistributionCriteria getCriteria() {
        return criteria;
    }

    public void setCriteria(CaseDistributionCriteria criteria) {
        this.criteria = criteria;
    }

    public Date getEndDate() {
        return endDate;
    }

    public void setEndDate(Date endDate) {
        this.endDate = endDate;
    }

    public Long getSnapshotId() {
        return snapshotId;
    }

    public void setSnapshotId(Long snapshotId) {
        this.snapshotId = snapshotId;
    }

    public Date getStartDate() {
        return startDate;
    }

    public void setStartDate(Date startDate) {
        this.startDate = startDate;
    }

    public Map<String, Map> getData() {
        return data;
    }

    public void setData(Map<String, Map> data) {
        this.data = data;
    }

    public boolean isShowChart() {
        return showChart;
    }

    public boolean isShowTable() {
        return showTable;
    }


    public List<Map> getDataAsList() {
        return dataAsList;
    }

    public String displayChart() {

        if (!validate()) {
            PrimeFaces.current().scrollTo("navbar");
            return null;
        }

        // Since the backing map for droplist is LinkedHashMap, order is guaranteed
        // therefore, the first value should be the most current snapshop
        Long[] snapshotIds = droplists.getSnapshots().values().toArray(new Long[0]);

        // if we ar esearch again the most current snapshot, then 
        // we want to set the snapshot criterion to null to differentiate 
        // from archived snapshot
        if (snapshotIds[0].equals(snapshotId)) {
            snapshotId = null;
        }

        loadData();
        showChart = true;
        showTable = false;

        PrimeFaces.current().scrollTo("form1:resultAsChart");

        return null;
    }

    public String displayTable() {

        if (!validate()) {
            PrimeFaces.current().scrollTo("navbar");
            return null;
        }

        // Since the backing map for droplist is LinkedHashMap, order is guaranteed
        // therefore, the first value should be the most current snapshop
        Long[] snapshotIds = droplists.getSnapshots().values().toArray(new Long[0]);

        // if we ar esearch again the most current snapshot, then 
        // we want to set the snapshot criterion to null to differentiate 
        // from archived snapshot
        if (snapshotIds[0].equals(snapshotId)) {
            snapshotId = null;
        }

        loadData();
        showChart = false;
        showTable = true;

        PrimeFaces.current().scrollTo("form1:resultAsTable");

        return null;
    }

    // Used to ensure browser always gets a fresh copy of
    // Chart image because the HTTP headers don't work all 
    // the time
    public String getImageId() {
        return UUID.randomUUID().toString();
    }

    private void loadData() {
        List<CaseDistributionFilter> filters = criteria.getFilters();

        data = caseDistributionFacade.getCaseDistributionForParams(snapshotId, startDate, endDate, criteria);
        convertDataToList();
        resultTableCols = criteria.buildColumnList();
        FacesContext.getCurrentInstance().getExternalContext().getSessionMap().put("CaseDistribution", this);
    }

    private void convertDataToList() {
        dataAsList.clear();
        if (data != null) {
            dataAsList.addAll(data.values());
        }
    }


    private boolean validate() {
        boolean isvalid = true;

        if (startDate == null) {
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, "'From' date range is required", "'From' date is required"));
            isvalid = false;
        }

        if (endDate == null) {
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, "'To' date range is required", "'To' date range is required"));
            isvalid = false;
        }

        Snapshot snapshot = snapshotFacade.find(snapshotId);

        if (startDate != null) {
            if (startDate.before(snapshot.getReportingPeriodStartDt()) || startDate.after(snapshot.getReportingPeriodEndDt())) {
                super.addErrorMessage("Start Date must be within Snapshot reporting period");
                isvalid = false;
            }
            if (endDate != null) {
                if (startDate.after(endDate)) {
                    addErrorMessage("'From' date cannot be after 'To' date.");
                    isvalid = false;
                }
                if (endDate.before(snapshot.getReportingPeriodStartDt()) || endDate.after(snapshot.getReportingPeriodEndDt())) {
                    super.addErrorMessage("End Date must be within Snapshot reporting period");
                    isvalid = false;
                }
            }
        }

        List<CaseDistributionFilter> filters = criteria.getFilters();

        // Confirm that at least one criterion is selected
        boolean criteriaSelected = false;
        for (CaseDistributionFilter f : filters) {

            if (f.getPrimaryGrouping()) {
                criteriaSelected = true;
                break;
            }
        }

        if (!criteriaSelected) {
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, "At least one field in primary group must be selected", "At least one field in primary group must be selected"));

            isvalid = false;
        }

        return isvalid;
    }
}
