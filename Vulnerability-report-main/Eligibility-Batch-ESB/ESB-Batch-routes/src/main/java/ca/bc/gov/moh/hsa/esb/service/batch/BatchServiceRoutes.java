/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.moh.hsa.esb.service.batch;

import ca.bc.gov.moh.hsa.esb.service.batch.dto.BatchRequestDTO;
import ca.bc.gov.moh.hsa.esb.service.batch.exception.AbstractBatchException;
import ca.bc.gov.moh.hsa.esb.service.batch.util.EligibilityMessageCorrector;
import java.net.URL;
import java.util.Properties;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.processor.validation.SchemaValidationException;
import org.springframework.stereotype.Component;

/**
 *
 * @author conrad.gustafson
 */
@Component
public class BatchServiceRoutes extends RouteBuilder {

    private static final BatchResponseAggregationStrategy batchResponseAggregationStrategy = new BatchResponseAggregationStrategy();
    
    private String fileDropPath;
    private int maximumRedeliveries;
    private int redeliveryDelay;
    
//    private @Value("${maximumRedeliveries}")
//    int maximumRedeliveries;
//    
//    private @Value("${redeliveryDelay}")
//    int redeliveryDelay;
    

    
    // GlassFish proterties
    protected Properties appProperties;
    
        // Default constructor
    public BatchServiceRoutes() throws NamingException {
        super();
        appProperties = (Properties) new InitialContext().lookup("java:app/eligibility/application_properties");
    }
    
    // Constructor used by InboundRouteBuilderTest to manually set ftpProperties and appProperties.
    public BatchServiceRoutes(Properties ftpProperties, Properties appProperties) {
        super();
        this.appProperties = appProperties;
    }
    
    // Maps JNDI properties to their corresponding attributes.
    private void mapProperties() {
        fileDropPath = appProperties.getProperty("messageDropDirectory");
        maximumRedeliveries = Integer.parseInt(appProperties.getProperty("maximumRedeliveries"));
        redeliveryDelay = Integer.parseInt(appProperties.getProperty("redeliveryDelay"));
    }

    public String getFileDropPath() {
        return fileDropPath;
    }
    
    @Override
    public void configure() throws Exception {
 
        URL batchUrl = BatchServiceRoutes.class.getResource("/ca/gov/moh/hsa/esb/service/batch/MCCI_AR200002.wsdl");
       
        mapProperties();
                
        String batchEndpoint = "cxf://batch?wsdlURL="+batchUrl.toExternalForm()+"&dataFormat=MESSAGE";
        String directEndpoint = "direct:batch";
        String auditEndpoint = "jms:queue:destinationResource?transferExchange=true";
        Namespaces ns = new Namespaces("soapenv", "http://schemas.xmlsoap.org/soap/envelope/");
        ns.add("v3", "urn:hl7-org:v3");
        
        from(auditEndpoint) 
            .routeId("auditEndpoint")
            .to("audit:START")
            .errorHandler(deadLetterChannel("direct:AuditError")
                .maximumRedeliveries(maximumRedeliveries)
                .redeliveryDelay(redeliveryDelay))
            ;
        
        from("direct:AuditError")
            .to("messagedrop:AuditError");
               
        from(batchEndpoint).to(directEndpoint);
        
        from(directEndpoint)
            .routeId("directEndpoint")
            // Register exception handlers
            .onException(SchemaValidationException.class)
                .handled(true)
                .to("bean:batchSchemaValidationExceptionProcessor")
                .setHeader("eventType", simple("ERROR")).setHeader("level", simple("ERROR"))
                .wireTap(auditEndpoint).end()
                .to("velocity:ca/gov/moh/hsa/esb/service/batch/batchExceptionTemplate.vm")
                .to("bean:endLogging")
            .end()
            .onException(AbstractBatchException.class)
                .handled(true)
                .to("bean:batchExceptionProcessor")
                .setHeader("eventType", simple("ERROR")).setHeader("level", simple("ERROR"))
                .wireTap(auditEndpoint).end()
                .to("velocity:ca/gov/moh/hsa/esb/service/batch/batchExceptionTemplate.vm")
                .to("bean:endLogging")
            .end()

            // For message logging
            .convertBodyTo(String.class) 
            .to("audit:INITIALIZE?transactionType=BATCH")
            .setHeader("eventType", simple("START")).setHeader("level", simple("INFO"))
            .wireTap(auditEndpoint)
            .to("messagedrop:BATCH_IN")               
            .to("bean:startLogging")

            // Validate for valid Batch request
            // can't validate first as it consumes the stream
            .convertBodyTo(String.class)
            .process((Exchange exchange) -> {
                // Prior to batch message validation and processing, correct namespaces
                String body = exchange.getIn().getBody(String.class);
                exchange.getIn().setBody(EligibilityMessageCorrector.correctBatchIn(body));
                // End of pre-validation corrections
            })
            .transform(ns.xquery("//v3:MCCI_IN200100BC"))

            // Convert to DTO (uses registered converter class)
            .convertBodyTo(BatchRequestDTO.class)                

            // Save the sending org/device as headers
            .to("bean:saveValuesHeaderProcessor")

            // Pull the SSL header info
            .to("bean:sslHeaderProcessor")
            /***
            * Validate the SSL header info - Org/Cert matching
            * Currently disabled - HCIM will match the Get Demo message Org with the Cert instead
            * Some user's, and RegOps, use a batch message without the correct Sender block
            * which doesn't work with the XPATH in BatchRequestTypeConverter.java
            * which causes the sslValidation to fail
            ****/
            // .to("bean:sslValidator")

            // Do Business validations
            // Bean validations also available (bean validator)
            .to("bean:batchRequestBusinessValidator")
                
            // Split into individual messages, process in parallel
            .split(body(), batchResponseAggregationStrategy)
            .parallelProcessing()
                .choice()
                    .when(simple("${in.body.isGetDemographics}"))
                        .to("direct:getDemographics")
                        .to("messagedrop:GD_OUT")
                    .endChoice()   
                    .when(simple("${in.body.isGetEligibility}"))
                        .to("direct:getEligibilty")
                        .to("messagedrop:GE_OUT")
                    .endChoice() 
                .end()
            .end()
                
            // Create a DTO object that can be passed to the template   
            .to("bean:batchResponseConverter")
            .choice()
                .when(simple("${in.body.isSurvivingPHN}"))
                    .setHeader("messageId", simple("${in.header.GET_ELIG_ID}"))
                    .setHeader("eventType", simple("RESEND_ELIG"))
                    .wireTap(auditEndpoint)
                    .to("bean:survivorGetEligibilityRequestConverter")
                    .convertBodyTo(String.class) //Convert to string so we can filedrop
                    .process((Exchange exchange) -> {
                        // Prior to filedroping and processing, fix up the message with schema corrections
                        String body = exchange.getIn().getBody(String.class);
                        exchange.getIn().setBody(EligibilityMessageCorrector.correctEligibilityIn((body)));
                        // End of schema corrections
                    })
                    .to("messagedrop:RESEND_GE_IN")
                    .to("direct:getEligibilityRawSecure")
                    .to("messagedrop:RESEND_GE_OUT")
                    .to("bean:survivorGetEligibilityResponseConverter")
                .endChoice()
            .end()
            .setHeader("eventType", simple("FINISH")).setHeader("level", simple("INFO"))
            .wireTap(auditEndpoint)
            .to("velocity:ca/gov/moh/hsa/esb/service/batch/batchResponseTemplate.vm")
            .to("bean:endLogging")

            // For message logging
            .to("messagedrop:BATCH_OUT");
        
        from("direct:getDemographics")
            .setHeader("eventType", simple("GET_DEMO"))
            .wireTap(auditEndpoint)
            .convertBodyTo(String.class) //Convert to string so we can filedrop
            .to("messagedrop:GD_IN")
            .doTry()   
                .to("direct:getDemographicsRawSecure")
            .doCatch(Throwable.class)
                .setHeader("messageId", simple("${in.header.GET_DEMO_ID}"))
                .to("bean:nackContextBuilder")
                .setHeader("eventType", simple("ERROR")).setHeader("level", simple("ERROR"))
                .wireTap(auditEndpoint)
                .to("velocity:ca/gov/moh/hsa/esb/service/batch/batchResponsePlaceholder.vm")      
            .end();
        
        from("direct:getEligibilty")
            .setHeader("eventType", simple("GET_ELIG"))
            .wireTap(auditEndpoint)
            .convertBodyTo(String.class) //Convert to string so we can filedrop
            .process((Exchange exchange) -> {
                // Prior to filedroping and processing, fix up the message with schema corrections
                String body = exchange.getIn().getBody(String.class);
                exchange.getIn().setBody(EligibilityMessageCorrector.correctEligibilityIn((body)));
                // End of schema corrections
            })
            .to("messagedrop:GE_IN")
            .doTry()   
                .to("direct:getEligibilityRawSecure")
            .doCatch(Throwable.class)
                .setHeader("messageId", simple("${in.header.GET_ELIG_ID}"))
                .to("bean:nackContextBuilder")
                .setHeader("eventType", simple("ERROR")).setHeader("level", simple("ERROR"))
                .wireTap(auditEndpoint)
                .to("velocity:ca/gov/moh/hsa/esb/service/batch/batchResponsePlaceholder.vm")
            .end();       
    }
}
