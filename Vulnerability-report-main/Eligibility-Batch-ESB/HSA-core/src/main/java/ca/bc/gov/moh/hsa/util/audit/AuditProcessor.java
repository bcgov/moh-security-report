/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.moh.hsa.util.audit;

import ca.bc.gov.moh.hsa.util.SimpleSerializer;
import static ca.bc.gov.moh.hsa.util.audit.TransactionIDAssigner.TRANSACTION_ID_HEADER_KEY;
import ca.bc.gov.moh.hsa.util.audit.entity.AffectedParty;
import ca.bc.gov.moh.hsa.util.audit.entity.EventMessage;
import ca.bc.gov.moh.hsa.util.audit.entity.Transaction;
import ca.bc.gov.moh.hsa.util.audit.entity.TransactionEvent;
import ca.bc.gov.moh.hsa.util.audit.entity.dao.TransactionDAO;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import javax.validation.ConstraintViolation;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.component.bean.validator.BeanValidationException;
import org.apache.commons.lang.StringUtils;
import org.springframework.stereotype.Component;


/**
 * Processor class for auditing events in the Camel flows. Details can be added
 * by implementing the following interfaces on the classes for a Message object:
 *
 * AuditableMessage AuditableResponse AuditableParty
 *
 * @author greg.perkins
 */
@Component
public class AuditProcessor implements Processor {

    public static final String TRANSACTION_HEADER_KEY = "HSA_TRANSACTION";

    public static final String MESSAGE_ID_HEADER_KEY = "messageId";

    private static final String LOGGED_EXCEPTIONS_HEADER_KEY = "LOGGED_EXCEPTIONS";
    
    /**
     * DAO for persisting transactions
     */
    private TransactionDAO dao;
    /**
     * Configuration variables passed in from camel config
     */
    private String eventType = "DEFAULT";
    private String level = "DEFAULT";
    private String status = null;
    private String transactionType = null;
    
    private static final String TRANSACTION_START = "START";
    
    private static final Object lock = new Object();

    /**
     * Default constructor
     */
    public AuditProcessor() {
    }

    /**
     * Constructor
     *
     * @param eventType String
     * @param level String
     * @param status String
     * @param transactionType String
     */
    public AuditProcessor(String eventType, String level, String status, String transactionType) {
        this.eventType = eventType;
        this.level = level;
        this.status = status;
        this.transactionType = transactionType;
    }

    /**
     * Setter for DAO
     *
     * @param dao TransactionDAO
     */
    public void setDao(TransactionDAO dao) {
        this.dao = dao;
    }

    /**
     * Audits the current state of the exchange to the transaction auditing
     * database
     *
     * @param exchange Exchange
     * @throws Exception
     */
    @Override
    public void process(Exchange exchange) throws Exception {

        String serializedTransaction = exchange.getIn().getHeader(TRANSACTION_HEADER_KEY, String.class);
        
        Transaction transaction = null;
        
        if (!StringUtils.isEmpty(serializedTransaction)) {
            try {
            transaction = (Transaction) SimpleSerializer.fromString(serializedTransaction);
            } catch (Exception e) {
                System.out.println("ERROR during Serialization: " + e.getMessage());
                throw e;
            }
        }  else {
            String hostName;
            String transactionID = UUID.randomUUID().toString();            
            exchange.getIn().setHeader(TRANSACTION_ID_HEADER_KEY, transactionID);
            transaction = new Transaction(transactionID);
            
            try {
                hostName = InetAddress.getLocalHost().getHostName();
            } catch (UnknownHostException ex){
                hostName = "unknown";
            } 
            transaction.setServer(hostName);
        }
        level = exchange.getIn().getHeader("level", String.class);
        status = exchange.getIn().getHeader("status", String.class);
        transactionType = exchange.getIn().getHeader("transactionType", String.class);
        eventType = exchange.getIn().getHeader("eventType", String.class);

        if (status != null) {
            transaction.setStatus(status);
        } else {
            transaction.setStatus(eventType);
        }
        if ((eventType != null) && !eventType.equals(TRANSACTION_START)) {
            transaction.setIsNew(false);
        }

        if (transactionType != null) {
            transaction.setType(transactionType);
           
            String messageTypeHeader = (String) exchange.getIn().getHeader(FileDropComponent.TRANSACTION_MESSAGE_TYPE_HEADER_KEY);
            if (StringUtils.isEmpty(messageTypeHeader)) {
                exchange.getIn().setHeader(FileDropComponent.TRANSACTION_MESSAGE_TYPE_HEADER_KEY, transactionType);
            }
        }
             
        String organization;
        String sourceSystem;
        String userId;
        Object body = exchange.getIn().getBody();
            
        TransactionEvent event = new TransactionEvent();
        event.setEventTime(new Date());
        event.setType(eventType);
        String messageId = null;    
        event.setTransactionId(transaction);
        
        if (body instanceof AuditableMessage) {
            messageId = ((AuditableMessage) body).getMessageId();
            
            if (transaction.getOrganization() == null) {
                organization = ((AuditableMessage) body).getSender().getOrganization();
                if (organization != null) {
                    transaction.setOrganization(organization);
                }          
            }
            
            if (transaction.getSourceSystem() == null) {
                sourceSystem = ((AuditableMessage) body).getSender().getSystemName();
                if (sourceSystem != null) {
                    transaction.setSourceSystem(sourceSystem);
                }        
            }   
            if (transaction.getUserId() == null) {              
                if (((AuditableMessage) body).getAuthor() != null) {
                    userId = ((AuditableMessage) body).getAuthor().getUser().getUserId();
                    if (userId != null) {
                        transaction.setUserId(userId);
                    }
                }                                     
            }
            
        } else {
            messageId = exchange.getIn().getHeader(MESSAGE_ID_HEADER_KEY, String.class);
        }
        event.setMessageId(messageId);
       

        Throwable exception = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Throwable.class);

        if (body instanceof AffectedParties) {
            List<AuditableParty> parties = ((AffectedParties) body).getAuditableParties();
            for (AuditableParty party : parties) {
                AffectedParty ap = new AffectedParty();
                ap.setTransactionId(transaction);
                ap.setIdentifierSource(party.getIdentifierSource());
                ap.setIdentifier(party.getIdentifier());
                ap.setIdentifierType(party.getIdentifierType());
                ap.setStatus(party.getStatus());
                if (ap.getIdentifier() != null && !ap.getIdentifier().isEmpty()) {
                    transaction.getAffectedPartyList().add(ap);
                }
            }
        }

        if (body instanceof AuditableResponse) {
            AuditableResponse auditable = (AuditableResponse) body;
            List<AuditableResponseMessage> auditableResponseMessageList = auditable.getAuditableResponseMessageList();
            for (AuditableResponseMessage auditableResponseMessage : auditableResponseMessageList) {
                EventMessage eventMessage = new EventMessage();
                eventMessage.setErrorCode(StringUtils.abbreviate(auditableResponseMessage.getResponseCode(), 50));
                eventMessage.setLevel(level);
                eventMessage.setMessageText(StringUtils.abbreviate(auditableResponseMessage.getResponseText(), 500));
                eventMessage.setTransactionEventId(event);
                if (auditableResponseMessage.getResponseCode()!=null && !auditableResponseMessage.getResponseCode().isEmpty() && 
                    auditableResponseMessage.getResponseText()!=null && !auditableResponseMessage.getResponseText().isEmpty()){
                    event.getEventMessageList().add(eventMessage);
                }
            }

        } 
        
        if (exception != null && !alreadyLogged(exception, exchange)) {

            if (exception.getCause() != null) {
                exception = exception.getCause();
            }

            if (exception instanceof BeanValidationException) {
                Set<ConstraintViolation<Object>> constraintViolations = ((BeanValidationException) exception).getConstraintViolations();
                for (ConstraintViolation<Object> constraintViolation : constraintViolations) {
                    EventMessage eventMessage = new EventMessage();
                    eventMessage.setErrorCode(StringUtils.abbreviate(constraintViolation.getMessageTemplate().replace("{", "").replace("}", ""), 50));
                    eventMessage.setLevel("ERROR");
                    String msg = StringUtils.abbreviate(constraintViolation.getMessage(), 500);
                    eventMessage.setMessageText(msg);
                    eventMessage.setTransactionEventId(event);
                    event.getEventMessageList().add(eventMessage);
                }
            } else {
                EventMessage eventMessage = new EventMessage();
                eventMessage.setErrorCode(StringUtils.abbreviate(exception.getClass().getSimpleName(), 50));
                eventMessage.setLevel("ERROR");
                String msg = StringUtils.abbreviate(exception.getMessage(), 500);
                eventMessage.setMessageText(msg);
                eventMessage.setTransactionEventId(event);
                event.getEventMessageList().add(eventMessage);
            }
            // Need to record the exception once it is logged so it doesn't 
            // hang around on the exchange and get logged with every
            // subsequent event (QC-151)
            // Note: clearing it caused problems with the audit processor
            addToLoggedList(exception, exchange);

        }
        transaction.getTransactionEventList().clear();
        transaction.getTransactionEventList().add(event);
        
        String newSerializedTransaction = SimpleSerializer.toString(transaction);
        exchange.getIn().setHeader(TRANSACTION_HEADER_KEY, newSerializedTransaction);

        try {
            if (transaction.getIsNew()) {
                dao.insert(transaction);
            } else {
                dao.update(transaction);
            }
        
        } catch (Exception e) {
            //Fail fast
            throw e;
        }   
        
        
    }

    private boolean alreadyLogged(Throwable exception, Exchange exchange) {

        Throwable exceptionToTest = exception;
        if (exception.getCause() != null) {
            exceptionToTest = exception.getCause();
        }

        List<Throwable> loggedExceptionList = getLoggedExceptionList(exchange);
        for (Throwable loggedException : loggedExceptionList) {
            if (loggedException == exceptionToTest) {
                return true;
            }
        }
        return false;
    }

    private void addToLoggedList(Throwable exception, Exchange exchange) {
        List<Throwable> loggedExceptionList = getLoggedExceptionList(exchange);
        loggedExceptionList.add(exception);
    }

    private List<Throwable> getLoggedExceptionList(Exchange exchange) {
        List<Throwable> loggedExceptions = (List<Throwable>) exchange.getIn().getHeader(LOGGED_EXCEPTIONS_HEADER_KEY);
        if (loggedExceptions == null) {
            loggedExceptions = new ArrayList<Throwable>();
            exchange.getIn().setHeader(LOGGED_EXCEPTIONS_HEADER_KEY, loggedExceptions);
        }
        return loggedExceptions;
    }

}
