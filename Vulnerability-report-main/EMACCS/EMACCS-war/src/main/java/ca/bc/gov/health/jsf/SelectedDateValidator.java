/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        SelectedDateValidator.java                     *
 * Date of Last Commit: $Date:: 2015-06-22 17:18:37 -0700 (Mon, 22 Jun 2015) $ *
 * Revision Number:      $Rev:: 2540                                         $ *
 * Last Commit by:    $Author:: cmatsond                                     $ *
 *                                                                             *
 *******************************************************************************/

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.jsf;

import jakarta.enterprise.context.RequestScoped;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.component.UIComponent;
import jakarta.faces.component.UIInput;
import jakarta.faces.component.UIOutput;
import jakarta.faces.context.FacesContext;
import jakarta.faces.validator.FacesValidator;
import jakarta.faces.validator.Validator;
import jakarta.faces.validator.ValidatorException;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.io.Serializable;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

/* This validator is used for checking whether or not an activity's end date falls within the currently selected reporting
 * year on the page.
 */
@RequestScoped
@FacesValidator(value = "validator.selectedDate", managed = true)
public class SelectedDateValidator implements Validator, Serializable {

    private static final String CLASS_NAME = SelectedDateValidator.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);

    @Inject
    @Named("ApplicationBean") // Necessary to avoid "WELD-001409: Ambiguous dependencies for type ApplicationBean"
    ApplicationBean appBean;

    @Override
    public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {
        if (!(component instanceof UIInput)) {
            log.log(Level.WARNING, "Validate did not recieve a UIInput component");
            return;
        }
        Date callDate = (Date) value;
        String dateMsg = "Date must fall within the selected reporting year, and must not occur in the future.";
        String yearMsg = "Failed to retrieve the selected reporting year please try again. Contact EMA Licensing if problem persists.";
        String yearConvertMsg = "Failed to convert the selected reporting year. Contact EMA Licensing if problem persists.";

        String componentId = (String) ((UIInput) component).getAttributes().get("reportingYear");
        Long reportingYearId = null;
        try {
            reportingYearId = (Long) ((UIOutput) context.getViewRoot().findComponent(componentId)).getValue();
        } catch (Exception e) {
            log.log(Level.WARNING, "Unable to validate Date in SelectedDateValidator due to: {0} and message: {1}", new Object[]{e.getClass().getSimpleName(), e.getMessage()});
            throwValidatorException(yearMsg);
        }
        Date today = new Date();

        int callDateYear = callDate.getYear() + 1900;
        /* Check if month is January-March; if so, it belongs to the previous calendar year */
        if (callDate.getMonth() < 3) {
            callDateYear--;
        }

        /* We can't directly reference the ReportingYearFacadeLocal from this validator,
         * so moved it to an ApplicationScoped bean */
        String fullReportingYear = appBean.getReportingYearString(reportingYearId);

        /* pull the first four characters of the reporting year to get the initial calendar year */
        int selCalendarYear = 0;
        try {
            selCalendarYear = Integer.parseInt(fullReportingYear.substring(0, 4));
        } catch (Exception e) {
            log.log(Level.WARNING, "Unable to convert Date in SelectedDateValidator due to: {0} and message: {1}", new Object[]{e.getClass().getSimpleName(), e.getMessage()});
            throwValidatorException(yearConvertMsg);
        }
        // we can compare callDateYear to the first 4 digits of calendarYear because we've subtracted 1 if callDateYear occurs before March 31, so it always matches the first half of the fraction
        if (selCalendarYear == 0 || callDate.after(today) || callDateYear != selCalendarYear) {
            log.log(Level.WARNING, "Calendar something");
            throwValidatorException(dateMsg);
        }
    }

    private void throwValidatorException(String msg) throws ValidatorException {

        FacesMessage message = new FacesMessage(msg);
        message.setSeverity(FacesMessage.SEVERITY_ERROR);
        throw new ValidatorException(message);
    }
}
