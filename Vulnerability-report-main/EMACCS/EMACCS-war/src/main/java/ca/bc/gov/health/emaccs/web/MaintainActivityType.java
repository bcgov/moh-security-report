/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        MaintainActivityType.java                      *
 * Date of Last Commit: $Date:: 2016-12-19 10:04:18 -0800 (Mon, 19 Dec 2016) $ *
 * Revision Number:      $Rev:: 2669                                         $ *
 * Last Commit by:    $Author:: tschiavo                                     $ *
 *                                                                             *
 *******************************************************************************/
package ca.bc.gov.health.emaccs.web;

import ca.bc.gov.health.ejb.exception.FacadeException;
import ca.bc.gov.health.emaccs.ejb.entity.ActivityNocpArea;
import ca.bc.gov.health.emaccs.ejb.entity.ActivityNocpCompSubtype;
import ca.bc.gov.health.emaccs.ejb.entity.ActivityNocpCompType;
import ca.bc.gov.health.emaccs.ejb.entity.ActivityType;
import ca.bc.gov.health.emaccs.ejb.entity.NocpArea;
import ca.bc.gov.health.emaccs.ejb.entity.NocpCompetencySubtype;
import ca.bc.gov.health.emaccs.ejb.entity.NocpCompetencyType;
import ca.bc.gov.health.emaccs.ejb.session.ActivityTypeFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.ApprovedActivityFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.EmaccsApplicationVariablesFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.NocpAreaFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.NocpCompetencySubtypeFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.NocpCompetencyTypeFacadeLocal;
import ca.bc.gov.health.jsf.ApplicationBean;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.primefaces.PrimeFaces;
import org.primefaces.model.DualListModel;

/**
 * Backing bean for ActivityType code table maintenance
 */
@ViewScoped
@Named("MaintainActivityType")
public class MaintainActivityType extends ApplicationBean implements java.io.Serializable {

    private static final long serialVersionUID = 1L;
    private static final String CLASS_NAME = MaintainActivityType.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);
    /*
     * Facade for persistence
     */
    @EJB
    private ActivityTypeFacadeLocal activityTypeFacade;

    @EJB
    private EmaccsApplicationVariablesFacadeLocal emaccsApplicationVariablesFacade;
    @EJB
    private NocpAreaFacadeLocal nocpAreaFacade;
    @EJB
    private NocpCompetencySubtypeFacadeLocal nocpCompetencySubtypeFacade;
    @EJB
    private NocpCompetencyTypeFacadeLocal nocpCompetencyTypeFacade;
    @EJB
    private ApprovedActivityFacadeLocal approvedActivityFacade;

    /*
     * List of all values in the code table
     */
    private List<ActivityType> allActivityTypes;

    /*
     * The instance we're currently editing
     */
    private ActivityType activityType;
    /**
     * Lists of selected rows for the picklist controls
     */
    private List<NocpArea> allAreas;
    private List<NocpCompetencyType> allTypes;
    private List<NocpCompetencySubtype> allSourceSubtypes;

    private List<NocpArea> sourceAreas;
    private List<NocpCompetencyType> sourceTypes;
    private List<NocpCompetencySubtype> sourceSubtypes;

    private List<NocpArea> selectedAreas;
    private List<NocpCompetencyType> selectedTypes;
    private List<NocpCompetencySubtype> selectedSubtypes;

    private DualListModel<NocpArea> picklistAreas;
    private DualListModel<NocpCompetencyType> picklistCompetencyType;
    private DualListModel<NocpCompetencySubtype> picklistCompetencySubtype;

    // Credit value change for listener
    private BigDecimal oldCreditValue = null;

    /**
     * Initializes this bean after injection
     */
    @PostConstruct
    public void init() {
        allActivityTypes = activityTypeFacade.findAll();
        setupNewActivityType();
        //needed to blank out the lists associated with an entry
        allAreas = nocpAreaFacade.findAll();
        allTypes = nocpCompetencyTypeFacade.findAll();
        allSourceSubtypes = nocpCompetencySubtypeFacade.findAll();
        initSelectLists();
    }

    public void initSelectLists() {

        //Setup areas
        selectedAreas = new ArrayList<>();
        sourceAreas = new ArrayList<>(allAreas);

        if (activityType.getActivityNocpAreaList() == null || activityType.getActivityNocpAreaList().isEmpty()) {
            activityType.setActivityNocpAreaList(new ArrayList());
        } else {
            for (ActivityNocpArea area : activityType.getActivityNocpAreaList()) {
                selectedAreas.add(area.getNocpAreaId());
                sourceAreas.remove(area.getNocpAreaId());
            }
        }

        //Setup Competency Types
        selectedTypes = new ArrayList<>();
        sourceTypes = new ArrayList<>(allTypes);

        if (activityType.getActivityNocpCompTypeList() == null) {
            activityType.setActivityNocpCompTypeList(new ArrayList());
        } else {
            for (ActivityNocpCompType compType : activityType.getActivityNocpCompTypeList()) {
                selectedTypes.add(compType.getNocpCompTypeId());
                sourceTypes.remove(compType.getNocpCompTypeId());
            }
        }

        //Setup Competency SubTypes
        selectedSubtypes = new ArrayList<>();
        sourceSubtypes = new ArrayList<>(allSourceSubtypes);

        if (activityType.getActivityNocpCompSubtypeList() == null) {
            activityType.setActivityNocpCompSubtypeList(new ArrayList());
        } else {
            for (ActivityNocpCompSubtype compSubType : activityType.getActivityNocpCompSubtypeList()) {
                selectedSubtypes.add(compSubType.getNocpCompSubtypeId());
                sourceSubtypes.remove(compSubType.getNocpCompSubtypeId());
            }
        }

        picklistAreas = new DualListModel<>(sourceAreas, selectedAreas);
        picklistCompetencyType = new DualListModel<>(sourceTypes, selectedTypes);
        picklistCompetencySubtype = new DualListModel<>(sourceSubtypes, selectedSubtypes);
    }

    private void setupNewActivityType() {
        activityType = new ActivityType();
        // This ID is temporary, and is used to compare  objects
        activityType.setActivityNocpAreaList(new ArrayList());
        activityType.setActivityNocpCompTypeList(new ArrayList());
        activityType.setActivityNocpCompSubtypeList(new ArrayList());
    }

    /**
     * Adds a new record
     */
    public String add() {

        for (NocpArea selectedArea : picklistAreas.getTarget()) {
            ActivityNocpArea ana = new ActivityNocpArea();
            ana.setNocpAreaId(new NocpArea(selectedArea.getId()));
            ana.setActivityTypeId(activityType);
            activityType.getActivityNocpAreaList().add(ana);
        }
        for (NocpCompetencyType selectedType : picklistCompetencyType.getTarget()) {
            ActivityNocpCompType anct = new ActivityNocpCompType();
            anct.setNocpCompTypeId(new NocpCompetencyType(selectedType.getId()));
            anct.setActivityTypeId(activityType);
            activityType.getActivityNocpCompTypeList().add(anct);
        }
        for (NocpCompetencySubtype selectedSubtype : picklistCompetencySubtype.getTarget()) {
            ActivityNocpCompSubtype anct = new ActivityNocpCompSubtype();
            anct.setNocpCompSubtypeId(new NocpCompetencySubtype(selectedSubtype.getId()));
            anct.setActivityTypeId(activityType);
            activityType.getActivityNocpCompSubtypeList().add(anct);
        }

        try {
            activityTypeFacade.create(activityType);
            allActivityTypes.add(0, activityType);
            addInfoMessage("Add Successful");
            emaccsApplicationVariablesFacade.clearActivityNames();
        } catch (FacadeException e) {
            if (e.getExceptionClass() != null && e.getExceptionClass().getSimpleName().equals("PersistenceException")) {
                Throwable innerCause = e.getException().getCause();
                addErrorMessage("Error encountered during add:");
                addErrorMessage(" Check that the entry does not already exist");
                if (innerCause != null && innerCause.getClass().getSimpleName().equals("DatabaseException")) {
                    addErrorMessage(" Verify all chosen data values");
                }
                addErrorMessage(" or try again by leaving the page and returning");
            } else {
                addErrorMessage("Error encountered during add. Cannot add record with name" + activityType.getActivityName());
            }
        } catch (Exception e) {
            addErrorMessage("Error encountered. Cannot add record with name" + activityType.getActivityName());
            log.log(Level.WARNING, "Unable to add record {0}", e.getMessage());
        }
        droplists.initActivityTypes();
        droplists.initEnabledActivityTypes();
        return clear();
    }

    /**
     * Updates an existing record
     */
    public String update() {

        //Clear out child lists
        activityType.getActivityNocpAreaList().clear();
        activityType.getActivityNocpCompTypeList().clear();
        activityType.getActivityNocpCompSubtypeList().clear();

        //TODO - examane what's happening here. something is fishy.
        //Add new child records
        for (NocpArea selectedArea : picklistAreas.getTarget()) {
            ActivityNocpArea ana = new ActivityNocpArea();
            ana.setNocpAreaId(new NocpArea(selectedArea.getId()));
            ana.setActivityTypeId(activityType);

            activityType.getActivityNocpAreaList().add(ana);
        }
        for (NocpCompetencyType selectedType : picklistCompetencyType.getTarget()) {
            ActivityNocpCompType anct = new ActivityNocpCompType();
            anct.setNocpCompTypeId(new NocpCompetencyType(selectedType.getId()));
            anct.setActivityTypeId(activityType);

            activityType.getActivityNocpCompTypeList().add(anct);
        }
        for (NocpCompetencySubtype selectedSubtype : picklistCompetencySubtype.getTarget()) {
            ActivityNocpCompSubtype anct = new ActivityNocpCompSubtype();
            anct.setNocpCompSubtypeId(new NocpCompetencySubtype(selectedSubtype.getId()));
            anct.setActivityTypeId(activityType);

            activityType.getActivityNocpCompSubtypeList().add(anct);
        }
        ActivityType replacement = null;
        try {
            replacement = activityTypeFacade.edit(activityType);
            
            // Credit change to a value different that the old one.
            // Update EMA requirement to their newest status based on the new value.
            if (oldCreditValue.compareTo(activityType.getDefaultCredits()) != 0) {
                List<Long> emaIdList = approvedActivityFacade.updatedAffectedActivitiesForCurrentYear(activityType.getId(),activityType.getDefaultCredits());
                approvedActivityFacade.updateAffectedEMAStatusForCurrentYear(activityType.getId(),emaIdList);
            }
            
            addInfoMessage("Update Successful");
            emaccsApplicationVariablesFacade.clearActivityNames();
        } catch (FacadeException e) {
            if (e.getException().getClass().getSimpleName().equals("OptimisticLockException")) {
                addErrorMessage("Update Failed. Please leave the page and return.");
            } else {
                addErrorMessage("Update Failed. ");
            }
            log.log(Level.WARNING, "Error editing Activity type - Log message above");
        }

        if (replacement != null) {
            try {
                int index = allActivityTypes.indexOf(activityType);
                try {
                    allActivityTypes.set(index, replacement);
                } catch (Exception e) {
                    log.log(Level.SEVERE, "Unable to replace updated record: {0}", e.getMessage());
                    init();
                }
            } catch (Exception e) {
                log.log(Level.SEVERE, "Unable to replace updated record: {0}", e.getMessage());
            }
        }
        droplists.initActivityTypes();
        droplists.initEnabledActivityTypes();
        return clear();
    }

    public boolean isCreditsChangeAndLower() {
        if (activityType.getDefaultCredits() == null) {
            return false;
        }
        return oldCreditValue.compareTo(activityType.getDefaultCredits()) == 1;
    }

    public void handleValueChange() {
        PrimeFaces.current().ajax().update("form1");
    }

    /**
     * Deletes a record
     */
    public void delete() {
        try {
            activityTypeFacade.remove(activityType);

            boolean worked = allActivityTypes.remove(activityType);
            if (!worked) {
                init();
            }
            addInfoMessage("Remove Successful");
            emaccsApplicationVariablesFacade.clearActivityNames();
        } catch (Exception e) {
            addInfoMessage("Remove Failed");
            addErrorMessage("Error encountered. Cannot delete record with code " + activityType.getActivityCode() + " and name:" + activityType.getActivityName());
            log.log(Level.WARNING, "Unable to delete record {0}", e.getMessage());
        }
        clear();
    }

    public void disabledCheck(ActivityType actType) {
        ActivityType replacement = null;
        try {
            replacement = activityTypeFacade.edit(actType);
            if (actType.getDisabledBool()) {
                addInfoMessage("Activity " + actType.getActivityCode() + " disabled");
            } else if (!actType.getDisabledBool()) {
                addInfoMessage("Activity " + actType.getActivityCode() + " enabled");
            }
        } catch (Exception e) {
            addErrorMessage("Error encountered. Cannot modify record with code " + actType.getActivityCode());
            log.log(Level.WARNING, "Unable to modify record {0}", e.getMessage());
        }
        if (replacement != null) {
            try {
                int index = allActivityTypes.indexOf(actType);
                try {
                    allActivityTypes.set(index, replacement);
                } catch (Exception e) {
                    log.log(Level.SEVERE, "Unable to replace updated record: {0}", e.getMessage());
                    init();
                }
            } catch (Exception e) {
                log.log(Level.SEVERE, "Unable to replace updated record: {0}", e.getMessage());
            }
        }
        droplists.initEnabledActivityTypes();
    }

    /**
     * Clears the form
     */
    public String clear() {
        setupNewActivityType();
        initSelectLists();
        return null;
    }

    /**
     * Selects a record for editing
     */
    public void select() {
        initSelectLists();
        oldCreditValue = activityType.getDefaultCredits();
    }

    /*
     * Getters and Setters
     */
    public List<ActivityType> getAllActivityTypes() {
        return allActivityTypes;
    }

    public void setAllActivityTypes(List<ActivityType> allActivityTypes) {
        this.allActivityTypes = allActivityTypes;
    }

    public ActivityType getActivityType() {
        return activityType;
    }

    public void setActivityType(ActivityType activityType) {
        this.activityType = activityType;
    }

    public DualListModel<NocpArea> getPicklistAreas() {
        return picklistAreas;
    }

    public void setPicklistAreas(DualListModel<NocpArea> picklistAreas) {
        this.picklistAreas = picklistAreas;
    }

    public DualListModel<NocpCompetencyType> getPicklistCompetencyType() {
        return picklistCompetencyType;
    }

    public void setPicklistCompetencyType(DualListModel<NocpCompetencyType> picklistCompetencyType) {
        this.picklistCompetencyType = picklistCompetencyType;
    }

    public DualListModel<NocpCompetencySubtype> getPicklistCompetencySubtype() {
        return picklistCompetencySubtype;
    }

    public void setPicklistCompetencySubtype(DualListModel<NocpCompetencySubtype> picklistCompetencySubtype) {
        this.picklistCompetencySubtype = picklistCompetencySubtype;
    }
   
}
