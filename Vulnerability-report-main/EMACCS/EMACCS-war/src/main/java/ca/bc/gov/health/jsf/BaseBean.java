/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        BaseBean.java                                  *
 * Date of Last Commit: $Date:: 2015-06-22 17:18:37 -0700 (Mon, 22 Jun 2015) $ *
 * Revision Number:      $Rev:: 2540                                         $ *
 * Last Commit by:    $Author:: cmatsond                                     $ *
 *                                                                             *
 *******************************************************************************/

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.jsf;

import ca.bc.gov.health.emaccs.ejb.entity.ReportingYear;
import ca.bc.gov.health.emaccs.ejb.session.ReportingYearFacadeLocal;
import jakarta.ejb.EJB;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.application.FacesMessage.Severity;
import jakarta.faces.component.UIComponent;
import jakarta.faces.component.UIInput;
import jakarta.faces.context.FacesContext;
import jakarta.servlet.http.HttpServletRequest;
import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.naming.InitialContext;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;


/**
 * Base class for JSF backing beans
 * @author greg.perkins
 */
public class BaseBean implements Serializable{
    private static final String CLASS_NAME = BaseBean.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);
    @EJB
    private ReportingYearFacadeLocal reportingYearFacade;

    protected static final String dateFormat = "yyyy/MM/dd";
    protected static final String dateTimeFormat = "yyyy/MM/dd HH:mm";
    ThreadLocal<SimpleDateFormat> q;
    //private final SimpleDateFormat dateFormater = new SimpleDateFormat(dateFormat);
    //private final SimpleDateFormat dateTimeFormater = new SimpleDateFormat(dateTimeFormat);
    
    // SimpleDateFormat is not thread-safe, so give one to each thread
    private static final ThreadLocal<SimpleDateFormat> dateFormater = new ThreadLocal<SimpleDateFormat>(){
        @Override
        protected SimpleDateFormat initialValue()
        {
            return new SimpleDateFormat(dateFormat);
        }
    };
    
    // SimpleDateFormat is not thread-safe, so give one to each thread
    private static final ThreadLocal<SimpleDateFormat> dateTimeFormater = new ThreadLocal<SimpleDateFormat>(){
        @Override
        protected SimpleDateFormat initialValue()
        {
            return new SimpleDateFormat(dateTimeFormat);
        }
    };
    

    public void addErrorMessage(String msg) {
        addMessage(msg, FacesMessage.SEVERITY_ERROR);
    }

    public void addInfoMessage(String msg) {
        addMessage(msg, FacesMessage.SEVERITY_INFO);
    }
    
    public void addWarningMessage(String msg) {
        addMessage(msg, FacesMessage.SEVERITY_WARN);
    }

    private void addMessage(String msg, Severity severity) {
        FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(severity, msg, msg));
    }
    
    public void resetComponent(String componentId) {
        UIComponent form = (UIComponent) FacesContext.getCurrentInstance().getViewRoot().findComponent(componentId);
        resetComponent(form);
    }

    public void resetComponent(UIComponent form) {
        for (UIComponent uic : form.getChildren()) {
            if (uic instanceof UIInput) {
                UIInput evh = (UIInput) uic;
                evh.resetValue();
            }
            resetComponent(uic);
        }
    }

    // used to properly format phone numbers
    public String stripPhoneNumber(String phoneNumber) {
        String strippedNumber;
        if (phoneNumber.replaceAll("[^\\d]", "").length() > 10) {
            // international, must be prefixed with a +
            // digits, dashes, spaces allowed
            // \d \- \s
            strippedNumber = "+" + phoneNumber.replaceAll("[^\\d\\-\\s]", "");
        } else {
            // national numbers
            // digits, x for extension, dashes, brackets, and spaces allowed
            // \d x X \- \( \) \s
            strippedNumber = phoneNumber.replaceAll("[^\\dxX\\-\\(\\)\\s]", "");
        }
        return strippedNumber;
    }
    
    private SimpleDateFormat reportyearDateFormat = new SimpleDateFormat("yyyy/MM/dd K:mm:ss");
    public Date getReportYearStartDate(Long reportingYearId){
        int year = Integer.parseInt(getReportingYearById(reportingYearId).substring(0,4));
        Date theStart = null;
        try{
                theStart =reportyearDateFormat.parse(year + "/04/01 0:00:00");
        }catch(Exception e){
                log.log(Level.SEVERE, "Date parse failed in getting start date");
        }
        return theStart;
    }
     public Date getReportYearEndDate(Long reportingYearId){
        int year = Integer.parseInt(getReportingYearById(reportingYearId).substring(0,4));
        Date theEnd = null;
        try{
                theEnd =reportyearDateFormat.parse((year + 1) + "/03/31 23:59:59");
        }catch(Exception e){
                log.log(Level.SEVERE, "Date parse failed in getting end date");
        }
        return theEnd;
    }    

  /***
   * 
   * @param reportingYearDte - the year of the reporting year to find e.g ####/reportingYearDte or reportingYearDte/####
   * @return the ID of the reporting year found or null
   */
     //TODO move to the facade?
  public Long getReportingYearId(Date reportingYearDte) {
        int year = reportingYearDte.getYear() + 1900;
        String strYear = String.valueOf(year);

        if (reportingYearDte.getMonth() < 3) {
            strYear = String.valueOf(year-1) + "/" + strYear;
        } else {
            strYear = strYear + "/" + String.valueOf(year+1);
        }
        return getReportingYearId(strYear);
    }
    
    /***
     * 
     * @param reportingYearStr - the reporting year string ####/#### to find a reporting year by
     * @return the ID of the reporting year found or null
     */
    //TODO move to the facade?
    private Long getReportingYearId(String reportingYearStr) {
        ReportingYear query = new ReportingYear();
        query.setReportingYear(reportingYearStr);
        List<ReportingYear> results = reportingYearFacade.search(query);
        if (!results.isEmpty()) {
            return results.get(0).getId();
        } else {
            return null;
        }
    }

    /*
     * Returns the String value of a reporting year, based on the reportingYearId
     */
    //TODO move to the facade
    public String getReportingYearById(Long reportingYearId) {
        ReportingYear query = reportingYearFacade.find(reportingYearId);
        return query.getReportingYear();
    }

    //DO NOT USE WITH - <f:convertDateTime in anything view scoped. use the converters instead
    public String getDateFormat() {
        return dateFormat;
    }
//DO NOT USE WITH - <f:convertDateTime in anything view scoped. use the converters instead
    public String getDateTimeFormat() {
        return dateTimeFormat;
    }

    // return todays date, without the timestamp
    public Date getTodaysDate() {
        Calendar cal = Calendar.getInstance();
        Date today = new Date();
        cal.set(today.getYear() + 1900, today.getMonth(), today.getDate(), 0, 0, 0);
        return cal.getTime();
    }

    /**
     * Returns an LDAP context
     * @param request HttpServletRequest
     * @return DirContext
     * @throws Exception
     */
    //TODO - removable?
    @Deprecated
    public static DirContext getDirContext(HttpServletRequest request) throws Exception {
        String jndiPath = request.getSession().getServletContext().getInitParameter("ldap_jndi_name");
        Object props = new InitialContext().lookup(jndiPath);
        Hashtable env = (Hashtable) props;

        // Create the initial context
        DirContext ctx = new InitialDirContext(env);

        return ctx;
    }

     /*
     * Pull a reporting year string based on an ID value
     */
        //TODO move to the facade
    public String getReportingYearString(Long reportingYearId) {
        if(reportingYearId == null){
            return "";
        }
        ReportingYear query = reportingYearFacade.find(reportingYearId);
        return query.getReportingYear();
    }  
      
    protected boolean selectedYearEditable(boolean userIsEma, boolean ccExempt,boolean shortfall, boolean pendingAdj, boolean adjPeriod,boolean shortPeriod, Long reportingYearId){
        if (userIsEma) {
            if(ccExempt){
                return false;
            }if (shortfall && shortPeriod) {
            // if current year and shortfall, then editable
                return true;
            } else if (pendingAdj && adjPeriod) {
            // if previous year and pending adjudication, then editable
                return true;
            } else {
            // else, not editable
                return false;
            }
        } else {
            // only EMA users have business logic
            return true;
        }
    }
    public String getAsDateTimeString(Date inDate) {
        if(inDate==null){
            return "";
        }
        return dateTimeFormater.get().format(inDate).toUpperCase();
    }
    public String getAsBasicDateString(Date inDate) {
            if(inDate==null){
                return "";
            }
            return dateFormater.get().format(inDate).toUpperCase();
    }
 
}
