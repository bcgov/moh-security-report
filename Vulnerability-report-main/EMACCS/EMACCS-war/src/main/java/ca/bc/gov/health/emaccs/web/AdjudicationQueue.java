/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        AdjudicationQueue.java                         *
 * Date of Last Commit: $Date:: 2015-06-22 17:18:37 -0700 (Mon, 22 Jun 2015) $ *
 * Revision Number:      $Rev:: 2540                                         $ *
 * Last Commit by:    $Author:: cmatsond                                     $ *
 *                                                                             *
 *******************************************************************************/
package ca.bc.gov.health.emaccs.web;

import ca.bc.gov.health.emaccs.ejb.entity.EmergencyMedicalAssistant;
import ca.bc.gov.health.emaccs.ejb.entity.LicenceMaintenance;
import ca.bc.gov.health.emaccs.ejb.entity.Lkadjstatus;
import ca.bc.gov.health.emaccs.ejb.entity.Lkcmedat;
import ca.bc.gov.health.emaccs.ejb.entity.Lkexamtype;
import ca.bc.gov.health.emaccs.ejb.entity.ReportingYear;
import ca.bc.gov.health.emaccs.ejb.session.LicenceMaintenanceFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.LkadjstatusFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.LkcmedatFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.LkexamtypeFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.ReportingYearFacadeLocal;
import ca.bc.gov.health.jsf.ApplicationBean;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.event.ValueChangeEvent;
import jakarta.faces.model.SelectItem;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;
import java.io.Serializable;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * Backing bean to assist in searching for EMAs who have requested adjudication and marked their
 * submission as complete for a specific reporting period
 *
 * @author dan.stepanov
 */
@ViewScoped
@Named("AdjudicationQueue")
public class AdjudicationQueue extends ApplicationBean implements Serializable {

    private static final long serialVersionUID = 1L;
    /**
     * Session bean to perform search
     */
    @EJB
    private LicenceMaintenanceFacadeLocal paramsLicenceFacade;
    @EJB
    private LkadjstatusFacadeLocal lkAdjstatusFacade;
    @EJB
    private LkexamtypeFacadeLocal lkExamtypeFacade;
    @EJB
    private LkcmedatFacadeLocal lkCmedatFacade;
    @EJB
    private ReportingYearFacadeLocal reportingYearFacade;
    /**
     * Search results
     */
    private List<LicenceMaintenance> resultsLicence;
    /**
     * Template object for search criteria for licence
     */
    private LicenceMaintenance paramsLicenceMaintenance = new LicenceMaintenance();
    /*
     * PK of the selected instance
     */
    private Integer selectedKey;

    private List<SelectItem> usersList;
    private List<SelectItem> lkcmedats;
    private List<SelectItem> lkexamtype;
    private List<SelectItem> lkadjstatus;

    /**
     * Default constructor
     */
    public AdjudicationQueue() {
    }

    /**
     * Initializes this bean after injection is complete
     */
    @PostConstruct
    public void init() {
        setUp();
        buildLkcemedatsList();
        search();
    }

    private void setUp() {
        paramsLicenceMaintenance = new LicenceMaintenance();
        paramsLicenceMaintenance.setRegisId(new EmergencyMedicalAssistant());
        resultsLicence = new ArrayList();

        //TODO: Default reporting year to current year if not set
        //TODO investigate why todo above says current whenthis has always used previous
        if (paramsLicenceMaintenance.getReportyr() == null) {
            paramsLicenceMaintenance.setReportyr(new ReportingYear(reportingYearFacade.getCurrentReportingYear().getId()));
        }
    }
    
    private void buildLkcemedatsList() {
      
        List<SelectItem> tempLkcmedats = droplists.getLkCmedats();
        
        lkcmedats = new ArrayList();
        for (SelectItem anItem : tempLkcmedats) {
            String label = (String) anItem.getValue();
            String lowerLabel = label.toLowerCase();
            switch (lowerLabel) {
                case "t307": //PENDING ADJUDICATION
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "Pending Adj."));
                    break;
                case "t300": //EXEMPT
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "Exempt"));
                    break;
                case "t301": //IN SHORTFALL
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "Shortfall"));
                    break;
                case "t302": //IN SHORTFALL - ADJUDICATED
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "Shortfall - Adj."));
                    break;
                case "t303": //REQUIREMENTS MET
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "Req. Met"));
                    break;
                case "t304": //REQUIREMENTS MET - CC TRANSFER
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "Req. Met - CC Trans."));
                    break;
                case "t305": //REQUIREMENTS MET - ADJUDICATED
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "Req. Met - Adj."));
                    break;
                case "t306": //REQUIREMENTS MET - EXAM
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "Req. Met - Exam."));
                    break;
                case "t200": //CME Complete
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "CME Complete.", "Unused", true));
                    break;
                case "t210": //CME Exempt
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "CME Exempt.", "Unused", true));
                    break;
                case "t201": //2010/2011 - LM Adjudication
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), " 2010/11 LM Adj.", "Unused", true));
                    break;
                case "t202": //2010 IV Adjudication
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "2010 IV Adj.", "Unused", true));
                    break;
                case "t203": //LM - Assessed competence
                    lkcmedats.add(new SelectItem((String) anItem.getValue(), "LM-Assessed Comp.", "Unused", true));
                    break;
                default:
                    lkcmedats.add(new SelectItem(anItem.getLabel(), (String) anItem.getValue()));
                    break;
            }
        }
    }
 

    /**
     * Clears the state of this bean
     */
    public void clear() {
        setUp();
        resetComponent("form1");
    }

    /**
     * Perform search
     */
    public String search() {
        LicenceMaintenance paramSearch = new LicenceMaintenance();

        paramSearch.setReportyr(paramsLicenceMaintenance.getReportyr());
        paramSearch.setLicno(paramsLicenceMaintenance.getLicno());
        paramSearch.setAssignedToUsername(paramsLicenceMaintenance.getAssignedToUsername());

        EmergencyMedicalAssistant ema = paramsLicenceMaintenance.getRegisId();
        ema.setFname(paramsLicenceMaintenance.getRegisId().getFname());
        ema.setLname(paramsLicenceMaintenance.getRegisId().getLname());
        paramSearch.setRegisId(ema);

        // When updating multiple items from a list, new objects have to be created for foreign keys, else
        // the application will consider same types as same objects
//        resultsLicence = paramsLicenceFacade.searchParamsForm(paramSearch);
        resultsLicence = paramsLicenceFacade.adjudicationSearch(paramSearch);
        //resultsLicence = paramsLicenceFacade.search(paramsLicenceMaintenance);
        for (LicenceMaintenance oRow : resultsLicence) {
            LicenceMaintenance lmRow = (LicenceMaintenance) oRow;
            Lkcmedat ccode;
            Lkadjstatus directorApproval;
            Lkadjstatus lastDirectorApproval;
            Lkexamtype examRecommendation;
            //TODO - is it smart to set it to shortfall when it's not in the db or does it hide as an update? would still need a save to fix. not sure if in shortfall is best
            ccode = lmRow.getCcode() != null
                ? new Lkcmedat(lmRow.getCcode().getCcode())
                : new Lkcmedat(lkCmedatFacade.getCcode("IN SHORTFALL"));

            directorApproval = lmRow.getDirectorApproval() != null
                ? lkAdjstatusFacade.find(lmRow.getDirectorApproval().getId())
                : new Lkadjstatus(1L);

            lastDirectorApproval = lmRow.getLastDirectorApproval() != null
                ? lkAdjstatusFacade.find(lmRow.getLastDirectorApproval().getId())
                : new Lkadjstatus(1L);

            examRecommendation = lmRow.getExamRecommendation() != null
                ? lkExamtypeFacade.find(lmRow.getExamRecommendation().getId())
                : new Lkexamtype(1L);

            lmRow.setCcode(ccode);
            lmRow.setDirectorApproval(directorApproval);
            lmRow.setLastDirectorApproval(lastDirectorApproval);
            lmRow.setExamRecommendation(examRecommendation);
        }

        return null;
    }

    /**
     * Selects a record for editing
     */
    public String select() {
        // handle screen navigation based on the search results
        if (!resultsLicence.isEmpty()) {
            return "MyContinuingCompetence.xhtml";
        }
        return null;
    }

    /**
     * Selects licence and navigates to evaluate other activity screen for editing
     */
    public String selectOtherActivity() {
        // handle screen navigation based on the search results
        if (!resultsLicence.isEmpty()) {
            return "EvaluateOtherActivities.xhtml";
        }
        return null;
    }

    public void changeReportingYear(ValueChangeEvent event) {
        init();
        LicenceMaintenance paramRepYearSearch = new LicenceMaintenance();
        paramRepYearSearch.setReportyr(new ReportingYear((Long) event.getNewValue()));
    }

    /**
     * Updates an existing licence record with EMAs status and assign to username values
     */
    public String save() throws ParseException {
        ArrayList<String> allErrors = new ArrayList<>();
        int countProcessed = 0;
        // check if there are licences in the results
        if (!resultsLicence.isEmpty()) {
            for (LicenceMaintenance row : resultsLicence) {
                // select the licence to be updated
                LicenceMaintenance origLm = paramsLicenceFacade.find(row.getCmedatId());

                if (origLm.getLastEmaStatus() == null || origLm.getLastEmaStatus().getCcode() == null) {
                    origLm.setLastEmaStatus(new Lkcmedat());
                    origLm.getLastEmaStatus().setCcode("null");
                }

                // If a director is updating...
                if (user.getUserRole().equals("DIRECTOR")) {

                    /*
 * If the new Director Approval is not empty and
 * does not match the old Director Approval
                     */
                    if (!row.getDirectorApproval().getAddesc().isEmpty()
                        && !origLm.getDirectorApproval().getId().equals(row.getDirectorApproval().getId())) {

                        row.setLastDirectorApproval(origLm.getDirectorApproval());
                        row.setLastDirectorApprovalDate(new Date());
                        row.setLastEmaStatus(origLm.getCcode());
                    }

                }

                if (row.getCcode() != null && row.getCcode().getCcode() != null) {
                    // check to see if the status changed
                    if (!origLm.getLastEmaStatus().getCcode().equals(row.getCcode().getCcode())) {
                        row.setCmedate(super.getTodaysDate());
                        row.setStatusDate(row.getCmedate());
                    }
                    row.setCcode(new Lkcmedat(row.getCcode().getCcode()));
                } else {
                    row.setCcode(null);
                }

                if (row.getExamRecommendation() != null && row.getExamRecommendation().getId() != null) {
                    row.setExamRecommendation(new Lkexamtype(row.getExamRecommendation().getId()));
                } else {
                    row.setExamRecommendation(new Lkexamtype(1L));
                }

                if (row.getDirectorApproval() != null && row.getDirectorApproval().getId() != null) {
                    row.setDirectorApproval(new Lkadjstatus(row.getDirectorApproval().getId()));
                } else {
                    row.setDirectorApproval(new Lkadjstatus(1L));
                }
                try {
                    paramsLicenceFacade.edit(row);
                    countProcessed++;
                } catch (Exception e) {
                    allErrors.add("Change of '" + row.getLicno() + " " + row.getAssignedToUsername() + " failed");
                }
            }

        }
        if (allErrors.isEmpty()) {
            addInfoMessage("Save Successful");
        } else if (allErrors.size() == resultsLicence.size()) {
            addErrorMessage("Update Failed");
        } else {
            addInfoMessage("Update encountered problems " + allErrors.size() + "/" + resultsLicence.size() + "update(s) failed");
            for (String error : allErrors) {
                addErrorMessage(error);
            }
        }

        init();

        return null;
    }

    /**
     * Cancel button will reload the contents of the list with the current information from the
     * database
     */
    public String cancel() {
        init();
        return null;
    }

    /*
     * Getters and Setters
     */
    public LicenceMaintenance getParamsLicenceMaintenance() {
        return paramsLicenceMaintenance;
    }

    public void setParamsLicenceMaintenance(LicenceMaintenance paramsLicenceMaintenance) {
        this.paramsLicenceMaintenance = paramsLicenceMaintenance;
    }

    public List<LicenceMaintenance> getResultsLicence() {
        return resultsLicence;
    }

    public Integer getSelectedKey() {
        return selectedKey;
    }

    public void setSelectedKey(Integer selectedKey) {
        this.selectedKey = selectedKey;
    }

    public List<SelectItem> getLkadjstatus() {
        if (lkadjstatus == null || lkadjstatus.isEmpty()) {
            lkadjstatus = droplists.getLkAdjstatus();
        }
        return lkadjstatus;
    }

    public void setLkadjstatus(List<SelectItem> lkadjstatus) {
        this.lkadjstatus = lkadjstatus;
    }


    public List<SelectItem> getLkcmedats() {
      return lkcmedats;
    }

    public List<SelectItem> getLkexamtype() {
        if (lkexamtype == null || lkexamtype.isEmpty()) {
            lkexamtype = droplists.getLkExamType();
        }
        return lkexamtype;
    }

    public void setLkexamtype(List<SelectItem> lkexamtype) {
        this.lkexamtype = lkexamtype;
    }

    public List<SelectItem> getUsers() {
        if (usersList == null || usersList.isEmpty()) {
            usersList = droplists.getUsers();
        }
        return usersList;
    }

    public void setUsersList(List<SelectItem> usersList) {
        this.usersList = usersList;
    }

}
