/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        MyContinuingCompetence.java                    *
 * Date of Last Commit: $Date:: 2015-06-22 17:18:37 -0700 (Mon, 22 Jun 2015) $ *
 * Revision Number:      $Rev:: 2540                                         $ *
 * Last Commit by:    $Author:: cmatsond                                     $ *
 *                                                                             *
 *******************************************************************************/
package ca.bc.gov.health.emaccs.web;

import ca.bc.gov.health.emaccs.ejb.entity.AdjudicationRequest;
import ca.bc.gov.health.emaccs.ejb.entity.ApprovedActivity;
import ca.bc.gov.health.emaccs.ejb.entity.EmergencyMedicalAssistant;
import ca.bc.gov.health.emaccs.ejb.entity.LicenceMaintenance;
import ca.bc.gov.health.emaccs.ejb.entity.Lkcmedat;
import ca.bc.gov.health.emaccs.ejb.entity.OtherActivity;
import ca.bc.gov.health.emaccs.ejb.entity.PatientContact;
import ca.bc.gov.health.emaccs.ejb.entity.ReportingYear;
import ca.bc.gov.health.emaccs.ejb.session.AdjudicationRequestFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.ApprovedActivityFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.EmaccsApplicationVariablesFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.EmergencyMedicalAssistantFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.LicenceMaintenanceFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.LkcmedatFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.OtherActivityFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.PatientContactFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.ReportingYearFacadeLocal;
import ca.bc.gov.health.jsf.ApplicationBean;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.context.FacesContext;
import jakarta.faces.context.Flash;
import jakarta.faces.event.ValueChangeEvent;
import jakarta.faces.model.SelectItem;
import jakarta.faces.validator.ValidatorException;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.primefaces.event.FileUploadEvent;
import org.primefaces.model.file.UploadedFile;

/**
 *
 * @author joshua.lewis
 */
@Named("MyContinuingCompetence")
@ViewScoped
public class MyContinuingCompetence extends ApplicationBean implements java.io.Serializable {

    private static final long serialVersionUID = 1L;
    private List<PatientContact> patientContacts = new ArrayList<>();
    private List approvedActivities = new ArrayList();
    private List<OtherActivity> pendingActivities = new ArrayList<>();
    private List<OtherActivity> rejectedActivities = new ArrayList<>();
    private LicenceMaintenance licenceMaintenance; //ccStatus contained here
    private int patientContactCount;
    private double contEducationCreditCount;
    private boolean adjudicationPeriod;
    private boolean pendingAdj;

    /*
     * Flash scope to handle passing parameters from other views
     */
    private Flash flash;
    private Long reportingYearId;
    private Long emaId = null;
    private String licenceNumber = "";

    /*
     * The instance we're currently editing
     */
    private AdjudicationRequest adjudicationRequest = new AdjudicationRequest();
    /*
     * Facades for persistence
     */
     @EJB
    private ReportingYearFacadeLocal reportingYearFacade;
    @EJB
    private AdjudicationRequestFacadeLocal adjudicationRequestFacade;
    @EJB
    private ApprovedActivityFacadeLocal approvedActivityFacade;
    @EJB
    private OtherActivityFacadeLocal otherActivityFacade;
    @EJB
    private PatientContactFacadeLocal patientContactFacade;
    @EJB
    private LicenceMaintenanceFacadeLocal licenceMaintenanceFacade;
    @EJB
    private EmergencyMedicalAssistantFacadeLocal emergencyMedicalAssistantFacade;
    @EJB
    private LkcmedatFacadeLocal lkCmedatFacade;
    @EJB
    private EmaccsApplicationVariablesFacadeLocal emaccsApplicationVariablesFacade;

    public MyContinuingCompetence() {
    }

    // This method sets the reporting year when the page first loads, then populates the tables
    // By default, the reporting year should be the current year, but it's currently hard-coded
    @PostConstruct
    public void init() {
        flash = FacesContext.getCurrentInstance().getExternalContext().getFlash();

        List<SelectItem> allYears = droplists.getReportingYears();
        if (allYears == null || allYears.isEmpty()) {
            droplists.initReportingYears();
        }
        if (flash.get("emaId") != null) {
            emaId = (Long) flash.get("emaId");
            licenceNumber = (String) flash.get("licenceNumber");
            reportingYearId = (Long) flash.get("reportingYearId");
            adjudicationRequest.setReportingYearId(new ReportingYear(reportingYearId));
            adjudicationRequest.setEmaId(new EmergencyMedicalAssistant(emaId));
        }

        if (reportingYearId == null) {
            reportingYearId = reportingYearFacade.getCurrentReportingYear().getId();
        }

        if (user.getUserRole().equals("EMA")) {
            adjudicationPeriod = emaccsApplicationVariablesFacade.isAdjudicationPeriod(reportingYearId);
            pendingAdj = user.isPendingAdj(reportingYearId);
            searchByCurrentUser();
        } else if (!licenceNumber.isEmpty()) {
            searchByLicenceNo();
        }

        if (emaId != null) {
            // uses Global reportingYearId and emaId
            updateTables();
        }
    }

    public String navigateTo() {
        if (flash.get("emaId") != null) {
            emaId = (Long) flash.get("emaId");
            licenceNumber = (String) flash.get("licenceNumber");
            reportingYearId = (Long) flash.get("reportingYearId");
            adjudicationRequest.setReportingYearId(new ReportingYear(reportingYearId));
            adjudicationRequest.setEmaId(new EmergencyMedicalAssistant(emaId));
            init();
        }
        return "MyContinuingCompetence.xhtml";
    }

    private void searchByCurrentUser() {
        emaId = user.getEmaId();
        licenceNumber = user.getLicenceNo();
    }

    private void searchByLicenceNo() {
        EmergencyMedicalAssistant emergencyMedicalAssistant = new EmergencyMedicalAssistant();
        emergencyMedicalAssistant.setLicno(licenceNumber);
        List<EmergencyMedicalAssistant> results;
        results = emergencyMedicalAssistantFacade.search(emergencyMedicalAssistant);
        if (results != null && !results.isEmpty()) {
            emergencyMedicalAssistant = results.get(0);
            emaId = emergencyMedicalAssistant.getRegisId();
        }
    }

    public void changeLicenceNumber(ValueChangeEvent event) {
        //find list of other activities for that EMA when the user searches for an EMA by licence number
        licenceNumber = (String) event.getNewValue();
        adjudicationRequest = new AdjudicationRequest();
        if (!isValidLicenceNumber()) {
            addErrorMessage(licenceNumber + " is an invalid licence number.");
        }
        init();
    }

    public void search() {
        //find list of other activities for that EMA when the user searches for an EMA by licence number
        String lsc = licenceNumber;
        if(licenceNumber.length() < 6) {
            addErrorMessage("Please insert a valid licence number.");
            return;
        }
        adjudicationRequest = new AdjudicationRequest();
        if (!isValidLicenceNumber()) {
            addErrorMessage(licenceNumber + " is an invalid licence number.");
        }
        init();
    }

    public boolean isValidLicenceNumber() {
        return super.isValidLicenceNumber(licenceNumber);
    }

    public void selectReportingYear(ValueChangeEvent vcEvent) {
        reportingYearId = (Long) vcEvent.getNewValue();

        // uses Global reportingYearId
        updateTables();
    }

    // uses Global reportingYearId
    public void updateTables() {
        patientContacts = patientContactFacade.findByLicenceNumber(licenceNumber, reportingYearId);

        // get patient contact count
        patientContactCount = patientContacts.size();

        /* get approved activities */
        ApprovedActivity aaQuery = new ApprovedActivity();
        aaQuery.setEmaId(new EmergencyMedicalAssistant(emaId));
        aaQuery.setReportingYearId(new ReportingYear(reportingYearId));

        approvedActivities = approvedActivityFacade.search(aaQuery);
        List<OtherActivity> otherActivities = otherActivityFacade.findApproved(reportingYearId, emaId);

        // set up continuing education credit count
        contEducationCreditCount = 0.0;
        // retrieve the ones of ApprovedActivity type
        for (Object aa : approvedActivities) {
            contEducationCreditCount += ((ApprovedActivity) aa).getCredits().doubleValue();
        }

        // retrieve the ones of OtherActivity type
        for (OtherActivity oa : otherActivities) {
            if (oa.getCredits() != null) {
                contEducationCreditCount += oa.getCredits().doubleValue();
            }
            if (oa.getAdjudicatedCredits() != null) {
                contEducationCreditCount += oa.getAdjudicatedCredits().doubleValue();
            }

        }
        // add list of OtherActivity type to complete list of approved activities
        approvedActivities.addAll(otherActivities);

        /* get pending activities */
        pendingActivities = otherActivityFacade.findPending(reportingYearId, emaId);

        /* get pending activities */
        rejectedActivities = otherActivityFacade.findRejected(reportingYearId, emaId);

        //get licence maintenance for ccstatus
        LicenceMaintenance lmQuery = new LicenceMaintenance();
        lmQuery.setRegisId(new EmergencyMedicalAssistant(emaId));
        lmQuery.setReportyr(new ReportingYear(reportingYearId));
        licenceMaintenance = licenceMaintenanceFacade.getCurrentLicenceMaintenanceForEmaReportingYear(lmQuery);

        /*  get Adjudication Report */
        AdjudicationRequest arQuery = new AdjudicationRequest();
        arQuery.setEmaId(new EmergencyMedicalAssistant(emaId));
        arQuery.setReportingYearId(new ReportingYear(reportingYearId));

        List<AdjudicationRequest> arResults = adjudicationRequestFacade.search(arQuery);
        if (arResults != null && !arResults.isEmpty()) {
            adjudicationRequest = arResults.get(0);
        } else {
            adjudicationRequest = arQuery;
        }
    }

    //TODO make into one transaction
    // method called if the initial submission is complete
    public String requestYes() {
        boolean success = setStatusPendingAdj();
        if (success) {
            return requestAdjudication("Y");
        } else {
            return null;
        }
    }

    // method called if the initial submission is not complete
    public String requestNo() {
        return requestAdjudication("N");
    }

    private String requestAdjudication(String submissionComplete) {
        nullify();
        adjudicationRequest.setSubmissionCompleteYn(submissionComplete);
        try {
            adjudicationRequestFacade.create(adjudicationRequest);
            addInfoMessage("Successfully requested Adjudication");
        } catch (Exception e) {
            if (submissionComplete.equals("Y")) {
                addErrorMessage("Submission of adjudication request failed, please try again later");
            } else {
                addErrorMessage("Your current changes could not be saved, please try again later");
            }
        }

        init();
        return clear();
    }

    // updates the status to 'Pending Adjudication'
    private boolean setStatusPendingAdj() {
        // The record for the PREVIOUS year is the one that needs to be updated
        LicenceMaintenance lmQuery = new LicenceMaintenance();
        lmQuery.setRegisId(new EmergencyMedicalAssistant(emaId));
        lmQuery.setReportyr(new ReportingYear(emaccsApplicationVariablesFacade.getPreviousReportingYearId()));
        LicenceMaintenance lmToSave = licenceMaintenanceFacade.getCurrentLicenceMaintenanceForEmaReportingYear(lmQuery);

        if (lmToSave != null) {
            if (!lmToSave.getCcode().getCdesc().contains("PENDING ADJUDICATION")) {
                lmToSave.setCcode(new Lkcmedat(lkCmedatFacade.getCcode("PENDING ADJUDICATION")));
                lmToSave.setCmedate(super.getTodaysDate());
                lmToSave.setStatusDate(lmToSave.getCmedate());
                try {
                    licenceMaintenanceFacade.edit(lmToSave);
                } catch (Exception e) {
                    addErrorMessage("Submission of adjudication request failed, please try again later");
                    return false;
                }
            }
        }
        return true;
    }

    //TODO make into one transaction
    // method called if the request is updated and complete
    public String updateYes() {
        boolean success = setStatusPendingAdj();
        if (success) {
            return updateRequest("Y");
        } else {
            return null;
        }
    }

    // method called if the request is updated and not complete
    public String updateNo() {
        return updateRequest("N");
    }

    private String updateRequest(String submissionComplete) {
        nullify();
        adjudicationRequest.setSubmissionCompleteYn(submissionComplete);
        //TODO - check if this is even nesessary
        //TODO - confirm that if was previously Yes can be set to No
        try {
            adjudicationRequestFacade.edit(adjudicationRequest);
            addInfoMessage("Update Successful");
        } catch (Exception e) {
            if (submissionComplete.equals("Y")) {
                addErrorMessage("Submission of adjudication update failed, please try again later");
            } else {
                addErrorMessage("Your current changes could not be saved, please try again later");
            }
        }
        init();
        return clear();
    }

    public String uploadFile(FileUploadEvent event) throws Exception {
        UploadedFile item = event.getFile();
        String name = item.getFileName();
        String mimeType = item.getContentType();

        if (name.contains("\\")) {
            name = name.substring(name.lastIndexOf('\\') + 1);
        }

        if (name.length() > 200) {
            String message = "Filename for file to upload must be 200 characters or less.";
            addErrorMessage(message);
            throw new ValidatorException(new FacesMessage(message));
        }
        if (mimeType.length() > 200) {
            mimeType = mimeType.substring(0, 200);
        }

        adjudicationRequest.setAttachment(item.getContent());
        adjudicationRequest.setMimetype(mimeType);
        adjudicationRequest.setFilename(name);

        return null;
    }

    //TODO fix this to align to when the shortfall date is set
    //TODO remove
    public boolean isExamPeriod() {
        Date todayDate = new Date();
        Date date = new Date(todayDate.getYear(), 3, 30);
        if (todayDate.after(date) && reportingYearId.equals(emaccsApplicationVariablesFacade.getPreviousReportingYearId())) {
            return emaccsApplicationVariablesFacade.isExamPeriod(reportingYearId);
        }
        return false;
    }

    /**
     * Clears the form
     */
    public String clear() {
        return null;
    }

    public String requestExam() {
        addInfoMessage("Request Exam not yet available.");
        return null;
    }

    private void nullify() {
    }

    /*
     * Getters and Setters
     */
    //TODO remove and only use super
    public String getReportingYearString() {
        return super.getReportingYearString(reportingYearId);
    }

    public List getApprovedActivities() {
        return approvedActivities;
    }

    public void setApprovedActivities(List approvedActivities) {
        this.approvedActivities = approvedActivities;
    }

    public LicenceMaintenance getLicenceMaintenance() {
        return licenceMaintenance;
    }

    public void setLicenceMaintenance(LicenceMaintenance licenceMaintenance) {
        this.licenceMaintenance = licenceMaintenance;
    }

    public List<OtherActivity> getPendingActivities() {
        return pendingActivities;
    }

    public void setPendingActivities(List<OtherActivity> otherActivities) {
        this.pendingActivities = otherActivities;
    }

    public List<OtherActivity> getRejectedActivities() {
        return rejectedActivities;
    }

    public void setRejectedActivities(List<OtherActivity> rejectedActivities) {
        this.rejectedActivities = rejectedActivities;
    }

    public List<PatientContact> getPatientContacts() {
        return patientContacts;
    }

    public void setPatientContacts(List<PatientContact> patientContacts) {
        this.patientContacts = patientContacts;
    }

    public Long getReportingYearId() {
        return reportingYearId;
    }

    public void setReportingYearId(Long reportingYearId) {
        this.reportingYearId = reportingYearId;
    }

    public AdjudicationRequest getAdjudicationRequest() {
        return adjudicationRequest;
    }

    public void setAdjudicationRequest(AdjudicationRequest adjudicationRequest) {
        this.adjudicationRequest = adjudicationRequest;
    }

    public int getPatientContactCount() {
        return patientContactCount;
    }

    public double getContEducationCreditCount() {
        return contEducationCreditCount;
    }

    public String getLicenceNumber() {
        return licenceNumber;
    }

    public void setLicenceNumber(String licenceNumber) {
        this.licenceNumber = licenceNumber;
    }

    public Flash getFlash() {
        return flash;
    }

    public void setFlash(Flash flash) {
        this.flash = flash;
    }

    public boolean isAdjudicationPeriod() {
        return adjudicationPeriod;
    }

    public boolean isPendingAdj() {
        return pendingAdj;
    }

}
