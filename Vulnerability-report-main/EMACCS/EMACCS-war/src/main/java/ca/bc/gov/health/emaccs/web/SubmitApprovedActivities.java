/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        SubmitApprovedActivities.java                  *
 * Date of Last Commit: $Date:: 2017-02-23 12:14:45 -0800 (Thu, 23 Feb 2017) $ *
 * Revision Number:      $Rev:: 2694                                         $ *
 * Last Commit by:    $Author:: tschiavo                                     $ *
 *                                                                             *
 *******************************************************************************/
package ca.bc.gov.health.emaccs.web;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import ca.bc.gov.health.ejb.exception.FacadeException;
import ca.bc.gov.health.emaccs.ejb.entity.ActivityType;
import ca.bc.gov.health.emaccs.ejb.entity.ApprovedActivity;
import ca.bc.gov.health.emaccs.ejb.entity.EmergencyMedicalAssistant;
import ca.bc.gov.health.emaccs.ejb.entity.ReportingYear;
import ca.bc.gov.health.emaccs.ejb.session.ActivityTypeFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.ApprovedActivityFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.EmaccsApplicationVariablesFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.EmergencyMedicalAssistantFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.ReportingYearFacadeLocal;
import ca.bc.gov.health.jsf.ApplicationBean;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.event.ValueChangeEvent;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;

@ViewScoped
@Named("SubmitApprovedActivities")
public class SubmitApprovedActivities extends ApplicationBean implements java.io.Serializable {

    private static final long serialVersionUID = 1L;
    private static final String CLASS_NAME = SubmitApprovedActivities.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);
    /*
     * Facade for persistence
     */
    @EJB
    private ApprovedActivityFacadeLocal approvedActivityFacade;
    @EJB
    private ActivityTypeFacadeLocal activityTypeFacade;
    @EJB
    private EmergencyMedicalAssistantFacadeLocal emergencyMedicalAssistantFacade;
    @EJB
    private EmaccsApplicationVariablesFacadeLocal emaccsApplicationVariablesFacade;
     @EJB
    private ReportingYearFacadeLocal reportingYearFacade;
    /*
     * The instance we're currently editing
     */
    private ApprovedActivity approvedActivity = new ApprovedActivity();
    private List<ApprovedActivity> approvedActivityList = new ArrayList<>();
    private ActivityType currentActivityType = new ActivityType();
    private List<ApprovedActivity> deletes = new ArrayList<>();
    //   private List<ApprovedActivity> check = new ArrayList<>();

    /**
     * Lists of selected NOCPs for this area to display on the screen
     */
    private List<String> selectedAreas;
    private List<String> selectedTypes;
    private List<String> selectedSubtypes;
    /*
     * PK of the selected instance
     */
    private Integer selectedKey;
    private Long reportingYearId;
    private boolean ccExempt = false;
    private boolean pendingAdj = true;
    private boolean shortfall = true;
    private boolean userIsEma;
    private boolean editable = false;
    private boolean adjudicationPeriod = false;
    private boolean shortfallPeriod = false;


    /* Currently searched for licence number; There's good reason to have it not null... */
    private String licenceNumber = "";

    /**
     * Default Constructor
     */
    public SubmitApprovedActivities() {
    }

    private void searchByLicenceNo() {
        approvedActivityList = approvedActivityFacade.findByLicenceNumber(licenceNumber, reportingYearId);
    }

    private void searchByCurrentUser() {
        approvedActivityList = approvedActivityFacade.findByEmaIdReportingYear(user.getEmaId(), reportingYearId);
    }

    private ApprovedActivity setupApprovedActivity() {
        ApprovedActivity temp = new ApprovedActivity();

        temp.setReportingYearId(new ReportingYear(emaccsApplicationVariablesFacade.getCurrentReportingYearId()));

        if (userIsEma) {
            temp.setEmaId(new EmergencyMedicalAssistant(user.getEmaId()));
        } else if (!licenceNumber.isEmpty()) {
            EmergencyMedicalAssistant eQuery = new EmergencyMedicalAssistant();
            List<EmergencyMedicalAssistant> results;
            eQuery.setLicno(licenceNumber);
            results = emergencyMedicalAssistantFacade.search(eQuery);
            if (results != null && !results.isEmpty()) {
                temp.setEmaId(new EmergencyMedicalAssistant(results.get(0).getRegisId()));
            }
        }
        temp.setActivityId(new ActivityType());
        // This ID is temporary, and is used to compare approved activity objects

        return temp;
    }

    /**
     * Initializes this bean after injection
     */
    @PostConstruct
    public void init() {
        setUp();

        if (!licenceNumber.isEmpty()) {
            initList();
        }
    }

    private void setUp() {
        if (reportingYearId == null) {
            reportingYearId = reportingYearFacade.getCurrentReportingYear().getId();
        }

        if (user.getUserRole().equals("EMA")) {
            userIsEma = true;
            licenceNumber = user.getLicenceNo();

            ccExempt = user.isCCExempt(reportingYearId);
            shortfall = user.isShortFall(reportingYearId);
            pendingAdj = user.isPendingAdj(reportingYearId);
            adjudicationPeriod = emaccsApplicationVariablesFacade.isAdjudicationPeriod(reportingYearId);
            shortfallPeriod = emaccsApplicationVariablesFacade.isShortfallPeriod(reportingYearId);

        } else {
            userIsEma = false;
        }

        editable = super.selectedYearEditable(userIsEma, ccExempt, shortfall, pendingAdj, adjudicationPeriod, shortfallPeriod, reportingYearId);
        approvedActivity = setupApprovedActivity();

    }

    /**
     * Separate method for initializing the list on the page
     */
    private void initList() {
        if (userIsEma) {
            searchByCurrentUser();
        } else if (!licenceNumber.isEmpty()) {
            searchByLicenceNo();
        }
        deletes = new ArrayList<>();
        //  check = new ArrayList<>();
    }

    /*
     * searches based on licence number
     */
    public void changeLicenceNumber(ValueChangeEvent event) {
        //find list of approved activities for that EMA when the user searches for an EMA by licence number
        licenceNumber = (String) event.getNewValue();
        approvedActivity = null;
        if (!isValidLicenceNumber()) {
            addErrorMessage(licenceNumber + " is an invalid licence number.");
        }
        init();
    }

    public void search() {
        if (licenceNumber.length() < 6 ) {
            addErrorMessage("Please insert a valid licence number.");
            return;
        }
        approvedActivity = null;
        if (!isValidLicenceNumber()) {
            addErrorMessage(licenceNumber + " is an invalid licence number.");
        }
        init();
    }

    public boolean isValidLicenceNumber() {
        return super.isValidLicenceNumber(licenceNumber);
    }

    public void changeReportingYear(ValueChangeEvent event) {
        approvedActivity = null;
        reportingYearId = (Long) event.getNewValue();
        init();
    }

    public void changeActivityName(ValueChangeEvent event) {
        if (!event.getNewValue().equals("")) {
            /*
             * retrieve the Approved Activity information for the selected
             * activity based on its ID
             */
            approvedActivity.setActivityId(activityTypeFacade.find((Long) event.getNewValue()));
        }
    }

    public double getApprovedCreditTotal() {

        double total = 0;
        for (ApprovedActivity aa : approvedActivityList) {
            if (aa.getCredits() != null) {
                total += aa.getCredits().doubleValue();
            }
        }
        return total;
    }

    /**
     * Adds a new record
     */
    public String add() {
        
        // fix any broken keys
        nullify();
          for(int i=0; i<approvedActivityList.size() ;i++){
                if(approvedActivityList.get(i).getActivityName().equals(approvedActivity.getActivityName())){ 
                    addErrorMessage("The activity is duplicated.");
                    return refresh();}
            }
           
        try {
            approvedActivity.setReportingYearId(new ReportingYear(super.getReportingYearId(approvedActivity.getEndDate())));
            // Set the default credit value from his activity type.
            approvedActivity.setCredits(approvedActivity.getActivityId().getDefaultCredits());
            approvedActivityFacade.create(approvedActivity);
           
            approvedActivityList.add(0, approvedActivity);

            try {
                approvedActivityFacade.checkRequirements(approvedActivity.getEmaId().getRegisId(), reportingYearId, false);
            } catch (Exception e) {

            }
            addInfoMessage("Added approved activity.");
        } catch (FacadeException e) {
            addErrorMessage("Add Failed. Try again by navigating away and returning to screen. Contact EMA Licensing if problem persists");
            if (e.getExceptionClass() != null && e.getExceptionClass().getSimpleName().equals("PersistenceException")) {
                addErrorMessage("Please double check your values as you enter them");
            }

        } catch (Exception e) {
            addErrorMessage("Add Failed. Try again by navigating away and returning to screen. Contact EMA Licensing if problem persists");
        }

        // reset the current object and set up the form again
        return refresh();
    }

    /**
     * Updates an existing record
     */
    public String update() {
        // fix any broken keys
        nullify();
        ApprovedActivity replacement = null;
        try {
            approvedActivity.setReportingYearId(new ReportingYear(super.getReportingYearId(approvedActivity.getEndDate())));
            replacement = approvedActivityFacade.edit(approvedActivity);
            try {
                approvedActivityFacade.checkRequirements(approvedActivity.getEmaId().getRegisId(), reportingYearId, true);
            } catch (Exception e) {

            }
            addInfoMessage("Updated approved activity.");
        } catch (FacadeException e) {
            addErrorMessage("Update Failed. Try again by navigating away and returning to screen. Contact EMA Licensing if problem persists");
            if (e.getExceptionClass() != null && e.getExceptionClass().getSimpleName().equals("PersistenceException")) {
                addErrorMessage("Please double check your values as you enter them");
            }

        } catch (Exception e) {
            addErrorMessage("Update Failed. Try again by navigating away and returning to screen. Contact EMA Licensing if problem persists");
        }
        if (replacement != null) {
            approvedActivityList.add(0, replacement);
        } else {
            approvedActivityList.add(0, approvedActivity);
        }

        // reset the current object and set up the form again
        return refresh();
    }

    /**
     * Selects a record for editing
     */
    public String select() {
        approvedActivityList = removeThisAa(approvedActivity, approvedActivityList);
        return null;
    }

    /**
     * called at the end of add / update serves a similar purpose to clear(),
     * but doesn't reprocess the displayed list i.e. doesn't erase the displayed
     * list, re-query the database, and re-add the temp lists (inserts, updates)
     */
    public String refresh() {
        approvedActivity = null;
        return clear();
    }

    /**
     * Clears the form
     */
    public String clear() {
        this.setApprovedActivity(setupApprovedActivity());
        return null;
    }

    /**
     * Cancels current action Clears the temp lists and retrieves the displayed
     * list from the database
     */
    public String cancel() {
        init();
        return clear();
    }

    /**
     * Deletes a record
     *
     * @return null
     */
    public String delete() {

        nullify();

        //Adding the Activy that's being deleted to the list 'deletes' since processMultipleEntitys takes a list
        //Preserving that functionality since CAST 18694 doesn't include making a change to other 
        //classes that call processMultipleEntities - TSS
        if (approvedActivity.getId() != null) {
            deletes.add(approvedActivity);
        }

        //TODO change processMultipleEntities to throw an exception on error rather than making a list of deleteFailures
        //and modify error handling accordingly
        approvedActivityFacade.processMultipleEntities(null, null, deletes, reportingYearId);
        List<ApprovedActivity> removeFailures = approvedActivityFacade.getDeleteFailuresMultipleEntityProcess();

        //figure out error and success messaging
        int removeFailCount = removeFailures.size();

        if (!approvedActivityFacade.isRequirementCheckSuccessful()) {
            addErrorMessage("Calculation of your licence status failed. Should the changes have altered your licence status that alteration will not be reflected");
        }

        if (removeFailCount == 0) {
            addInfoMessage("Deletion Successful");
        } else {
            addErrorMessage("Deletion Failed. If problem persists contact EMA Licensing");
            return cancel();
        }

        approvedActivityList.remove(approvedActivity);
        deletes.clear();
        refresh();
        return null;
    }

    /**
     * Nullifies any parent records where proper PKs aren't set
     */
    private void nullify() {
        if (approvedActivity.getReportingYearId() != null && approvedActivity.getReportingYearId().getId() == null) {
            approvedActivity.setReportingYearId(null);
        }
    }

    /*
     * Method to remove an EmploymentHolder object from a list, based on ID
     * Used to ensure there are no duplicates, and called in multiple places
     */
    private List<ApprovedActivity> removeThisAa(ApprovedActivity removeObjectLikeThis, List<ApprovedActivity> theList) {
        if (!theList.isEmpty()) {
            for (ApprovedActivity theObject : theList) {
                if (removeObjectLikeThis.getId().toString().equals(theObject.getId().toString())) {
                    theList.remove(theObject);
                    break;
                }
            }
        }
        return theList;
    }

    /*
     * Getters and Setters
     */
    public ApprovedActivity getApprovedActivity() {
        return approvedActivity;
    }

    public void setApprovedActivity(ApprovedActivity approvedActivity) {
        if (this.approvedActivity != null && this.approvedActivity.getId() != null) {
            approvedActivityList.add(0, this.approvedActivity);
        }
        this.approvedActivity = approvedActivity;
    }

    public ActivityType getCurrentActivityType() {
        return currentActivityType;
    }

    public void setCurrentActivityType(ActivityType currentActivityType) {
        this.currentActivityType = currentActivityType;
    }

    public List<ApprovedActivity> getApprovedActivityList() {
        return approvedActivityList;
    }

    public void setApprovedActivityList(List<ApprovedActivity> approvedActivityList) {
        this.approvedActivityList = approvedActivityList;
    }

    public Long getReportingYearId() {
        return reportingYearId;
    }

    public void setReportingYearId(Long reportingYearId) {
        this.reportingYearId = reportingYearId;
    }

    public String getLicenceNumber() {
        return licenceNumber;
    }

    public void setLicenceNumber(String licenceNumber) {
        this.licenceNumber = licenceNumber;
    }

    public Integer getSelectedKey() {
        return selectedKey;
    }

    public void setSelectedKey(Integer selectedKey) {
        this.selectedKey = selectedKey;
    }

    public List<String> getSelectedAreas() {
        return selectedAreas;
    }

    public void setSelectedAreas(List<String> selectedAreas) {
        this.selectedAreas = selectedAreas;
    }

    public List<String> getSelectedSubtypes() {
        return selectedSubtypes;
    }

    public void setSelectedSubtypes(List<String> selectedSubtypes) {
        this.selectedSubtypes = selectedSubtypes;
    }

    public List<String> getSelectedTypes() {
        return selectedTypes;
    }

    public void setSelectedTypes(List<String> selectedTypes) {
        this.selectedTypes = selectedTypes;
    }

    public boolean isCcExempt() {
        return ccExempt;
    }

    //depends on setup
    public boolean isPendingAdj() {
        return pendingAdj;
    }

    //depends on setup
    public boolean isShortfall() {
        return shortfall;
    }

    public boolean isUserIsEma() {
        return userIsEma;
    }

    public String getPendingAdjStr() {
        return Boolean.toString(pendingAdj);
    }

    public String getUserIsEmaStr() {
        return Boolean.toString(userIsEma);
    }

    public String getShortfallStr() {
        return Boolean.toString(shortfall);
    }

    public boolean isEditable() {
        return editable;
    }

    public boolean isAdjudicationPeriod() {
        return adjudicationPeriod;
    }

    public boolean isShortfallPeriod() {
        return shortfallPeriod;
    }

    public List<ApprovedActivity> getDeletes() {
        return deletes;
    }
}
