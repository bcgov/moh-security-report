/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        LogPatientContacts.java                        *
 * Date of Last Commit: $Date:: 2015-06-22 17:18:37 -0700 (Mon, 22 Jun 2015) $ *
 * Revision Number:      $Rev:: 2540                                         $ *
 * Last Commit by:    $Author:: cmatsond                                     $ *
 *                                                                             *
 *******************************************************************************/

package ca.bc.gov.health.emaccs.web;

import ca.bc.gov.health.ejb.exception.FacadeException;
import ca.bc.gov.health.emaccs.ejb.entity.ContactSubtype;
import ca.bc.gov.health.emaccs.ejb.entity.ContactType;
import ca.bc.gov.health.emaccs.ejb.entity.EmergencyMedicalAssistant;
import ca.bc.gov.health.emaccs.ejb.entity.PatientContact;
import ca.bc.gov.health.emaccs.ejb.entity.ReportingYear;
import ca.bc.gov.health.emaccs.ejb.entity.Skill;
import ca.bc.gov.health.emaccs.ejb.session.ContactSubtypeFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.ContactTypeFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.EmaccsApplicationVariablesFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.EmergencyMedicalAssistantFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.LicenceMaintenanceFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.PatientContactFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.ReportingYearFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.SkillFacadeLocal;
import ca.bc.gov.health.jsf.ApplicationBean;
import ca.bc.gov.health.jsf.SelectItemHelper;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.context.FacesContext;
import jakarta.faces.context.Flash;
import jakarta.faces.event.ValueChangeEvent;
import jakarta.faces.model.SelectItem;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Named;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;


/**
 * Backing bean for Log Patient Contacts Screen
 *
 * @author dan.stepanov
 */
@ViewScoped
@Named("LogPatientContacts")
public class LogPatientContacts extends ApplicationBean implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    private static final String CLASS_NAME = LogPatientContacts.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);
    
    /* These are the required patient contact and activity credit totals for each reporting year for an EMA */
    private final int REQUIRED_PATIENT_CONTACTS = 20;
    /*
     * Facade for persistence
     */
    @EJB
    private PatientContactFacadeLocal patientContactFacade;
    @EJB
    private ContactSubtypeFacadeLocal contactSubtypeFacade;
    @EJB
    private ContactTypeFacadeLocal contactTypeFacade;
    @EJB
    private SkillFacadeLocal skillFacade;
    @EJB
    private ReportingYearFacadeLocal reportingYearFacade;
    @EJB
    private EmergencyMedicalAssistantFacadeLocal emergencyMedicalAssistantFacade;
    @EJB 
    private EmaccsApplicationVariablesFacadeLocal emaccsApplicationVariablesFacade;
    @EJB
    private LicenceMaintenanceFacadeLocal LicenceMaintenanceFacade;

    /*
     * The instance we're currently editing
     */
    private PatientContact patientContact = new PatientContact();
    private PatientContact patientContactForDelete = new PatientContact();
    private List<PatientContact> patientContactList = new ArrayList<>();
    private List<SelectItem> filteredContactSubTypes = new ArrayList<>();
    /*
     * PK of the selected instance
     */
    private Long reportingYearId;
    private boolean ccExempt = false;
    private boolean pendingAdj = true;
    private boolean adjudicationPeriod = false;
    private boolean shortfallPeriod = false;
    private boolean shortfall = true;
    private boolean editable = false;
    private boolean contactLimit = false;
    private boolean userIsEma;

    /*
     * Current search for licence number
     */
    private String licenceNumber = "";

    /*
     * Flash scope to handle passing parameters from other views
     */
    private Flash flash;
    private Long emaId = null;

    /**
     * Default Constructor
     */
    public LogPatientContacts() {
    }

    /**
     * This method populates all the form fields and the current reporting year
     * is selected
     */
    private List<SelectItem>defaultContactSubTypes = new ArrayList<>(); ;
    private PatientContact setupPatientContact() {
        PatientContact temp = new PatientContact();
        //TODO - check if reporting year is important (or around where this is called - aka outside of method
        if (reportingYearId != null) {
            temp.setReportingYearId(new ReportingYear(reportingYearId));
        }

            temp.setEmaId(new EmergencyMedicalAssistant(emaId));


            temp.setContactTypeId(new ContactType());


            temp.setContactSubtypeId(new ContactSubtype());


            ContactSubtype contactSubtype = new ContactSubtype();
            contactSubtype.setContactTypeId(temp.getContactTypeId());
//used to make the list here
            temp.setSkill1Id(new Skill());

            temp.setSkill2Id(new Skill());

            temp.setCallDate(new Date());

            temp.setLocation("");
        
        return temp;
    }

    /**
     * Searches by licence number and displays the corresponding patient contact
     * list
     */
    private void searchByLicenceNo() {
        EmergencyMedicalAssistant emergencyMedicalAssistant = new EmergencyMedicalAssistant();
        emergencyMedicalAssistant.setLicno(licenceNumber);
        List<EmergencyMedicalAssistant> results;
        results = emergencyMedicalAssistantFacade.search(emergencyMedicalAssistant);
        if (results!=null&&!results.isEmpty()) {
            emergencyMedicalAssistant = results.get(0);
            emaId = emergencyMedicalAssistant.getRegisId();
            patientContact.setEmaId(new EmergencyMedicalAssistant(emaId));
        }

        patientContactList = patientContactFacade.findByLicenceNumber(licenceNumber, reportingYearId);
    }

    /**
     * Searches by current logged user and the selected reporting year and
     * displays the corresponding patient contact list
     */
    private void searchByCurrentUser() {
        emaId = user.getEmaId();
        patientContact.setEmaId(new EmergencyMedicalAssistant(emaId));
        patientContactList = patientContactFacade.findByEmaIdReportingYear(user.getEmaId(), reportingYearId);
    }

    /**
     * Initializes this bean after injection
     */
    @PostConstruct
    public void init() {
        flash = FacesContext.getCurrentInstance().getExternalContext().getFlash();
        if (flash.get("emaId") != null) {
            emaId = (Long) flash.get("emaId");
            licenceNumber = (String) flash.get("licenceNumber");
            reportingYearId = (Long) flash.get("reportingYearId");
            patientContact.setReportingYearId(new ReportingYear(reportingYearId));
            patientContact.setEmaId(new EmergencyMedicalAssistant(emaId));
        }

        setUp();

        if (!licenceNumber.isEmpty()) {
            initList();
        }
    }

    public void setUp() {
        if (reportingYearId == null) {
            if (patientContact.getReportingYearId() != null) {
                reportingYearId = patientContact.getReportingYearId().getId();
            } else {
                reportingYearId = reportingYearFacade.getCurrentReportingYear().getId();
            }
        }
        // search by licence number or by current logged EMA and reporting year
        if (user.getUserRole().equals("EMA")) {
            userIsEma = true;
            licenceNumber = user.getLicenceNo();

            ccExempt = user.isCCExempt(reportingYearId);
            shortfall = user.isShortFall(reportingYearId);
            pendingAdj = user.isPendingAdj(reportingYearId);
            adjudicationPeriod = emaccsApplicationVariablesFacade.isAdjudicationPeriod(reportingYearId);
            shortfallPeriod = emaccsApplicationVariablesFacade.isShortfallPeriod(reportingYearId);
        }

        editable = super.selectedYearEditable(userIsEma,ccExempt,shortfall,pendingAdj,adjudicationPeriod,shortfallPeriod,reportingYearId);       
        
        patientContact = setupPatientContact();
    }

    public void initList() {

        if (user.getUserRole().equals("EMA")) {
            searchByCurrentUser();
        } else if (!licenceNumber.isEmpty()) {
            searchByLicenceNo();
        }
        
        if(defaultContactSubTypes==null||defaultContactSubTypes.isEmpty()){
            List<ContactSubtype> results = contactSubtypeFacade.search(patientContact.getContactSubtypeId());
            defaultContactSubTypes = SelectItemHelper.buildSelectItemList(results, "contactSubtypeName", "id");
        }
        if(filteredContactSubTypes==null){
            filteredContactSubTypes = new ArrayList<>();
        }else{
            filteredContactSubTypes.clear();    
        }
        filteredContactSubTypes.addAll(defaultContactSubTypes);
        
        checkContactLimit();

    }

    private void checkContactLimit() {
        contactLimit = (userIsEma && patientContactList.size() >= REQUIRED_PATIENT_CONTACTS);
    }

    //TODO - remove all navigateTo
    public String navigateTo() {
        if (flash.get("emaId") != null) {
            emaId = (Long) flash.get("emaId");
            licenceNumber = (String) flash.get("licenceNumber");
            reportingYearId = (Long) flash.get("reportingYearId");
            patientContact.setReportingYearId(new ReportingYear(reportingYearId));
            patientContact.setEmaId(new EmergencyMedicalAssistant(emaId));
            init();
        }
        return "LogPatientContacts.xhtml";
    }

    /**
     * Find list of contact types/subtypes/skill1/skill2 for that EMA when the
     * user searches for an EMA by licence number and then displays the
     * corresponding patient contact list
     */
    public void changeLicenceNumber(ValueChangeEvent event) {

        licenceNumber = (String) event.getNewValue();
        clearContactSubTypeList();
        if (!isValidLicenceNumber()) {
            addErrorMessage(licenceNumber + " is an invalid licence number.");
            licenceNumber = "";
        }
        init();
    }

    public void search() {

        if(licenceNumber.length() < 6) {
            addErrorMessage("Please insert a valid licence number.");
            return;
        }
        clearContactSubTypeList();
        if (!isValidLicenceNumber()) {
            addErrorMessage(licenceNumber + " is an invalid licence number.");
            licenceNumber = "";
        }
        init();
    }

    public boolean isValidLicenceNumber() {
        return super.isValidLicenceNumber(licenceNumber);
    }
    
    public void delete() {
        try {
            long emaID = patientContactForDelete.getEMA_Id();
            long reportYR = patientContactForDelete.getReportingYearId().getId();
            patientContactFacade.remove(patientContactForDelete);
            patientContactList.remove(patientContactForDelete);
            patientContactForDelete = null;
            addInfoMessage("Delete Successful");
            LicenceMaintenanceFacade.checkIfRequirementsMet(emaID, reportYR, true);

        } catch(FacadeException e) {
            addErrorMessage("Delete Failed. Try again by navigating away and returning to screen. Contact EMA Licensing if problem persists");
        }
    }

    /**
     * Adds a new record
     */
    public void add() throws ParseException {

        // fix any broken keys
        nullify();
        // set these IDs to valid objects, this helps with displaying the names in the list
        patientContact.setContactTypeId(contactTypeFacade.find(patientContact.getContactTypeId().getId()));
        patientContact.setContactSubtypeId(contactSubtypeFacade.find(patientContact.getContactSubtypeId().getId()));
        patientContact.setSkill1Id(skillFacade.find(patientContact.getSkill1Id().getId()));
        patientContact.setSkill2Id(skillFacade.find(patientContact.getSkill2Id().getId()));
        try{
                patientContactFacade.create(patientContact);
                // add it to the inserts list, and the displayed list
                patientContactList.add(0, patientContact);
                addInfoMessage("Add Successful");
                refresh();
                // sort patient contacts in descending order by call date
                Collections.sort(patientContactList, new Comparator<PatientContact>() {

                    @Override
                    public int compare(PatientContact pc1, PatientContact pc2) {
                        return pc2.getCallDate().compareTo(pc1.getCallDate());
                    }
                });
                try{
                    patientContactFacade.checkRequirements(emaId, reportingYearId, false);
                }catch(Exception e){
                    
                }
        }catch(FacadeException e){
            addErrorMessage("Add Failed. Try again by navigating away and returning to screen. Contact EMA Licensing if problem persists");
             if(e.getExceptionClass()!=null&&e.getExceptionClass().getSimpleName().equals("PersistenceException")){
                  addErrorMessage("Please double check your values as you enter them");
             }

        }catch(Exception e){
            addErrorMessage("Add Failed. Try again by navigating away and returning to screen. Contact EMA Licensing if problem persists");
        }

    }

    /**
     * Updates an existing record
     * @throws java.text.ParseException
     */
    public void update() throws ParseException {

        if (!validDateRange()) {
            String message = "The Call Date entered does not match the selected Reporting Year.";
            addErrorMessage(message);

        } else {
            // fix any broken keys
            nullify();
            try{
                // set these IDs to valid objects, this helps with displaying the names in the list
                patientContact.setContactTypeId(contactTypeFacade.find(patientContact.getContactTypeId().getId()));
                patientContact.setContactSubtypeId(contactSubtypeFacade.find(patientContact.getContactSubtypeId().getId()));
                patientContact.setSkill1Id(skillFacade.find(patientContact.getSkill1Id().getId()));
                patientContact.setSkill2Id(skillFacade.find(patientContact.getSkill2Id().getId()));
                PatientContact replacement = null;
                replacement=patientContactFacade.edit(patientContact);
                if(replacement!=null){
                       patientContactList.add(0, replacement);
                }else{
                     patientContactList.add(0, patientContact);
                }
                // add it to the updates list, and the displayed list
                // patientContactList.add(0, patientContact);
                addInfoMessage("Update Successful");
                refresh();
                try{
                    patientContactFacade.checkRequirements(emaId, reportingYearId, false);
                } catch(Exception e){

                }
            }catch(FacadeException e){
                addErrorMessage("Add Failed. Try again by navigating away and returning to screen. Contact EMA Licensing if problem persists");
                 if(e.getExceptionClass()!=null&&e.getExceptionClass().getSimpleName().equals("PersistenceException")){
                      addErrorMessage("Please double check your values as you enter them");
                 }

            }catch(Exception e){
                addErrorMessage("Add Failed. Try again by navigating away and returning to screen. Contact EMA Licensing if problem persists");
            }
            
        }
    }

    /**
     * called at the end of add / update serves a similar purpose to clear(),
     * but doesn't reprocess the displayed list i.e. doesn't erase the displayed
     * list, re-query the database, and re-add the temp lists (inserts, updates)
     */
    public void refresh() {
        patientContact = null;
        checkContactLimit();
        clear();
    }

    /**
     * Clears the form
     */
    public void clear() {
        this.setPatientContact(setupPatientContact());
        clearContactSubTypeList();
    }

    /**
     * Selects a record for editing
     */
    public void select() {
        patientContactList = removeThisPc(patientContact, patientContactList);
        if(defaultContactSubTypes==null||defaultContactSubTypes.isEmpty()){
            List<ContactSubtype> results = contactSubtypeFacade.search(patientContact.getContactSubtypeId());
            defaultContactSubTypes = SelectItemHelper.buildSelectItemList(results, "contactSubtypeName", "id");
        }
        if(filteredContactSubTypes==null){
            filteredContactSubTypes = new ArrayList<>();
        }else{
            filteredContactSubTypes.clear();    
        }
        filteredContactSubTypes.addAll(defaultContactSubTypes);
    }

    public void cancel() {
        init();
    }


    public void changeReportingYear(ValueChangeEvent event) {
        reportingYearId = (Long) event.getNewValue();
        //patientContact.setContactTypeId(null);
        init();

        //patientContactList = patientContactFacade.findByEmaIdReportingYear(emaId, reportingYearId);
    }

    public void changeContactType(Long id) {
        // clear contact sub type list before is populated with the values
        // for the corresponding contact type id
        clearContactSubTypeList();

        if (id != null) {
            ContactSubtype params = new ContactSubtype();
            params.setContactTypeId(new ContactType(id));
            List<ContactSubtype> results = contactSubtypeFacade.search(params);
            filteredContactSubTypes = SelectItemHelper.buildSelectItemList(results, "contactSubtypeName", "id");
        } 
    }

    /*
     * Check whether the call date is within the currently selected calendar
     * year.
     */
    public boolean validDateRange() throws ParseException {

        boolean dateFlag = false;
        // added check if reporting year is null
        if (patientContact.getReportingYearId().getId() != null) {
            PatientContact params = new PatientContact();
            ReportingYear reportingYear = reportingYearFacade.find(patientContact.getReportingYearId().getId());
            params.setReportingYearId(reportingYear);

            // extract reporting year value from the selected year on screen
            String selectedReportYear = params.getReportingYearId().getReportingYear();
            // split selected reporting year for date comparison
            // call date within reporting year period (01-APR-2012 to 31-MAR-2013)
            String selectYearFirst = selectedReportYear.substring(0, 4);
            String selectDayMonth = "01-APR-";
            String selectYearSecond = selectedReportYear.substring(5, 9);

            try {
                SimpleDateFormat sdf = new SimpleDateFormat("dd-MMM-yyyy");
                Date parsedDateYearFirst = sdf.parse(selectDayMonth.concat(selectYearFirst));
                Date parsedDateYearSecond = sdf.parse(selectDayMonth.concat(selectYearSecond));

                if (patientContact.getCallDate() == null) {
                    //dateFlag already false
                } else {
                    if (patientContact.getCallDate().before(parsedDateYearFirst)
                            || patientContact.getCallDate().after(parsedDateYearSecond)) {
                        //dateFlag already false
                    } else {
                        dateFlag = true;
                    }
                }
            } catch (ParseException pex) {
                pex.getStackTrace();
            }
        }
        return dateFlag;

    }

    /**
     * Retrieve all patient contacts associated with the licence number for the
     * selected reporting year
     * @param licno
     * @return int patientContactList size
     */
    public int getPatientContactsCount(String licno) {
        List<PatientContact> patientContactsList = patientContactFacade.findByLicenceNumber(licenceNumber, reportingYearId);
        return patientContactsList.size();
    }

    /**
     * Nullifies any parent records where proper PKs aren't set
     */
    private void nullify() {
        if (patientContact.getContactTypeId() != null && patientContact.getContactTypeId() == null) {
            patientContact.setContactTypeId(null);
        }
        if (patientContact.getReportingYearId() != null && patientContact.getReportingYearId().getId() == null) {
            patientContact.setReportingYearId(null);
        }
        if (patientContact.getContactSubtypeId() != null && patientContact.getContactSubtypeId().getId() == null) {
            patientContact.setContactSubtypeId(null);
        }
        if (patientContact.getSkill1Id() != null && patientContact.getSkill1Id().getId() == null) {
            patientContact.setSkill1Id(null);
        }
        if (patientContact.getSkill2Id() != null && patientContact.getSkill2Id().getId() == null) {
            patientContact.setSkill2Id(null);
        }
    }

    /*
     * Method to remove an EmploymentHolder object from a list, based on ID Used
     * to ensure there are no duplicates, and called in multiple places
     */
    private List<PatientContact> removeThisPc(PatientContact removeObjectLikeThis, List<PatientContact> theList) {
        if (!theList.isEmpty()) {
            for (PatientContact theObject : theList) {
                if (removeObjectLikeThis.getId().toString().equals(theObject.getId().toString())) {
                    theList.remove(theObject);
                    break;
                }
            }
        }
        return theList;
    }

    public void clearContactSubTypeList() {
        filteredContactSubTypes.clear();
    }

    public PatientContact getPatientContact() {
        return patientContact;
    }

    public void setPatientContact(PatientContact patientContact) {
         if(this.patientContact!=null&&this.patientContact.getId()!=null){
            patientContactList.add(0,this.patientContact);            
        }
        this.patientContact = patientContact;
    }

    public List<PatientContact> getPatientContactList() {
        return patientContactList;
    }

    public void setPatientContactList(List<PatientContact> patientContactList) {
        this.patientContactList = patientContactList;
    }

    public Long getReportingYearId() {
        return reportingYearId;
    }

    public void setReportingYearId(Long reportingYearId) {
        this.reportingYearId = reportingYearId;
    }

    public List<SelectItem> getFilteredContactSubTypes() {
        return filteredContactSubTypes;
    }

    public void setFilteredContactSubTypes(List<SelectItem> filteredContactSubTypes) {
        this.filteredContactSubTypes = filteredContactSubTypes;
    }

    public String getLicenceNumber() {
        return licenceNumber;
    }
    public void setLicenceNumber(String licenceNumber) {
        this.licenceNumber = licenceNumber;
    }
    public Flash getFlash() {
        return flash;
    }
    public void setFlash(Flash flash) {
        this.flash = flash;
    }
    public boolean isCcExempt() {
        return ccExempt;
    }
    //depends on setup
    public boolean isPendingAdj() {
        return pendingAdj;
    }
    public boolean isAdjudicationPeriod() {
          return adjudicationPeriod;
    }
    public boolean isShortfallPeriod() {
          return shortfallPeriod;
    }
    //depends on setup
    public boolean isShortfall() {
        return shortfall;
    }
    public boolean isUserIsEma() {
        return userIsEma;
    }
    public boolean isEditable() {
        return editable;
    }
    public boolean isContactLimit() {
        return contactLimit;
    }

    public PatientContact getPatientContactForDelete() {
        return patientContactForDelete;
    }

    public void setPatientContactForDelete(PatientContact patientContactForDelete) {
        this.patientContactForDelete = patientContactForDelete;
    }

}