/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        MaintainNocpCompetencySubtype.java             *
 * Date of Last Commit: $Date:: 2015-06-22 17:18:37 -0700 (Mon, 22 Jun 2015) $ *
 * Revision Number:      $Rev:: 2540                                         $ *
 * Last Commit by:    $Author:: cmatsond                                     $ *
 *                                                                             *
 *******************************************************************************/

package ca.bc.gov.health.emaccs.web;

import ca.bc.gov.health.ejb.exception.FacadeException;
import ca.bc.gov.health.emaccs.ejb.entity.NocpCompetencySubtype;
import ca.bc.gov.health.emaccs.ejb.entity.NocpCompetencyType;
import ca.bc.gov.health.emaccs.ejb.session.NocpCompetencySubtypeFacadeLocal;
import ca.bc.gov.health.emaccs.ejb.session.NocpCompetencyTypeFacadeLocal;
import ca.bc.gov.health.jsf.BaseBean;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.faces.view.ViewScoped;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;


/**
 * Backing bean for NocpCompetencySubtype code table maintenance
 */
@ViewScoped
@Named("MaintainNocpCompetencySubtype")
public class MaintainNocpCompetencySubtype extends BaseBean implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    /*
     * Facade for persistence
     */
    @EJB
    private NocpCompetencySubtypeFacadeLocal nocpCompetencySubtypeFacade;
    @EJB
    private NocpCompetencyTypeFacadeLocal nocpCompetencyTypeFacade;
    
    private static final String CLASS_NAME = NocpCompetencySubtypeFacadeLocal.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);
    
    @Inject
    private Droplists droplists;

    private List<NocpCompetencySubtype> allNocpCompetencySubtypes;
    private NocpCompetencySubtype nocpCompetencySubtype;


    public MaintainNocpCompetencySubtype() {
    }

    /**
     * Initializes this bean after injection
     */
    @PostConstruct
    public void init() {
        allNocpCompetencySubtypes = nocpCompetencySubtypeFacade.findAll();
        setupNewSpecificComp();
        
    }

    private void setupNewSpecificComp(){
        nocpCompetencySubtype = new NocpCompetencySubtype();

        // This ID is temporary, and is used to compare  objects
        nocpCompetencySubtype.setId(new Date().getTime());
        nocpCompetencySubtype.setNocpGeneralCompetencyId(new NocpCompetencyType());
    }
      
    /**
     * Adds a new record
     */
    public String add() {
        // remove the temporary ID
        nocpCompetencySubtype.setId(null);
        nullify();

        try {
            nocpCompetencySubtypeFacade.create(nocpCompetencySubtype);
            nocpCompetencySubtype.setNocpGeneralCompetencyId(nocpCompetencyTypeFacade.find(nocpCompetencySubtype.getNocpGeneralCompetencyId().getId()));
            allNocpCompetencySubtypes.add(0,nocpCompetencySubtype);
            addInfoMessage("Add Successful");
            droplists.initNocpSubtypes();
            //TODO - not sure why the make new is called just below.
            setupNewSpecificComp();
        }catch(FacadeException e){
            if(e.getExceptionClass()!=null&&e.getExceptionClass().getSimpleName().equals("PersistenceException")){
                addErrorMessage("Error encountered during add:");
                    addErrorMessage(" Check that the entry does not already exist" );
                    addErrorMessage(" Verify all chosen data values");
                    addErrorMessage(" or try again by leaving the page and returning" );
            }else{
                addErrorMessage("Error encountered during add. Cannot add record with code"+nocpCompetencySubtype.getSubtypeCompetencyCode()+" and name:"+nocpCompetencySubtype.getSubtypeCompetencyName());
            }
        }catch(Exception e){
            addErrorMessage("Error encountered. Cannot add record with code"+nocpCompetencySubtype.getSubtypeCompetencyCode()+" and name:"+nocpCompetencySubtype.getSubtypeCompetencyName());
            log.log(Level.WARNING, "Unable to add record {0}", e.getMessage());
        }
        return clear();
    }

    /**
     * Updates an existing record
     */
    public String update() {
        nullify();
        nocpCompetencySubtype.setNocpGeneralCompetencyId(new NocpCompetencyType(nocpCompetencySubtype.getNocpGeneralCompetencyId().getId()));
        NocpCompetencySubtype replacement = null;
        nocpCompetencySubtype.getNocpGeneralCompetencyId();
        nocpCompetencySubtype.getNocpGeneralCompetencyId().getCompetencyName();
        try{
            replacement =nocpCompetencySubtypeFacade.edit(nocpCompetencySubtype);
            addInfoMessage("Update Successful");
            droplists.initNocpSubtypes();
        }catch(Exception e){
            addErrorMessage("Update Failed.");
            log.log(Level.WARNING, "Unable to update record: {0}", e.getMessage());
        }
        if(replacement!=null){
            try{
                int index = allNocpCompetencySubtypes.indexOf(nocpCompetencySubtype);
                try{
                    allNocpCompetencySubtypes.set(index, replacement);
                }catch(Exception e){
                    init();
                }
            }catch(Exception e){
                log.log(Level.SEVERE, "Unable to replace updated record: {0}", e.getMessage());
            }
        }
        return clear();
    }

    /**
     * Deletes a record
     */
    public String delete() {
        nullify();
        try {
            nocpCompetencySubtypeFacade.remove(nocpCompetencySubtype);
            boolean worked = allNocpCompetencySubtypes.remove(nocpCompetencySubtype);
            
            if(!worked){
                 init();
            }
           
            addInfoMessage("Remove Successful");
            droplists.initNocpSubtypes();
        }catch(Exception e){
            addInfoMessage("Remove Failed");
            addErrorMessage("Error encountered. Cannot delete record with code"+nocpCompetencySubtype.getSubtypeCompetencyCode()+" and name:"+nocpCompetencySubtype.getSubtypeCompetencyName());
            log.log(Level.WARNING, "Unable to delete record {0}", e.getMessage());
        }
        return clear();
    }

    /**
     * Clears the form
     */
    public String clear() {
        //covers if just after add/update
        if (nocpCompetencySubtype.getNocpGeneralCompetencyId() == null) {
            nocpCompetencySubtype.setNocpGeneralCompetencyId(new NocpCompetencyType());
        }
        setupNewSpecificComp();
        return null;
    }

    /**
     * Selects a record for editing
     */
    public String select() {
        //doesn't need to do anything as doesn't drop from list
        return null;
    }

    /**
     * Nullifies any parent records where proper PKs aren't set
     */
    private void nullify() {
        if (nocpCompetencySubtype.getNocpGeneralCompetencyId() != null && nocpCompetencySubtype.getNocpGeneralCompetencyId().getId() == null) {
            nocpCompetencySubtype.setNocpGeneralCompetencyId(null);
        }
    }
    /*
     * Getters and Setters
     */

    public List<NocpCompetencySubtype> getAllNocpCompetencySubtypes() {
        return allNocpCompetencySubtypes;
    }

    public void setAllNocpCompetencySubtypes(List<NocpCompetencySubtype> allNocpCompetencySubtypes) {
        this.allNocpCompetencySubtypes = allNocpCompetencySubtypes;
    }

    public NocpCompetencySubtype getNocpCompetencySubtype() {
        return nocpCompetencySubtype;
    }

    public void setNocpCompetencySubtype(NocpCompetencySubtype nocpCompetencySubtype) {
        this.nocpCompetencySubtype = nocpCompetencySubtype;
    }
    
    //Required due to ManagedProperty above
    public void setDroplists(Droplists droplists) {
        this.droplists = droplists;
    }
}