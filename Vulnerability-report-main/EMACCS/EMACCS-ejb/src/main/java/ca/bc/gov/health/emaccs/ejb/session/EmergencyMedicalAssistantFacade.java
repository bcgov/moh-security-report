/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        EmergencyMedicalAssistantFacade.java           *
 * Date of Last Commit: $Date:: 2016-12-19 10:04:18 -0800 (Mon, 19 Dec 2016) $ *
 * Revision Number:      $Rev:: 2669                                         $ *
 * Last Commit by:    $Author:: tschiavo                                     $ *
 *                                                                             *
 *******************************************************************************/

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.emaccs.ejb.session;

import ca.bc.gov.health.emaccs.ejb.entity.EmergencyMedicalAssistant;
import static ca.bc.gov.health.util.Constants.ROLE_EMA;
import static ca.bc.gov.health.util.Constants.ROLE_NONE;
import jakarta.ejb.Stateless;
import jakarta.ejb.TransactionAttribute;
import jakarta.ejb.TransactionAttributeType;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;
import jakarta.persistence.TypedQuery;
import java.io.Serializable;
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author greg.perkins
 */
@Stateless
public class EmergencyMedicalAssistantFacade extends AbstractFacade<EmergencyMedicalAssistant> implements EmergencyMedicalAssistantFacadeLocal, Serializable {

    private static final long serialVersionUID = 1L;
    private static final String CLASS_NAME = EmergencyMedicalAssistantFacade.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);

    @PersistenceContext(unitName = "EMACCS-ejbPU")
    private EntityManager em;

    @Override
    protected EntityManager getEntityManager() {
        return em;
    }

    public EmergencyMedicalAssistantFacade() {
        super(EmergencyMedicalAssistant.class);
    }

    @Override
    public EmergencyMedicalAssistant findByLicenceNo(Long licenceNo) throws NoResultException {
        Query q = em.createNativeQuery("SELECT * FROM REGIS e WHERE licno = ?1", EmergencyMedicalAssistant.class);
        q.setParameter(1, licenceNo);
        EmergencyMedicalAssistant res = null;
        try {
            res = (EmergencyMedicalAssistant) q.getSingleResult();
        } catch (Exception e) {
            log.log(Level.WARNING, "Failure finding by LicenceNo due to {0} with message: {1}", new Object[]{e.getClass().getSimpleName(), e.getMessage()});
        }
        return res;
    }

    @Override
    public EmergencyMedicalAssistant findByRegisId(Long regisId) throws NoResultException {
        Query q = em.createNativeQuery("SELECT * FROM REGIS e WHERE regis_id = ?1", EmergencyMedicalAssistant.class);
        q.setParameter(1, regisId);
        EmergencyMedicalAssistant res = null;
        try {
            res = (EmergencyMedicalAssistant) q.getSingleResult();
        } catch (Exception e) {
            log.log(Level.WARNING, "Failure finding by LicenceNo due to {0} with message: {1}", new Object[]{e.getClass().getSimpleName(), e.getMessage()});
        }
        return res;
    }

    @Override
    public boolean isValidEma(String licNo) {
        Query q = em.createNativeQuery("select count(*) from REGIS r inner join QUAL q on q.REGIS_ID = r.REGIS_ID where r.LICNO = ? and q.ISCURRENT = '-1' and (q.QCODE in ('L20','L22','L30','L32','L40','43','L50','L60') or r.STATUS='S13')");

        q.setParameter(1, licNo);
        BigDecimal count;
        try {
            count = (BigDecimal) q.getSingleResult();
        } catch (Exception e) {
            //if more than a single result is returned catch it
            return false;
        }
        if (count == null) {
            return false;
        } else if (count.intValue() == 1) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    public boolean isStudentEma(String licNo) {
        Query q = em.createNativeQuery("select count(*) from REGIS r  where r.LICNO = ? and r.STATUS='S13'");
        q.setParameter(1, licNo);
        BigDecimal count;
        try {
            count = (BigDecimal) q.getSingleResult();
        } catch (Exception e) {
            //if more than a single result is returned catch it
            return false;
        }
        if (count == null) {
            return false;
        } else if (count.intValue() == 1) {
            return true;
        } else {
            return false;
        }
    }

    /* 
    *  exempt EMA?
     */
    @Override
    public boolean isExemptEMA(Long reportingYearId, String Licno) {
        Query queryAllActive = em.createNativeQuery("select count(distinct r.licno)"
                + " from regis r"
                + " left outer join cmedat cdat on cdat.regis_id = r.regis_id"
                + " where r.licno = ?1"
                + " and ((r.status = 'S13' and ?2 = (select id from ema_codes_reporting_years where reporting_year like case when  sysdate >= to_date(concat('01-04-',to_char( sysdate, 'YYYY')),'dd-mm-yyyy') then concat(to_char(sysdate, 'YYYY'),'/%') else concat('%/',to_char(sysdate, 'YYYY')) end))"
                + " or (cdat.reportyr = ?2 and cdat.ccode = 'T300'))");

        queryAllActive.setParameter(1, Licno);
        queryAllActive.setParameter(2, reportingYearId);

        BigDecimal count;
        try {
            count = (BigDecimal) queryAllActive.getSingleResult();
        } catch (Exception e) {
            return false;
        }
        if (count == null) {
            return false;
        } else if (count.intValue() == 1) {
            return true;
        } else {
            return false;
        }
    }

    /* 
    *  exempt EMA?
     */
    @Override
    public boolean isInShortfall(Long reportingYearId, String Licno) {
        Query queryAllActive = em.createNativeQuery("select count(distinct r.LICNO)"
                + " from REGIS r"
                + " inner join cmedat cme"
                + " on cme.REGIS_ID = r.REGIS_ID"
                + " inner join lkcmedat lkcme on lkcme.ccode = cme.ccode"
                + " where cme.reportyr = ?1"
                + " and r.licno= ?2"
                + " and (lkcme.cdesc ='IN SHORTFALL' or lkcme.cdesc ='IN SHORTFALL - ADJUDICATED')");
        queryAllActive.setParameter(1, reportingYearId);
        queryAllActive.setParameter(2, Licno);
        BigDecimal count;
        try {
            count = (BigDecimal) queryAllActive.getSingleResult();
        } catch (Exception e) {
            return false;
        }
        if (count == null) {
            return false;
        } else if (count.intValue() == 1) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    public boolean isPendingAdjudication(Long reportingYearId, String Licno) {
        Query queryAllActive = em.createNativeQuery("select count(distinct r.LICNO)"
                + " from REGIS r"
                + " inner join cmedat cme"
                + " on cme.REGIS_ID = r.REGIS_ID"
                + " inner join lkcmedat lkcme on lkcme.ccode = cme.ccode"
                + " where cme.reportyr =?1"
                + " and r.licno=?2"
                + " and lkcme.cdesc ='PENDING ADJUDICATION'");
        queryAllActive.setParameter(1, reportingYearId);
        queryAllActive.setParameter(2, Licno);
        BigDecimal count;
        try {
            count = (BigDecimal) queryAllActive.getSingleResult();
        } catch (Exception e) {
            return false;
        }
        if (count == null) {
            return false;
        } else if (count.intValue() == 1) {
            return true;
        } else {
            return false;
        }
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    @Override
    public boolean isInactive(String Licno) {
        boolean noAccess = isNoAccess(Licno);
        if (noAccess) {
            return true;
        }
        //--inactive
        Query queryAllActive = em.createNativeQuery(
                //--status means no
                " select 'Licence '|| r.licno|| ' is inactive with status '||lkw.lkw_desc ||' and ' ||lkq.qdesc as reason"
                + " from qual q"
                + " join lkqual lkq on  lkq.qcode = q.qcode"
                + " join regis r on r.regis_id = q.regis_id"
                + " join lkwsg lkw on  lkw.wsgcode = r.status"
                + " where r.licno = ?1"
                + " and r.status in('S12', 'S22', 'S40', 'S41', 'S90', 'S99')"
                + " and q.iscurrent = -1"
                + " and q.qcode like 'L%'");

        queryAllActive.setParameter(1, Licno);
        List all;
        try {
            all = queryAllActive.getResultList();
        } catch (Exception e) {
            log.log(Level.WARNING, "Failure finding inactivity due to {0} with message: {1}", new Object[]{e.getClass().getSimpleName(), e.getMessage()});
            return false;
        }
        //the search actually returns a description of why they are null for logging.
        if (all == null || all.isEmpty()) {
            return false;
        } else {
            log.log(Level.WARNING, all.get(0).toString());
            return true;
        }
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    @Override
    public boolean isNoAccess(String Licno) {
        //--inactive
        Query queryAllActive = em.createNativeQuery("select 'Licence '|| r.licno|| ' has expired as of '|| to_char(q.licexpdt,'Mon DD, YYYY') as reason"
                + " from qual q"
                + " join regis r on r.regis_id = q.regis_id"
                + " where r.licno = ?1"
                + " and q.iscurrent = -1"
                + " and q.licexpdt <= sysdate"
                + " union"
                //--suspended
                + " select 'Licence '|| r.licno|| ' has been suspended as of '|| to_char(q.enddate,'Mon DD, YYYY') as reason"
                + " from qual q"
                + " join regis r on r.regis_id = q.regis_id"
                + " where r.licno = ?1"
                + " and q.iscurrent = -1"
                + " and q.enddate is not null and q.enddate <= sysdate");

        queryAllActive.setParameter(1, Licno);
        List all;
        try {
            all = queryAllActive.getResultList();
        } catch (Exception e) {
            log.log(Level.WARNING, "Failure finding NoAccess due to {0} with message: {1}", new Object[]{e.getClass().getSimpleName(), e.getMessage()});
            return false;
        }
        //the search actually returns a description of why they are null for logging.
        if (all == null || all.isEmpty()) {
            return false;
        } else {
            log.log(Level.WARNING, all.get(0).toString());
            return true;
        }
    }

    @Override
    public List<EmergencyMedicalAssistant> find(String userName, String firstName, String lastName,
            String licenseNo, boolean includeAllNoneEma) {
        // Filter out empty licence, empty role, other roles besides EMA, none
        StringBuilder sb = new StringBuilder();
        sb.append("select ema from EmergencyMedicalAssistant ema where");
        sb.append(" ema.licno is not null");
        sb.append(" and ema.role is not null and ema.role in :roles");
        sb.append(" and (:userName is null or upper(ema.userId) = upper(:userName))");
        sb.append(" and (:fname is null or upper(ema.fname) = upper(:fname))");
        sb.append(" and (:lname is null or upper(ema.lname) = upper(:lname))");
        sb.append(" and (:licno is null or upper(ema.licno) = upper(:licno))");

        if (includeAllNoneEma) {
            sb.append("and ema.role = :role");
        }
        TypedQuery<EmergencyMedicalAssistant> query = em.createQuery(sb.toString(), EmergencyMedicalAssistant.class);
        query.setParameter("roles", Arrays.asList(new String[]{ROLE_EMA, ROLE_NONE}));
        query.setParameter("userName", userName);
        query.setParameter("fname", firstName);
        query.setParameter("lname", lastName);
        query.setParameter("licno", licenseNo);
        if (includeAllNoneEma) {
            query.setParameter("role", ROLE_NONE);
        }

        return query.getResultList();
    }

    @Override
    public EmergencyMedicalAssistant findByUserGuid(String userGuid) {
        TypedQuery<EmergencyMedicalAssistant> query = em.createQuery("select ema from EmergencyMedicalAssistant ema where ema.userGuid = :userGuid", EmergencyMedicalAssistant.class);
        query.setParameter("userGuid", userGuid);

        EmergencyMedicalAssistant ema = null;
        List<EmergencyMedicalAssistant> emas = query.getResultList();
        if (!emas.isEmpty()) {
            ema = emas.get(0);
        }
        return ema;
    }

}
