/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        ActivityTypeFacade.java                        *
 * Date of Last Commit: $Date:: 2016-12-19 10:04:18 -0800 (Mon, 19 Dec 2016) $ *
 * Revision Number:      $Rev:: 2669                                         $ *
 * Last Commit by:    $Author:: tschiavo                                     $ *
 *                                                                             *
 *******************************************************************************/

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.emaccs.ejb.session;

import ca.bc.gov.health.ejb.exception.FacadeException;
import ca.bc.gov.health.emaccs.ejb.entity.ActivityNocpArea;
import ca.bc.gov.health.emaccs.ejb.entity.ActivityNocpCompSubtype;
import ca.bc.gov.health.emaccs.ejb.entity.ActivityNocpCompType;
import ca.bc.gov.health.emaccs.ejb.entity.ActivityType;
import jakarta.annotation.Resource;
import jakarta.ejb.EJB;
import jakarta.ejb.Stateless;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.DataSource;

/**
 *
 * @author greg.perkins
 */
@Stateless
public class ActivityTypeFacade extends AbstractFacade<ActivityType> implements ActivityTypeFacadeLocal, Serializable {
    @PersistenceContext(unitName = "EMACCS-ejbPU")
    private EntityManager em;

    @EJB
    ActivityNocpAreaFacadeLocal activityNocpAreaFacade;
    @EJB
    ActivityNocpCompTypeFacadeLocal activityNocpCompTypeFacade;
    @EJB
    ActivityNocpCompSubtypeFacadeLocal activityNocpCompSubtypeFacade;

    private static final String CLASS_NAME = ActivityTypeFacade.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);
    /**
     * Data source injected to execute the update statement
     */
    @Resource(lookup = "java:app/jdbc/EMA")
    private DataSource ds;    
    
    @Override
    protected EntityManager getEntityManager() {
        return em;
    }

    public ActivityTypeFacade() {
        super(ActivityType.class);
    }
    
    /* Default Activity Type query with ordering by code */
    @Override
    public List<ActivityType> findAll() {
        Query query = em.createNativeQuery("select * from EMA_CODES_ACTIVITY_TYPES a" +
                " order by a.activity_code",
                ActivityType.class);
        
        return query.getResultList();
    }
    
    @Override
    public List<ActivityType> findEnabled() {
        
        List<ActivityType> enabledActivities;   
        Query q = em.createNamedQuery("ActivityType.findEnabled");
        enabledActivities = q.getResultList();
        
        return enabledActivities;
                
    }

    @Override
    public void deleteChildren(List children) {
        for (Object o: children){
            em.remove(em.merge(o));
        }
    }

    @Override
    public ActivityType edit(ActivityType activityType){
        //TODO make transactional - or at least confirm it's transacitonal
        try{
         ActivityType orig=   this.find(activityType.getId());
        
        List<ActivityNocpArea> editedAreaList = activityType.getActivityNocpAreaList();
        List<ActivityNocpCompType> editedTypeList =         activityType.getActivityNocpCompTypeList();
        List<ActivityNocpCompSubtype> editedSubTypeList = activityType.getActivityNocpCompSubtypeList();
        
        List<ActivityNocpArea>origAreaList = new ArrayList(orig.getActivityNocpAreaList());
        List<ActivityNocpCompType> origTypeList=  new ArrayList(orig.getActivityNocpCompTypeList());
        List<ActivityNocpCompSubtype> origSubTypeList = new ArrayList(orig.getActivityNocpCompSubtypeList());
        //Determine which to remove
        origAreaList.removeAll(editedAreaList);
        origTypeList.removeAll(editedTypeList);
        origSubTypeList.removeAll(editedSubTypeList);
        
        //Determine which to add
        editedAreaList.removeAll(orig.getActivityNocpAreaList());
        editedTypeList.removeAll(orig.getActivityNocpCompTypeList());
        editedSubTypeList.removeAll(orig.getActivityNocpCompSubtypeList());
                
        //if the original list still contains something then delete it as it was removed.
        for(ActivityNocpArea toCheck:origAreaList){
            activityNocpAreaFacade.remove(activityNocpAreaFacade.refresh(toCheck));
        }
        for(ActivityNocpCompType toCheck:origTypeList){
            activityNocpCompTypeFacade.remove(activityNocpCompTypeFacade.refresh(toCheck));
        }
        for(ActivityNocpCompSubtype toCheck:origSubTypeList){
            activityNocpCompSubtypeFacade.remove(activityNocpCompSubtypeFacade.refresh(toCheck));
        }
        }catch( Exception e){
            log.log(Level.SEVERE, "Error during preprosessing in edit{0}", e.getMessage());
            FacadeException messageToUser = new FacadeException(e, e.getClass());
             throw messageToUser;
        }
        ActivityType toReturn = null;
        try{
            toReturn =super.edit(activityType);
        }catch(FacadeException e){
             log.log(Level.SEVERE, "Error during ActivityType edit - logged above");
             throw e;
        }catch(Exception e){
            log.log(Level.SEVERE, "Error during ActivityType edit{0}", e.getMessage());
            FacadeException messageToUser = new FacadeException(e, e.getClass());
             throw messageToUser;
        }
        //if it edited list still contains something add it as they're new
        
        return toReturn;
    }
    
}
