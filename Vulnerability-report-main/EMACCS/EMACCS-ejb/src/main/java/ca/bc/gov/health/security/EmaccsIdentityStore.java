package ca.bc.gov.health.security;

import static ca.bc.gov.health.util.Constants.CLAIM_SITEMINDER_GUID;
import static ca.bc.gov.health.util.Constants.ROLE_UNKNOWN;

import java.util.HashSet;
import java.util.Set;

import ca.bc.gov.health.emaccs.ejb.entity.EmergencyMedicalAssistant;
import ca.bc.gov.health.emaccs.ejb.session.EmergencyMedicalAssistantFacadeLocal;
import ca.bc.gov.health.util.SecurityUtil;
import fish.payara.security.openid.OpenIdCredential;
import fish.payara.security.openid.OpenIdIdentityStore;
import fish.payara.security.openid.api.AccessToken;
import fish.payara.security.openid.api.OpenIdContext;
import jakarta.annotation.Priority;
import jakarta.ejb.EJB;
import jakarta.enterprise.inject.Alternative;
import jakarta.inject.Inject;
import jakarta.security.enterprise.CallerPrincipal;
import jakarta.security.enterprise.identitystore.CredentialValidationResult;

/**
 * Customized EMACCS specific implementation of a JSR375 <code>IdentityStore</code> for database authorizations.
 * Modified from HoopcIdentityStore
 *
 * @see <a href="https://javaee.github.io/security-spec/">JSR 375</a>
 * @author CGI Information Management Consultants Inc.
 */
@Alternative
@Priority(Integer.MAX_VALUE)
public class EmaccsIdentityStore extends OpenIdIdentityStore {

    private static final int PRIORITY = 80;

    @EJB
    private EmergencyMedicalAssistantFacadeLocal emaFacade;

    @Inject
    private OpenIdContext context;

    /**
     * Override IdentityStore priority()
     *
     * @return
     */
    @Override
    public int priority() {
        return PRIORITY;
    }

    /**
     * Override OpenIdIdentityStore validate() to further validate OpenIdCredential against the database
     *
     * @param credential - JSR375 object holding the access token
     * @see <a href="https://javaee.github.io/security-spec/">JSR 375</a>
     * @return CredentialValidationResult - JSR375 object holding the AuthenticationStatus
     */
    @Override
    public CredentialValidationResult validate(OpenIdCredential credential) {

        /* Validate against Keycloak */
        CredentialValidationResult credentialValidationResult = super.validate(credential);

        return new CredentialValidationResult(credentialValidationResult.getCallerPrincipal(),
                loadUserRoles(credentialValidationResult.getCallerPrincipal()));
    }

    /**
     * Return the role stored in the database
     *
     * @param callerPrincipal
     * @return the role associated with the caller from the identity store
     */
    private Set<String> loadUserRoles(CallerPrincipal callerPrincipal) {

        AccessToken token = context.getAccessToken();

        String siteminderGuid = token.getJwtClaims().getStringClaim(CLAIM_SITEMINDER_GUID).get();

        Set<String> roles = new HashSet<String>(SecurityUtil.loadKeycloakRoles(token));

        if (!roles.isEmpty()) {
            return roles;
        }

        // No admin roles in Keycloak - lookup the EMA by guid
        EmergencyMedicalAssistant ema = emaFacade.findByUserGuid(siteminderGuid);

        if (ema != null) {
            roles.add(ema.getRole());
        } else {
            roles.add(ROLE_UNKNOWN);
        }
        return roles;
    }
}
