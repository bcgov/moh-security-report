/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        NewYearBatch.java                              *
 * Date of Last Commit: $Date:: 2018-04-03 07:42:01 -0700 (Tue, 03 Apr 2018) $ *
 * Revision Number:      $Rev:: 2921                                         $ *
 * Last Commit by:    $Author:: cgrebic                                      $ *
 *                                                                             *
 *******************************************************************************/
package ca.bc.gov.health.emaccs.ejb.session.batch;

import ca.bc.gov.health.emaccs.ejb.session.email.EmailFacadeLocal;
import jakarta.annotation.Resource;
import jakarta.ejb.EJB;
import jakarta.ejb.Lock;
import jakarta.ejb.LockType;
import jakarta.ejb.Schedule;
import jakarta.ejb.Schedules;
import jakarta.ejb.Singleton;
import jakarta.ejb.Startup;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.DataSource;

/**
 *
 * @author joshua.lewis
 */
@Singleton
@Startup
@Lock(LockType.READ)
public class NewYearBatch implements Serializable {

    @EJB
    private EmailFacadeLocal emailFacade;
// Queries
    private final String findReportingYearId = "select ID from EMA_CODES_REPORTING_YEARS where REPORTING_YEAR = ?";

    private final String ccCodeQuery = "select distinct REGIS_ID, LICNO"
            + " from CMEDAT "
            + " where REPORTYR = ?"
            + " and CCODE = ?";
    private final String noQuals = "select distinct r.REGIS_ID, r.LICNO"
            + " from REGIS r"
            + " left outer join QUAL q"
            + " on q.REGIS_ID = r.REGIS_ID"
            + " where q.REGIS_ID is null"
            + " and r.STATUS not in ('S12','S22','S40','S41','S90','S99')";
    private final String noCurrentQuals = "select distinct regis_id, licno from regis r where r.regis_id in ("
            + " select distinct r.regis_id from regis r where r.STATUS not in ('S12','S22','S40','S41','S90','S99')"
            + " minus"
            + " select distinct r.regis_id from regis r"
            + " left outer join qual q"
            + " on q.regis_id = r.regis_id"
            + " where q.regis_id is null or q.iscurrent = -1"
            + " )";
    private final String multiCMEForYear = "select regis_id,licno, reportyr, theCount"
            + " from("
            + " select regis_id,licno, reportyr, count(regis_id) theCount "
            + " from cmedat "
            + " where reportyr != ?"
            + " group by regis_id,licno,reportyr"
            + " ) where theCount >1";
    private final String multiCMEForSpecificYear = "select regis_id, licno, reportyr, theCount"
            + " from("
            + " select regis_id,licno, reportyr, count(regis_id) theCount "
            + " from cmedat "
            + " where reportyr = ?"
            + " group by regis_id,licno,reportyr"
            + " ) where theCount >1";

// Insert statements
    private final String insertCcExempt
            = "insert into CMEDAT (CCODE, REGIS_ID, LICNO, REPORTYR, STATELESS_TRANSACTION_NBR, CMEDATE, STATUS_DATE, CMECOMPLET, CMEREQUIRD)"
            + " ("
            + " select distinct ?, r.REGIS_ID, r.LICNO, ?, '1', to_date(?, 'yyyy-MM-dd'), to_date(?, 'yyyy-MM-dd'), '-1', '0'"
            + " from REGIS R"
            + " where r.status = 'S13')";
    private final String insertShortfall
            = "insert into CMEDAT (CCODE, REGIS_ID, LICNO, REPORTYR, STATELESS_TRANSACTION_NBR, CMEDATE, STATUS_DATE, CMECOMPLET, CMEREQUIRD)"
            + " ("
            + " select distinct ?, r.REGIS_ID, r.LICNO, ?, '1', to_date(?, 'yyyy-MM-dd'), to_date(?, 'yyyy-MM-dd'), '0', '-1'"
            + " from REGIS R"
            + " inner join QUAL Q"
            + " on q.REGIS_ID = r.REGIS_ID"
            + " where q.QCODE in ('L20','L22','L30','L32','L40','43','L50','L60')"
            + " and r.STATUS not in ('S12','S13','S22','S40','S41','S90','S99')"
            + " and q.LICEXPDT >= (current_date - 365)"
            + " and q.ISCURRENT = -1"
            + " )";

    /**
     * Data source injected to execute the update statement
     */
    @Resource(lookup = "java:app/jdbc/EMA")
    private DataSource ds;
    private static final String CLASS_NAME = NewYearBatch.class.getName();
    private static final Logger logger = Logger.getLogger(CLASS_NAME);
    //TODO - This error string is not built or used correctly, really should be fixed.
    private String errStr = "";
    private String todayDateStr;

    /**
     * Run the New Year Batch Job at the first second of April every year
     */
    @Schedules({
        //@Schedule(year = "2015", month = "Apr", dayOfMonth = "09", hour = "08", minute = "00", second = "01", timezone = "PST"), // for testing
        @Schedule(year = "*", month = "May", dayOfMonth = "15", hour = "00", minute = "00", second = "01", timezone = "PST")
    })
    @Lock(LockType.WRITE)
    public void startNewYearBatchJob() {

        java.util.Date utilDate = new java.util.Date();
        logger.info("Starting New Year Batch process starts at: " + utilDate);

        Connection conn = null;
        PreparedStatement pstmt = null;
        todayDateStr = getCurrentYearStr() + "-04-01";
        Date startTime = new Date(System.currentTimeMillis());
        StringBuilder finalOutput = new StringBuilder(1024);
        String status = "pass";
        Long reportingYearId = getReportingYearId();

        boolean sentSuccessful = false;
        long start = System.currentTimeMillis();
        try {

            if (reportingYearId == null) {
                logger.log(Level.SEVERE, "Retrieval of reporting year failed (null returned) - batch process stopped");
                finalOutput.append("Retrieval of reporting year failed - batch process stopped");
                status = "fail";
                return;
            }

            conn = ds.getConnection();

            // The next two lines call the methods for writing to the database
            finalOutput.append(recordExempt(reportingYearId, conn));
            finalOutput.append(recordShortfall(reportingYearId, conn));

            finalOutput.append("\n\nData Quality checks\n");
            finalOutput.append("All EMA who had multiple CMEDAT entries  for this reporting year\n");
            finalOutput.append(getEmaListFromCME(multiCMEForSpecificYear, reportingYearId, conn));
            finalOutput.append("\n\nAll EMA who have a multiple CMEDAT entries for other reporting year\n");
            finalOutput.append(getEmaListFromCME(multiCMEForYear, reportingYearId, conn));
            finalOutput.append(getEmaListOfQualifications(noCurrentQuals, "EMA IDs and Licence numbers of EMA without an isCurrent Qual", conn));
            finalOutput.append(getEmaListOfQualifications(noQuals, "EMA IDs and Licence numbers of EMA with no Qual:", conn));
        } catch (Exception ignore) {
            // failed to create connection
            status = "fail";
        } finally {
            try {
                if (errStr.isEmpty()) {
                    if (conn != null) {
                        conn.commit();
                    }
                } else {
                    logger.severe(errStr);
                    if (conn != null) {
                        conn.rollback();
                    }
                    status = "fail";
                }

            } catch (SQLException ignore) {
                //failed to commit or rollback
                logger.log(Level.SEVERE, "Batch process encountered: {0}", ignore.getMessage());
                status = "fail";
            } finally {
                try {
                    // do logging
                    String results = finalOutput.toString();
                    try {
                        if (conn == null) {
                            conn = ds.getConnection();
                        }
                        logBatchResults(startTime, status, (results).getBytes(), conn);

                        // now send out an email!
                        //sendNotificationEmail(results,conn);
                        sentSuccessful = emailFacade.sendNewYearBatch(results);
                        if (!sentSuccessful) {
                            logger.warning("Failure in email sending detected");
                        }
                    } catch (Exception e) {
                        logger.log(Level.SEVERE, "Batch process encountered: {0}", e.getMessage());
                    }
                } finally {
                    try {
                        if (pstmt != null) {
                            pstmt.close();
                        }
                    } catch (Exception e) {
                    }
                    try {
                        if (conn != null) {
                            conn.close();
                        }
                    } catch (Exception e) {
                    }
                }
            }
        }

        if (sentSuccessful) {
            logger.info("New Year Batch process completed successfully in " + (System.currentTimeMillis() - start) + " ms ");
        } else {
            logger.warning("New Year Batch process failed.");
        }

    }

    /**
     * *
     * records into CMEDAT all exempt EMA for the new year
     *
     * @param reportingYearId - the reporting year to insert records for
     * @return a string recording all the results
     * @throws SQLException
     * @throws Exception
     */
    private String recordExempt(Long reportingYearId, Connection conn) throws SQLException, Exception {
        String output;
        String exemptCCode = "T300";
        PreparedStatement pstmt = null;
        try {
            pstmt = conn.prepareStatement(insertCcExempt);
            pstmt.setString(1, exemptCCode);
            pstmt.setLong(2, reportingYearId);
            pstmt.setString(3, todayDateStr);
            pstmt.setString(4, todayDateStr);
            output = Integer.toString(pstmt.executeUpdate());
            logger.log(Level.INFO, "{0} records of exemt EMA are inserted into EMA.CMEDAT table.", output);

            output = String.format("%s %s %s%n%s%n",
                    "Insert for CC Exempt EMAs resulted in",
                    output,
                    "records.",
                    "The statement completed successfully.");
            output = output + getEmaList(ccCodeQuery, exemptCCode, reportingYearId, conn);

        } catch (SQLException sqle) {
            // Record information about this exception
            output = sqle.getMessage();
            logger.severe(output);
            errStr = String.format("%s %s%n", errStr, "New Year Batch process failed while inserting CC Exempt EMAs. (SQL Error)");
            output = String.format("%s%n%s%n", errStr, output);

        } catch (Exception ex) {
            // Record information about this exception
            output = ex.getMessage();
            logger.severe(output);
            errStr = String.format("%s %s%n", errStr, "New Year Batch process failed while inserting CC Exempt EMAs. (non-SQL Error");
            output = String.format("%s%n%s%n", errStr, output);
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            //Do not close connection it's acquired from the method which calls this
        }
        logger.log(Level.INFO, "Result of recordExempt(): {0}", output);
        return output;
    }

    /**
     * *
     * records into CMEDAT all shortfall EMA for the new year
     *
     * @param reportingYearId - the reporting year to insert records for
     * @return a string recording all the results
     * @throws SQLException
     * @throws Exception
     */
    private String recordShortfall(Long reportingYearId, Connection conn) throws SQLException, Exception {
        String output;
        PreparedStatement pstmt = null;
        String shortfallCCode = "T301";
        try {
            pstmt = conn.prepareStatement(insertShortfall);
            pstmt.setString(1, shortfallCCode);
            pstmt.setLong(2, reportingYearId);
            pstmt.setString(3, todayDateStr);
            pstmt.setString(4, todayDateStr);
            output = Integer.toString(pstmt.executeUpdate());
            logger.log(Level.INFO, "{0} records of shortfall EMA are inserted into EMA.CMEDAT table.", output);

            output = String.format("%s %s %s%n%s%n",
                    "Insert for EMAs in shortfall resulted in",
                    output,
                    "records.",
                    "The statement completed successfully.");
            output = output + getEmaList(ccCodeQuery, shortfallCCode, reportingYearId, conn);
        } catch (SQLException sqle) {
            // Record information about this exception
            output = sqle.getMessage();
            logger.severe(output);
            errStr = String.format("%s %s%n", errStr, "New Year Batch process failed while inserting non CC Exempt.");
            output = String.format("%s %s%n", errStr, output);

        } catch (Exception ex) {
            // Record information about this exception
            output = ex.getMessage();
            logger.severe(output);
            errStr = String.format("%s %s%n", errStr, "New Year Batch process failed while inserting non CC Exempt. (non-SQL Error");
            output = String.format("%s%n%s%n", errStr, output);
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            //Do not close connection it's acquired from the method which calls this
        }
        logger.log(Level.INFO, "Result of recordShortfall(): {0}", output);
        return output;
    }

    /**
     * *
     *
     * @param query - the query to run
     * @param reportingYearId the option reporting year id
     * @return the results, formatted, of the search
     * @throws SQLException
     */
    private String getEmaListFromCME(String query, Long reportingYearId, Connection conn) throws SQLException {
        String output = "";
        PreparedStatement pstmt = null;
        ResultSet results = null;
        try {
            pstmt = conn.prepareStatement(query);
            if (reportingYearId != null) {
                pstmt.setLong(1, reportingYearId);
            }
            results = pstmt.executeQuery();
            if (results != null && results.next()) {
                output = String.format("%s%n%s, %s yr:%s - total:%s",
                        "EMA IDs, Licence numbers, reportingYearID and entries for that year recorded for this operation:",
                        results.getString(1), results.getString(2), results.getString(3), results.getString(4));

                while (results.next()) {
                    output = String.format("%s%n%s, %s yr:%s - total:%s",
                            output, results.getString(1), results.getString(2), results.getString(3), results.getString(4));
                }
            } else {
                output = String.format("%s%n", "There were no EMAs recorded for this operation.");
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, "problem getEmaListFromCME: {0}", e.getMessage());
        } finally {
            try {
                if (results != null) {
                    results.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            //Do not close connection it's acquired from the method which calls this
        }
        return String.format("%s%n", output);
    }

    /**
     * *
     *
     * @param query - the query to run
     * @param openingSentence - the opening sentence in the returned results
     * @return - a string containing all results
     * @throws SQLException
     */
    private String getEmaListOfQualifications(String query, String openingSentence, Connection conn) throws SQLException {
        String output = "";
        PreparedStatement pstmt = null;
        ResultSet results = null;
        try {
            pstmt = conn.prepareStatement(query);
            results = pstmt.executeQuery();
            if (results != null && results.next()) {
                output = String.format("%s%n%s, %s",
                        openingSentence,
                        results.getString(1), results.getString(2));

                while (results.next()) {
                    output = String.format("%s%n%s, %s",
                            output, results.getString(1), results.getString(2));
                }
            } else {
                output = String.format("%s%n", "There were no EMAs recorded for this operation.");
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, "problem getEmaListOfQualifications: {0}", e.getMessage());
        } finally {
            try {
                if (results != null) {
                    results.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            //Do not close connection it's acquired from the method which calls this
        }
        return String.format("%s%n", output);
    }

    private String getEmaList(String query, String cCode, Long reportingYearId, Connection conn) throws SQLException {
        String output = "";
        PreparedStatement pstmt = null;
        ResultSet results = null;
        try {
            pstmt = conn.prepareStatement(query);
            pstmt.setLong(1, reportingYearId);
            pstmt.setString(2, cCode);
            results = pstmt.executeQuery();
            if (results != null && results.next()) {
                output = String.format("%s%n%s, %s",
                        "EMA IDs and Licence numbers recorded for this operation:",
                        results.getString(1), results.getString(2));

                while (results.next()) {
                    output = String.format("%s%n%s, %s",
                            output, results.getString(1), results.getString(2));
                }
            } else {
                output = String.format("%s%n", "There were no EMAs recorded for this operation.");
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, "problem getting ema list: {0}", e.getMessage());
        } finally {
            try {
                if (results != null) {
                    results.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            //Do not close connection it's acquired from the method which calls this
        }
        return String.format("%s%n", output);
    }

    private void logBatchResults(Date startTime, String status, byte[] log, Connection conn) {
        Date endTime = new Date(System.currentTimeMillis());
        PreparedStatement pstmt = null;
        String insertLog = "insert into EMA_BATCH_JOB_LOG"
                + "(ID, JOB_TYPE, START_TIME, END_TIME, STATUS, JOB_LOG, CREATED_BY_NM, CREATED_ON_DTM)"
                + "VALUES (EMA_BATCH_JOB_LOG_SEQ.nextval, 'New Year Batch job', ?, ?, ?, ?, 'todo', sysdate)";
        String output;
        try {

            pstmt = conn.prepareStatement(insertLog);
            pstmt.setDate(1, startTime);
            pstmt.setDate(2, endTime);
            pstmt.setString(3, status);
            pstmt.setBytes(4, log);
            output = Integer.toString(pstmt.executeUpdate());
            logger.info(String.format("%s records inserted into the database EMA_BATCH_JOB_LOG table.", output));

            conn.commit();
        } catch (SQLException sqle) {
            output = String.format("logBatchResults Inserting to database log may have failed. Error: %s%n", sqle.getMessage());
            logger.log(Level.SEVERE, output);
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            //do not close connection
        }
    }

    /**
     * *
     * Gets the reporting year id. opens and closes it's own connection
     *
     * @return reporting year id or null
     */
    //TODO use reportingyearfacade - probalby the current year method..
    private Long getReportingYearId() {
        Long output = null;
        Connection conn = null;
        PreparedStatement pstmt = null;
        // set up for the upcoming year (this year, plus next year)
        String reportingYear = getReportingYearStr();
        ResultSet results = null;
        try {
            conn = ds.getConnection();
            pstmt = conn.prepareStatement(findReportingYearId);
            pstmt.setString(1, reportingYear);

            results = pstmt.executeQuery();

            if (results.next()) {
                output = results.getLong(1);
            }

        } catch (SQLException e1) {
            logger.log(Level.SEVERE, "problem getting reportingyearid: {0}", e1.getMessage());
            try {
                if (conn != null) {
                    conn.rollback();
                }
            } catch (SQLException e2) {
                //ignore
            }
        } finally {
            try {
                if (results != null) {
                    results.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (Exception e) {/*ignore*/
            }
            try {
                if (conn != null) {
                    conn.close();
                }
            } catch (Exception e) {/*ignore*/
            }
        }

        return output;
    }

    protected String getReportingYearStr() {
        Date today = new Date(System.currentTimeMillis());
        int year = today.getYear() + 1900;
        if (today.getMonth() < 3) {
            year--;
        }
        // set up for the upcoming year (this year, plus next year
        return (year) + "/" + (year + 1);
    }

    private String getCurrentYearStr() {
        Date today = new Date(System.currentTimeMillis());
        return Integer.toString(today.getYear() + 1900);
    }

}
