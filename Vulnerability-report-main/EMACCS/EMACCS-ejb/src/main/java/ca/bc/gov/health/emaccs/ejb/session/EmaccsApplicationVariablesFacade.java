/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        EmaccsApplicationVariablesFacade.java          *
 * Date of Last Commit: $Date::                                              $ *
 * Revision Number:      $Rev::                                              $ *
 * Last Commit by:    $Author::                                              $ *
 *                                                                             *
 *******************************************************************************/

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.emaccs.ejb.session;

import ca.bc.gov.health.emaccs.ejb.entity.ActivityType;
import ca.bc.gov.health.emaccs.ejb.entity.ReportingYear;
import jakarta.annotation.PostConstruct;
import jakarta.ejb.EJB;
import jakarta.ejb.Schedule;
import jakarta.ejb.Singleton;
import jakarta.ejb.Startup;
import jakarta.inject.Named;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Logger;

/**
 *
 * @author ian.scott
 */
@Singleton
@Startup
@Named("EmaccsVariables") //required
public class EmaccsApplicationVariablesFacade implements EmaccsApplicationVariablesFacadeLocal, Serializable {

    private static final String CLASS_NAME = EmaccsApplicationVariablesFacade.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);
    @EJB
    private ReportingYearFacadeLocal reportingYearFacade;
    @EJB
    private ActivityTypeFacadeLocal activityTypeFacade;

    //boolean setTracking
    //once a day
    HashMap<Long, Boolean> inExamPeriod = new HashMap<>();
    private Long currentReportingYearId = 00L;
    private String currentReportingYearStr = "";
    private Long previousReportingYearId = 00L;
    private String previousReportingYearStr = "";
    HashMap<Long, Boolean> inPendingAdj = new HashMap<>();
    HashMap<Long, Boolean> inShortfall = new HashMap<>();
    //regular
    private List<String> activityNames = new ArrayList();

    @PostConstruct
    void init() {
        activityNames = getActivityNames();
        currentReportingYearId = getCurrentReportingYearId();
        currentReportingYearStr = getCurrentReportingYearStr();
        previousReportingYearId = getPreviousReportingYearId();
        previousReportingYearStr = getPreviousReportingYearStr();
        List<ReportingYear> b = reportingYearFacade.findAll();
        for (ReportingYear aYear : b) {
            isAdjudicationPeriod(aYear.getId());
            isShortfallPeriod(aYear.getId());
            isExamPeriod(aYear.getId());
        }
    }

    //from base bean
    @Override
    public boolean isExamPeriod(Long reportingYearId) {
        if (reportingYearId == null) {
            return false;
        }
        Boolean answer = inExamPeriod.get(reportingYearId);
        boolean examPeriod;
        if (answer == null) {
            examPeriod = reportingYearFacade.isExamPeriod(reportingYearId);
            inExamPeriod.put(reportingYearId, examPeriod);
        } else {
            return answer.booleanValue();
        }
        return examPeriod;
    }

    @Override
    public void reportingYearUpdate(Long reportingYearId) {
        if (inExamPeriod.remove(reportingYearId) != null) {
            isExamPeriod(reportingYearId);
        }
        if (inPendingAdj.remove(reportingYearId) != null) {
            isAdjudicationPeriod(reportingYearId);
        }
        if (inShortfall.remove(reportingYearId) != null) {
            isShortfallPeriod(reportingYearId);
        }
    }

    /*
     * Returns the reporting year id for the current year
     */
    //from basebean
    @Override
    public Long getCurrentReportingYearId() {
        if (currentReportingYearId != null && !currentReportingYearId.equals(00L)) {
            return currentReportingYearId;
        }
        ReportingYear rYear = reportingYearFacade.getCurrentReportingYear();
        if (rYear == null) {
            //returning null is consitent with previous architecture
            return null;
        }
        currentReportingYearId = rYear.getId();
        return currentReportingYearId;
    }

    /*
     * Returns the reporting year id for the previous year
     */
    //from basebean
    @Override
    public Long getPreviousReportingYearId() {
        if (!previousReportingYearId.equals(00L)) {
            return previousReportingYearId;
        }
        ReportingYear rYear = reportingYearFacade.getPreviousReportingYear();
        if (rYear == null) {
            //returning null is consitent with previous architecture
            return null;
        }
        previousReportingYearId = rYear.getId();
        return previousReportingYearId;
    }


    /*
     * Returns the String value of a reporting year, based on the current year
     */
    //from basebean
    @Override
    public String getCurrentReportingYearStr() {
      /*  if (!currentReportingYearStr.isEmpty()) {
            return currentReportingYearStr;
        }*/
        ReportingYear rYear = reportingYearFacade.getCurrentReportingYear();
        if (rYear != null) {
            String yearString = rYear.getReportingYear();
            if (yearString != null) {
                currentReportingYearStr = yearString;
                return currentReportingYearStr;
            }
        }
        //This returns something in case the other fails (previously below was all that happened)
        int year = getYear();
        currentReportingYearStr = (year) + "/" + (year + 1);
        return currentReportingYearStr;
    }

    //from base bean
    @Override
    public boolean isAdjudicationPeriod(Long reportingYearId) {
        if (reportingYearId == null) {
            return false;
        }
        Boolean answer = inPendingAdj.get(reportingYearId);
        boolean pendingAdj;
        if (answer == null) {
            pendingAdj = reportingYearFacade.isAdjudicationPeriod(reportingYearId);
            inPendingAdj.put(reportingYearId, pendingAdj);
        } else {
            return answer.booleanValue();
        }
        return pendingAdj;
    }
    //from base bean

    @Override
    public boolean isShortfallPeriod(Long reportingYearId) {
        if (reportingYearId == null) {
            return false;
        }
        Boolean answer = inShortfall.get(reportingYearId);
        boolean shortfall;
        if (answer == null) {
            shortfall = reportingYearFacade.isShortfallPeriod(reportingYearId);
            inShortfall.put(reportingYearId, shortfall);
        } else {
            return answer.booleanValue();
        }
        return shortfall;
    }

    /*
     * Returns the String value of a reporting year, based on the previous year
     */
    //from basebean
    @Override
    public String getPreviousReportingYearStr() {
        if (!previousReportingYearStr.isEmpty()) {
            return previousReportingYearStr;
        }
        ReportingYear rYear = reportingYearFacade.getPreviousReportingYear();
        if (rYear != null) {
            String yearString = rYear.getReportingYear();
            if (yearString != null) {
                previousReportingYearStr = yearString;
                return previousReportingYearStr;
            }
        }
        //This returns something in case the other fails (previously below was all that happened)
        int year = getYear();
        previousReportingYearStr = (year - 1) + "/" + (year);
        return previousReportingYearStr;
    }

    /*
     * Return a list of Approved Activity names
     */
    //from applicationBean
    @Override
    public List<String> getActivityNames() {
        if (!activityNames.isEmpty()) {
            return activityNames;
        }
        List<ActivityType> activityList = activityTypeFacade.findAll();

        for (ActivityType activity : activityList) {
            activityNames.add(activity.getActivityName());
        }
        return activityNames;
    }

    public void clearActivityNames() {
        activityNames.clear();
    }

    private void runOnceADay() {
        log.info("===Starting Daily variables resetting.===");
        inExamPeriod.clear();
        inShortfall.clear();
        inPendingAdj.clear();

        currentReportingYearId = 00L;
        previousReportingYearId = 00L;
        currentReportingYearStr = "";
        previousReportingYearStr = "";
        init();
        log.info("1, currentReportingYearId = " + currentReportingYearId);
        log.info("2, previousReportingYearId = " + previousReportingYearId);
        log.info("3, currentReportingYearStr = " + currentReportingYearStr);
        log.info("4, previousReportingYearStr = " + previousReportingYearStr);

    }

    @Schedule(year = "*", month = "*", dayOfMonth = "*", hour = "00", minute = "00", second = "01")
    private void go() {
        runOnceADay();
    }

    ///////////////
    //UTILITY
    /*
     * Simply returns the current year
     */
    private int getYear() {
        Date today = new Date();
        int year = today.getYear() + 1900;
        if (today.getMonth() < 3) {
            year--;
        }
        return year;
    }
}
