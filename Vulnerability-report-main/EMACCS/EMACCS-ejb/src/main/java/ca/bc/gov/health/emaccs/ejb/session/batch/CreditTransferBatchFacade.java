/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        CreditTransferBatchFacade.java                 *
 * Date of Last Commit: $Date:: 2016-12-19 10:04:18 -0800 (Mon, 19 Dec 2016) $ *
 * Revision Number:      $Rev:: 2669                                         $ *
 * Last Commit by:    $Author:: tschiavo                                     $ *
 *                                                                             *
 *******************************************************************************/

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.emaccs.ejb.session.batch;

import ca.bc.gov.health.ejb.exception.FacadeException;
import ca.bc.gov.health.emaccs.ejb.session.email.EmailFacadeLocal;
import jakarta.annotation.Resource;
import jakarta.ejb.EJB;
import jakarta.ejb.Local;
import jakarta.ejb.Stateless;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.DataSource;

/**
 * Session bean for performing the batch credit transfer process.
 *
 * @author greg.perkins
 */
@Stateless
public class CreditTransferBatchFacade implements CreditTransferBatchFacadeLocal, Serializable {

    private static final String CLASS_NAME = CreditTransferBatchFacade.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);
    @EJB
    private EmailFacadeLocal emailFacade;
    /**
     * Update statement which performs the transfer based on a reporting year ID
     */
    /*private static final String sql =
     "UPDATE CMEDAT SET CCODE = 'T304', last_modified_on_dtm = ?  WHERE CMEDAT_ID IN ("+
     "SELECT CMEDAT_ID FROM "+
     "("+
     "SELECT "+
     "LICMAN.CCODE, "+
     "LICMAN.CMEDAT_ID, "+
     "LICMAN.REGIS_ID, "+
     "LICMAN.REPORTYR, "+
     "(SELECT COUNT (DISTINCT EPC.ID) FROM EMA_PATIENT_CONTACTS epc WHERE epc.EMA_ID = LICMAN.REGIS_ID AND epc.REPORTING_YEAR_ID = LICMAN.REPORTYR) CONTACTS, "+
     "NVL((SELECT SUM(ecat.credits) FROM EMA_APPROVED_ACTIVITIES eaa, EMA_CODES_ACTIVITY_TYPES ecat WHERE eaa.EMA_ID = LICMAN.REGIS_ID AND eaa.REPORTING_YEAR_ID = LICMAN.REPORTYR AND ECAT.ID = EAA.ACTIVITY_ID),0) + "+
     "NVL((SELECT SUM(eoa.CREDITS) FROM EMA_OTHER_ACTIVITIES eoa WHERE eoa.EMA_ID(+) = LICMAN.REGIS_ID AND eoa.REPORTING_YEAR_ID(+) = LICMAN.REPORTYR),0) + "+
     "NVL((SELECT SUM(eoa.ADJUDICATED_CREDITS) FROM EMA_OTHER_ACTIVITIES eoa WHERE eoa.EMA_ID(+) = LICMAN.REGIS_ID AND eoa.REPORTING_YEAR_ID(+) = LICMAN.REPORTYR),0) TOTAL_CREDITS "+
     "FROM "+
     "CMEDAT licman "+
     ") STATS "+
     "WHERE "+
     "CONTACTS+TOTAL_CREDITS >= 40 "+
     "AND CONTACTS < 20 "+
     "AND REPORTYR = ? "+
     "AND CCODE IN ('T301','T302')"+
     ")";*/
    private static final String SQL = "update CMEDAT SET CCODE = 'T304', last_modified_on_dtm = ? "
            + "  where "
            + " CCODE IN ('T301','T302')"
            + " AND REPORTYR = ?"
            + " and regis_id in("
            + " select distinct toCheck.regis_id from("
            + " (select * from cmedat cdat"
            + " inner join QUAL Q on q.REGIS_ID = cdat.REGIS_ID"
            + " join REGIS r on r.regis_id = q.regis_id"
            + " where cdat.REPORTYR = ? AND cdat.CCODE IN ('T301','T302')"
            + " and q.QCODE in ('L20','L22','L30','L32','L40','43','L50','L60')"
            + " and r.STATUS not in ('S12','S13','S22','S40','S41','S90','S99')"
            + " and (q.LICEXPDT is null or  q.LICEXPDT>= sysdate)"
            + " and q.enddate is null"
            + " and q.ISCURRENT = -1 ) toCheck"
            + " left outer join (SELECT ema_id, COUNT (DISTINCT EPC.ID) as contacts FROM EMA_PATIENT_CONTACTS EPC where EPC.reporting_Year_id = ? group by EPC.ema_id ) contact on contact.ema_id =toCheck.regis_id"
            + " left outer join (select eaa.ema_id,nvl(sum(ecat.default_credits),0) as appCred from EMA_APPROVED_ACTIVITIES eaa join EMA_CODES_ACTIVITY_TYPES ecat on ECAT.ID = EAA.ACTIVITY_ID where reporting_year_id = ? group by eaa.EMA_id) appActs on  appActs.ema_id =toCheck.regis_id"
            + " left outer join (select eoa.EMA_id, nvl(sum(eoa.adjudicated_credits),0) as adjOCred from EMA_OTHER_ACTIVITIES EOA join EMA_CODES_ACTIVITY_STATUSES ECAS on ECAS.id = EOA.status_id and lower(ECAS.Activity_status) = 'adjudicated' where reporting_year_id = ? group by eoa.EMA_id) appOActs on  appOActs.ema_id =toCheck.regis_id"
            + " left outer join (select eoa.EMA_id,  nvl(sum(eoa.credits),0) as appOCred from EMA_OTHER_ACTIVITIES EOA join EMA_CODES_ACTIVITY_STATUSES ECAS on ECAS.id = EOA.status_id and lower(ECAS.Activity_status) = 'approved' where reporting_year_id = ? group by eoa.EMA_id) adjOActs on  adjOActs.ema_id =toCheck.regis_id"
            + " )"
            + " where (nvl(appCred,0)+nvl(adjOCred,0)+nvl(appOCred,0)+nvl(contacts,0) >=40)"
            + " )";
    /**
     * Data source injected to execute the update statement
     */
    @Resource(lookup = "java:app/jdbc/EMA")
    private DataSource ds;

    /**
     * Performs the batch credit transfer
     *
     * @param reportingYearId Long - The reporting year to run the batch for
     * @return String - Message containing the batch results or error code
     */
    @Override
    public String transferCredits(Long reportingYearId) {
        
        log.log(Level.INFO, "=== Start batch credit transfer for reporting year id: {0}", reportingYearId);
        long startTime = System.currentTimeMillis();
        Timestamp enterTime = new Timestamp(System.currentTimeMillis());
        String successMessage = "";
        StringBuilder output = new StringBuilder(1024);
        FacadeException error = null;
        Connection conn = null;
        PreparedStatement stmt = null;
        ArrayList<String> affected = null;
        try {
            conn = ds.getConnection();
            stmt = conn.prepareStatement(SQL);
            stmt.setTimestamp(1, enterTime);
            stmt.setLong(2, reportingYearId);
            stmt.setLong(3, reportingYearId);
            stmt.setLong(4, reportingYearId);
            stmt.setLong(5, reportingYearId);
            stmt.setLong(6, reportingYearId);
            stmt.setLong(7, reportingYearId);
            int rowCount = stmt.executeUpdate();
            output.append("Batch Transfer successfully completed: ").append(rowCount).append(" records updated \n");
            successMessage = output.toString();
            affected = getEmaList(enterTime, reportingYearId, conn);
            if (affected == null) {
                output.append("\n Problems encountered logging modified EMAs");
            } else if (!affected.isEmpty()) {
                output.append("EMA IDs and Licence numbers recorded for this operation:");
                for (String licno : affected) {
                    output.append("\n").append(licno);
                }
                try {
                    new Thread(new CCBatchNotifier(affected, emailFacade)).start();
                } catch (Exception e) {
                    log.log(Level.SEVERE, "Batch Cc Req Met emails not sent. failure {0} with message: {1}", new Object[]{e.getClass().getSimpleName(), e.getMessage()});
                }
            } else {
                output.append("There were no EMAs recorded for this operation.");
            }
            conn.commit();
        } catch (SQLException e1) {
            output.append("Batch Transfer of Credits failed.");
            log.log(Level.SEVERE, "Batch Transfer of Credits failed: {0}", e1.getMessage());
            error = new FacadeException(e1, e1.getClass());
            try {
                if (conn != null) {
                    conn.rollback();
                }
            } catch (SQLException e2) {
                output.append(" Rollback attempt in Batch Transfer of Credits failed.");
                log.log(Level.WARNING, "Rollback attempt in Batch Transfer of Credits failed: {0}", e2.getMessage());
            }
        } finally {
            try {
                if (stmt != null) {
                    stmt.close();
                }
            } catch (Exception e) {}
        }
        try {
            String results = output.toString();
            try {
                boolean sent = emailFacade.sendCCTransferBatch(results);
                if (!sent) {
                    log.log(Level.WARNING, "Notification email to EMA Licencing did not send.");
                }
            } catch (Exception e) {
                log.log(Level.WARNING, "Notification email to EMA Licencing did not send. due to:{0}", e.getMessage());
            }
            if (error != null) {
                logBatchResults(enterTime, "fail", (results).getBytes(), conn);
                throw error;
            } else {
                logBatchResults(enterTime, "pass", (results).getBytes(), conn);
                return successMessage;
            }
        } finally {

            try {
                if (stmt != null) {
                    stmt.close();
                }
            } catch (Exception e) {}
            try {
                if (conn != null) {
                    conn.close();
                }
            } catch (Exception e) {}
            log.log(Level.INFO, "=== Batch credit transfer completed in : " + (System.currentTimeMillis() - startTime) + " ms ");
        }    
    }

    private ArrayList<String> getEmaList(Timestamp enterTime, Long reportingYearId, Connection conn) throws SQLException {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        String ccCodeQuery = "Select distinct LICNO  from CMEDAT "
                + " where REPORTYR = ? "
                + " and CCODE = 'T304' "
                + " and to_char(last_modified_on_dtm,'YYYY/MM/DD HH24:MI:SS') = ?";
        ArrayList<String> allLicno = new ArrayList<>();
        PreparedStatement pstmt = null;
        ResultSet results = null;
        try {
            pstmt = conn.prepareStatement(ccCodeQuery);
            pstmt.setLong(1, reportingYearId);
            pstmt.setString(2, sdf.format(enterTime));
            results = pstmt.executeQuery();
            if (results != null && results.next()) {
                allLicno.add(results.getString(1));

                while (results.next()) {
                    allLicno.add(results.getString(1));
                }
            }
        } catch (Exception e) {
            log.log(Level.SEVERE, "problem getting ema list: {0}", e.getMessage());
            return null;
        } finally {
            try {
                if (results != null) {
                    results.close();
                }
            } catch (Exception e) {/*ignore*/

            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (Exception e) {/*ignore*/

            }
            //Do not close connection it's acquired from the method which calls this
        }
        return allLicno;
    }

    private void logBatchResults(Timestamp startTime, String status, byte[] logEntry, Connection conn) {
        Timestamp endTime = new Timestamp(System.currentTimeMillis());
        PreparedStatement pstmt = null;
        String insertLog = "insert into EMA_BATCH_JOB_LOG"
                + "(ID, JOB_TYPE, START_TIME, END_TIME, STATUS, JOB_LOG, CREATED_BY_NM, CREATED_ON_DTM)"
                + "VALUES (EMA_BATCH_JOB_LOG_SEQ.nextval, 'Credit Transfer Batch Job', ?, ?, ?, ?, 'todo', sysdate)";
        String output;
        try {

            pstmt = conn.prepareStatement(insertLog);
            pstmt.setTimestamp(1, startTime);
            pstmt.setTimestamp(2, endTime);
            pstmt.setString(3, status);
            pstmt.setBytes(4, logEntry);
            output = Integer.toString(pstmt.executeUpdate());
            log.log(Level.INFO, "{0} records inserted into the database log.", output);
            conn.commit();
        } catch (SQLException sqle) {
            output = String.format("CreditTransfer Inserting to database log may have failed. Error: %s%n", sqle.getMessage());
            log.log(Level.SEVERE, output);
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (Exception e) {/*ignore*/

            }
            //do not close connection
        }
    }

    //may not need the @ local or@ ejb.  @ejb without hte passed in parameter is null.
    @Local
    class CCBatchNotifier implements Runnable, Serializable {

        @EJB
        private EmailFacadeLocal emailFacade;
        ArrayList<String> some = new ArrayList<>();

        public CCBatchNotifier(ArrayList<String> received_array, EmailFacadeLocal inEmailFacade) {
            this.some = received_array;
            emailFacade = inEmailFacade;
        }

        @Override
        public void run() {
            log.log(Level.INFO, "Batch CC emails Starting");
            for (String licenceNo : this.some) {
                try {
                    Long licNo = Long.parseLong(licenceNo);
                    emailFacade.sendRequirementMet_CCTransfer(licNo, null);
                } catch (Exception e) {
                    log.log(Level.WARNING, "Emailing failed due to: {0} with message: {1}", new Object[]{e.getClass().getName(), e.getMessage()});
                    log.log(Level.WARNING, "Failed to email Licno: {0}", licenceNo);
                }
            }
            log.log(Level.INFO, "Batch CC emails Finished");
        }
    }
}
