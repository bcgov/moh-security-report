/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        CCStatusManagerFacade.java                     *
 * Date of Last Commit: $Date::                                              $ *
 * Revision Number:      $Rev::                                              $ *
 * Last Commit by:    $Author::                                              $ *
 *                                                                             *
 *******************************************************************************/

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.emaccs.ejb.session.custom;

import ca.bc.gov.health.ejb.exception.FacadeException;
import ca.bc.gov.health.emaccs.ejb.entity.custom.CCStatus;
import ca.bc.gov.health.emaccs.ejb.session.AbstractFacade;
import ca.bc.gov.health.emaccs.ejb.session.LicenceMaintenanceFacadeLocal;
import jakarta.ejb.EJB;
import jakarta.ejb.TransactionAttribute;
import jakarta.ejb.TransactionAttributeType;
import jakarta.persistence.EntityManager;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author ian.scott
 */
public abstract class CCStatusManagerFacade<T extends CCStatus> extends AbstractFacade<T> implements Serializable {// implements CCStatusFacadeLocal {

    private static final String CLASS_NAME = CCStatusManagerFacade.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);
    private boolean requirementCheckAttempted = false;

    private boolean requirementCheckSuccessful = false;
    ArrayList<T> allCreateFailures = new ArrayList<>();
    ArrayList<T> allEditFailures = new ArrayList<>();
    ArrayList<T> allRemoveFailures = new ArrayList<>();

    @EJB
    private LicenceMaintenanceFacadeLocal licenceMaintenanceFacade;

    @Override
    protected abstract EntityManager getEntityManager();

    public CCStatusManagerFacade(Class<T> entityClass) {
        super(entityClass);
    }

    //TODO - TSS 2017/02/09
    //It looks like this is now only used for deletes. The Add and Update logic should likely be removed
    //I think this should throw an exception rather than build a list of failures
    //Since the allXFailures list is only used to display errors in cases where list.size() != 0 
    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public void processMultipleEntities(List<T> entityToAdd, List<T> entityToUpdate, List<T> entityToDelete, Long reportingYearID) {
        //The handling of deleted entities can differ so this is a flag
        //TODO remove all deleted logic from the check
        boolean checkReq = true;
        requirementCheckAttempted = false;
        requirementCheckSuccessful = false;
        allCreateFailures.clear();
        allEditFailures.clear();
        allRemoveFailures.clear();
        HashMap<Long, Boolean> emaChanged = new HashMap<>();

        if (entityToDelete != null && !entityToDelete.isEmpty()) {
            for (T anEntity : entityToDelete) {
                try {
                    this.internalRemove(anEntity);
                    emaChanged.put(anEntity.getEMA_Id(), checkReq);
                } catch (Exception e) {
                    allRemoveFailures.add(anEntity);
                }
            }
        } //Remove process ends
        //if they are an ema and something was removed
        if (!emaChanged.isEmpty()) {
            checkRequirements(emaChanged, reportingYearID);
        }

    }

    public List<T> getAddFailuresFromMultipleEntityProcess() {
        return allCreateFailures;
    }

    public List<T> getUpdateFailuresMultipleEntityProcess() {
        return allEditFailures;
    }

    public List<T> getDeleteFailuresMultipleEntityProcess() {
        return allRemoveFailures;
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    private void internalEdit(T entity) throws FacadeException {
        super.edit(entity);
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    private void internalRemove(T entity) throws FacadeException {
        super.remove(entity);
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    private void internalCreate(T entity) throws FacadeException {
        super.create(entity);
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public T edit(T entity) throws FacadeException {
        return super.edit(entity);
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void create(T entity) throws FacadeException {
        super.create(entity);
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void remove(T entity) throws FacadeException {
        super.remove(entity);
        //TODO - process on Delete, how to determine EMAness
    }

    /**
     * *
     *
     * @return true if a check of the requirements was attempted
     */
    public boolean getRequirementCheckAttempted() {
        return requirementCheckAttempted;
    }

    /**
     *
     * @return true only if a requirements check was attempted and did not fail.
     */
    public boolean isRequirementCheckSuccessful() {
        if (!requirementCheckAttempted) {
            return true;
        }
        return requirementCheckSuccessful;
    }

    /**
     * *
     *
     * @param emaId aka regisID
     * @param reportingYearID
     * @param isEMA
     * @return false if requirements didn't check successfually
     */
    public boolean checkRequirements(Long emaId, Long reportingYearID, boolean deleteOccured) {
        if (emaId == null) {
            return false;
        }
        try {
            licenceMaintenanceFacade.checkIfRequirementsMet(emaId, reportingYearID, deleteOccured);
            return true;
        } catch (FacadeException e) {
            log.log(Level.SEVERE, "Error checking requirements for regis_id: {0} due to: {1}", new Object[]{emaId, e.getException().getMessage()});
            return false;
        }
    }

    private void checkRequirements(HashMap<Long, Boolean> emaChanged, Long reportingYearID) {
        requirementCheckAttempted = true;
        //process all the deleted
        int countSuccess = 0;
        int numberToCheck = emaChanged.size();
        ArrayList<String> errorMsg = new ArrayList<>();
        Exception lastException = null;
        Long id = null;
        boolean deleteOccured = true;
        try {
            for (Map.Entry<Long, Boolean> pairs : emaChanged.entrySet()) {
                id = pairs.getKey();
                deleteOccured = pairs.getValue();
                licenceMaintenanceFacade.checkIfRequirementsMet(id, reportingYearID, deleteOccured);
                countSuccess++;
            }
        } catch (FacadeException e) {
            if (e.getException() != null) {
                lastException = e.getException();
            }
            if (numberToCheck == 1) {
                log.log(Level.SEVERE, "Error checking requirements for regis_id: {0} due to: {1}", new Object[]{id, e.getException().getMessage()});
            } else {
                errorMsg.add("Failed to check/execute change in licence status for regis_id: " + id);
            }
        }
        if (errorMsg.size() > 0) {
            if (errorMsg.size() == numberToCheck) {
                log.log(Level.SEVERE, "Checking for change of status completely failed. Producing the following");
            } else {
                log.log(Level.WARNING, "Checking for change of status produced the following failures");
            }
            for (String msg : errorMsg) {
                log.log(Level.WARNING, msg);
            }
            if (lastException != null) {
                log.log(Level.WARNING, "Probably due to: {0}", lastException.getMessage());
            }
        }

        if (countSuccess != 0 && numberToCheck > 0) {
            requirementCheckSuccessful = true;
        } else if (numberToCheck == 0) {
            log.log(Level.SEVERE, "A check of requirements was ordered but no changes qualified for checking");
        }
    }
}
