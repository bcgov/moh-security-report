/*******************************************************************************
 * Copyright Â© 2015, Province of British Columbia.                             *
 *                                                                             *
 * All rights reserved.                                                        *
 *                                                                             *
 * File:                        AbstractFacade.java                            *
 * Date of Last Commit: $Date:: 2015-06-22 17:18:37 -0700 (Mon, 22 Jun 2015) $ *
 * Revision Number:      $Rev:: 2540                                         $ *
 * Last Commit by:    $Author:: cmatsond                                     $ *
 *                                                                             *
 *******************************************************************************/

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.bc.gov.health.emaccs.ejb.session;

import ca.bc.gov.health.ejb.exception.FacadeException;
import jakarta.faces.validator.ValidatorException;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Id;
import jakarta.persistence.PersistenceException;
import jakarta.persistence.Query;
import jakarta.persistence.Transient;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLIntegrityConstraintViolationException;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author greg.perkins
 */
public abstract class AbstractFacade<T> implements Serializable {

    private static final String CLASS_NAME = AbstractFacade.class.getName();
    private static final Logger log = Logger.getLogger(CLASS_NAME);
    private Class<T> entityClass;

    public static enum EntityChange {

        New, Change, Remove, None
    };

    private enum EntityChangeProcess {

        SAVE, UPDATE, DELETE
    };

    public AbstractFacade(Class<T> entityClass) {
        this.entityClass = entityClass;
    }

    protected abstract EntityManager getEntityManager();

    //TODO made it return T and update all Facades with the T edit
    public T edit(T entity) throws FacadeException {
        return processEntityChange(entity, EntityChangeProcess.UPDATE);
    }

    public void create(T entity) throws FacadeException {
        processEntityChange(entity, EntityChangeProcess.SAVE);
    }

    public void remove(T entity) throws FacadeException {
        processEntityChange(entity, EntityChangeProcess.DELETE);
    }

    public T refresh(T entity) throws FacadeException {
        EntityManager entM = getEntityManager();
        try {
            entM.refresh(entity);
        } catch (Exception e) {
            log.log(Level.SEVERE, "Difficulties encounter refreshing {0} due to {1} with message: {2}", new Object[]{entity.getClass().getSimpleName(), e.getClass().getSimpleName(), e.getMessage()});
        }
        return entity;
    }

    private T processEntityChange(T entity, EntityChangeProcess toDo) throws FacadeException {
        try {
            switch (toDo) {
                case SAVE:
                    this.createEntity(entity);
                    return null;
                case UPDATE:
                    return editEntity(entity);
                case DELETE:
                    this.removeEntity(entity);
                    return null;
            }
        } catch (ConstraintViolationException cve) {
            try {
                log.log(Level.SEVERE, cve.getMessage());
                Set<ConstraintViolation<?>> errs = cve.getConstraintViolations();
                for (ConstraintViolation<?> vio : errs) {
                    //TODO - what about unique..
                    log.log(Level.SEVERE, toDo.toString() + ": {0} encountered: {1} {2}.", new Object[]{entity.getClass().getSimpleName(), vio.getPropertyPath(), vio.getMessage()});
                }
            } catch (Exception e) {
                // This is to make sure the message returns to the user should something fail during logging.
            }
            FacadeException messageToUser = new FacadeException(cve, cve.getClass());
            throw messageToUser;
        } catch (ValidatorException ve) {
            log.log(Level.SEVERE, "{0}: {1} encountered: {2} with message: {3}", new Object[]{toDo.toString(), entity.getClass().getSimpleName(), ve.getClass().getSimpleName(), ve.getMessage()});
            FacadeException messageToUser = new FacadeException(ve, ve.getClass());
            throw messageToUser;
        } catch (PersistenceException e) {
            Throwable x = e.getCause();
            if (x != null && x.getClass().getSimpleName().equals("DatabaseException")) {
                Throwable y = x.getCause();
                if (y != null && y.getClass().getSimpleName().equals("SQLIntegrityConstraintViolationException")) {
                    SQLIntegrityConstraintViolationException innerE = (SQLIntegrityConstraintViolationException) y;
                    //TODO - build up something that 'runs with this' - or remove it and stick with persistenceException
                }
            }
            log.log(Level.SEVERE, "{0}: {1} encountered: {2} with message: {3}", new Object[]{toDo.toString(), entity.getClass().getSimpleName(), e.getClass().getSimpleName(), e.getMessage()});
            FacadeException messageToUser = new FacadeException(e, e.getClass());
            throw messageToUser;
        } catch (Exception e) {
            log.log(Level.SEVERE, "{0}: {1} encountered: {2} with message: {3}", new Object[]{toDo.toString(), entity.getClass().getSimpleName(), e.getClass().getSimpleName(), e.getMessage()});
            FacadeException messageToUser = new FacadeException(e, e.getClass());
            throw messageToUser;
        }
        return null;
    }

    private void createEntity(T entity) throws ConstraintViolationException, ValidatorException, Exception {
        EntityManager entM = getEntityManager();
        entM.persist(entity);
        entM.flush();

    }

    private void removeEntity(T entity) throws ConstraintViolationException, ValidatorException, Exception {
        EntityManager entM = getEntityManager();
        T entityToRemove = entM.merge(entity);
        entM.remove(entityToRemove);
        entM.flush();
    }

    private T editEntity(T entity) throws ConstraintViolationException, ValidatorException, Exception {
        EntityManager entM = getEntityManager();
        T returnedEnt = entM.merge(entity);
        //Flushing to generate opourtunistic lock exception early
        entM.flush();
        return returnedEnt;
    }

    public T find(Object id) {
        if (id == null) {
            return null;
        }
        return getEntityManager().find(entityClass, id);
    }

    public List<T> findAll() {
        try {
            jakarta.persistence.criteria.CriteriaQuery cq = getEntityManager().getCriteriaBuilder().createQuery();
            cq.select(cq.from(entityClass));
            return getEntityManager().createQuery(cq).getResultList();
        } catch (Exception e) {
            log.log(Level.SEVERE, "findAll failed due to: {0} which had error: {1}", new Object[]{e.getClass().getSimpleName(), e.getMessage()});
        }
        return null;
    }

    public List<T> findRange(int[] range) {
        jakarta.persistence.criteria.CriteriaQuery cq = getEntityManager().getCriteriaBuilder().createQuery();
        cq.select(cq.from(entityClass));
        jakarta.persistence.Query q = getEntityManager().createQuery(cq);
        q.setMaxResults(range[1] - range[0]);
        q.setFirstResult(range[0]);
        return q.getResultList();
    }

    public int count() {
        jakarta.persistence.criteria.CriteriaQuery cq = getEntityManager().getCriteriaBuilder().createQuery();
        jakarta.persistence.criteria.Root<T> rt = cq.from(entityClass);
        cq.select(getEntityManager().getCriteriaBuilder().count(rt));
        jakarta.persistence.Query q = getEntityManager().createQuery(cq);
        return ((Long) q.getSingleResult()).intValue();
    }

    //TODO - Chris fix this fundimental problem
    //TODO may nee dto account for transient annotations
    public <T> List<T> search(T entity) {
        try {
            EntityManager em = getEntityManager();
            Class clazz = entity.getClass();
            List<String> cols = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            Field[] fields = clazz.getDeclaredFields();
            for (Field field : fields) {
                try {
                    String fieldName = field.getName();
                    //Added to stop the constant exceptions from _persistence_key and etc
                    if (fieldName.startsWith("_") || field.getAnnotation(Transient.class) != null) {
                        continue;
                    }
                    Method m = clazz.getMethod("get" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1), new Class[0]);
                    //for each field in the entity find the getversionof it and gather the value there. later process differently if empty/null
                    Object value = m.invoke(entity, new Object[0]);
                    //if the value it returns is an entity class 'somewhere' else,  find the correct subfield within it
                    if (value != null && value.getClass().getAnnotation(Entity.class) != null) {
                        Field[] subFields = value.getClass().getDeclaredFields();
                        for (Field field1 : subFields) {
                            if (field1.getAnnotation(Id.class) != null) {
                                fieldName += "." + field1.getName();
                                m = value.getClass().getMethod("get" + field1.getName().substring(0, 1).toUpperCase() + field1.getName().substring(1), new Class[0]);
                                break;
                            }
                        }
                        value = m.invoke(value, new Object[0]);
                    }
                    if (value != null
                            && !((value instanceof String)
                            && ((String) value).isEmpty())) {
                        cols.add(fieldName);
                        values.add(value);
                    }

                } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
                    //ignore
                }
            }
            StringBuilder buff = new StringBuilder(1024);
            buff.append("select o from ").append(clazz.getSimpleName()).append(" o ");
            for (int i = 0; i < values.size(); i++) {
                String col = cols.get(i);
                if (i == 0) {
                    buff.append("where ");
                } else {
                    buff.append(" and ");
                }
                if (values.get(i).toString().contains("%")) {
                    buff.append("o.").append(col).append(" like ?").append(i + 1);
                } else {
                    buff.append("o.").append(col).append("=?").append(i + 1);
                }
            }
            buff.append(" ").append(getOrderByClause());
            Query q = em.createQuery(buff.toString(), clazz);
            for (int i = 0; i < values.size(); i++) {
                Object object = values.get(i);
                q.setParameter(i + 1, object);
            }
            return q.getResultList();
        } catch (Exception e) {
            log.log(Level.SEVERE, "There is a search problem in AbstractFacade for: {0} due to {1}", new Object[]{e.getClass().getSimpleName(), e.getMessage()});
            return null;
        }

    }

    protected String getOrderByClause() {
        return "";
    }

    protected void closeQuietly(ResultSet rs, PreparedStatement stmt, Connection conn) {
        try {
            if (rs != null) {
                rs.close();
            }
        } catch (Exception e) {/* ignored */

        }
        try {
            if (stmt != null) {
                stmt.close();
            }
        } catch (Exception e) {/* ignored */

        }
        try {
            if (conn != null) {
                conn.close();
            }
        } catch (Exception e) {/* ignored */

        }
    }
}
