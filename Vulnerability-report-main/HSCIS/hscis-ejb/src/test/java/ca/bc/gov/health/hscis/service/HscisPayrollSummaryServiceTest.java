package ca.bc.gov.health.hscis.service;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import ca.bc.gov.health.hscis.dao.HscisPayrollSummaryDao;
import ca.bc.gov.health.hscis.dto.PayrollSummary;
import ca.bc.gov.health.hscis.dto.PayrollSummaryGroupComp;
import ca.bc.gov.health.hscis.dto.PayrollSummaryStatus;
import ca.bc.gov.health.hscis.dto.ReportingPeriod;
import ca.bc.gov.health.hscis.entity.HcdMembership;
import ca.bc.gov.health.hscis.entity.HcdPayrollSummary;
import ca.bc.gov.health.hscis.entity.HcdPayrollSummaryGroupComp;
import ca.bc.gov.health.hscis.entity.PayrollSummaryPK;
import ca.bc.gov.health.hscis.exception.HscisException;
import ca.bc.gov.health.hscis.mapper.PayrollSummaryEmployeeMapperImpl;
import ca.bc.gov.health.hscis.mapper.PayrollSummaryGroupCompMapperImpl;
import ca.bc.gov.health.hscis.mapper.PayrollSummaryMapperImpl;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.Month;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class HscisPayrollSummaryServiceTest {

  @InjectMocks HscisPayrollSummaryService service = new HscisPayrollSummaryService();

  @Spy @InjectMocks PayrollSummaryMapperImpl sumMapper;
  @Spy @InjectMocks PayrollSummaryGroupCompMapperImpl groupMapper;
  @Spy @InjectMocks PayrollSummaryEmployeeMapperImpl empMapper;

  @Mock HscisPayrollSummaryDao dao;

  private static int testYear = 2020;

  @BeforeEach
  public void setUp() {
    MockitoAnnotations.initMocks(this);
  }

  @Test
  public void testListSummaries_Empty() throws HscisException {
    String userId = "batman";

    when(dao.listPayrollSummaries(userId)).thenReturn(emptyList());

    List<PayrollSummary> ret = service.listPayrollSummaries(userId);

    verify(dao).listPayrollSummaries(userId);

    assertNotNull(ret);
    assertEquals(0, ret.size());
  }

  @Test
  public void testListSummaries_NotEmpty() throws HscisException {
    String userId = "batman";

    when(dao.listPayrollSummaries(userId)).thenReturn(summaryList());

    List<PayrollSummary> ret = service.listPayrollSummaries(userId);

    assertNotNull(ret);
    assertEquals(2, ret.size());

    // This checks the status mapping rule
    assertEquals(PayrollSummaryStatus.COMPLETED, ret.get(0).getStatus());
    assertEquals(PayrollSummaryStatus.IN_PROGRESS, ret.get(1).getStatus());
  }

  @Test
  public void testValidate_nulls() {
    Long corpId = 1L;
    Long siteId = 2L;
    LocalDate fromDate = LocalDate.of(testYear, 01, 01);
    LocalDate toDate = LocalDate.of(testYear, 06, 30);

    try {
      service.validatePeriod(null, siteId, fromDate, toDate);
      fail("Should throw exception");
    } catch (IllegalArgumentException e) {
      assertEquals("Null values in validatePeriod", e.getMessage());
    }

    try {
      service.validatePeriod(corpId, null, fromDate, toDate);
      fail("Should throw exception");
    } catch (IllegalArgumentException e) {
      assertEquals("Null values in validatePeriod", e.getMessage());
    }

    try {
      service.validatePeriod(corpId, siteId, null, toDate);
      fail("Should throw exception");
    } catch (IllegalArgumentException e) {
      assertEquals("Null values in validatePeriod", e.getMessage());
    }

    try {
      service.validatePeriod(corpId, siteId, fromDate, null);
      fail("Should throw exception");
    } catch (IllegalArgumentException e) {
      assertEquals("Null values in validatePeriod", e.getMessage());
    }
  }

  @Test
  public void testValidate_noconflict() {
    Long corpId = 999L;
    Long siteId = 998L;
    Long hscisId = 3L;

    String errorMessage = "A payroll summary already exists for this period";

    LocalDate fromDate = LocalDate.of(testYear, 01, 01);
    LocalDate toDate = LocalDate.of(testYear, 12, 31);

    when(dao.readMembership(siteId)).thenReturn(membership(hscisId, false));
    when(dao.listPayrollSummaries(hscisId)).thenReturn(summaryList());

    List<String> errors = service.validatePeriod(corpId, siteId, fromDate, toDate);

    assertNotNull(errors);
    assertErrorNotContains(errors, errorMessage);
  }

  @Test
  public void testValidate_conflict() {
    Long corpId = 1L;
    Long siteId = 2L;
    Long hscisId = 3L;

    String errorMessage = "A payroll summary already exists for this period";

    LocalDate fromDate = LocalDate.of(testYear, 01, 01);
    LocalDate toDate = LocalDate.of(testYear, 06, 30);

    when(dao.readMembership(siteId)).thenReturn(membership(hscisId, false));
    when(dao.listPayrollSummaries(hscisId)).thenReturn(summaryList());

    List<String> errors = service.validatePeriod(corpId, siteId, fromDate, toDate);

    assertNotNull(errors);
    assertTrue(errors.size() > 0);
    assertErrorContains(errors, errorMessage);
  }

  @Test
  public void testValidate_notNewMember() {
    Long corpId = 999L;
    Long siteId = 998L;
    Long hscisId = 3L;

    String errorMessage = "Reporting From must be +/- 22 days from Jan 1st of reporting year";
    String errorMessage2 = "Cannot report for years prior to becoming a member";
    // For new member, any from date after jan 1 is valid
    LocalDate fromDate = LocalDate.of(testYear, 03, 01);
    LocalDate toDate = LocalDate.of(testYear, 06, 30);

    when(dao.readMembership(siteId)).thenReturn(membership(hscisId, false));
    when(dao.listPayrollSummaries(hscisId)).thenReturn(summaryList());

    List<String> errors = service.validatePeriod(corpId, siteId, fromDate, toDate);

    assertNotNull(errors);
    assertErrorContains(errors, errorMessage);
    assertErrorNotContains(errors, errorMessage2);
  }

  @Test
  public void testValidate_newMember() {
    Long corpId = 999L;
    Long siteId = 998L;
    Long hscisId = 3L;

    String errorMessage = "Reporting From must be +/- 22 days from Jan 1st of reporting year";
    String errorMessage2 = "Cannot report for years prior to becoming a member";

    // For new member, any from date after jan 1 is valid
    LocalDate fromDate = LocalDate.of(testYear, 03, 01);
    LocalDate toDate = LocalDate.of(testYear, 06, 30);

    when(dao.readMembership(siteId)).thenReturn(membership(hscisId, true));
    when(dao.listPayrollSummaries(hscisId)).thenReturn(summaryList());

    List<String> errors = service.validatePeriod(corpId, siteId, fromDate, toDate);

    assertNotNull(errors);
    assertErrorNotContains(errors, errorMessage);
    assertErrorNotContains(errors, errorMessage2);
  }

  @Test
  public void testValidate_newMemberPreviousYear() {
    Long corpId = 999L;
    Long siteId = 998L;
    Long hscisId = 3L;

    String errorMessage = "Reporting From must be +/- 22 days from Jan 1st of reporting year";
    String errorMessage2 = "Cannot report for years prior to becoming a member";

    // For new member, any from date after jan 1 is valid
    LocalDate fromDate = LocalDate.of(testYear - 1, 03, 01);
    LocalDate toDate = LocalDate.of(testYear - 1, 06, 30);

    when(dao.readMembership(siteId)).thenReturn(membership(hscisId, true));
    when(dao.listPayrollSummaries(hscisId)).thenReturn(summaryList());

    List<String> errors = service.validatePeriod(corpId, siteId, fromDate, toDate);

    assertNotNull(errors);
    assertErrorNotContains(errors, errorMessage);
    assertErrorContains(errors, errorMessage2);
  }

  private void assertErrorContains(List<String> errors, String errorMessage) {
    assertNotNull(
        errors.stream().filter(e -> e.contains(errorMessage)).findAny().orElse(null),
        "Expecting error: " + errorMessage);
  }

  private void assertErrorNotContains(List<String> errors, String errorMessage) {
    assertNull(
        errors.stream().filter(e -> e.contains(errorMessage)).findAny().orElse(null),
        "Expecting no error: " + errorMessage);
  }

  @Test
  public void testAddDesignatedGroup() throws HscisException {

    PayrollSummary sum = summary();
    PayrollSummaryGroupComp groupToAdd = newGroup();
    doNothing().when(dao).save(any(HcdPayrollSummaryGroupComp.class));

    service.addDesignatedGroup(sum, groupToAdd);

    verify(dao, times(1)).save(any(HcdPayrollSummaryGroupComp.class));
    assertEquals(1, sum.getGroupSummaries().size());
  }

  @Test
  public void testUpdateDesignatedGroup() throws HscisException {

    long id = 10L;
    PayrollSummary sum = summary();
    PayrollSummaryGroupComp groupToUpdate = newGroup();
    groupToUpdate.setId(id);
    sum.getGroupSummaries().add(groupToUpdate);
    HcdPayrollSummaryGroupComp entity = new HcdPayrollSummaryGroupComp();

    when(dao.readPayrollSummaryGroupComp(id)).thenReturn(entity);

    doNothing().when(dao).save(entity);

    service.updateDesignatedGroup(groupToUpdate);

    verify(dao, times(1)).save(entity);
    assertEquals(1, sum.getGroupSummaries().size());
  }

  @Test
  public void testDeleteDesignatedGroup() throws HscisException {

    long id = 10L;
    PayrollSummary sum = summary();
    PayrollSummaryGroupComp groupToDelete = newGroup();
    groupToDelete.setId(id);
    sum.getGroupSummaries().add(groupToDelete);
    HcdPayrollSummaryGroupComp entity = new HcdPayrollSummaryGroupComp();

    when(dao.readPayrollSummaryGroupComp(id)).thenReturn(entity);

    doNothing().when(dao).delete(entity);

    service.deleteDesignatedGroup(sum, groupToDelete);

    verify(dao, times(1)).delete(entity);
    assertEquals(0, sum.getGroupSummaries().size());
  }

  @SuppressWarnings("serial")
  private HcdMembership membership(Long hscisId, boolean isNew) {
    return new HcdMembership() {
      {
        setHscisId(hscisId);
        setMembershipDate(
            isNew ? LocalDate.of(testYear, 03, 01) : LocalDate.of(testYear - 1, 03, 01));
      }
    };
  }

  @SuppressWarnings("serial")
  private PayrollSummary summary() {
    Long corpId = 1L;
    Long siteId = 2L;
    LocalDate fromDate = LocalDate.of(2020, 01, 01);
    LocalDate toDate = LocalDate.of(2020, 12, 31);
    Long hscisId = 999L;
    return new PayrollSummary() {
      {
        setEmployerID(corpId);
        setSiteID(siteId);
        setReportingPeriod(new ReportingPeriod(fromDate, toDate));
        setMembershipId(hscisId);
      }
    };
  }

  @SuppressWarnings("serial")
  private PayrollSummaryGroupComp newGroup() {

    Long corpId = 1L;
    Long siteId = 2L;
    LocalDate fromDate = LocalDate.of(2020, 01, 01);
    LocalDate toDate = LocalDate.of(2020, 12, 31);

    PayrollSummaryGroupComp newGroup =
        new PayrollSummaryGroupComp() {
          {
            setSummary(
                new PayrollSummary() {
                  {
                    setEmployerID(corpId);
                    setSiteID(siteId);
                    setReportingPeriod(new ReportingPeriod(fromDate, toDate));
                  }
                });
            setTotalOvertime15(BigDecimal.valueOf(10));
          }
        };

    return newGroup;
  }

  @SuppressWarnings("serial")
  private List<HcdPayrollSummary> summaryList() {
    return List.of(
        // first one is completed
        new HcdPayrollSummary() {
          {
            setId(
                new PayrollSummaryPK() {
                  {
                    setCorporateEmployerNumber(999);
                    setSiteEmployerNumber(998);
                    setReportingFrom(LocalDate.of(testYear, Month.JANUARY, 1));
                    setReportingTo(LocalDate.of(testYear, Month.JUNE, 30));
                  }
                });
            setCompleteDate(LocalDate.of(testYear, Month.JULY, 1));
            setPayrollSummaryGroupComp(new ArrayList<>());
            setPayrollSummaryEmployee(new ArrayList<>());
          }
        },
        // second is not completed
        new HcdPayrollSummary() {
          {
            setId(
                new PayrollSummaryPK() {
                  {
                    setCorporateEmployerNumber(999);
                    setSiteEmployerNumber(997);
                    setReportingFrom(LocalDate.of(testYear, Month.JANUARY, 1));
                    setReportingTo(LocalDate.of(testYear, Month.JUNE, 30));
                  }
                });
            setCompleteDate(null);
            setPayrollSummaryGroupComp(new ArrayList<>());
            setPayrollSummaryEmployee(new ArrayList<>());
          }
        });
  }

  private List<HcdPayrollSummary> emptyList() {
    return new ArrayList<>();
  }
}
