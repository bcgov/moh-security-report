package ca.bc.gov.health.hscis.service;

import ca.bc.gov.health.hscis.dao.HscisAdminDao;
import ca.bc.gov.health.hscis.dao.HscisPayrollSummaryDao;
import ca.bc.gov.health.hscis.dto.PayrollSummary;
import ca.bc.gov.health.hscis.dto.PayrollSummaryEmployee;
import ca.bc.gov.health.hscis.dto.PayrollSummaryGroupComp;
import ca.bc.gov.health.hscis.dto.ReportingPeriod;
import ca.bc.gov.health.hscis.entity.HcdClassification;
import ca.bc.gov.health.hscis.entity.HcdMembership;
import ca.bc.gov.health.hscis.entity.HcdPayrollSummary;
import ca.bc.gov.health.hscis.entity.HcdPayrollSummaryEmployee;
import ca.bc.gov.health.hscis.entity.HcdPayrollSummaryGroupComp;
import ca.bc.gov.health.hscis.entity.HcdPeriodConfirmation;
import ca.bc.gov.health.hscis.entity.PayrollSummaryPK;
import ca.bc.gov.health.hscis.exception.HscisException;
import ca.bc.gov.health.hscis.mapper.PayrollSummaryEmployeeMapper;
import ca.bc.gov.health.hscis.mapper.PayrollSummaryGroupCompMapper;
import ca.bc.gov.health.hscis.mapper.PayrollSummaryMapper;
import jakarta.ejb.LocalBean;
import jakarta.ejb.Stateless;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

/** Service for Payroll Summary data entry related operations */
@Stateless
@LocalBean
public class HscisPayrollSummaryService {

  @Inject private PayrollSummaryMapper psMapper;
  @Inject private PayrollSummaryGroupCompMapper psgcMapper;
  @Inject private PayrollSummaryEmployeeMapper psemMapper;

  @Inject private HscisPayrollSummaryDao dao;
  @Inject private HscisAdminDao adminDao;

  /**
   * Returns the payroll summaries (a.k.a.: Audit Logs in old HSCIS or PeriodConfirmation in DB)
   * available for a given user. <br>
   * <b>NOTE:</b> There is no payroll summary table in the DB. We use the PayrollSummarry view as an
   * alternative to get the payroll summaries. This mimics the old HSCIS Web App were the closest
   * thing from the payroll summary concept is a set of queries for Audit Logs and Period
   * Confirmation.
   *
   * @param userId
   * @return
   * @throws HscisException
   */
  public List<PayrollSummary> listPayrollSummaries(String userId) throws HscisException {
    dao.resetCache();
    // Get all payroll summaries
    List<HcdPayrollSummary> summaries = dao.listPayrollSummaries(userId);
    // Transform to dto
    List<PayrollSummary> dtos = psMapper.toSummaries(summaries);
    return dtos;
  }

  public PayrollSummary loadSummary(PayrollSummaryPK pk) {
    dao.resetCache();
    HcdPayrollSummary summary = dao.readPayrollSummary(pk);
    // Transform to dto
    PayrollSummary dto = psMapper.toSummary(summary);
    return dto;
  }

  public PayrollSummaryEmployee loadEmployee(Long id) {
    dao.resetCache();
    HcdPayrollSummaryEmployee employee = dao.readPayrollSummaryEmployee(id);
    // Transform to dto
    PayrollSummaryEmployee dto = psemMapper.toDto(employee);
    return dto;
  }

  /**
   * Returns the memberships for a given user
   *
   * @param userId
   * @return
   * @throws HscisException
   */
  public List<HcdMembership> listMemberships(String userId) throws HscisException {
    return dao.readMemberships(userId);
  }

  /**
   * Validate the period (from - to). The following rules are validated:
   * <li>To Date must be after From date
   * <li>To Date must be before or equal current date
   * <li>From Date must be within 22 days of January 1
   * <li>To Date must be within 22 days of June 30 or December 31'
   * <li>Period must not already exists (in progress or completed)<br>
   *     <b>Rules for new members:</b>
   * <li>From Date can be after 22 days before January 1 (current year)
   * <li>From Date cannot be before 22 days before January 1
   *
   * @param corpId
   * @param siteId
   * @param fromDate
   * @param toDate
   * @return List of all error messages, empty list for no errors
   * @throws IllegalArgumentException for null parameters
   */
  public List<String> validatePeriod(
      Long corpId, Long siteId, LocalDate fromDate, LocalDate toDate) {
    // Assume non null values
    if (corpId == null || siteId == null || fromDate == null || toDate == null) {
      // TODO: externalize error messages???
      throw new IllegalArgumentException("Null values in validatePeriod");
    }

    List<String> errors = new ArrayList<>();
    ReportingPeriod newPeriod = new ReportingPeriod(fromDate, toDate);

    HcdMembership membership = dao.readMembership(siteId);

    // Check if new Member
    boolean newMember = membership.getMembershipDate().getYear() >= newPeriod.getReportingYear();
    if (membership.getMembershipDate().getYear() > newPeriod.getReportingYear()) {
      errors.add("Cannot report for years prior to becoming a member");
    }

    // Reporting period does the all the 'dates only' validations
    errors.addAll(ReportingPeriod.validatePeriod(fromDate, toDate, newMember));

    // Do not check for conflicting period if period range too large was triggered
    if (!errors.contains("Reporting Period Range too large. Period must be for only 1 year")) {
      // Test if there is a conflicting period in existing payroll summaries
      List<HcdPayrollSummary> summaries = dao.listPayrollSummaries(membership.getHscisId());

      HcdPayrollSummary conflicting =
          summaries.stream()
              .filter(
                  s ->
                      newPeriod.equals(
                          new ReportingPeriod(
                              s.getId().getReportingFrom(), s.getId().getReportingTo())))
              .findFirst()
              .orElse(null);

      if (conflicting != null) {
        if (conflicting.getId().getReportingFrom().equals(fromDate)
            && conflicting.getId().getReportingTo().equals(toDate)) {
          errors.add("A payroll summary already exists for this period");
        } else {
          errors.add(
              String.format(
                  "A payroll summary already exists for this period (%s to %s)",
                  conflicting.getId().getReportingFrom().format(DateTimeFormatter.ISO_DATE),
                  conflicting.getId().getReportingTo().format(DateTimeFormatter.ISO_DATE)));
        }
      }
    }

    return errors;
  }

  /**
   * Add a new PayrollSummaryGroupComp for a given summary. Assumes:
   * <li>summary fields corpId, siteId, reportingFrom, and reportinTo are set and valid.
   * <li>newGroup fields designatedGroup.code are set and valid.
   *
   * @param summary
   * @param newGroup
   * @throws HscisException
   */
  @Transactional
  public void addDesignatedGroup(PayrollSummary summary, PayrollSummaryGroupComp newGroup)
      throws HscisException {
    // Make sure all redundant hscisId are set
    try {
      Long membershipId = summary.getMembershipId();
      if (membershipId == null) {
        membershipId = dao.readMembership(summary.getSiteID()).getHscisId();
      }

      // Make sure all child entities will be merged
      summary.setMembershipId(membershipId);
      newGroup.setHscisid(membershipId);
      summary.getGroupSummaries().add(newGroup);

      // Map dtos to entity
      HcdPayrollSummaryGroupComp entity = new HcdPayrollSummaryGroupComp();
      entity = psgcMapper.toEntity(newGroup, entity);

      // Save the record
      dao.save(entity);
    } catch (Exception e) {
      throw new HscisException("Error in addDesignatedGroup()", e);
    }
  }

  /**
   * Updates a PayrollSummaryGroupComp for a given summary.
   *
   * @param groupSummary
   * @throws HscisException
   */
  @Transactional
  public void updateDesignatedGroup(PayrollSummaryGroupComp groupSummary) throws HscisException {
    try {
      // Map dtos to entity
      HcdPayrollSummaryGroupComp entity = dao.readPayrollSummaryGroupComp(groupSummary.getId());
      psgcMapper.toEntity(groupSummary, entity);

      // Save the record
      dao.save(entity);

    } catch (Exception e) {
      throw new HscisException("Error in updateDesignatedGroup()", e);
    }
  }

  /**
   * Deletes a PayrollSummaryGroupComp for a given summary.
   *
   * @param summary
   * @param groupToDelete
   * @throws HscisException
   */
  @Transactional
  public void deleteDesignatedGroup(PayrollSummary summary, PayrollSummaryGroupComp groupToDelete)
      throws HscisException {
    try {
      // Map dtos to entity
      HcdPayrollSummaryGroupComp entity = dao.readPayrollSummaryGroupComp(groupToDelete.getId());

      // Save the record
      dao.delete(entity);

      summary.getGroupSummaries().remove(groupToDelete);
    } catch (Exception e) {
      throw new HscisException("Error in deleteDesignatedGroup()", e);
    }
  }

  /**
   * Add a new PayrollSummaryEmployee for a given summary. Assumes:
   * <li>summary fields corpId, siteId, reportingFrom, and reportingTo are set and valid.
   * <li>newEmployee fields designatedGroup.code are set and valid.
   *
   * @param summary
   * @param newEmployee
   * @throws HscisException
   */
  @Transactional
  public void addEmployee(PayrollSummary summary, PayrollSummaryEmployee newEmployee)
      throws HscisException {
    // Make sure all redundant hscisId are set
    try {
      Long membershipId = summary.getMembershipId();
      if (membershipId == null) {
        membershipId = dao.readMembership(summary.getSiteID()).getHscisId();
      }

      if (newEmployee.getId() == null) {
        // New Employee; Employee SIN value must be encrypted
        newEmployee.setEmployeeSinHash(getPasswordHash(newEmployee.getEmployeeSinHash()));
      } else {
        // Duplicate Employee; Employee SIN value already hashed
        newEmployee.setId(null);
      }

      // Make sure all child entities will be merged
      summary.setMembershipId(membershipId);
      newEmployee.setHscisid(membershipId);
      summary.getEmployeeSummaries().add(newEmployee);

      // Map dtos to entity
      HcdPayrollSummaryEmployee entity = new HcdPayrollSummaryEmployee();
      entity = psemMapper.toEntity(newEmployee, entity);

      // Save the record
      entity = (HcdPayrollSummaryEmployee) dao.saveAndReturn(entity);
      newEmployee.setId(entity.getHcdPaysumEmpId());
    } catch (Exception e) {
      throw new HscisException("Error in addEmployee()", e);
    }
  }

  /**
   * Updates a PayrollSummaryEmployee for a given summary.
   *
   * @param employee
   * @throws HscisException
   */
  @Transactional
  public void updateEmployee(PayrollSummaryEmployee employee) throws HscisException {
    try {
      // Make sure all child entities will be merged
      employee.setDesignatedGroup(
          adminDao.findDesignatedGroupById(employee.getDesignatedGroup().getDesignatedGroupCode()));
      employee.setClassification(
          adminDao.findClassificationCodeById(
              employee.getClassification().getClassificationCode()));
      employee.setGender(adminDao.findGenderById(employee.getGender().getGenderCode()));
      employee.setJobStatus(adminDao.findJobStatusById(employee.getJobStatus().getJobStatusCode()));
      employee.setUnion(adminDao.findUnionById(employee.getUnion().getUnionCode()));

      // Map dtos to entity
      HcdPayrollSummaryEmployee entity = dao.readPayrollSummaryEmployee(employee.getId());
      psemMapper.toEntity(employee, entity);

      // Save the record
      dao.save(entity);

    } catch (Exception e) {
      throw new HscisException("Error in updateEmployee()", e);
    }
  }

  /**
   * Deletes a PayrollSummaryEmployee for a given summary.
   *
   * @param summary
   * @param employeeToDelete
   * @throws HscisException
   */
  @Transactional
  public void deleteEmployee(PayrollSummary summary, PayrollSummaryEmployee employeeToDelete)
      throws HscisException {
    try {
      // Map dtos to entity
      HcdPayrollSummaryEmployee entity = dao.readPayrollSummaryEmployee(employeeToDelete.getId());

      // Save the record
      dao.delete(entity);

      summary.getEmployeeSummaries().remove(employeeToDelete);
    } catch (Exception e) {
      throw new HscisException("Error in deleteEmployee()", e);
    }
  }

  /**
   * Deletes a PayrollSummary.
   *
   * @param summary
   * @throws HscisException
   */
  @Transactional
  public void deletePayrollSummary(PayrollSummary summary) throws HscisException {
    try {
      boolean result = dao.deletePayrollSummary(summary.getPK());
      if (!result) {
        throw new HscisException("The payroll summary was not deleted");
      }
    } catch (Exception e) {
      throw new HscisException("Error in deletePayrollSummary()", e);
    }
  }

  /**
   * Submits a PayrollSummary.
   *
   * @param summary
   * @param userId
   * @throws HscisException
   */
  @Transactional
  public void submitPayrollSummary(PayrollSummary summary, String userId) throws HscisException {
    try {
      Long membershipId = summary.getMembershipId();
      if (membershipId == null) {
        membershipId = dao.readMembership(summary.getSiteID()).getHscisId();
      }

      // Save the record
      HcdPeriodConfirmation periodConfirmation = new HcdPeriodConfirmation();
      periodConfirmation.setId(summary.getPK());
      periodConfirmation.setHscisid(membershipId);
      periodConfirmation.setCreatedBy(userId);
      dao.save(periodConfirmation);
    } catch (Exception e) {
      throw new HscisException("Error in submitPayrollSummary()", e);
    }
  }

  private static String encodeBase64(byte[] inBytes) {
    return Base64.getEncoder().encodeToString(inBytes);
  }

  /**
   * Creates a Netscape Directory Server password hash (SHA hash and Base64 encoded)
   *
   * <p>Previously found in HNSharedCode's PasswordUtility class
   *
   * @param password The clear text password to be hashed
   * @return <code>java.lang.String</code>
   */
  private static String getPasswordHash(String password) {
    String retVal = null;
    if (password != null) {
      byte[] pwbytes = password.getBytes();
      try {
        MessageDigest md = MessageDigest.getInstance("SHA");
        md.update(pwbytes);
        retVal = encodeBase64(md.digest());
      } catch (NoSuchAlgorithmException e) {
        // Do nothing
      }
    }
    return retVal;
  }

  public List<HcdClassification> listClassCodesByDesignatedGroup(String code) {
    return dao.listClassCodesByDesignatedGroup(code);
  }

  /**
   * Returns all increments
   *
   * @return
   */
  public List<String> listIncrements() {
    List<String> increments = new ArrayList<>();
    increments.add("0");
    increments.add("1");
    increments.add("2");
    increments.add("3");
    increments.add("4");
    increments.add("5");
    increments.add("6");
    increments.add("7");
    increments.add("8");
    increments.add("9");
    increments.add("R");
    return increments;
  }
}
